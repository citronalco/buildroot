diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/addrspace.h linux-2.6.35.4/arch/mips/include/asm/addrspace.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/addrspace.h	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/include/asm/addrspace.h	2014-07-18 22:29:43.522367724 +0200
@@ -54,7 +54,7 @@
 #define XPHYSADDR(a)            ((_ACAST64_(a)) &			\
 				 _CONST64_(0x000000ffffffffff))
 
-#ifdef CONFIG_64BIT
+#if defined(CONFIG_64BIT) && !defined(CONFIG_CPU_R5900)
 
 /*
  * Memory segments (64bit kernel mode addresses)
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/asm.h linux-2.6.35.4/arch/mips/include/asm/asm.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/asm.h	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/include/asm/asm.h	2014-07-18 22:29:43.526367724 +0200
@@ -134,6 +134,46 @@ symbol		=	value
 1:		.asciiz	string;                         \
 		.popsection
 
+#ifdef __ASSEMBLY__
+#ifdef CONFIG_CPU_R5900
+/* ld would be replaced by 2 lw instructions with newer binutils when using
+ * ABI o32. Force use of ld by updating to ISA MIPS III.
+ */
+.macro force_ld to, from
+	.set push
+	.set mips3
+	ld \to, \from
+	.set pop
+.endm
+
+/* sd would be replaced by 2 sw instructions with newer binutils when using
+ * ABI o32. Force use of sd by updating to ISA MIPS III.
+ */
+.macro force_sd to, from
+	.set push
+	.set mips3
+	sd \to, \from
+	.set pop
+.endm
+
+#else
+.macro force_ld to, from
+	.set push
+	ld \to, \from
+	.set pop
+.endm
+
+.macro force_sd to, from
+	.set push
+	sd \to, \from
+	.set pop
+.endm
+#endif
+
+#define LD force_ld
+#define SD force_sd
+#endif
+
 /*
  * MIPS IV pref instruction.
  * Use with .set noreorder only!
@@ -288,20 +328,75 @@ symbol		=	value
  * How to add/sub/load/store/shift C long variables.
  */
 #if (_MIPS_SZLONG == 32)
-#define LONG_ADD	add
-#define LONG_ADDU	addu
-#define LONG_ADDI	addi
-#define LONG_ADDIU	addiu
-#define LONG_SUB	sub
-#define LONG_SUBU	subu
-#define LONG_L		lw
-#define LONG_S		sw
-#define LONG_SLL	sll
-#define LONG_SLLV	sllv
-#define LONG_SRL	srl
-#define LONG_SRLV	srlv
-#define LONG_SRA	sra
-#define LONG_SRAV	srav
+#ifdef CONFIG_R5900_128BIT_SUPPORT
+#define LONGD_ADD	dadd
+#define LONGI_ADD	add
+#define LONGD_ADDU	daddu
+#define LONGI_ADDU	addu
+#define LONGD_ADDI	daddi
+#define LONGI_ADDI	addi
+#define LONGD_ADDIU	daddiu
+#define LONGI_ADDIU	addiu
+#define LONGD_SUB	dsub
+#define LONGI_SUB	sub
+#define LONGD_SUBU	dsubu
+#define LONGI_SUBU	subu
+/* Load data register. */
+#define LONGD_L		lq
+/* Load hi/lo register. */
+#define LONGH_L		force_ld
+/* Load instruction register. */
+#define LONGI_L		lw
+/* Save data register. */
+#define LONGD_S		sq
+/* Save hi/lo register. */
+#define LONGH_S		force_sd
+/* Save instruction register. */
+#define LONGI_S		sw
+#define LONGD_SLL	dsll
+#define LONGI_SLL	sll
+#define LONGD_SLLV	dsllv
+#define LONGI_SLLV	sllv
+#define LONGD_SRL	dsrl
+#define LONGI_SRL	srl
+#define LONGD_SRLV	dsrlv
+#define LONGI_SRLV	srlv
+#define LONGD_SRA	dsra
+#define LONGI_SRA	sra
+#define LONGD_SRAV	dsrav
+#define LONGI_SRAV	srav
+#else
+#define LONGD_ADD	add
+#define LONGI_ADD	add
+#define LONGD_ADDU	addu
+#define LONGI_ADDU	addu
+#define LONGD_ADDI	addi
+#define LONGI_ADDI	addi
+#define LONGD_ADDIU	addiu
+#define LONGI_ADDIU	addiu
+#define LONGD_SUB	sub
+#define LONGI_SUB	sub
+#define LONGD_SUBU	subu
+#define LONGI_SUBU	subu
+#define LONGD_L		lw
+#define LONGI_L		lw
+#define LONGH_L		lw
+#define LONGD_S		sw
+#define LONGH_S		sw
+#define LONGI_S		sw
+#define LONGD_SLL	sll
+#define LONGI_SLL	sll
+#define LONGD_SLLV	sllv
+#define LONGI_SLLV	sllv
+#define LONGD_SRL	srl
+#define LONGI_SRL	srl
+#define LONGD_SRLV	srlv
+#define LONGI_SRLV	srlv
+#define LONGD_SRA	sra
+#define LONGI_SRA	sra
+#define LONGD_SRAV	srav
+#define LONGI_SRAV	srav
+#endif
 
 #define LONG		.word
 #define LONGSIZE	4
@@ -310,20 +405,44 @@ symbol		=	value
 #endif
 
 #if (_MIPS_SZLONG == 64)
-#define LONG_ADD	dadd
-#define LONG_ADDU	daddu
-#define LONG_ADDI	daddi
-#define LONG_ADDIU	daddiu
-#define LONG_SUB	dsub
-#define LONG_SUBU	dsubu
-#define LONG_L		ld
-#define LONG_S		sd
-#define LONG_SLL	dsll
-#define LONG_SLLV	dsllv
-#define LONG_SRL	dsrl
-#define LONG_SRLV	dsrlv
-#define LONG_SRA	dsra
-#define LONG_SRAV	dsrav
+#define LONGD_ADD	dadd
+#define LONGI_ADD	dadd
+#define LONGD_ADDU	daddu
+#define LONGI_ADDU	daddu
+#define LONGD_ADDI	daddi
+#define LONGI_ADDI	daddi
+#define LONGD_ADDIU	daddiu
+#define LONGI_ADDIU	daddiu
+#define LONGD_SUB	dsub
+#define LONGI_SUB	dsub
+#define LONGD_SUBU	dsubu
+#define LONGI_SUBU	dsubu
+#ifdef CONFIG_R5900_128BIT_SUPPORT
+#define LONGD_L		lq
+#else
+#define LONGD_L		ld
+#endif
+#define LONGI_L		ld
+#define LONGH_L		ld
+#ifdef CONFIG_R5900_128BIT_SUPPORT
+#define LONGD_S		sq
+#else
+#define LONGD_S		sd
+#endif
+#define LONGI_S		sd
+#define LONGH_S		sd
+#define LONGD_SLL	dsll
+#define LONGI_SLL	dsll
+#define LONGD_SLLV	dsllv
+#define LONGI_SLLV	dsllv
+#define LONGD_SRL	dsrl
+#define LONGI_SRL	dsrl
+#define LONGD_SRLV	dsrlv
+#define LONGI_SRLV	dsrlv
+#define LONGD_SRA	dsra
+#define LONGI_SRA	dsra
+#define LONGD_SRAV	dsrav
+#define LONGI_SRAV	dsrav
 
 #define LONG		.dword
 #define LONGSIZE	8
@@ -387,11 +506,11 @@ symbol		=	value
 /*
  * Some cp0 registers were extended to 64bit for MIPS III.
  */
-#if (_MIPS_SIM == _MIPS_SIM_ABI32)
+#if (_MIPS_SIM == _MIPS_SIM_ABI32) || defined(CONFIG_CPU_R5900)
 #define MFC0		mfc0
 #define MTC0		mtc0
 #endif
-#if (_MIPS_SIM == _MIPS_SIM_NABI32) || (_MIPS_SIM == _MIPS_SIM_ABI64)
+#if ((_MIPS_SIM == _MIPS_SIM_NABI32) || (_MIPS_SIM == _MIPS_SIM_ABI64)) && !defined(CONFIG_CPU_R5900)
 #define MFC0		dmfc0
 #define MTC0		dmtc0
 #endif
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/asmmacro-32.h linux-2.6.35.4/arch/mips/include/asm/asmmacro-32.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/asmmacro-32.h	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/include/asm/asmmacro-32.h	2014-07-18 22:29:43.526367724 +0200
@@ -12,6 +12,48 @@
 #include <asm/fpregdef.h>
 #include <asm/mipsregs.h>
 
+#ifdef CONFIG_CPU_R5900
+	/* Kernel expects that floating point registers are saved as 64-bit
+	 * with the sdc1 instruction, but this is not working with R5900.
+	 * The 64-bit write is simulated as two 32-bit writes.
+	 */
+	.macro fpu_save_double thread status tmp1=t0
+	cfc1	\tmp1,  fcr31
+	swc1	$f0,  THREAD_FPR0(\thread)
+	swc1	$f1,  (THREAD_FPR0 + 4)(\thread)
+	swc1	$f2,  THREAD_FPR2(\thread)
+	swc1	$f3,  (THREAD_FPR2 + 4)(\thread)
+	swc1	$f4,  THREAD_FPR4(\thread)
+	swc1	$f5,  (THREAD_FPR4 + 4)(\thread)
+	swc1	$f6,  THREAD_FPR6(\thread)
+	swc1	$f7,  (THREAD_FPR6 + 4)(\thread)
+	swc1	$f8,  THREAD_FPR8(\thread)
+	swc1	$f9,  (THREAD_FPR8 + 4)(\thread)
+	swc1	$f10, THREAD_FPR10(\thread)
+	swc1	$f11, (THREAD_FPR10 + 4)(\thread)
+	swc1	$f12, THREAD_FPR12(\thread)
+	swc1	$f13, (THREAD_FPR12 + 4)(\thread)
+	swc1	$f14, THREAD_FPR14(\thread)
+	swc1	$f15, (THREAD_FPR14 + 4)(\thread)
+	swc1	$f16, THREAD_FPR16(\thread)
+	swc1	$f17, (THREAD_FPR16 + 4)(\thread)
+	swc1	$f18, THREAD_FPR18(\thread)
+	swc1	$f19, (THREAD_FPR18 + 4)(\thread)
+	swc1	$f20, THREAD_FPR20(\thread)
+	swc1	$f21, (THREAD_FPR20 + 4)(\thread)
+	swc1	$f22, THREAD_FPR22(\thread)
+	swc1	$f23, (THREAD_FPR22 + 4)(\thread)
+	swc1	$f24, THREAD_FPR24(\thread)
+	swc1	$f25, (THREAD_FPR24 + 4)(\thread)
+	swc1	$f26, THREAD_FPR26(\thread)
+	swc1	$f27, (THREAD_FPR26 + 4)(\thread)
+	swc1	$f28, THREAD_FPR28(\thread)
+	swc1	$f29, (THREAD_FPR28 + 4)(\thread)
+	swc1	$f30, THREAD_FPR30(\thread)
+	swc1	$f31, (THREAD_FPR30 + 4)(\thread)
+	sw	\tmp1, THREAD_FCR31(\thread)
+	.endm
+#else
 	.macro	fpu_save_double thread status tmp1=t0
 	cfc1	\tmp1,  fcr31
 	sdc1	$f0,  THREAD_FPR0(\thread)
@@ -32,6 +74,7 @@
 	sdc1	$f30, THREAD_FPR30(\thread)
 	sw	\tmp1, THREAD_FCR31(\thread)
 	.endm
+#endif
 
 	.macro	fpu_save_single thread tmp=t0
 	cfc1	\tmp,  fcr31
@@ -70,6 +113,48 @@
 	sw	\tmp, THREAD_FCR31(\thread)
 	.endm
 
+#ifdef CONFIG_CPU_R5900
+	/* Kernel expects that floating point registers are read as 64-bit
+	 * with the ldc1 instruction, but this is not working with R5900.
+	 * The 64-bit read is simulated as two 32-bit reads.
+	 */
+	.macro	fpu_restore_double thread status tmp=t0
+	lw	\tmp, THREAD_FCR31(\thread)
+	lwc1	$f0,  THREAD_FPR0(\thread)
+	lwc1	$f1,  (THREAD_FPR0 + 4)(\thread)
+	lwc1	$f2,  THREAD_FPR2(\thread)
+	lwc1	$f3,  (THREAD_FPR2 + 4)(\thread)
+	lwc1	$f4,  THREAD_FPR4(\thread)
+	lwc1	$f5,  (THREAD_FPR4 + 4)(\thread)
+	lwc1	$f6,  THREAD_FPR6(\thread)
+	lwc1	$f7,  (THREAD_FPR6 + 4)(\thread)
+	lwc1	$f8,  THREAD_FPR8(\thread)
+	lwc1	$f9,  (THREAD_FPR8 + 4)(\thread)
+	lwc1	$f10, THREAD_FPR10(\thread)
+	lwc1	$f11, (THREAD_FPR10 + 4)(\thread)
+	lwc1	$f12, THREAD_FPR12(\thread)
+	lwc1	$f13, (THREAD_FPR12 + 4)(\thread)
+	lwc1	$f14, THREAD_FPR14(\thread)
+	lwc1	$f15, (THREAD_FPR14 + 4)(\thread)
+	lwc1	$f16, THREAD_FPR16(\thread)
+	lwc1	$f17, (THREAD_FPR16 + 4)(\thread)
+	lwc1	$f18, THREAD_FPR18(\thread)
+	lwc1	$f19, (THREAD_FPR18 + 4)(\thread)
+	lwc1	$f20, THREAD_FPR20(\thread)
+	lwc1	$f21, (THREAD_FPR20 + 4)(\thread)
+	lwc1	$f22, THREAD_FPR22(\thread)
+	lwc1	$f23, (THREAD_FPR22 + 4)(\thread)
+	lwc1	$f24, THREAD_FPR24(\thread)
+	lwc1	$f25, (THREAD_FPR24 + 4)(\thread)
+	lwc1	$f26, THREAD_FPR26(\thread)
+	lwc1	$f27, (THREAD_FPR26 + 4)(\thread)
+	lwc1	$f28, THREAD_FPR28(\thread)
+	lwc1	$f29, (THREAD_FPR28 + 4)(\thread)
+	lwc1	$f30, THREAD_FPR30(\thread)
+	lwc1	$f31, (THREAD_FPR30 + 4)(\thread)
+	ctc1	\tmp, fcr31
+	.endm
+#else
 	.macro	fpu_restore_double thread status tmp=t0
 	lw	\tmp, THREAD_FCR31(\thread)
 	ldc1	$f0,  THREAD_FPR0(\thread)
@@ -90,6 +175,7 @@
 	ldc1	$f30, THREAD_FPR30(\thread)
 	ctc1	\tmp, fcr31
 	.endm
+#endif
 
 	.macro	fpu_restore_single thread tmp=t0
 	lw	\tmp, THREAD_FCR31(\thread)
@@ -129,30 +215,30 @@
 	.endm
 
 	.macro	cpu_save_nonscratch thread
-	LONG_S	s0, THREAD_REG16(\thread)
-	LONG_S	s1, THREAD_REG17(\thread)
-	LONG_S	s2, THREAD_REG18(\thread)
-	LONG_S	s3, THREAD_REG19(\thread)
-	LONG_S	s4, THREAD_REG20(\thread)
-	LONG_S	s5, THREAD_REG21(\thread)
-	LONG_S	s6, THREAD_REG22(\thread)
-	LONG_S	s7, THREAD_REG23(\thread)
-	LONG_S	sp, THREAD_REG29(\thread)
-	LONG_S	fp, THREAD_REG30(\thread)
+	LONGD_S	s0, THREAD_REG16(\thread)
+	LONGD_S	s1, THREAD_REG17(\thread)
+	LONGD_S	s2, THREAD_REG18(\thread)
+	LONGD_S	s3, THREAD_REG19(\thread)
+	LONGD_S	s4, THREAD_REG20(\thread)
+	LONGD_S	s5, THREAD_REG21(\thread)
+	LONGD_S	s6, THREAD_REG22(\thread)
+	LONGD_S	s7, THREAD_REG23(\thread)
+	LONGD_S	sp, THREAD_REG29(\thread)
+	LONGD_S	fp, THREAD_REG30(\thread)
 	.endm
 
 	.macro	cpu_restore_nonscratch thread
-	LONG_L	s0, THREAD_REG16(\thread)
-	LONG_L	s1, THREAD_REG17(\thread)
-	LONG_L	s2, THREAD_REG18(\thread)
-	LONG_L	s3, THREAD_REG19(\thread)
-	LONG_L	s4, THREAD_REG20(\thread)
-	LONG_L	s5, THREAD_REG21(\thread)
-	LONG_L	s6, THREAD_REG22(\thread)
-	LONG_L	s7, THREAD_REG23(\thread)
-	LONG_L	sp, THREAD_REG29(\thread)
-	LONG_L	fp, THREAD_REG30(\thread)
-	LONG_L	ra, THREAD_REG31(\thread)
+	LONGD_L	s0, THREAD_REG16(\thread)
+	LONGD_L	s1, THREAD_REG17(\thread)
+	LONGD_L	s2, THREAD_REG18(\thread)
+	LONGD_L	s3, THREAD_REG19(\thread)
+	LONGD_L	s4, THREAD_REG20(\thread)
+	LONGD_L	s5, THREAD_REG21(\thread)
+	LONGD_L	s6, THREAD_REG22(\thread)
+	LONGD_L	s7, THREAD_REG23(\thread)
+	LONGD_L	sp, THREAD_REG29(\thread)
+	LONGD_L	fp, THREAD_REG30(\thread)
+	LONGD_L	ra, THREAD_REG31(\thread)
 	.endm
 
 #endif /* _ASM_ASMMACRO_32_H */
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/asmmacro-64.h linux-2.6.35.4/arch/mips/include/asm/asmmacro-64.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/asmmacro-64.h	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/include/asm/asmmacro-64.h	2014-07-18 22:29:43.526367724 +0200
@@ -110,30 +110,30 @@
 	.endm
 
 	.macro	cpu_save_nonscratch thread
-	LONG_S	s0, THREAD_REG16(\thread)
-	LONG_S	s1, THREAD_REG17(\thread)
-	LONG_S	s2, THREAD_REG18(\thread)
-	LONG_S	s3, THREAD_REG19(\thread)
-	LONG_S	s4, THREAD_REG20(\thread)
-	LONG_S	s5, THREAD_REG21(\thread)
-	LONG_S	s6, THREAD_REG22(\thread)
-	LONG_S	s7, THREAD_REG23(\thread)
-	LONG_S	sp, THREAD_REG29(\thread)
-	LONG_S	fp, THREAD_REG30(\thread)
+	LONGD_S	s0, THREAD_REG16(\thread)
+	LONGD_S	s1, THREAD_REG17(\thread)
+	LONGD_S	s2, THREAD_REG18(\thread)
+	LONGD_S	s3, THREAD_REG19(\thread)
+	LONGD_S	s4, THREAD_REG20(\thread)
+	LONGD_S	s5, THREAD_REG21(\thread)
+	LONGD_S	s6, THREAD_REG22(\thread)
+	LONGD_S	s7, THREAD_REG23(\thread)
+	LONGD_S	sp, THREAD_REG29(\thread)
+	LONGD_S	fp, THREAD_REG30(\thread)
 	.endm
 
 	.macro	cpu_restore_nonscratch thread
-	LONG_L	s0, THREAD_REG16(\thread)
-	LONG_L	s1, THREAD_REG17(\thread)
-	LONG_L	s2, THREAD_REG18(\thread)
-	LONG_L	s3, THREAD_REG19(\thread)
-	LONG_L	s4, THREAD_REG20(\thread)
-	LONG_L	s5, THREAD_REG21(\thread)
-	LONG_L	s6, THREAD_REG22(\thread)
-	LONG_L	s7, THREAD_REG23(\thread)
-	LONG_L	sp, THREAD_REG29(\thread)
-	LONG_L	fp, THREAD_REG30(\thread)
-	LONG_L	ra, THREAD_REG31(\thread)
+	LONGD_L	s0, THREAD_REG16(\thread)
+	LONGD_L	s1, THREAD_REG17(\thread)
+	LONGD_L	s2, THREAD_REG18(\thread)
+	LONGD_L	s3, THREAD_REG19(\thread)
+	LONGD_L	s4, THREAD_REG20(\thread)
+	LONGD_L	s5, THREAD_REG21(\thread)
+	LONGD_L	s6, THREAD_REG22(\thread)
+	LONGD_L	s7, THREAD_REG23(\thread)
+	LONGD_L	sp, THREAD_REG29(\thread)
+	LONGD_L	fp, THREAD_REG30(\thread)
+	LONGD_L	ra, THREAD_REG31(\thread)
 	.endm
 
 #endif /* _ASM_ASMMACRO_64_H */
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/asmmacro.h linux-2.6.35.4/arch/mips/include/asm/asmmacro.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/asmmacro.h	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/include/asm/asmmacro.h	2014-07-18 22:29:43.526367724 +0200
@@ -10,10 +10,10 @@
 
 #include <asm/hazards.h>
 
-#ifdef CONFIG_32BIT
+#if defined(CONFIG_32BIT) || defined(CONFIG_CPU_R5900)
 #include <asm/asmmacro-32.h>
 #endif
-#ifdef CONFIG_64BIT
+#if defined(CONFIG_64BIT) && !defined(CONFIG_CPU_R5900)
 #include <asm/asmmacro-64.h>
 #endif
 #ifdef CONFIG_MIPS_MT_SMTC
@@ -22,17 +22,29 @@
 
 #ifdef CONFIG_MIPS_MT_SMTC
 	.macro	local_irq_enable reg=t0
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	mfc0	\reg, CP0_TCSTATUS
 	ori	\reg, \reg, TCSTATUS_IXMT
 	xori	\reg, \reg, TCSTATUS_IXMT
 	mtc0	\reg, CP0_TCSTATUS
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	_ehb
 	.endm
 
 	.macro	local_irq_disable reg=t0
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	mfc0	\reg, CP0_TCSTATUS
 	ori	\reg, \reg, TCSTATUS_IXMT
 	mtc0	\reg, CP0_TCSTATUS
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	_ehb
 	.endm
 #elif defined(CONFIG_CPU_MIPSR2)
@@ -47,17 +59,29 @@
 	.endm
 #else
 	.macro	local_irq_enable reg=t0
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	mfc0	\reg, CP0_STATUS
 	ori	\reg, \reg, 1
 	mtc0	\reg, CP0_STATUS
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	irq_enable_hazard
 	.endm
 
 	.macro	local_irq_disable reg=t0
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	mfc0	\reg, CP0_STATUS
 	ori	\reg, \reg, 1
 	xori	\reg, \reg, 1
 	mtc0	\reg, CP0_STATUS
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	irq_disable_hazard
 	.endm
 #endif /* CONFIG_MIPS_MT_SMTC */
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/atomic.h linux-2.6.35.4/arch/mips/include/asm/atomic.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/atomic.h	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/include/asm/atomic.h	2014-07-18 22:29:43.526367724 +0200
@@ -21,6 +21,10 @@
 #include <asm/war.h>
 #include <asm/system.h>
 
+#ifdef CONFIG_GENERIC_ATOMIC64
+#include <asm-generic/atomic64.h>
+#endif
+
 #define ATOMIC_INIT(i)    { (i) }
 
 /*
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/cacheops.h linux-2.6.35.4/arch/mips/include/asm/cacheops.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/cacheops.h	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/include/asm/cacheops.h	2014-07-18 22:29:43.526367724 +0200
@@ -14,6 +14,17 @@
 /*
  * Cache Operations available on all MIPS processors with R4000-style caches
  */
+#ifdef CONFIG_CPU_R5900
+#define Index_Invalidate_I      0x07
+#define Index_Writeback_Inv_D   0x14
+#define Index_Load_Tag_I	0x00
+#define Index_Load_Tag_D	0x10
+#define Index_Store_Tag_I	0x04
+#define Index_Store_Tag_D	0x12
+#define Hit_Invalidate_I    	0x0b
+#define Hit_Invalidate_D	0x1a
+#define Hit_Writeback_Inv_D	0x18
+#else
 #define Index_Invalidate_I      0x00
 #define Index_Writeback_Inv_D   0x01
 #define Index_Load_Tag_I	0x04
@@ -27,14 +38,20 @@
 #endif
 #define Hit_Invalidate_D	0x11
 #define Hit_Writeback_Inv_D	0x15
+#endif
 
 /*
  * R4000-specific cacheops
  */
 #define Create_Dirty_Excl_D	0x0d
+#ifdef CONFIG_CPU_R5900
+#define Fill			0x0e
+#define Hit_Writeback_D		0x1c
+#else
 #define Fill			0x14
 #define Hit_Writeback_I		0x18
 #define Hit_Writeback_D		0x19
+#endif
 
 /*
  * R4000SC and R4400SC-specific cacheops
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/cpu.h linux-2.6.35.4/arch/mips/include/asm/cpu.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/cpu.h	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/include/asm/cpu.h	2014-07-18 22:29:43.526367724 +0200
@@ -62,6 +62,7 @@
 #define PRID_IMP_R4650		0x2200		/* Same as R4640 */
 #define PRID_IMP_R5000		0x2300
 #define PRID_IMP_TX49		0x2d00
+#define PRID_IMP_R5900		0x2e00		/* Playstation 2 */
 #define PRID_IMP_SONIC		0x2400
 #define PRID_IMP_MAGIC		0x2500
 #define PRID_IMP_RM7000		0x2700
@@ -226,6 +227,11 @@ enum cpu_type_enum {
 	CPU_5KC, CPU_20KC, CPU_25KF, CPU_SB1, CPU_SB1A, CPU_LOONGSON2,
 	CPU_CAVIUM_OCTEON, CPU_CAVIUM_OCTEON_PLUS,
 
+	/*
+	 * Playstation 2 processors
+	 */
+	CPU_R5900,
+
 	CPU_LAST
 };
 
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/dsp.h linux-2.6.35.4/arch/mips/include/asm/dsp.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/dsp.h	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/include/asm/dsp.h	2014-07-18 22:29:43.526367724 +0200
@@ -27,11 +27,15 @@ static inline void __init_dsp(void)
 {
 	mthi1(0);
 	mtlo1(0);
+#ifdef CONFIG_CPU_R5900
+	mtsa(0);
+#else
 	mthi2(0);
 	mtlo2(0);
 	mthi3(0);
 	mtlo3(0);
 	wrdsp(DSP_DEFAULT, DSP_MASK);
+#endif
 }
 
 static inline void init_dsp(void)
@@ -40,6 +44,14 @@ static inline void init_dsp(void)
 		__init_dsp();
 }
 
+#ifdef CONFIG_CPU_R5900
+#define __save_dsp(tsk)							\
+do {									\
+	tsk->thread.dsp.dspr[0] = mfhi1();				\
+	tsk->thread.dsp.dspr[1] = mflo1();				\
+	tsk->thread.sa = mfsa();						\
+} while (0)
+#else
 #define __save_dsp(tsk)							\
 do {									\
 	tsk->thread.dsp.dspr[0] = mfhi1();				\
@@ -50,6 +62,7 @@ do {									\
 	tsk->thread.dsp.dspr[5] = mflo3();				\
 	tsk->thread.dsp.dspcontrol = rddsp(DSP_MASK);			\
 } while (0)
+#endif
 
 #define save_dsp(tsk)							\
 do {									\
@@ -57,6 +70,14 @@ do {									\
 		__save_dsp(tsk);					\
 } while (0)
 
+#ifdef CONFIG_CPU_R5900
+#define __restore_dsp(tsk)						\
+do {									\
+	mthi1(tsk->thread.dsp.dspr[0]);					\
+	mtlo1(tsk->thread.dsp.dspr[1]);					\
+	mtsa(tsk->thread.sa);							\
+} while (0)
+#else
 #define __restore_dsp(tsk)						\
 do {									\
 	mthi1(tsk->thread.dsp.dspr[0]);					\
@@ -67,6 +88,7 @@ do {									\
 	mtlo3(tsk->thread.dsp.dspr[5]);					\
 	wrdsp(tsk->thread.dsp.dspcontrol, DSP_MASK);			\
 } while (0)
+#endif
 
 #define restore_dsp(tsk)						\
 do {									\
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/elf.h linux-2.6.35.4/arch/mips/include/asm/elf.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/elf.h	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/include/asm/elf.h	2014-07-18 22:29:43.526367724 +0200
@@ -21,6 +21,10 @@
 #define EF_MIPS_ARCH_32R2	0x70000000	/* MIPS32 R2 code.  */
 #define EF_MIPS_ARCH_64R2	0x80000000	/* MIPS64 R2 code.  */
 
+/* MIPS CPU type. */
+#define EF_MIPS_MACH		0x00FF0000
+#define EF_MIPS_MACH_5900	0x00920000	/* MIPS R5900 Sony Playstation 2 */
+
 /* The ABI of a file. */
 #define EF_MIPS_ABI_O32		0x00001000	/* O32 ABI.  */
 #define EF_MIPS_ABI_O64		0x00002000	/* O32 extended for 64 bit.  */
@@ -247,18 +251,53 @@ extern struct mips_abi mips_abi_n32;
 
 #ifdef CONFIG_32BIT
 
+#ifdef CONFIG_R5900_128BIT_SUPPORT
+#define __SET_PERSONALITY32(ex)						\
+do {									\
+	if (((ex).e_flags & EF_MIPS_MACH) == EF_MIPS_MACH_5900)		\
+		set_thread_flag(TIF_R5900FPU);				\
+	if ((((ex).e_flags & EF_MIPS_ABI2) != 0) &&			\
+	     ((ex).e_flags & EF_MIPS_ABI) == 0) {			\
+		__SET_PERSONALITY32_N32();				\
+	} else								\
+		__SET_PERSONALITY32_O32();				\
+	set_personality(PER_LINUX);					\
+} while (0)
+
 #define SET_PERSONALITY(ex)						\
 do {									\
+	clear_thread_flag(TIF_32BIT_REGS);				\
+	clear_thread_flag(TIF_R5900FPU);				\
+	set_thread_flag(TIF_32BIT_ADDR);				\
+									\
+	__SET_PERSONALITY32(ex);					\
+} while (0)
+
+#define __SET_PERSONALITY32_O32()					\
+	do {								\
+		set_thread_flag(TIF_32BIT_REGS);			\
+		set_thread_flag(TIF_32BIT_ADDR);			\
+		current->thread.abi = &mips_abi;			\
+	} while (0)
+
+
+#else /* ! CONFIG_R5900_128BIT_SUPPORT */
+#define SET_PERSONALITY(ex)						\
+do {									\
+	clear_thread_flag(TIF_R5900FPU);				\
+	if (((ex).e_flags & EF_MIPS_MACH) == EF_MIPS_MACH_5900)		\
+		set_thread_flag(TIF_R5900FPU);				\
 	set_personality(PER_LINUX);					\
 									\
 	current->thread.abi = &mips_abi;				\
 } while (0)
+#endif /* CONFIG_R5900_128BIT_SUPPORT */
 
 #endif /* CONFIG_32BIT */
 
-#ifdef CONFIG_64BIT
+#if defined(CONFIG_64BIT) || defined(CONFIG_R5900_128BIT_SUPPORT)
 
-#ifdef CONFIG_MIPS32_N32
+#if defined(CONFIG_MIPS32_N32) || defined(CONFIG_MIPS_N32)
 #define __SET_PERSONALITY32_N32()					\
 	do {								\
 		set_thread_flag(TIF_32BIT_ADDR);			\
@@ -267,7 +306,11 @@ do {									\
 #else
 #define __SET_PERSONALITY32_N32()					\
 	do { } while (0)
-#endif
+#endif /* CONFIG_MIPS32_N32 || CONFIG_MIPS_N32 */
+
+#endif /* CONFIG_64BIT || CONFIG_R5900_128BIT_SUPPORT */
+
+#ifdef CONFIG_64BIT
 
 #ifdef CONFIG_MIPS32_O32
 #define __SET_PERSONALITY32_O32()					\
@@ -285,9 +328,9 @@ do {									\
 #define __SET_PERSONALITY32(ex)						\
 do {									\
 	if ((((ex).e_flags & EF_MIPS_ABI2) != 0) &&			\
-	     ((ex).e_flags & EF_MIPS_ABI) == 0)				\
+	     ((ex).e_flags & EF_MIPS_ABI) == 0) {			\
 		__SET_PERSONALITY32_N32();				\
-	else								\
+	} else								\
 		__SET_PERSONALITY32_O32();				\
 } while (0)
 #else
@@ -348,6 +391,40 @@ extern const char *__elf_platform;
  * See comments in asm-alpha/elf.h, this is the same thing
  * on the MIPS.
  */
+#ifdef CONFIG_R5900_128BIT_SUPPORT
+#define ELF_PLAT_INIT(_r, load_addr)	do { \
+	_r->regs[1].lo = _r->regs[1].hi = \
+	_r->regs[2].lo = _r->regs[2].hi = \
+	_r->regs[3].lo = _r->regs[3].hi = \
+	_r->regs[4].lo = _r->regs[4].hi = \
+	_r->regs[5].lo = _r->regs[5].hi = \
+	_r->regs[6].lo = _r->regs[6].hi = \
+	_r->regs[7].lo = _r->regs[7].hi = \
+	_r->regs[8].lo = _r->regs[8].hi = \
+	_r->regs[9].lo = _r->regs[9].hi = \
+	_r->regs[10].lo = _r->regs[10].hi = \
+	_r->regs[11].lo = _r->regs[11].hi = \
+	_r->regs[12].lo = _r->regs[12].hi = \
+	_r->regs[13].lo = _r->regs[13].hi = \
+	_r->regs[14].lo = _r->regs[14].hi = \
+	_r->regs[15].lo = _r->regs[15].hi = \
+	_r->regs[16].lo = _r->regs[16].hi = \
+	_r->regs[17].lo = _r->regs[17].hi = \
+	_r->regs[18].lo = _r->regs[18].hi = \
+	_r->regs[19].lo = _r->regs[19].hi = \
+	_r->regs[20].lo = _r->regs[20].hi = \
+	_r->regs[21].lo = _r->regs[21].hi = \
+	_r->regs[22].lo = _r->regs[22].hi = \
+	_r->regs[23].lo = _r->regs[23].hi = \
+	_r->regs[24].lo = _r->regs[24].hi = \
+	_r->regs[25].lo = _r->regs[25].hi = \
+	_r->regs[26].lo = _r->regs[26].hi = \
+	_r->regs[27].lo = _r->regs[27].hi = \
+	_r->regs[28].lo = _r->regs[28].hi = \
+	_r->regs[30].lo = _r->regs[30].hi = \
+	_r->regs[31].lo = _r->regs[31].hi = 0; \
+} while (0)
+#else
 #define ELF_PLAT_INIT(_r, load_addr)	do { \
 	_r->regs[1] = _r->regs[2] = _r->regs[3] = _r->regs[4] = 0;	\
 	_r->regs[5] = _r->regs[6] = _r->regs[7] = _r->regs[8] = 0;	\
@@ -358,6 +435,7 @@ extern const char *__elf_platform;
 	_r->regs[25] = _r->regs[26] = _r->regs[27] = _r->regs[28] = 0;	\
 	_r->regs[30] = _r->regs[31] = 0;				\
 } while (0)
+#endif
 
 /* This is the location that an ET_DYN program is loaded if exec'ed.  Typical
    use of this is to invoke "./ld.so someprog" to test out a new version of
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/ftrace.h linux-2.6.35.4/arch/mips/include/asm/ftrace.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/ftrace.h	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/include/asm/ftrace.h	2014-07-18 22:29:43.526367724 +0200
@@ -19,9 +19,12 @@
 extern void _mcount(void);
 #define mcount _mcount
 
+#ifdef CONFIG_CPU_R5900
 #define safe_load(load, src, dst, error)		\
 do {							\
 	asm volatile (					\
+		/* In an error exception handler the user space could be uncached. */ \
+		"sync.l							\n"	\
 		"1: " load " %[" STR(dst) "], 0(%[" STR(src) "])\n"\
 		"   li %[" STR(error) "], 0\n"		\
 		"2:\n"					\
@@ -40,7 +43,55 @@ do {							\
 		: "memory"				\
 	);						\
 } while (0)
+#else
+#define safe_load(load, src, dst, error)		\
+do {							\
+	asm volatile (					\
+		"1: " load " %[" STR(dst) "], 0(%[" STR(src) "])\n"\
+		"   li %[" STR(error) "], 0\n"		\
+		"2:\n"					\
+							\
+		".section .fixup, \"ax\"\n"		\
+		"3: li %[" STR(error) "], 1\n"		\
+		"   j 2b\n"				\
+		".previous\n"				\
+							\
+		".section\t__ex_table,\"a\"\n\t"	\
+		STR(PTR) "\t1b, 3b\n\t"			\
+		".previous\n"				\
+							\
+		: [dst] "=&r" (dst), [error] "=r" (error)\
+		: [src] "r" (src)			\
+		: "memory"				\
+	);						\
+} while (0)
+#endif
 
+#ifdef CONFIG_CPU_R5900
+#define safe_store(store, src, dst, error)	\
+do {						\
+	asm volatile (				\
+		/* In an error exception handler the user space could be uncached. */ \
+		"sync.l							\n"	\
+		"1: " store " %[" STR(src) "], 0(%[" STR(dst) "])\n"\
+		"   li %[" STR(error) "], 0\n"	\
+		"2:\n"				\
+						\
+		".section .fixup, \"ax\"\n"	\
+		"3: li %[" STR(error) "], 1\n"	\
+		"   j 2b\n"			\
+		".previous\n"			\
+						\
+		".section\t__ex_table,\"a\"\n\t"\
+		STR(PTR) "\t1b, 3b\n\t"		\
+		".previous\n"			\
+						\
+		: [error] "=r" (error)		\
+		: [dst] "r" (dst), [src] "r" (src)\
+		: "memory"			\
+	);					\
+} while (0)
+#else
 #define safe_store(store, src, dst, error)	\
 do {						\
 	asm volatile (				\
@@ -62,6 +113,7 @@ do {						\
 		: "memory"			\
 	);					\
 } while (0)
+#endif
 
 #define safe_load_code(dst, src, error) \
 	safe_load(STR(lw), src, dst, error)
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/io.h linux-2.6.35.4/arch/mips/include/asm/io.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/io.h	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/include/asm/io.h	2014-07-18 22:29:43.526367724 +0200
@@ -384,10 +384,23 @@ static inline void pfx##out##bwlq##p(typ
 									\
 	__val = pfx##ioswab##bwlq(__addr, val);				\
 									\
-	/* Really, we want this to be atomic */				\
-	BUILD_BUG_ON(sizeof(type) > sizeof(unsigned long));		\
-									\
-	*__addr = __val;						\
+	if (sizeof(type) != sizeof(u64) || sizeof(u64) == sizeof(long))	\
+		*__addr = __val;					\
+	else if (cpu_has_64bits) {					\
+		type __tmp;						\
+									\
+		__asm__ __volatile__(					\
+			".set	mips3"		"\t\t# __writeq""\n\t"	\
+			"dsll32	%L0, %L0, 0"			"\n\t"	\
+			"dsrl32	%L0, %L0, 0"			"\n\t"	\
+			"dsll32	%M0, %M0, 0"			"\n\t"	\
+			"or	%L0, %L0, %M0"			"\n\t"	\
+			"sd	%L0, %2"			"\n\t"	\
+			".set	mips0"				"\n"	\
+			: "=r" (__tmp)					\
+			: "0" (__val), "m" (*__addr));			\
+	} else								\
+		BUG();							\
 	slow;								\
 }									\
 									\
@@ -398,9 +411,22 @@ static inline type pfx##in##bwlq##p(unsi
 									\
 	__addr = (void *)__swizzle_addr_##bwlq(mips_io_port_base + port); \
 									\
-	BUILD_BUG_ON(sizeof(type) > sizeof(unsigned long));		\
-									\
-	__val = *__addr;						\
+	if (sizeof(type) != sizeof(u64) || sizeof(u64) == sizeof(long))	\
+		__val = *__addr;					\
+	else if (cpu_has_64bits) {					\
+									\
+		__asm__ __volatile__(					\
+			".set	mips3"		"\t\t# __outq"	"\n\t"	\
+			"ld	%L0, %1"			"\n\t"	\
+			"dsra32	%M0, %L0, 0"			"\n\t"	\
+			"sll	%L0, %L0, 0"			"\n\t"	\
+			".set	mips0"				"\n"	\
+			: "=r" (__val)					\
+			: "m" (*__addr));				\
+	} else {							\
+		__val = 0;						\
+		BUG();							\
+	}								\
 	slow;								\
 									\
 	return pfx##ioswab##bwlq(__addr, __val);			\
@@ -432,7 +458,7 @@ BUILDIO_MEM(q, u64)
 BUILDIO_IOPORT(b, u8)
 BUILDIO_IOPORT(w, u16)
 BUILDIO_IOPORT(l, u32)
-#ifdef CONFIG_64BIT
+#if defined(CONFIG_64BIT) || defined(CONFIG_CPU_R5900)
 BUILDIO_IOPORT(q, u64)
 #endif
 
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/irqflags.h linux-2.6.35.4/arch/mips/include/asm/irqflags.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/irqflags.h	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/include/asm/irqflags.h	2014-07-18 22:29:43.526367724 +0200
@@ -29,10 +29,16 @@ __asm__(
 #elif defined(CONFIG_CPU_MIPSR2)
 	"	ei							\n"
 #else
+#ifdef CONFIG_CPU_R5900
+	"	sync.p							\n"
+#endif
 	"	mfc0	$1,$12						\n"
 	"	ori	$1,0x1f						\n"
 	"	xori	$1,0x1e						\n"
 	"	mtc0	$1,$12						\n"
+#ifdef CONFIG_CPU_R5900
+	"	sync.p							\n"
+#endif
 #endif
 	"	irq_enable_hazard					\n"
 	"	.set	pop						\n"
@@ -87,11 +93,17 @@ __asm__(
 #elif defined(CONFIG_CPU_MIPSR2)
 	"	di							\n"
 #else
+#ifdef CONFIG_CPU_R5900
+	"	sync.p							\n"
+#endif
 	"	mfc0	$1,$12						\n"
 	"	ori	$1,0x1f						\n"
 	"	xori	$1,0x1f						\n"
 	"	.set	noreorder					\n"
 	"	mtc0	$1,$12						\n"
+#ifdef CONFIG_CPU_R5900
+	"	sync.p							\n"
+#endif
 #endif
 	"	irq_disable_hazard					\n"
 	"	.set	pop						\n"
@@ -113,6 +125,9 @@ __asm__(
 #ifdef CONFIG_MIPS_MT_SMTC
 	"	mfc0	\\flags, $2, 1					\n"
 #else
+#ifdef CONFIG_CPU_R5900
+	"	sync.p							\n"
+#endif
 	"	mfc0	\\flags, $12					\n"
 #endif
 	"	.set	pop						\n"
@@ -138,11 +153,17 @@ __asm__(
 	"	di	\\result					\n"
 	"	andi	\\result, 1					\n"
 #else
+#ifdef CONFIG_CPU_R5900
+	"	sync.p							\n"
+#endif
 	"	mfc0	\\result, $12					\n"
 	"	ori	$1, \\result, 0x1f				\n"
 	"	xori	$1, 0x1f					\n"
 	"	.set	noreorder					\n"
 	"	mtc0	$1, $12						\n"
+#ifdef CONFIG_CPU_R5900
+	"	sync.p							\n"
+#endif
 #endif
 	"	irq_disable_hazard					\n"
 	"	.set	pop						\n"
@@ -184,12 +205,18 @@ __asm__(
 	"	ins	$1, \\flags, 0, 1				\n"
 	"	mtc0	$1, $12						\n"
 #else
+#ifdef CONFIG_CPU_R5900
+	"	sync.p							\n"
+#endif
 	"	mfc0	$1, $12						\n"
 	"	andi	\\flags, 1					\n"
 	"	ori	$1, 0x1f					\n"
 	"	xori	$1, 0x1f					\n"
 	"	or	\\flags, $1					\n"
 	"	mtc0	\\flags, $12					\n"
+#ifdef CONFIG_CPU_R5900
+	"	sync.p							\n"
+#endif
 #endif
 	"	irq_disable_hazard					\n"
 	"	.set	pop						\n"
@@ -249,22 +276,22 @@ static inline int raw_irqs_disabled_flag
 /* Reload some registers clobbered by trace_hardirqs_on */
 #ifdef CONFIG_64BIT
 # define TRACE_IRQS_RELOAD_REGS						\
-	LONG_L	$11, PT_R11(sp);					\
-	LONG_L	$10, PT_R10(sp);					\
-	LONG_L	$9, PT_R9(sp);						\
-	LONG_L	$8, PT_R8(sp);						\
-	LONG_L	$7, PT_R7(sp);						\
-	LONG_L	$6, PT_R6(sp);						\
-	LONG_L	$5, PT_R5(sp);						\
-	LONG_L	$4, PT_R4(sp);						\
-	LONG_L	$2, PT_R2(sp)
+	LONGD_L	$11, PT_R11(sp);					\
+	LONGD_L	$10, PT_R10(sp);					\
+	LONGD_L	$9, PT_R9(sp);						\
+	LONGD_L	$8, PT_R8(sp);						\
+	LONGD_L	$7, PT_R7(sp);						\
+	LONGD_L	$6, PT_R6(sp);						\
+	LONGD_L	$5, PT_R5(sp);						\
+	LONGD_L	$4, PT_R4(sp);						\
+	LONGD_L	$2, PT_R2(sp)
 #else
 # define TRACE_IRQS_RELOAD_REGS						\
-	LONG_L	$7, PT_R7(sp);						\
-	LONG_L	$6, PT_R6(sp);						\
-	LONG_L	$5, PT_R5(sp);						\
-	LONG_L	$4, PT_R4(sp);						\
-	LONG_L	$2, PT_R2(sp)
+	LONGD_L	$7, PT_R7(sp);						\
+	LONGD_L	$6, PT_R6(sp);						\
+	LONGD_L	$5, PT_R5(sp);						\
+	LONGD_L	$4, PT_R4(sp);						\
+	LONGD_L	$2, PT_R2(sp)
 #endif
 # define TRACE_IRQS_ON							\
 	CLI;	/* make sure trace_hardirqs_on() is called in kernel level */ \
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/mach-generic/spaces.h linux-2.6.35.4/arch/mips/include/asm/mach-generic/spaces.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/mach-generic/spaces.h	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/include/asm/mach-generic/spaces.h	2014-07-18 22:29:43.534367724 +0200
@@ -19,7 +19,7 @@
 #define PHYS_OFFSET		_AC(0, UL)
 #endif
 
-#ifdef CONFIG_32BIT
+#if defined(CONFIG_32BIT) || defined(CONFIG_CPU_R5900)
 
 #define CAC_BASE		_AC(0x80000000, UL)
 #define IO_BASE			_AC(0xa0000000, UL)
@@ -38,7 +38,7 @@
 
 #endif /* CONFIG_32BIT */
 
-#ifdef CONFIG_64BIT
+#if defined(CONFIG_64BIT) && !defined(CONFIG_CPU_R5900)
 
 #ifndef CAC_BASE
 #ifdef CONFIG_DMA_NONCOHERENT
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/bootinfo.h linux-2.6.35.4/arch/mips/include/asm/mach-ps2/bootinfo.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/bootinfo.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/include/asm/mach-ps2/bootinfo.h	2014-07-18 22:29:43.534367724 +0200
@@ -0,0 +1,72 @@
+/*
+ *  PlayStation 2 Bootinfo
+ *
+ *  Copyright (C) 2000-2001 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_PS2_BOOTINFO_H
+#define __ASM_PS2_BOOTINFO_H
+
+#include <asm/mach-ps2/sysconf.h>
+
+#define PS2_BOOTINFO_MAGIC	0x50324c42	/* "P2LB" */
+#define PS2_BOOTINFO_OLDADDR	0x01fff000
+#define PS2_BOOTINFO_MACHTYPE_PS2	0
+#define PS2_BOOTINFO_MACHTYPE_T10K	1
+
+struct ps2_rtc {
+    u_char padding_1;
+    u_char sec;
+    u_char min;
+    u_char hour;
+    u_char padding_2;
+    u_char day;
+    u_char mon;
+    u_char year;
+};
+
+struct ps2_bootinfo {
+    __u32		pccard_type;
+    __u32		opt_string;
+    __u32		reserved0;
+    __u32		reserved1;
+    struct ps2_rtc	boot_time;
+    __u32		mach_type;
+    __u32		pcic_type;
+    struct ps2_sysconf	sysconf;
+    __u32		magic;
+    __s32		size;
+    __u32		sbios_base;
+    __u32		maxmem;
+    __u32		stringsize;
+    char		*stringdata;
+    char		*ver_vm;
+    char		*ver_rb;
+    char		*ver_model;
+    char		*ver_ps1drv_rom;
+    char		*ver_ps1drv_hdd;
+    char		*ver_ps1drv_path;
+    char		*ver_dvd_id;
+    char		*ver_dvd_rom;
+    char		*ver_dvd_hdd;
+    char		*ver_dvd_path;
+};
+#define PS2_BOOTINFO_OLDSIZE	((uintptr_t)(&((struct ps2_bootinfo*)0)->magic))
+
+extern struct ps2_bootinfo *ps2_bootinfo;
+
+#endif /* __ASM_PS2_BOOTINFO_H */
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/cdrom.h linux-2.6.35.4/arch/mips/include/asm/mach-ps2/cdrom.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/cdrom.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/include/asm/mach-ps2/cdrom.h	2014-07-18 22:29:43.534367724 +0200
@@ -0,0 +1,123 @@
+/*
+ *  PlayStation 2 CDROM
+ *
+ *  Copyright (C) 2000-2001 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_PS2_CDROM_H
+#define __ASM_PS2_CDROM_H
+
+/*
+ * read data pattern
+ */
+#define SCECdSecS2048		0	/* sector size 2048 */
+#define SCECdSecS2328		1	/* sector size 2328 */
+#define SCECdSecS2340		2	/* sector size 2340 */
+#define SCECdSecS2352		0	/* sector size 2352  CD-DA read */
+#define SCECdSecS2368		1	/* sector size 2368  CD-DA read */
+#define SCECdSecS2448		2	/* sector size 2448  CD-DA read */
+
+/*
+ * spindle control
+ */
+#define SCECdSpinMax		0	/* maximum speed	*/
+#define SCECdSpinNom		1	/* optimized speed	*/
+#define SCECdSpinX1             2	/* x1			*/
+#define SCECdSpinX2             3	/* x2			*/
+#define SCECdSpinX4             4	/* x4			*/
+#define SCECdSpinX12            5	/* x12			*/
+#define SCECdSpinNm2           10	/* optimized speed
+					   (based on current speed) */
+#define SCECdSpin1p6           11	/* DVD x1.6 CLV		*/
+#define SCECdSpinMx            20	/* maximum speed	*/
+
+/*
+ * read mode
+ */
+typedef struct sceCdRMode {
+	u_char trycount;	/* trycount   */
+	u_char spindlctrl;	/* spindlctrl */
+	u_char datapattern;	/* datapattern */
+	u_char pad;		/* pad         */
+} sceCdRMode;
+
+/*
+ *      stream command
+ */
+#define PS2CDVD_STREAM_START	1
+#define PS2CDVD_STREAM_READ	2
+#define PS2CDVD_STREAM_STOP	3
+#define PS2CDVD_STREAM_SEEK	4
+#define PS2CDVD_STREAM_INIT	5
+#define PS2CDVD_STREAM_STAT	6
+#define PS2CDVD_STREAM_PAUSE	7
+#define PS2CDVD_STREAM_RESUME	8
+#define PS2CDVD_STREAM_SEEKF	9
+
+/*
+ * disc type
+ */
+#define SCECdIllgalMedia 	0xff
+#define SCECdDVDV		0xfe
+#define SCECdCDDA		0xfd
+#define SCECdPS2DVD		0x14
+#define SCECdPS2CDDA		0x13
+#define SCECdPS2CD		0x12
+#define SCECdPSCDDA 		0x11
+#define SCECdPSCD		0x10
+#define SCECdUNKNOWN		0x05
+#define SCECdDETCTDVDD		0x04
+#define SCECdDETCTDVDS		0x03
+#define SCECdDETCTCD		0x02
+#define SCECdDETCT		0x01
+#define SCECdNODISC 		0x00
+
+typedef struct ps2cdvd_dastream_command {
+    u_int command;
+    u_int lbn;
+    u_int sectors;
+    void *buf;
+    struct sceCdRMode rmode;
+    int result;
+} ps2cdvd_dastream_command;
+
+typedef struct ps2cdvd_subchannel {
+    int stat;
+    u_char data[10];
+    u_char reserved[2];
+} ps2cdvd_subchannel;
+
+typedef struct ps2cdvd_read
+{
+    u_int lbn;
+    u_int sectors;
+    void *buf;
+} ps2cdvd_read;
+
+typedef struct ps2cdvd_rcbyctl {
+    int param;
+    int stat;
+} ps2cdvd_rcbyctl;
+
+#define PS2CDVDIO_DASTREAM	_IOWR('V', 0, ps2cdvd_dastream_command)
+#define PS2CDVDIO_READSUBQ	_IOWR('V', 1, ps2cdvd_subchannel)
+#define PS2CDVDIO_GETDISCTYPE	_IOR('V', 2, int)
+#define PS2CDVDIO_READMODE1	_IOW('V', 3, ps2cdvd_read)
+#define PS2CDVDIO_RCBYCTL	_IOWR('V', 4, ps2cdvd_rcbyctl)
+#define PS2CDVDIO_CHANGETRYCNT  _IO('V', 5)
+
+#endif /* __ASM_PS2_CDROM_H */
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/cdvdcall.h linux-2.6.35.4/arch/mips/include/asm/mach-ps2/cdvdcall.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/cdvdcall.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/include/asm/mach-ps2/cdvdcall.h	2014-07-18 22:29:43.534367724 +0200
@@ -0,0 +1,246 @@
+/*
+ *  PlayStation 2 CD/DVD driver
+ *
+ *  Copyright (C) 2000-2001 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/sched.h>
+
+#include <asm/mach-ps2/sifdefs.h>
+#include <asm/mach-ps2/sbios.h>
+#include <asm/mach-ps2/cdrom.h>
+
+static __inline__ int ps2cdvdcall_init(void)
+{
+	int res;
+
+#ifdef CONFIG_PS2_SBIOS_VER_CHECK
+	if (sbios(SB_GETVER, NULL) < 0x0200)
+		return -1;
+#endif
+
+	do {
+		if (sbios_rpc(SBR_CDVD_INIT, NULL, &res) < 0)
+			return (-1);
+		schedule_timeout(1);
+	} while (res < 0);
+
+	return (res);
+}
+
+static __inline__ int ps2cdvdcall_reset(void)
+{
+	int res;
+
+	if (sbios_rpc(SBR_CDVD_RESET, NULL, &res) < 0)
+		return (-1);
+
+	return (res);
+}
+
+static __inline__ int ps2cdvdcall_ready(int mode)
+{
+	struct sbr_cdvd_ready_arg arg;
+	int res;
+
+	arg.mode = mode;
+
+	if (sbios_rpc(SBR_CDVD_READY, &arg, &res) < 0)
+		return (-1);
+
+	return (res);
+}
+
+static __inline__ int ps2cdvdcall_read(u_int lbn, u_int sectors, void *buf,
+				       struct sceCdRMode *rmode)
+{
+	struct sbr_cdvd_read_arg arg;
+	int res;
+
+	arg.lbn = lbn;
+	arg.sectors = sectors;
+	arg.buf = buf;
+	arg.rmode = rmode;
+
+	if (sbios_rpc(SBR_CDVD_READ, &arg, &res) < 0)
+		return (-1);
+
+	return (res);
+}
+
+static __inline__ int ps2cdvdcall_stop(void)
+{
+	int res;
+
+	if (sbios_rpc(SBR_CDVD_STOP, NULL, &res) < 0)
+		return (-1);
+
+	return (res);
+}
+
+static __inline__ int ps2cdvdcall_gettoc(u_char *buf, int *len, int *media)
+{
+	struct sbr_cdvd_gettoc_arg arg;
+	int res;
+
+	arg.buf = buf;
+	arg.len = *len;
+	if (sbios_rpc(SBR_CDVD_GETTOC, &arg, &res) < 0)
+		return (-1);
+	*len = arg.len;
+	*media = arg.media;
+
+	return (res);
+}
+
+static __inline__ int ps2cdvdcall_readrtc(struct sbr_cdvd_rtc_arg *rtc)
+{
+	int res;
+
+	if (sbios_rpc(SBR_CDVD_READRTC, rtc, &res) < 0)
+		return (-1);
+
+	return (res);
+}
+
+static __inline__ int ps2cdvdcall_writertc(struct sbr_cdvd_rtc_arg *rtc)
+{
+	int res;
+
+	if (sbios_rpc(SBR_CDVD_WRITERTC, rtc, &res) < 0)
+		return (-1);
+
+	return (res);
+}
+
+static __inline__ int ps2cdvdcall_mmode(int media)
+{
+	struct sbr_cdvd_mmode_arg arg;
+	int res;
+
+	arg.media = media;
+	if (sbios_rpc(SBR_CDVD_MMODE, &arg, &res) < 0)
+		return (-1);
+
+	return (res);
+}
+
+#ifdef PS2LIBCDVD_H /* TBD: Move definition of SCECdErFAIL. */
+static __inline__ int ps2cdvdcall_geterror(void)
+{
+	int res;
+
+	if (sbios_rpc(SBR_CDVD_GETERROR, NULL, &res) < 0)
+		return (SCECdErFAIL);
+
+	return (res);
+}
+#endif
+
+static __inline__ int ps2cdvdcall_gettype(int *type)
+{
+	return sbios_rpc(SBR_CDVD_GETTYPE, NULL, type);
+}
+
+static __inline__ int ps2cdvdcall_trayreq(int req, int *traycount)
+{
+	struct sbr_cdvd_trayreq_arg arg;
+	int res;
+
+	arg.req = req;
+	if (sbios_rpc(SBR_CDVD_TRAYREQ, &arg, &res) < 0)
+		return (-1);
+	if (traycount)
+		*traycount = arg.traycount; 
+
+	return (res);
+}
+
+static __inline__ int ps2cdvdcall_dastream(u_int command, u_int lbn,
+					   int size, void *buf,
+					   struct sceCdRMode *rmode)
+{
+	struct sbr_cdvd_dastream_arg arg;
+	int res;
+
+#ifdef CONFIG_PS2_SBIOS_VER_CHECK
+	if (sbios(SB_GETVER, NULL) < 0x0202)
+		return (-1);
+#endif
+
+	arg.command = command;
+	arg.lbn = lbn;
+	arg.size = size;
+	arg.buf = buf;
+	arg.rmode = rmode;
+
+	if (sbios_rpc(SBR_CDVD_DASTREAM, &arg, &res) < 0)
+		return (-1);
+
+	return (res);
+}
+
+static __inline__ int ps2cdvdcall_readsubq(u_char *subq, int *stat)
+{
+	struct sbr_cdvd_readsubq_arg arg;
+	int res;
+
+#ifdef CONFIG_PS2_SBIOS_VER_CHECK
+	if (sbios(SB_GETVER, NULL) < 0x0202)
+		return (-1);
+#endif
+        if (sbios_rpc(SBR_CDVD_READSUBQ, &arg, &res) < 0)
+		return (-1);
+	if (subq)
+		memcpy(subq, arg.data, 10);
+	if (stat)
+		*stat = arg.stat;
+
+	return (res != 0 ? 0 : -1); /* res=0 means failure */
+}
+
+static __inline__ int ps2cdvdcall_rcbyctl(int param, int *stat)
+{
+	struct sbr_cdvd_rcbyctl_arg arg;
+	int res;
+
+	arg.param = param;
+
+	if (sbios_rpc(SBR_CDVD_RCBYCTL, &arg, &res) < 0)
+		return (0);
+
+	*stat = arg.stat;
+
+	return (res);
+}
+
+static __inline__ int ps2cdvdcall_read_dvd(u_int lbn, u_int sectors, void *buf,
+				       struct sceCdRMode *rmode)
+{
+	struct sbr_cdvd_read_arg arg;
+	int res;
+
+	arg.lbn = lbn;
+	arg.sectors = sectors;
+	arg.buf = buf;
+	arg.rmode = rmode;
+
+	if (sbios_rpc(SBR_CDVD_READ_DVD, &arg, &res) < 0)
+		return (-1);
+
+	return (res);
+}
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/cpu-feature-overrides.h linux-2.6.35.4/arch/mips/include/asm/mach-ps2/cpu-feature-overrides.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/cpu-feature-overrides.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/include/asm/mach-ps2/cpu-feature-overrides.h	2014-07-18 22:29:43.534367724 +0200
@@ -0,0 +1,64 @@
+/*
+ *  PlayStation 2 CPU features
+ *
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_MACH_PS2_CPU_FEATURE_OVERRIDES_H
+#define __ASM_MACH_PS2_CPU_FEATURE_OVERRIDES_H
+
+#define cpu_has_llsc			0
+#define cpu_has_4k_cache		1
+#define cpu_has_divec			1
+#define cpu_has_4kex			1
+#define cpu_has_counter			1
+#define cpu_has_cache_cdex_p		0
+#define cpu_has_cache_cdex_s		0
+#define cpu_has_mcheck			0
+#define cpu_has_nofpuex			1
+#define cpu_has_mipsmt			0
+#define cpu_has_vce			0
+#define cpu_has_dsp			1
+#define cpu_has_userlocal		0
+#define cpu_has_64bit_addresses		0
+#define cpu_has_64bit   		1
+#ifdef CONFIG_R5900_128BIT_SUPPORT
+#define cpu_has_64bit_gp_regs		1
+#define cpu_has_64bit_zero_reg		1
+#else
+#define cpu_has_64bit_gp_regs		0
+#define cpu_has_64bit_zero_reg		0
+#endif
+#define cpu_vmbits			31
+#define cpu_has_clo_clz			0
+#define cpu_has_ejtag			0
+#define cpu_has_ic_fills_f_dc		0
+#define cpu_has_inclusive_pcaches	0
+/* TBD: Currently there is no newer GCC which creates compatible FPU code.
+ * Only GCC 2.95 creates compatible FPU code.
+ * So FPU is always emulated and disabled here.
+ */
+#if 1
+/* For ABI n32 the 64 bit CPU must be emulated. The 32 bit CPU can't be used.
+ * The r5900 FPU doesn't comply with IEEE 794 which is expected by
+ * most programs.
+ * Tasks with TIF_32BIT_REGS set, are compiled with r5900 FPU support.
+ */
+#define cpu_has_fpu (test_thread_flag(TIF_R5900FPU))
+#else
+#define cpu_has_fpu 			0
+#endif
+
+#endif
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/dma.h linux-2.6.35.4/arch/mips/include/asm/mach-ps2/dma.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/dma.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/include/asm/mach-ps2/dma.h	2014-07-18 22:29:43.534367724 +0200
@@ -0,0 +1,156 @@
+/*
+ *  PlayStation 2 DMA
+ *
+ *  Copyright (C) 2000-2001 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_PS2_DMA_H
+#define __ASM_PS2_DMA_H
+
+#include <linux/spinlock.h>
+#include <linux/completion.h>
+#include <linux/interrupt.h>
+#include <asm/types.h>
+#include <asm/io.h>
+
+//#define DEBUG
+#ifdef DEBUG
+#define DPRINT(fmt, args...) \
+	printk(__FILE__ ": " fmt, ## args)
+#define DSPRINT(fmt, args...) \
+	prom_printf(__FILE__ ": " fmt, ## args)
+#else
+#define DPRINT(fmt, args...)
+#define DSPRINT(fmt, args...)
+#endif
+
+#define DMA_VIF0	0
+#define DMA_VIF1	1
+#define DMA_GIF		2
+#define DMA_IPU_from	3
+#define DMA_IPU_to	4
+#define DMA_SPR_from	5
+#define DMA_SPR_to	6
+
+#define DMA_SENDCH	0
+#define DMA_RECVCH	1
+
+#define DMA_TRUNIT	16
+#define DMA_ALIGN(x)	((__typeof__(x))(((unsigned long)(x) + (DMA_TRUNIT - 1)) & ~(DMA_TRUNIT - 1)))
+
+#define DMA_TRUNIT_IMG		128
+#define DMA_ALIGN_IMG(x)	((__typeof__(x))(((unsigned long)(x) + (DMA_TRUNIT_IMG - 1)) & ~(DMA_TRUNIT_IMG - 1)))
+
+#define DMA_TIMEOUT		(HZ / 2)
+#define DMA_POLLING_TIMEOUT	1500000
+
+/* DMA registers */
+
+#define PS2_D_STAT	0x1000e010
+#define PS2_D_ENABLER	0x1000f520
+#define PS2_D_ENABLEW	0x1000f590
+
+#define PS2_Dn_CHCR	0x0000
+#define PS2_Dn_MADR	0x0010
+#define PS2_Dn_QWC	0x0020
+#define PS2_Dn_TADR	0x0030
+#define PS2_Dn_SADR	0x0080
+
+#define CHCR_STOP	0x0000
+#define CHCR_SENDN	0x0101
+#define CHCR_SENDC	0x0105
+#define CHCR_SENDC_TTE	0x0145
+#define CHCR_RECVN	0x0100
+
+#define READDMAREG(ch, x)		inl((ch)->base + (x))
+#define WRITEDMAREG(ch, x, value)	outl((value), (ch)->base + (x))
+#define DMABREAK(ch)	\
+    do { \
+	 outl(inl(PS2_D_ENABLER) | (1 << 16), PS2_D_ENABLEW); \
+	 READDMAREG((ch), PS2_Dn_CHCR); \
+	 READDMAREG((ch), PS2_Dn_CHCR); \
+	 WRITEDMAREG((ch), PS2_Dn_CHCR, CHCR_STOP); \
+	 outl(inl(PS2_D_ENABLER) & ~(1 << 16), PS2_D_ENABLEW); } while (0)
+#define IS_DMA_RUNNING(ch)	((READDMAREG((ch), PS2_Dn_CHCR) & 0x0100) != 0)
+
+struct dma_tag {
+    u16 qwc;
+    u16 id;
+    u32 addr;
+} __attribute__((aligned(DMA_TRUNIT)));
+
+#define DMATAG_SET(qwc, id, addr)	\
+	((u64)(qwc) | ((u64)(id) << 16) | ((u64)(addr) << 32))
+#define DMATAG_REFE	0x0000
+#define DMATAG_CNT	0x1000
+#define DMATAG_NEXT	0x2000
+#define DMATAG_REF	0x3000
+#define DMATAG_REFS	0x4000
+#define DMATAG_CALL	0x5000
+#define DMATAG_RET	0x6000
+#define DMATAG_END	0x7000
+
+/* DMA channel structures */
+
+struct dma_request;
+
+struct dma_channel {
+    int irq;				/* DMA interrupt IRQ # */
+    unsigned long base;			/* DMA register base addr */
+    int direction;			/* data direction */
+    int isspr;				/* true if DMA for scratchpad RAM */
+    char *device;			/* request_irq() device name */
+    void (*reset)(void);		/* FIFO reset function */
+    spinlock_t lock;
+
+    struct dma_request *head, *tail;	/* DMA request queue */
+    struct dma_tag *tagp;		/* tag pointer (for destination DMA) */
+};
+
+struct dma_ops {
+    void (*start)(struct dma_request *, struct dma_channel *);
+    int (*isdone)(struct dma_request *, struct dma_channel *);
+    unsigned long (*stop)(struct dma_request *, struct dma_channel *);
+    void (*free)(struct dma_request *, struct dma_channel *);
+};
+
+struct dma_request {
+    struct dma_request *next;		/* next request */
+    struct dma_ops *ops;		/* DMA operation functions */
+};
+
+#define init_dma_request(_req, _ops)	\
+    do { (_req)->next = NULL; (_req)->ops = (_ops); } while (0)
+
+struct dma_completion {
+    int done;
+    spinlock_t lock;
+    wait_queue_head_t wait;
+};
+
+/* function prototypes */
+
+extern struct dma_channel ps2dma_channels[];
+void __init ps2dma_init(void);
+irqreturn_t ps2dma_intr_handler(int irq, void *dev_id);
+void ps2dma_add_queue(struct dma_request *req, struct dma_channel *ch, int flushall);
+void ps2dma_complete(struct dma_completion *x);
+void ps2dma_init_completion(struct dma_completion *x);
+int ps2dma_intr_safe_wait_for_completion(struct dma_channel *ch, int polling, struct dma_completion *x);
+int ps2sdma_send(int chno, const void *ptr, int len, int flushall);
+
+#endif /* __ASM_PS2_DMA_H */
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/dmarelay.h linux-2.6.35.4/arch/mips/include/asm/mach-ps2/dmarelay.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/dmarelay.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/include/asm/mach-ps2/dmarelay.h	2014-07-18 22:29:43.534367724 +0200
@@ -0,0 +1,65 @@
+/*
+ *  PlayStation 2 DMA relay
+ *
+ *  Copyright (C) 2001      Sony Computer Entertainment Inc.
+ *  Copyright (C) 2011-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_PS2_DMARELAY_H
+#define __ASM_PS2_DMARELAY_H
+
+#define	SIFNUM_ATA_DMA_BEGIN		0x2000
+#define	SIFNUM_GetBufAddr		0
+#define	SIFNUM_DmaRead			1
+#define	SIFNUM_DmaWrite			2
+#define	SIFNUM_ATA_DMA_END		0x2001
+
+/* 0x2002,0x2003,0x2004 and 0x2005 are obsolete. */
+#define	SIFNUM_SMAP_TX_DMA_BEGIN	0x2006
+#define	SIFNUM_SmapGetTxBufAddr		0
+#define	SIFNUM_SmapDmaWrite		1
+#define	SIFNUM_SMAP_TX_DMA_END		0x2007
+#define	SIFNUM_SMAP_RX_DMA_BEGIN	0x2008
+#define	SIFNUM_SmapGetRxBufAddr		0
+#define	SIFNUM_SmapDmaRead		1
+#define	SIFNUM_SMAP_RX_DMA_END		0x2009
+
+#define ATA_MAX_ENTRIES		256
+#define ATA_BUFFER_SIZE		(512 * ATA_MAX_ENTRIES)
+
+struct ata_dma_request {
+    int command;
+    int size;
+    int count;
+    int devctrl;
+    ps2sif_dmadata_t sdd[ATA_MAX_ENTRIES];
+};
+
+#define	SMAP_DMA_ENTRIES		10
+
+struct smap_dma_request {
+    int command;
+    int size;
+    int count;
+    int devctrl;
+    struct {
+	unsigned int i_addr;
+	unsigned int f_addr;
+	unsigned int size;
+	unsigned int sdd_misc;
+    } sdd[SMAP_DMA_ENTRIES];
+};
+#endif /* __ASM_PS2_DMARELAY_H */
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/eedev.h linux-2.6.35.4/arch/mips/include/asm/mach-ps2/eedev.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/eedev.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/include/asm/mach-ps2/eedev.h	2014-07-18 22:29:43.534367724 +0200
@@ -0,0 +1,111 @@
+/*
+ *  PlayStation 2 Emotion Engine
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_PS2_EEDEV_H
+#define __ASM_PS2_EEDEV_H
+
+#include <asm/types.h>
+#include <asm/io.h>
+
+#define ALIGN16(x)	(((unsigned long)(x) + 15) & ~15)
+#define PACK32(x, y)	((x) | ((y) << 16))
+#define PACK64(x, y)	((u64)(x) | ((u64)(y) << 32))
+
+#define GSFB_SIZE		(4 * 1024 * 1024)
+/* The scratchpad has no physical address, ise the following value to detect
+ * the scratchpad in the TLB handlers.
+ * The TLB handler expects that the highest bit is set.
+ */
+#define SPR_PHYS_ADDR		0x80000000
+/* EntryLo0 flag to use scratchpad instead or normal RAM. */
+#define SCRATCHPAD_RAM		0x80000000
+/* Size of scratchpad memory. */
+#define SPR_SIZE		16384
+
+/* register defines */
+
+#define IPUREG_CMD		0x10002000
+#define IPUREG_CTRL		0x10002010
+#define IPUREG_BP		0x10002020
+#define IPUREG_TOP		0x10002030
+
+#define GIFREG_BASE		0x10003000
+#define GIFREG(x)		(inl(GIFREG_BASE + ((x) << 4)))
+#define SET_GIFREG(x, val)	(outl(val, GIFREG_BASE + ((x) << 4)))
+#define VIF0REG_BASE		0x10003800
+#define VIF0REG(x)		(inl(VIF0REG_BASE + ((x) << 4)))
+#define SET_VIF0REG(x, val)		(outl(val, VIF0REG_BASE + ((x) << 4)))
+#define VIF1REG_BASE		0x10003c00
+#define VIF1REG(x)		(inl(VIF1REG_BASE + ((x) << 4)))
+#define SET_VIF1REG(x, val)	(outl(val, VIF1REG_BASE + ((x) << 4)))
+#define VIFnREG(n, x)		\
+	(inl(VIF0REG_BASE + ((n) * 0x0400) + ((x) << 4)))
+#define SET_VIFnREG(n, x, val)		\
+	(outl(val, VIF0REG_BASE + ((n) * 0x0400) + ((x) << 4)))
+
+#define VIF0_FIFO		0x10004000
+#define VIF1_FIFO		0x10005000
+#define GIF_FIFO		0x10006000
+#define IPU_O_FIFO		0x10007000
+#define IPU_I_FIFO		0x10007010
+
+#define GSSREG_BASE1		0x12000000
+#define GSSREG_BASE2		0x12001000
+#define GSSREG1(x)		(GSSREG_BASE1 + ((x) << 4))
+#define GSSREG2(x)		(GSSREG_BASE2 + (((x) & 0x0f) << 4))
+
+/* inline assembler functions */
+
+union _dword {
+        __u64 di;
+        struct {
+#ifdef CONFIG_CPU_LITTLE_ENDIAN
+                __u32   lo, hi;
+#else
+                __u32   hi, lo;
+#endif
+        } si;
+};
+
+/* TBD: Use offical I/O functions of kernel instead. */
+static inline void move_quad(unsigned long dest, unsigned long src)
+{
+    __asm__ __volatile__(
+	"	.set	push\n"
+	"	.set	arch=r5900\n"
+	"	move	$8,%1\n"
+	"	lq     $9,($8)\n"
+	"	move	$8,%0\n"
+	"	sq     $9,($8)\n"
+	"	.set	pop"
+	: : "r" (dest), "r" (src) : "$8", "$9" );
+}
+
+static inline void dummy_read_quad(unsigned long addr)
+{
+    __asm__ __volatile__(
+	"	.set	push\n"
+	"	.set	arch=r5900\n"
+	"	lq	$9,(%0)\n"
+	"	.set	pop"
+	: : "r" (addr) : "$9" );
+}
+
+#endif /* __ASM_PS2_EEDEV_H */
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/gsfunc.h linux-2.6.35.4/arch/mips/include/asm/mach-ps2/gsfunc.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/gsfunc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/include/asm/mach-ps2/gsfunc.h	2014-07-18 22:29:43.534367724 +0200
@@ -0,0 +1,42 @@
+/*
+ *  PlayStation 2 Graphic Synthesizer
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_PS2_GSFUNC_H
+#define __ASM_PS2_GSFUNC_H
+
+#include <linux/ps2/dev.h>
+#include <asm/types.h>
+
+int ps2gs_set_gssreg(int reg, u64 val);
+int ps2gs_get_gssreg(int reg, u64 *val);
+int ps2gs_set_gsreg(int reg, u64 val);
+
+int ps2gs_crtmode(struct ps2_crtmode *crtmode, struct ps2_crtmode *old);
+int ps2gs_display(int ch, struct ps2_display *display, struct ps2_display *old);
+int ps2gs_dispfb(int ch, struct ps2_dispfb *dispfb, struct ps2_dispfb *old);
+int ps2gs_pmode(struct ps2_pmode *pmode, struct ps2_pmode *old);
+int ps2gs_screeninfo(struct ps2_screeninfo *info, struct ps2_screeninfo *old);
+int ps2gs_setdpms(int mode);
+int ps2gs_blank(int onoff);
+int ps2gs_reset(int mode);
+
+extern void (*ps2gs_screeninfo_hook)(struct ps2_screeninfo *info);
+
+#endif /* __ASM_PS2_GSFUNC_H */
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/ioremap.h linux-2.6.35.4/arch/mips/include/asm/mach-ps2/ioremap.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/ioremap.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/include/asm/mach-ps2/ioremap.h	2014-07-18 22:29:43.534367724 +0200
@@ -0,0 +1,61 @@
+/*
+ *  PlayStation 2 I/O remap
+ *
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_MACH_PS2_IOREMAP_H
+#define __ASM_MACH_PS2_IOREMAP_H
+
+#include <linux/types.h>
+
+#include <asm/mach-ps2/ps2.h>
+
+/* There are no 64 bit addresses. No fixup is needed. */
+static inline phys_t fixup_bigphys_addr(phys_t phys_addr, phys_t size)
+{
+	return phys_addr;
+}
+
+static inline void __iomem *plat_ioremap(phys_t offset, unsigned long size,
+	unsigned long flags)
+{
+	if ((offset >= 0) && (offset < CKSEG0)) {
+		/* Memory is already mapped. */
+		if (flags & _CACHE_UNCACHED) {
+			return (void __iomem *)
+				(unsigned long)CKSEG1ADDR(offset);
+		} else {
+			return (void __iomem *)
+				(unsigned long)CKSEG0ADDR(offset);
+		}
+	}
+	/* Memory will be page mapped by kernel. */
+	return NULL;
+}
+
+static inline int plat_iounmap(const volatile void __iomem *addr)
+{
+	unsigned long kseg_addr;
+
+	kseg_addr = (unsigned long) addr;
+	if ((kseg_addr >= CKSEG0) && (kseg_addr < CKSEG2)) {
+		/* Memory is always mapped in kernel mode. No unmap possible. */
+		return 1;
+	}
+	return 0;
+}
+
+#endif /* __ASM_MACH_PS2_IOREMAP_H */
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/irq.h linux-2.6.35.4/arch/mips/include/asm/mach-ps2/irq.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/irq.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/include/asm/mach-ps2/irq.h	2014-07-18 22:29:43.534367724 +0200
@@ -0,0 +1,87 @@
+/*
+ *  PlayStation 2 IRQs
+ *
+ *  Copyright (C) 2000       Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_PS2_IRQ_H
+#define __ASM_PS2_IRQ_H
+
+/*
+ * PlayStation 2 interrupts
+ */
+
+#define NR_IRQS	56
+
+/* INTC */
+#define IRQ_INTC	0
+#define IRQ_INTC_GS	0
+#define IRQ_INTC_SBUS	1
+#define IRQ_INTC_VB_ON	2
+#define IRQ_INTC_VB_OFF	3
+#define IRQ_INTC_VIF0	4
+#define IRQ_INTC_VIF1	5
+#define IRQ_INTC_VU0	6
+#define IRQ_INTC_VU1	7
+#define IRQ_INTC_IPU	8
+#define IRQ_INTC_TIMER0	9
+#define IRQ_INTC_TIMER1	10
+#define IRQ_INTC_TIMER2	11
+#define IRQ_INTC_TIMER3	12
+#define IRQ_INTC_SFIFO	13
+#define IRQ_INTC_VU0WD	14
+#define IRQ_INTC_PGPU	15
+
+/* DMAC */
+#define IRQ_DMAC	16
+#define IRQ_DMAC_0	16
+#define IRQ_DMAC_1	17
+#define IRQ_DMAC_2	18
+#define IRQ_DMAC_3	19
+#define IRQ_DMAC_4	20
+#define IRQ_DMAC_5	21
+#define IRQ_DMAC_6	22
+#define IRQ_DMAC_7	23
+#define IRQ_DMAC_8	24
+#define IRQ_DMAC_9	25
+#define IRQ_DMAC_S	29
+#define IRQ_DMAC_ME	30
+#define IRQ_DMAC_BE	31
+
+/* GS */
+#define IRQ_GS			32
+#define IRQ_GS_SIGNAL	32
+#define IRQ_GS_FINISH	33
+#define IRQ_GS_HSYNC	34
+#define IRQ_GS_VSYNC	35
+#define IRQ_GS_EDW		36
+#define IRQ_GS_EXHSYNC	37
+#define IRQ_GS_EXVSYNC	38
+
+/* SBUS */
+#define IRQ_SBUS		40
+#define IRQ_SBUS_AIF	40
+#define IRQ_SBUS_PCIC	41
+#define IRQ_SBUS_USB	42
+
+/* MIPS IRQs */
+#define MIPS_CPU_IRQ_BASE	48
+#define IRQ_C0_INTC			50
+#define IRQ_C0_DMAC			51
+#define IRQ_C0_IRQ7			55
+
+#endif /* __ASM_PS2_IRQ_H */
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/ps2con.h linux-2.6.35.4/arch/mips/include/asm/mach-ps2/ps2con.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/ps2con.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/include/asm/mach-ps2/ps2con.h	2014-07-18 22:29:43.538367724 +0200
@@ -0,0 +1,82 @@
+/*
+ *  PlayStation 2 Graphic console
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _VIDEO_PS2CON_H
+#define _VIDEO_PS2CON_H
+
+/* TBD: Please use framebuffer driver instead! */
+#include <linux/types.h>
+#include <linux/kd.h>
+#include <linux/console_struct.h>
+#include <linux/vt_buffer.h>
+#include <linux/ps2/dev.h>
+#include <asm/io.h>
+
+/*
+ *  PlayStation 2 display structure
+ */
+
+struct ps2dpy {
+    struct ps2_screeninfo info;
+    int fbw;				/* frame buffer width */
+    int pixel_size;			/* # of bytes per pixel (2/3/4) */
+    unsigned int cmap[16];		/* colormap */
+    unsigned short can_soft_blank;	/* zero if no hardware blanking */
+
+    struct vc_data *conp;		/* pointer to console data */
+    unsigned short cursor_x;		/* current cursor position */
+    unsigned short cursor_y;
+    int fgcol;				/* text colors */
+    int bgcol;
+    const unsigned char *fontdata;		/* Font associated to this display */
+    unsigned short _fontheight;
+    unsigned short _fontwidth;
+    int grayfont;			/* != 0 if font is 4bpp grayscale */
+    int userfont;			/* != 0 if fontdata kmalloc()ed */
+    unsigned char fgshift, bgshift;
+    unsigned short charmask;		/* 0xff or 0x1ff */
+};
+
+#define fontwidth(p)	((p)->_fontwidth)
+#define fontheight(p)	((p)->_fontheight)
+
+#define attr_fgcol(p,s)		\
+	(((s) >> ((p)->fgshift)) & 0x0f)
+#define attr_bgcol(p,s)		\
+	(((s) >> ((p)->bgshift)) & 0x0f)
+#define attr_bgcol_ec(p,conp)	\
+	((conp) ? (((conp)->vc_video_erase_char >> ((p)->bgshift)) & 0x0f) : 0)
+
+
+#define is_nointer(p)	((p->info.mode == PS2_GS_NTSC || p->info.mode == PS2_GS_PAL) && !(p->info.res & PS2_GS_INTERLACE))
+
+#define bpp32to16(col)	\
+	((((col) & 0xf8) >> (8 - 5)) + (((col) & 0xf800) >> (16 - 10)) + \
+	 (((col) & 0xf80000) >> (24 - 15)) + ((col & 0x80000000) >> 16))
+
+/* function prototypes */
+
+void ps2con_initinfo(struct ps2_screeninfo *info);
+void ps2con_gsp_init(void);
+u64 *ps2con_gsp_alloc(int request, int *avail);
+void ps2con_gsp_send(int len, int flushall);
+int ps2con_get_resolution(int mode, int w, int h, int rate);
+
+#endif /* _VIDEO_PS2CON_H */
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/ps2.h linux-2.6.35.4/arch/mips/include/asm/mach-ps2/ps2.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/ps2.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/include/asm/mach-ps2/ps2.h	2014-07-18 22:29:43.534367724 +0200
@@ -0,0 +1,46 @@
+/*
+ *  PlayStation 2
+ *
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_PS2_PS2_H
+#define __ASM_PS2_PS2_H
+
+#include <linux/kernel.h>
+
+/* Device name of PS2 SBIOS serial device. */
+#define PS2_SBIOS_SERIAL_DEVICE_NAME "ttyS"
+
+/* Base address for hardware. */
+#define PS2_HW_BASE 0x10000000
+
+/* Base address for IOP memory. */
+#define PS2_IOP_HEAP_BASE 0x1c000000
+
+extern int ps2_pccard_present;
+extern int ps2_pcic_type;
+extern struct ps2_sysconf *ps2_sysconf;
+
+extern void prom_putchar(char);
+extern int ps2_printf(const char *fmt, ...);
+void ps2_dev_init(void);
+extern int ps2sif_initiopheap(void);
+extern int ps2rtc_init(void);
+void ps2_halt(int mode);
+int ps2_powerbutton_init(void);
+int ps2_powerbutton_enable_auto_shutoff(int enable_auto_shutoff);
+
+#endif
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/sbios.h linux-2.6.35.4/arch/mips/include/asm/mach-ps2/sbios.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/sbios.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/include/asm/mach-ps2/sbios.h	2014-07-18 22:29:43.538367724 +0200
@@ -0,0 +1,700 @@
+/*
+ *  PlayStation 2 Graphic console
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * Change history:
+ *
+ * Version 2.57         Mar 13, 2003
+ *	added:
+ *		SB_SETRGBYC
+ * Version 2.56         Nov 26, 2002
+ *	added:
+ *		SBR_REMOCON2_INIT
+ *		SBR_REMOCON2_END
+ *		SBR_REMOCON2_PORTOPEN
+ *		SBR_REMOCON2_PORTCLOSE
+ *		SBR_REMOCON2_FEATURE
+ *		SBR_REMOCON2_IGNORE
+ *		SB_REMOCON2_READ
+ * Version 2.55		Jan 09, 2002
+ *	added SBR_SOUND_REMOTE command definitions
+ * Version 2.54		Jan 08, 2002
+ *	deleted:
+ *		SBR_SOUND_VOICE_TRANS
+ *		SBR_SOUND_VOICE_TRANSSTAT
+ * Version 2.53		Dec 19, 2001
+ *	added:
+ *		SBR_SOUND_REMOTE
+ * Version 2.52		Dec 04, 2001
+ *	added:
+ *		SBR_CDVD_OPENCONFIG
+ *		SBR_CDVD_CLOSECONFIG
+ *		SBR_CDVD_READCONFIG
+ *		SBR_CDVD_WRITECONFIG
+ * Version 2.51		Nov 19, 2001
+ *	added:
+ *		SBR_REMOCON_INIT
+ *		SBR_REMOCON_END
+ *		SBR_REMOCON_PORTOPEN
+ *		SBR_REMOCON_PORTCLOSE
+ *		SB_REMOCON_READ
+ * Version 6.66
+ *              SBIOS provided by kernelloader
+ */
+
+#ifndef _PS2_SBIOS_H_
+#define _PS2_SBIOS_H_
+
+#include <linux/types.h>
+
+#ifdef CONFIG_64BIT
+/** Kernel uses 64-Bit pointers, but SBIOS expects 32-Bit pointers. */
+typedef uint32_t ps2_addr_t;
+typedef uint32_t ps2_const_addr_t;
+#else
+typedef void *ps2_addr_t;
+typedef const void *ps2_const_addr_t;
+#endif
+
+int sbios(int sbcall, void *arg);
+
+#define SBIOS_VERSION	0x0257
+
+#define SB_GETVER		0
+#define SB_HALT			1
+struct sb_halt_arg {
+    int mode;
+#define SB_HALT_MODE_PWROFF	0
+#define SB_HALT_MODE_HALT	1
+#define SB_HALT_MODE_RESTART	2
+};
+#define SB_SETDVE		2
+struct sb_setdve_arg {
+    int mode;
+};
+#define SB_PUTCHAR		3
+struct sb_putchar_arg {
+    char c;
+};
+#define SB_GETCHAR		4
+#define SB_SETGSCRT		5
+struct sb_setgscrt_arg {
+    int inter;
+    int omode;
+    int ffmode;
+    ps2_addr_t dx1, dy1, dx2, dy2;
+};
+#define SB_SETRGBYC		6
+struct sb_setrgbyc_arg {
+    int rgbyc;
+};
+
+/** Debug output in TGE (not supported by RTE). */
+#define SB_SET_PRINTS_CALLBACK 15
+
+/*
+ *  SIF DMA services
+ */
+
+#define SB_SIFINIT		16
+#define SB_SIFEXIT		17
+#define SB_SIFSETDMA		18
+struct sb_sifsetdma_arg {
+    ps2_addr_t sdd;
+    int len;
+};
+#define SB_SIFDMASTAT		19
+struct sb_sifdmastat_arg {
+    int id;
+};
+#define SB_SIFSETDCHAIN		20
+/* 21-23: reserved */
+
+/*
+ *  SIF CMD services
+ */
+
+#define SB_SIFINITCMD		32
+#define SB_SIFEXITCMD		33
+#define SB_SIFSENDCMD		34
+struct sb_sifsendcmd_arg {
+    u_int fid;
+    ps2_addr_t pp;
+    int ps;
+    ps2_addr_t src;
+    ps2_addr_t dest;
+    int size;
+};
+#define SB_SIFCMDINTRHDLR	35
+#define SB_SIFADDCMDHANDLER	36
+struct sb_sifaddcmdhandler_arg {
+    u_int fid;
+    ps2_addr_t func;
+    ps2_addr_t data;
+};
+#define SB_SIFREMOVECMDHANDLER	37
+struct sb_sifremovecmdhandler_arg {
+    u_int fid;
+};
+#define SB_SIFSETCMDBUFFER	38
+struct sb_sifsetcmdbuffer_arg {
+    ps2_addr_t db;
+    int size;
+};
+/* 39-42: reserved */
+
+/*
+ *  SIF RPC services
+ */
+
+#define SB_SIFINITRPC		48
+#define SB_SIFEXITRPC		49
+#define SB_SIFGETOTHERDATA	50
+struct sb_sifgetotherdata_arg {
+    ps2_addr_t rd;
+    ps2_addr_t src;
+    ps2_addr_t dest;
+    int size;
+    u_int mode;
+    ps2_addr_t func;
+    ps2_addr_t para;
+};
+#define SB_SIFBINDRPC		51
+struct sb_sifbindrpc_arg {
+    ps2_addr_t bd;
+    u_int command;
+    u_int mode;
+    ps2_addr_t func;
+    ps2_addr_t para;
+};
+#define SB_SIFCALLRPC		52
+struct sb_sifcallrpc_arg {
+    ps2_addr_t bd;
+    u_int fno;
+    u_int mode;
+    ps2_addr_t send;
+    int ssize;
+    ps2_addr_t receive;
+    int rsize;
+    ps2_addr_t func;
+    ps2_addr_t para;
+};
+#define SB_SIFCHECKSTATRPC	53
+struct sb_sifcheckstatrpc_arg {
+    ps2_addr_t cd;
+};
+#define SB_SIFSETRPCQUEUE	54
+struct sb_sifsetrpcqueue_arg {
+    ps2_addr_t pSrqd;
+    ps2_addr_t callback;
+    ps2_addr_t arg;
+};
+#define SB_SIFREGISTERRPC	55
+struct sb_sifregisterrpc_arg {
+    ps2_addr_t pr;
+    u_int command;
+    ps2_addr_t func;
+    ps2_addr_t buff;
+    ps2_addr_t cfunc;
+    ps2_addr_t cbuff;
+    ps2_addr_t pq;
+};
+#define SB_SIFREMOVERPC		56
+struct sb_sifremoverpc_arg {
+    ps2_addr_t pr;
+    ps2_addr_t pq;
+};
+#define SB_SIFREMOVERPCQUEUE	57
+struct sb_sifremoverpcqueue_arg {
+    ps2_addr_t pSrqd;
+};
+#define SB_SIFGETNEXTREQUEST	58
+struct sb_sifgetnextrequest_arg {
+    ps2_addr_t qd;
+};
+#define SB_SIFEXECREQUEST	59
+struct sb_sifexecrequest_arg {
+    ps2_addr_t rdp;
+};
+
+/*
+ *  device services
+ */
+
+/* RPC common argument */
+
+struct sbr_common_arg {
+    int result;
+    ps2_addr_t arg;
+	/* void (*func)(void *, int); */
+    ps2_addr_t func;
+    ps2_addr_t para;
+};
+
+/* IOP heap */
+
+#define SBR_IOPH_INIT		64
+#define SBR_IOPH_ALLOC		65
+struct sbr_ioph_alloc_arg {
+    int size;
+};
+#define SBR_IOPH_FREE		66
+struct sbr_ioph_free_arg {
+    uint32_t addr;
+};
+
+/* pad device */
+
+#define SBR_PAD_INIT		80
+struct sbr_pad_init_arg {
+    int mode;
+};
+#define SBR_PAD_END		81
+#define SBR_PAD_PORTOPEN	82
+struct sbr_pad_portopen_arg {
+    int port;
+    int slot;
+    ps2_addr_t addr;
+};
+#define SBR_PAD_PORTCLOSE	83
+struct sbr_pad_portclose_arg {
+    int port;
+    int slot;
+};
+#define SBR_PAD_SETMAINMODE	84
+struct sbr_pad_setmainmode_arg {
+    int port;
+    int slot;
+    int offs;
+    int lock;
+};
+#define SBR_PAD_SETACTDIRECT	85
+struct sbr_pad_setactdirect_arg {
+    int port;
+    int slot;
+	/* const unsigned char *data */
+    ps2_const_addr_t data;
+};
+#define SBR_PAD_SETACTALIGN	86
+struct sbr_pad_setactalign_arg {
+    int port;
+    int slot;
+	/* const unsigned char *data */
+    ps2_const_addr_t data;
+};
+#define SBR_PAD_INFOPRESSMODE	87
+struct sbr_pad_pressmode_arg {
+    int port;
+    int slot;
+};
+#define SBR_PAD_ENTERPRESSMODE	88
+#define SBR_PAD_EXITPRESSMODE	89
+
+
+#define SB_PAD_READ		90
+struct sb_pad_read_arg {
+    int port;
+    int slot;
+    /* unsigned char *rdata; */
+	ps2_addr_t rdata;
+};
+#define SB_PAD_GETSTATE		91
+struct sb_pad_getstate_arg {
+    int port;
+    int slot;
+};
+#define SB_PAD_GETREQSTATE	92
+struct sb_pad_getreqstate_arg {
+    int port;
+    int slot;
+};
+#define SB_PAD_INFOACT		93
+struct sb_pad_infoact_arg {
+    int port;
+    int slot;
+    int actno;
+    int term;
+};
+#define SB_PAD_INFOCOMB		94
+struct sb_pad_infocomb_arg {
+    int port;
+    int slot;
+    int listno;
+    int offs;
+};
+#define SB_PAD_INFOMODE		95
+struct sb_pad_infomode_arg {
+    int port;
+    int slot;
+    int term;
+    int offs;
+};
+
+/* sound */
+
+#define SBR_SOUND_INIT		112
+struct sbr_sound_init_arg {
+#define SB_SOUND_INIT_COLD	0
+#define SB_SOUND_INIT_HOT	1
+    int flag;
+};
+#define SBR_SOUND_END		113
+#define SB_SOUND_GREG		114
+#define SB_SOUND_SREG		115
+struct sb_sound_reg_arg {
+    u_int idx;
+#define SB_SOUND_REG_MADR(core)		(0 + (core))
+#define SB_SOUND_REG_BCR(core)		(2 + (core))
+#define SB_SOUND_REG_BTCR(core)		(4 + (core))
+#define SB_SOUND_REG_CHCR(core)		(6 + (core))
+
+#define SB_SOUND_REG_MMIX(core)		(8 + (core))
+#define SB_SOUND_REG_DMAMOD(core)	(10 + (core))
+#define SB_SOUND_REG_MVOLL(core)	(12 + (core))
+#define SB_SOUND_REG_MVOLR(core)	(14 + (core))
+#define SB_SOUND_REG_EVOLL(core)	(16 + (core))
+#define SB_SOUND_REG_EVOLR(core)	(18 + (core))
+#define SB_SOUND_REG_AVOLL(core)	(20 + (core))
+#define SB_SOUND_REG_AVOLR(core)	(22 + (core))
+#define SB_SOUND_REG_BVOLL(core)	(24 + (core))
+#define SB_SOUND_REG_BVOLR(core)	(26 + (core))
+    u_int data;
+};
+#define SBR_SOUND_GCOREATTR	116
+#define SBR_SOUND_SCOREATTR	117
+struct sbr_sound_coreattr_arg {
+    u_int idx;
+#define SB_SOUND_CA_EFFECT_ENABLE	(1<<1)
+#define SB_SOUND_CA_IRQ_ENABLE		(2<<1)
+#define SB_SOUND_CA_MUTE_ENABLE		(3<<1)
+#define SB_SOUND_CA_NOISE_CLK		(4<<1)
+#define SB_SOUND_CA_SPDIF_MODE		(5<<1)
+    u_int data;
+};
+#define SBR_SOUND_TRANS		118
+struct sbr_sound_trans_arg {
+    int channel;
+    u_int mode;
+#define SB_SOUND_TRANS_MODE_WRITE	0
+#define SB_SOUND_TRANS_MODE_READ	1
+#define SB_SOUND_TRANS_MODE_STOP	2
+#define SB_SOUND_TRANS_MODE_DMA		(0<<3)
+#define SB_SOUND_TRANS_MODE_PIO		(1<<3)
+#define SB_SOUND_TRANS_MODE_ONCE	(0<<4)
+#define SB_SOUND_TRANS_MODE_LOOP	(1<<4)
+    u_int addr;
+    u_int size;
+    u_int start_addr;
+};
+#define SBR_SOUND_TRANSSTAT	119
+struct sbr_sound_trans_stat_arg {
+    int channel;
+#define SB_SOUND_TRANSSTAT_WAIT		1
+#define SB_SOUND_TRANSSTAT_CHECK	0
+    int flag;
+};
+#define SBR_SOUND_TRANSCALLBACK	120
+struct sbr_sound_trans_callback_arg {
+    int channel;
+    /* int (*func)(void*, int); */
+	ps2_addr_t func;
+    ps2_addr_t data;
+    /* int (*oldfunc)(void*, int); */
+	ps2_addr_t oldfunc;
+    ps2_addr_t olddata;
+};
+#define SBR_SOUND_REMOTE	123
+/*
+ * XXX, 
+ * struct sbr_sound_remote_arg in asm/mips/ps2/sbcall.h and
+ * struct ps2sd_command must have common members and alignments.
+ * double check if you change this structure.
+ */
+struct sbr_sound_remote_arg {
+    int command;
+#define PS2SDCTL_COMMAND_QUIT      0x1020
+#define PS2SDCTL_COMMAND_QUIT2     0x010000d0
+#define PS2SDCTL_COMMAND_OPEN1     0x1030
+#define PS2SDCTL_COMMAND_OPEN2     0x1040
+#define PS2SDCTL_COMMAND_OPEN3     0x1050
+#define PS2SDCTL_COMMAND_OPEN4     0x01009050
+#define PS2SDCTL_COMMAND_WRITE     0x1060
+#define PS2SDCTL_COMMAND_WRITE2    0x01000070
+#define PS2SDCTL_COMMAND_WRITE3    0x01000040
+#define PS2SDCTL_COMMAND_READ      0x1070
+    int args[126];
+};
+
+/* memory card */
+
+#define SBR_MC_INIT		144
+#define SBR_MC_OPEN		145
+struct sbr_mc_open_arg {
+    int port;
+    int slot;
+    /* const char *name; */
+	ps2_const_addr_t name;
+    int mode;
+};
+#define SBR_MC_MKDIR		146
+struct sbr_mc_mkdir_arg {
+    int port;
+    int slot;
+    /* const char *name; */
+	ps2_const_addr_t name;
+};
+#define SBR_MC_CLOSE		147
+struct sbr_mc_close_arg {
+    int fd;
+};
+#define SBR_MC_SEEK		148
+struct sbr_mc_seek_arg {
+    int fd;
+    int offset;
+    int mode;
+};
+#define SBR_MC_READ		149
+struct sbr_mc_read_arg {
+    int fd;
+    ps2_addr_t buff;
+    int size;
+};
+#define SBR_MC_WRITE		150
+struct sbr_mc_write_arg {
+    int fd;
+    ps2_const_addr_t buff;
+    int size;
+};
+#define SBR_MC_GETINFO		151
+struct sbr_mc_getinfo_arg {
+    int port;
+    int slot;
+    /* int *type; */
+	ps2_addr_t type;
+    /* int *free; */
+	ps2_addr_t free;
+    /* int *format; */
+	ps2_addr_t format;
+};
+#define SBR_MC_GETDIR		152
+struct sbr_mc_getdir_arg {
+    int port;
+    int slot;
+    /* const char *name; */
+	ps2_const_addr_t name;
+    unsigned int mode;
+    int maxent;
+    ps2_addr_t table;
+};
+#define SBR_MC_FORMAT		153
+struct sbr_mc_format_arg {
+    int port;
+    int slot;
+};
+#define SBR_MC_DELETE		154
+struct sbr_mc_delete_arg {
+    int port;
+    int slot;
+    /* const char *name; */
+	ps2_const_addr_t name;
+};
+#define SBR_MC_FLUSH		155
+struct sbr_mc_flush_arg {
+    int fd;
+};
+#define SBR_MC_SETFILEINFO	156
+struct sbr_mc_setfileinfo_arg {
+    int port;
+    int slot;
+    /* const char *name; */
+	ps2_const_addr_t name;
+    /* const char *info; */
+	ps2_const_addr_t info;
+    unsigned int valid;
+};
+#define SBR_MC_RENAME		157
+struct sbr_mc_rename_arg {
+    int port;
+    int slot;
+    /* const char *org; */
+	ps2_const_addr_t orgname;
+    /* const char *new; */
+	ps2_const_addr_t newname;
+};
+#define SBR_MC_UNFORMAT		158
+struct sbr_mc_unformat_arg {
+    int port;
+    int slot;
+};
+#define SBR_MC_GETENTSPACE	159
+struct sbr_mc_getentspace_arg {
+    int port;
+    int slot;
+    /* const char *path; */
+	ps2_const_addr_t path;
+};
+#define SBR_MC_CALL		160
+
+/*
+ * CD/DVD
+ */
+#define SBR_CDVD_INIT		176
+#define SBR_CDVD_RESET		177
+#define SBR_CDVD_READY		178
+struct sbr_cdvd_ready_arg {
+    int mode;
+};
+
+#define SBR_CDVD_READ		179
+struct sbr_cdvd_read_arg {
+    u_int lbn;
+    u_int sectors;
+    ps2_addr_t buf;
+    /* struct sceCdRMode *rmode; */
+	ps2_addr_t rmode;
+};
+
+#define SBR_CDVD_STOP		180
+#define SBR_CDVD_GETTOC		181
+struct sbr_cdvd_gettoc_arg {
+    /* u_char *buf; */
+	ps2_addr_t buf;
+    int len;
+    int media;
+};
+
+#define SBR_CDVD_READRTC	182
+#define SBR_CDVD_WRITERTC	183
+struct sbr_cdvd_rtc_arg {
+	u_char stat;		/* status */
+	u_char second;		/* second */
+	u_char minute;		/* minute */
+	u_char hour;		/* hour   */
+
+	u_char pad;		/* pad    */
+	u_char day;		/* day    */
+	u_char month;		/* 1900 or 2000 and  month  */
+	u_char year;		/* year   */
+};
+#define SBR_CDVD_MMODE		184
+struct sbr_cdvd_mmode_arg {
+    int media;
+};
+
+#define SBR_CDVD_GETERROR	185
+#define SBR_CDVD_GETTYPE	186
+#define SBR_CDVD_TRAYREQ	187
+struct sbr_cdvd_trayreq_arg {
+    int req;
+    int traycount;
+};
+
+#define SB_CDVD_POWERHOOK	188
+struct sb_cdvd_powerhook_arg {
+	/* void (*func)(void *); */
+	ps2_addr_t func;
+	ps2_addr_t arg;
+};
+
+#define SBR_CDVD_DASTREAM	189
+struct sbr_cdvd_dastream_arg {
+    u_int command;
+    u_int lbn;
+    int size;
+    ps2_addr_t buf;
+    /* struct sceCdRMode *rmode; */
+	ps2_addr_t rmode;
+};
+
+#define SBR_CDVD_READSUBQ	190
+struct sbr_cdvd_readsubq_arg {
+    int stat;
+    u_char data[10];
+    u_char reserved[2];
+};
+
+#define SBR_CDVD_OPENCONFIG	191
+#define SBR_CDVD_CLOSECONFIG	192
+#define SBR_CDVD_READCONFIG	193
+#define SBR_CDVD_WRITECONFIG	194
+struct sbr_cdvd_config_arg {
+    int dev;
+#define SB_CDVD_CFG_OSD		0x01    /* OSD    */
+    int mode;
+#define SB_CDVD_CFG_READ	0x00    /* READ   */
+#define SB_CDVD_CFG_WRITE	0x01    /* WRITE  */
+    int blk;
+#define SB_CDVD_CFG_BLKSIZE	15
+    /* u_char *data; */
+	ps2_addr_t data;
+    int stat;
+#define SB_CDVD_CFG_STAT_CMDERR	(1<<7)
+#define SB_CDVD_CFG_STAT_BUSY	(1<<0)
+};
+
+#define SBR_CDVD_RCBYCTL        195
+struct sbr_cdvd_rcbyctl_arg {
+    int param;
+    int stat;
+};
+
+/* Uses sbr_cdvd_read_arg */
+#define SBR_CDVD_READ_DVD	196
+
+/*
+ * Remote Controller
+ */
+#define SBR_REMOCON_INIT	208
+struct sbr_remocon_init_arg {
+    int mode;
+#define SBR_REMOCON_INIT_MODE	0
+};
+
+#define SBR_REMOCON_END		209
+#define SBR_REMOCON_PORTOPEN	210
+#define SBR_REMOCON_PORTCLOSE	211
+struct sbr_remocon_portopen_arg {
+    int port;
+    int slot;
+};
+
+#define SB_REMOCON_READ		212
+struct sb_remocon_read_arg {
+    int port;
+    int slot;
+    int len;
+#define SB_REMOCON_MAXDATASIZE	64
+    /* unsigned char *buf; */
+	ps2_addr_t buf;
+};
+
+#define SBR_REMOCON2_INIT	213
+#define SBR_REMOCON2_END	214
+#define SBR_REMOCON2_PORTOPEN	215
+#define SBR_REMOCON2_PORTCLOSE	216
+#define SB_REMOCON2_READ	217
+
+#define SBR_REMOCON2_IRFEATURE	218
+struct sbr_remocon2_feature_arg {
+    unsigned char feature;
+};
+
+
+#endif
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/sifdefs.h linux-2.6.35.4/arch/mips/include/asm/mach-ps2/sifdefs.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/sifdefs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/include/asm/mach-ps2/sifdefs.h	2014-07-18 22:29:43.538367724 +0200
@@ -0,0 +1,158 @@
+/*
+ *  PlayStation 2 SIFRPC
+ *
+ *  Copyright (C) 2001      Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_PS2_SIFDEFS_H
+#define __ASM_PS2_SIFDEFS_H
+
+/*
+ * SIF DMA defines
+ */
+
+#define SIF_DMA_INT_I	0x2
+#define SIF_DMA_INT_O	0x4
+
+typedef struct {
+	unsigned int	data;
+	unsigned int	addr;
+	unsigned int	size;
+	unsigned int	mode;
+} ps2sif_dmadata_t;
+
+extern unsigned int ps2sif_setdma(ps2sif_dmadata_t *sdd, int len);
+extern int ps2sif_dmastat(unsigned int id);
+extern unsigned int __ps2sif_setdma_wait(ps2sif_dmadata_t *, int, long);
+extern int __ps2sif_dmastat_wait(unsigned int, long);
+extern void ps2sif_writebackdcache(void *, int);
+
+#define ps2sif_setdma_wait(sdd, len)			\
+	__ps2sif_setdma_wait((sdd), (len), TASK_UNINTERRUPTIBLE)
+#define ps2sif_setdma_wait_interruptible(sdd, len)	\
+	__ps2sif_setdma_wait((sdd), (len), TASK_INTERRUPTIBLE)
+#define ps2sif_dmastat_wait(id)			\
+	((void)__ps2sif_dmastat_wait((id), TASK_UNINTERRUPTIBLE))
+#define ps2sif_dmastat_wait_interruptible(id)		\
+	__ps2sif_dmastat_wait((id), TASK_INTERRUPTIBLE)
+
+/*
+ * SIF RPC defines
+ */
+
+typedef struct _sif_rpc_data {
+	void			*paddr;	/* packet address */
+	unsigned int		pid;	/* packet id */
+	struct wait_queue	*wq;	/* wait queue */
+	unsigned int		mode;	/* call mode */
+} ps2sif_rpcdata_t;
+
+typedef void (*ps2sif_endfunc_t)(void *);
+
+typedef struct _sif_client_data {
+	struct _sif_rpc_data	rpcd;
+	unsigned int		command;
+	void			*buff;
+	void			*cbuff;
+	ps2sif_endfunc_t	func;
+	void			*para;
+	struct _sif_serve_data	*serve;
+} ps2sif_clientdata_t;
+
+typedef struct _sif_receive_data {
+	struct _sif_rpc_data	rpcd;
+	void			*src;
+	void			*dest;
+	int			size;
+	ps2sif_endfunc_t	func;
+	void			*para;
+} ps2sif_receivedata_t;
+
+typedef void *(*ps2sif_rpcfunc_t)(unsigned int, void *, int);
+
+typedef struct _sif_serve_data {
+	unsigned int		command;
+	ps2sif_rpcfunc_t	func;
+	void			*buff;
+	int			size;	
+	ps2sif_rpcfunc_t	cfunc;
+	void			*cbuff;
+	int			csize;	
+	ps2sif_clientdata_t *client;
+	void			*paddr;
+	unsigned int		fno;
+	void			*receive;
+	int			rsize;
+	int			rmode;
+	unsigned int		rid;
+	struct _sif_serve_data	*link;
+	struct _sif_serve_data	*next;
+	struct _sif_queue_data	*base;
+} ps2sif_servedata_t;
+
+typedef struct _sif_queue_data {
+	int             	active;
+	struct _sif_serve_data	*link;
+	struct _sif_serve_data	*start;
+	struct _sif_serve_data	*end;
+	struct _sif_queue_data	*next;  
+	struct wait_queue	*waitq;
+	void			(*callback)(void*);
+	void			*callback_arg;
+} ps2sif_queuedata_t; 
+
+/* call & bind mode */
+#define SIF_RPCM_NOWAIT		0x01	/* not wait for end of function */
+#define SIF_RPCM_NOWBDC		0x02	/* no write back d-cache */
+
+/* calling error */
+#define SIF_RPCE_GETP	1	/* fail to get packet data */
+#define SIF_RPCE_SENDP	2	/* fail to send dma packet */
+#define E_SIF_PKT_ALLOC 0xd610	/* Can't allocate SIF packet. */
+
+/* functions */
+
+int __init ps2sif_init(void);
+int ps2sif_bindrpc(ps2sif_clientdata_t *, unsigned int, unsigned int, ps2sif_endfunc_t, void *);
+int ps2sif_callrpc(ps2sif_clientdata_t *, unsigned int, unsigned int, void *, int, void *, int, ps2sif_endfunc_t, void *);
+
+int ps2sif_checkstatrpc(ps2sif_rpcdata_t *);
+
+void ps2sif_setrpcqueue(ps2sif_queuedata_t *, void (*)(void*), void *);
+ps2sif_servedata_t *ps2sif_getnextrequest(ps2sif_queuedata_t *);
+void ps2sif_execrequest(ps2sif_servedata_t *);
+void ps2sif_registerrpc(ps2sif_servedata_t *, unsigned int, ps2sif_rpcfunc_t, void *, ps2sif_rpcfunc_t, void *, ps2sif_queuedata_t *);
+int ps2sif_getotherdata(ps2sif_receivedata_t *, void *, void *, int, unsigned int, ps2sif_endfunc_t, void *);
+ps2sif_servedata_t *ps2sif_removerpc(ps2sif_servedata_t *, ps2sif_queuedata_t *);
+ps2sif_queuedata_t *ps2sif_removerpcqueue(ps2sif_queuedata_t *);
+
+/*
+ * IOP heap defines
+ */
+
+dma_addr_t ps2sif_allociopheap(int);
+int ps2sif_freeiopheap(dma_addr_t);
+dma_addr_t ps2sif_phystobus(phys_addr_t a);
+phys_addr_t ps2sif_bustophys(dma_addr_t a);
+
+/*
+ * SBIOS defines
+ */
+
+int sbios_rpc(int func, void *arg, int *result);
+
+#endif /* __ASM_PS2_SIFDEFS_H */
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/siflock.h linux-2.6.35.4/arch/mips/include/asm/mach-ps2/siflock.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/siflock.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/include/asm/mach-ps2/siflock.h	2014-07-18 22:29:43.538367724 +0200
@@ -0,0 +1,75 @@
+/*
+ *  PlayStation 2 SIF locks
+ *
+ *  Copyright (C) 2001      Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_PS2_SIFLOCK_H
+#define __ASM_PS2_SIFLOCK_H
+
+#include <linux/sched.h>
+
+#define PS2SIF_LOCK_QUEUING	(1<<0)
+
+#define PS2LOCK_CDVD	0
+#define PS2LOCK_SOUND	1
+#define PS2LOCK_PAD	2
+#define PS2LOCK_MC	3
+#define PS2LOCK_RTC	4
+#define PS2LOCK_POWER	5
+#define PS2LOCK_REMOCON	6
+#define PS2LOCK_SYSCONF	7
+
+#define PS2LOCK_FLAG_DEBUG	(1<<0)
+
+typedef struct ps2siflock_queue {
+	struct ps2siflock_queue *prev;
+	struct ps2siflock_queue *next;
+	int (*routine)(void*);
+	void *arg;
+	char *name;
+} ps2sif_lock_queue_t;
+
+struct ps2siflock;
+typedef struct ps2siflock ps2sif_lock_t;
+
+ps2sif_lock_t *ps2sif_getlock(int);
+void ps2sif_lockinit(ps2sif_lock_t *l);
+void ps2sif_lockqueueinit(ps2sif_lock_queue_t *q);
+int __ps2sif_lock(ps2sif_lock_t *l, char*, long state);
+void ps2sif_unlock(ps2sif_lock_t *l);
+void ps2sif_unlock_interruptible(ps2sif_lock_t *l);
+int ps2sif_lowlevel_lock(ps2sif_lock_t *, ps2sif_lock_queue_t *, int);
+void ps2sif_lowlevel_unlock(ps2sif_lock_t *l, ps2sif_lock_queue_t *);
+int ps2sif_iswaiting(ps2sif_lock_t *l);
+int ps2sif_havelock(ps2sif_lock_t *l);
+unsigned long ps2sif_setlockflags(ps2sif_lock_t *l, unsigned long);
+unsigned long ps2sif_getlockflags(ps2sif_lock_t *l);
+
+#define ps2sif_lock(l, n)		\
+	((void)__ps2sif_lock(l, n, TASK_UNINTERRUPTIBLE))
+#define ps2sif_lock_interruptible(l, n)	\
+	__ps2sif_lock(l, n, TASK_INTERRUPTIBLE)
+#define __ps2sif_str2(x) #x
+#define __ps2sif_str(x) __ps2sif_str2(x)
+#define ps2sif_assertlock(l, msg) \
+	do { if (!ps2sif_havelock(l)) \
+		panic(__BASE_FILE__ "(" __ps2sif_str(__LINE__) \
+			"): no lock: " msg);\
+	} while (0)
+
+#endif /* __ASM_PS2_SIFLOCK_H */
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/sifutil.h linux-2.6.35.4/arch/mips/include/asm/mach-ps2/sifutil.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/sifutil.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/include/asm/mach-ps2/sifutil.h	2014-07-18 22:29:43.538367724 +0200
@@ -0,0 +1,58 @@
+/*
+ *  PlayStation 2 DMA packet utility
+ *
+ *  Copyright (C) 2000-2001 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifdef __KERNEL__
+#define PS2SIF_ALLOC_PRINT(fmt, args...) \
+	printk(fmt, ## args)
+#else
+#ifndef PS2SIF_ALLOC_PRINT
+#define PS2SIF_ALLOC_PRINT(fmt, args...) \
+	fprintf(stderr, fmt, ## args)
+#endif
+#endif
+
+#ifdef PS2SIF_ALLOC_DEBUG
+#define PS2SIF_ALLOC_DPRINT(fmt, args...) \
+	PS2SIF_ALLOC_PRINT("ps2sif_alloc: " fmt, ## args)
+#else
+#define PS2SIF_ALLOC_DPRINT(fmt, args...)
+#endif
+
+#define PS2SIF_ALIGN(a, n)	((__typeof__(a))(((unsigned long)(a) + (n) - 1) / (n) * (n)))
+#define PS2SIF_ALLOC_BEGIN(buf, size) \
+    if ((buf) != NULL) { \
+      char *sif_alloc_base = (char*)(buf); \
+      char *sif_alloc_ptr = (char*)(buf); \
+      int limit = (size)
+#define PS2SIF_ALLOC(ptr, size, align) \
+    do { \
+      (ptr) = (__typeof__(ptr))(sif_alloc_ptr = PS2SIF_ALIGN(sif_alloc_ptr, (align)));\
+      PS2SIF_ALLOC_DPRINT("(%14s,%4d,%3d) = %p\n", #ptr,(size),(align),(ptr));\
+      sif_alloc_ptr += (size); \
+    } while (0)
+#define PS2SIF_ALLOC_END(fmt, args...) \
+      if (limit < sif_alloc_ptr - sif_alloc_base) { \
+        PS2SIF_ALLOC_PRINT("*********************************\n"); \
+        PS2SIF_ALLOC_PRINT("PS2SIF_ALLOC overrun %dbytes\n", \
+	       sif_alloc_ptr - sif_alloc_base - limit); \
+        PS2SIF_ALLOC_PRINT(fmt, ## args); \
+        PS2SIF_ALLOC_PRINT("*********************************\n"); \
+      } \
+    }
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/sound.h linux-2.6.35.4/arch/mips/include/asm/mach-ps2/sound.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/sound.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/include/asm/mach-ps2/sound.h	2014-07-18 22:29:43.538367724 +0200
@@ -0,0 +1,88 @@
+/*
+ *  PlayStation 2 Sound
+ *
+ *  Copyright (C) 2001      Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_PS2_SOUND_H
+#define __ASM_PS2_SOUND_H
+
+/*
+ * voice transfer
+ */
+typedef struct ps2sd_voice_data {
+    int addr;
+    int len;
+    unsigned char *data;
+} ps2sd_voice_data;
+#if 0 /* This function isn't implemented yet */
+#define PS2SDCTL_VOICE_GET		_IOWR('V', 0, ps2sd_voice_data)
+#endif
+#define PS2SDCTL_VOICE_PUT		_IOW ('V', 1, ps2sd_voice_data)
+
+/*
+ * SPU2 native format mode
+ */
+#define PS2SDCTL_SET_INTMODE		_IOW ('V', 2, int)
+#define PS2SD_INTMODE_NORMAL		0
+#define PS2SD_INTMODE_512		1
+
+/*
+ * SPDIF out mode
+ */
+#define PS2SDCTL_SET_SPDIFMODE		_IOW ('V', 3, int)
+#define SD_SPDIF_OUT_PCM	0
+#define SD_SPDIF_OUT_BITSTREAM  1
+#define SD_SPDIF_OUT_OFF	2
+#define SD_SPDIF_COPY_NORMAL    0x00
+#define SD_SPDIF_COPY_PROHIBIT  0x80
+#define SD_SPDIF_MEDIA_CD       0x000
+#define SD_SPDIF_MEDIA_DVD      0x800
+#define SD_BLOCK_MEM_DRY        0  /* no use */
+
+/*
+ * IOP memory
+ */
+#define PS2SDCTL_IOP_ALLOC		_IOWR('V', 4, ps2sd_voice_data)
+#define PS2SDCTL_IOP_FREE		_IO  ('V', 5)
+#if 0 /* This function isn't implemented yet */
+#define PS2SDCTL_IOP_GET		_IOW ('V', 6, ps2sd_voice_data)
+#endif
+#define PS2SDCTL_IOP_PUT		_IOW ('V', 7, ps2sd_voice_data)
+
+/*
+ * command
+ */
+/*
+ * XXX, 
+ * struct sbr_sound_remote_arg in asm/mips/ps2/sbcall.h and
+ * struct ps2sd_command must have common members.
+ * double check if you change this structure.
+ */
+typedef struct ps2sd_command {
+    int result;
+    int command;
+    int args[126];
+} ps2sd_command;
+#define PS2SDCTL_COMMAND_INIT		_IO  ('V', 8)
+#define PS2SDCTL_COMMAND		_IOWR('V', 9, ps2sd_command)
+#define PS2SDCTL_COMMAND_KERNEL22	0xc0005609
+#define PS2SDCTL_COMMAND_END		_IO  ('V', 10)
+
+#define PS2SDCTL_CHANGE_THPRI		_IO  ('V', 11)
+
+#endif /* __ASM_PS2_SOUND_H */
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/speed.h linux-2.6.35.4/arch/mips/include/asm/mach-ps2/speed.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/speed.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/include/asm/mach-ps2/speed.h	2014-07-18 22:29:43.538367724 +0200
@@ -0,0 +1,36 @@
+/*
+ *  PlayStation 2 Ethernet
+ *
+ *  Copyright (C) 2001      Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_PS2_SPEED_H
+#define __ASM_PS2_SPEED_H
+
+#define DEV9M_BASE		0x14000000
+
+#define SPD_R_REV		(DEV9M_BASE + 0x00)
+#define SPD_R_REV_1		(DEV9M_BASE + 0x00)
+#define SPD_R_REV_3		(DEV9M_BASE + 0x04)
+
+#define SPD_R_INTR_STAT		(DEV9M_BASE + 0x28)
+#define SPD_R_INTR_ENA		(DEV9M_BASE + 0x2a)
+#define SPD_R_XFR_CTRL		(DEV9M_BASE + 0x32)
+#define SPD_R_IF_CTRL		(DEV9M_BASE + 0x64)
+
+#endif /* __ASM_PS2_SPEED_H */
+
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/sysconf.h linux-2.6.35.4/arch/mips/include/asm/mach-ps2/sysconf.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/sysconf.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/include/asm/mach-ps2/sysconf.h	2014-07-18 22:29:43.538367724 +0200
@@ -0,0 +1,42 @@
+/*
+ *  PlayStation 2 Sysconf
+ *
+ *  Copyright (C) 2000-2001 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_PS2_SYSCONF_H
+#define __ASM_PS2_SYSCONF_H
+
+struct ps2_sysconf {
+    short timezone;
+    u_char aspect;
+    u_char datenotation;
+    u_char language;
+    u_char spdif;
+    u_char summertime;
+    u_char timenotation;
+    u_char video;
+};
+
+#define PS2SYSCONF_GETLINUXCONF		_IOR ('s', 0, struct ps2_sysconf)
+#define PS2SYSCONF_SETLINUXCONF		_IOW ('s', 1, struct ps2_sysconf)
+
+#ifdef __KERNEL__
+extern struct ps2_sysconf *ps2_sysconf;
+#endif
+
+#endif /* __ASM_PS2_SYSCONF_H */
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/war.h linux-2.6.35.4/arch/mips/include/asm/mach-ps2/war.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/mach-ps2/war.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/include/asm/mach-ps2/war.h	2014-07-18 22:29:43.538367724 +0200
@@ -0,0 +1,37 @@
+/*
+ *  PlayStation 2 Workaround list
+ *
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_MIPS_MACH_PS2_WAR_H
+#define __ASM_MIPS_MACH_PS2_WAR_H
+
+#define R4600_V1_INDEX_ICACHEOP_WAR	0
+#define R4600_V1_HIT_CACHEOP_WAR	0
+#define R4600_V2_HIT_CACHEOP_WAR	0
+#define R5432_CP0_INTERRUPT_WAR		0
+#define BCM1250_M3_WAR			0
+#define SIBYTE_1956_WAR			0
+#define MIPS4K_ICACHE_REFILL_WAR	0
+#define MIPS_CACHE_SYNC_WAR		0
+#define TX49XX_ICACHE_INDEX_INV_WAR	0
+#define RM9000_CDEX_SMP_WAR		0
+#define ICACHE_REFILLS_WORKAROUND_WAR	0
+#define R10000_LLSC_WAR			0
+#define MIPS34K_MISSED_ITLB_WAR		0
+
+#endif
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/mipsregs.h linux-2.6.35.4/arch/mips/include/asm/mipsregs.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/mipsregs.h	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/include/asm/mipsregs.h	2014-07-18 22:29:43.526367724 +0200
@@ -503,6 +503,10 @@
 #define R5K_CONF_SE		(_ULCAST_(1) << 12)
 #define R5K_CONF_SS		(_ULCAST_(3) << 20)
 
+#define R5900_CONF_ICE		(_ULCAST_(1) << 17)
+#define R5900_CONF_DCE		(_ULCAST_(1) << 16)
+#define R5900_CONF_BPE		(_ULCAST_(1) << 12)
+
 /* Bits specific to the RM7000.  */
 #define RM7K_CONF_SE		(_ULCAST_(1) <<  3)
 #define RM7K_CONF_TE		(_ULCAST_(1) << 12)
@@ -663,6 +667,30 @@ do {								\
  * Macros to access the system control coprocessor
  */
 
+#ifdef CONFIG_CPU_R5900
+#define __read_32bit_c0_register(source, sel)				\
+({ int __res;								\
+	if (sel == 0)							\
+		__asm__ __volatile__(					\
+			".set push\n\t"					\
+			".set noreorder\n\t"				\
+			"sync.p\n\t"					\
+			"mfc0\t%0, " #source "\n\t"			\
+			".set pop\n\t"					\
+			: "=r" (__res));				\
+	else								\
+		__asm__ __volatile__(					\
+			".set push\n\t"					\
+			".set noreorder\n\t"				\
+			".set\tmips32\n\t"				\
+			"sync.p\n\t"					\
+			"mfc0\t%0, " #source ", " #sel "\n\t"		\
+			".set\tmips0\n\t"				\
+			".set pop\n\t"					\
+			: "=r" (__res));				\
+	__res;								\
+})
+#else
 #define __read_32bit_c0_register(source, sel)				\
 ({ int __res;								\
 	if (sel == 0)							\
@@ -677,7 +705,9 @@ do {								\
 			: "=r" (__res));				\
 	__res;								\
 })
+#endif
 
+#if !defined(CONFIG_CPU_R5900)
 #define __read_64bit_c0_register(source, sel)				\
 ({ unsigned long long __res;						\
 	if (sizeof(unsigned long) == 4)					\
@@ -696,7 +726,31 @@ do {								\
 			: "=r" (__res));				\
 	__res;								\
 })
+#endif
 
+#ifdef CONFIG_CPU_R5900
+#define __write_32bit_c0_register(register, sel, value)			\
+do {									\
+	if (sel == 0)							\
+		__asm__ __volatile__(					\
+			".set push\n\t"					\
+			".set noreorder\n\t"				\
+			"mtc0\t%z0, " #register "\n\t"			\
+			"sync.p\n\t"					\
+			".set pop\n\t"					\
+			: : "Jr" ((unsigned int)(value)));		\
+	else								\
+		__asm__ __volatile__(					\
+			".set push\n\t"					\
+			".set noreorder\n\t"				\
+			".set\tmips32\n\t"				\
+			"mtc0\t%z0, " #register ", " #sel "\n\t"	\
+			"sync.p\n\t"					\
+			".set\tmips0\n\t"					\
+			".set pop\n\t"					\
+			: : "Jr" ((unsigned int)(value)));		\
+} while (0)
+#else
 #define __write_32bit_c0_register(register, sel, value)			\
 do {									\
 	if (sel == 0)							\
@@ -710,7 +764,9 @@ do {									\
 			".set\tmips0"					\
 			: : "Jr" ((unsigned int)(value)));		\
 } while (0)
+#endif
 
+#if !defined(CONFIG_CPU_R5900)
 #define __write_64bit_c0_register(register, sel, value)			\
 do {									\
 	if (sizeof(unsigned long) == 4)					\
@@ -728,12 +784,22 @@ do {									\
 			".set\tmips0"					\
 			: : "Jr" (value));				\
 } while (0)
+#endif
 
+#if defined(CONFIG_CPU_R5900)
+#define __read_ulong_c0_register(reg, sel)				\
+	((unsigned long) __read_32bit_c0_register(reg, sel))
+#else
 #define __read_ulong_c0_register(reg, sel)				\
 	((sizeof(unsigned long) == 4) ?					\
 	(unsigned long) __read_32bit_c0_register(reg, sel) :		\
 	(unsigned long) __read_64bit_c0_register(reg, sel))
+#endif
 
+#if defined(CONFIG_CPU_R5900)
+#define __write_ulong_c0_register(reg, sel, val)			\
+		__write_32bit_c0_register(reg, sel, val)
+#else
 #define __write_ulong_c0_register(reg, sel, val)			\
 do {									\
 	if (sizeof(unsigned long) == 4)					\
@@ -741,6 +807,7 @@ do {									\
 	else								\
 		__write_64bit_c0_register(reg, sel, val);		\
 } while (0)
+#endif
 
 /*
  * On RM7000/RM9000 these are uses to access cop0 set 1 registers
@@ -760,6 +827,7 @@ do {									\
 		: : "Jr" ((unsigned int)(value)));			\
 } while (0)
 
+#if !defined(CONFIG_CPU_R5900)
 /*
  * These versions are only needed for systems with more than 38 bits of
  * physical address space running the 32-bit kernel.  That's none atm :-)
@@ -792,7 +860,9 @@ do {									\
 									\
 	__val;								\
 })
+#endif
 
+#if !defined(CONFIG_CPU_R5900)
 #define __write_64bit_c0_split(source, sel, val)			\
 do {									\
 	unsigned long __flags;						\
@@ -820,6 +890,7 @@ do {									\
 			: : "r" (val));					\
 	local_irq_restore(__flags);					\
 } while (0)
+#endif
 
 #define read_c0_index()		__read_32bit_c0_register($0, 0)
 #define write_c0_index(val)	__write_32bit_c0_register($0, 0, val)
@@ -1148,6 +1219,28 @@ do {									\
 
 #else
 
+#ifdef CONFIG_CPU_R5900
+#define mfsa()								\
+({									\
+	unsigned long __treg;						\
+									\
+	__asm__ __volatile__(						\
+	"	mfsa	%0\n"			\
+	: "=r" (__treg));						\
+	__treg;								\
+})
+
+#define mtsa(x)							\
+do {									\
+	unsigned long __treg = (x);						\
+									\
+	__asm__ __volatile__(						\
+	"	mtsa	%0\n"	\
+	:								\
+	: "r" (__treg));							\
+} while (0)
+#endif
+
 #define mfhi0()								\
 ({									\
 	unsigned long __treg;						\
@@ -1163,6 +1256,34 @@ do {									\
 	__treg;								\
 })
 
+#ifdef CONFIG_CPU_R5900
+#ifdef CONFIG_32BIT
+#define mfhi1()								\
+({									\
+	unsigned long long __treg;						\
+									\
+	__asm__ __volatile__(						\
+	"	.set	push			\n"			\
+	"	.set	noat			\n"			\
+	"	.set	arch=r5900		\n"			\
+	"	mfhi1	$1\n"					\
+	"	sd		$1, %0\n"					\
+	"	.set	pop\n"					\
+	: "=m" (__treg));						\
+	__treg;								\
+})
+#else
+#define mfhi1()								\
+({									\
+	unsigned long long __treg;						\
+									\
+	__asm__ __volatile__(						\
+	"	mfhi1	%0\n"					\
+	: "=r" (__treg));						\
+	__treg;								\
+})
+#endif
+#else
 #define mfhi1()								\
 ({									\
 	unsigned long __treg;						\
@@ -1177,6 +1298,7 @@ do {									\
 	: "=r" (__treg));						\
 	__treg;								\
 })
+#endif
 
 #define mfhi2()								\
 ({									\
@@ -1223,6 +1345,34 @@ do {									\
 	__treg;								\
 })
 
+#ifdef CONFIG_CPU_R5900
+#ifdef CONFIG_32BIT
+#define mflo1()								\
+({									\
+	unsigned long long __treg;						\
+									\
+	__asm__ __volatile__(						\
+	"	.set	push			\n"			\
+	"	.set	noat			\n"			\
+	"	.set	arch=r5900		\n"			\
+	"	mflo1	$1\n"			\
+	"	sd		$1, %0\n"			\
+	"	.set	pop			\n"			\
+	: "=m" (__treg));						\
+	__treg;								\
+})
+#else
+#define mflo1()								\
+({									\
+	unsigned long long __treg;						\
+									\
+	__asm__ __volatile__(						\
+	"	mflo1	%0\n"			\
+	: "=r" (__treg));						\
+	__treg;								\
+})
+#endif
+#else
 #define mflo1()								\
 ({									\
 	unsigned long __treg;						\
@@ -1237,6 +1387,7 @@ do {									\
 	: "=r" (__treg));						\
 	__treg;								\
 })
+#endif
 
 #define mflo2()								\
 ({									\
@@ -1281,6 +1432,34 @@ do {									\
 	: "r" (x));							\
 } while (0)
 
+#ifdef CONFIG_CPU_R5900
+#ifdef CONFIG_32BIT
+#define mthi1(x)							\
+do {									\
+	unsigned long long __treg = (x);						\
+									\
+	__asm__ __volatile__(						\
+	"	.set	push			\n"			\
+	"	.set	noat			\n"			\
+	"	.set	arch=r5900		\n"			\
+	"	ld		$1, %0\n"	\
+	"	mthi1	$1\n"	\
+	"	.set	pop\n"			\
+	:								\
+	: "m" (__treg));							\
+} while (0)
+#else
+#define mthi1(x)							\
+do {									\
+	unsigned long long __treg = (x);						\
+									\
+	__asm__ __volatile__(						\
+	"	mthi1	%0\n"	\
+	:								\
+	: "r" (__treg));							\
+} while (0)
+#endif
+#else
 #define mthi1(x)							\
 do {									\
 	__asm__ __volatile__(						\
@@ -1293,6 +1472,7 @@ do {									\
 	:								\
 	: "r" (x));							\
 } while (0)
+#endif
 
 #define mthi2(x)							\
 do {									\
@@ -1333,6 +1513,34 @@ do {									\
 	: "r" (x));							\
 } while (0)
 
+#ifdef CONFIG_CPU_R5900
+#ifdef CONFIG_32BIT
+#define mtlo1(x)							\
+do {									\
+	unsigned long long __treg = (x);						\
+									\
+	__asm__ __volatile__(						\
+	"	.set	push			\n"			\
+	"	.set	noat			\n"			\
+	"	.set	arch=r5900		\n"			\
+	"	ld		$1, %0\n"	\
+	"	mtlo1	$1\n"	\
+	"	.set	pop					\n"	\
+	:								\
+	: "m" (__treg));							\
+} while (0)
+#else
+#define mtlo1(x)							\
+do {									\
+	unsigned long long __treg = (x);						\
+									\
+	__asm__ __volatile__(						\
+	"	mtlo1	%0\n"	\
+	:								\
+	: "r" (__treg));							\
+} while (0)
+#endif
+#else
 #define mtlo1(x)							\
 do {									\
 	__asm__ __volatile__(						\
@@ -1345,6 +1553,7 @@ do {									\
 	:								\
 	: "r" (x));							\
 } while (0)
+#endif
 
 #define mtlo2(x)							\
 do {									\
@@ -1384,6 +1593,14 @@ static inline void tlb_probe(void)
 	__asm__ __volatile__(
 		".set noreorder\n\t"
 		"tlbp\n\t"
+#ifdef CONFIG_CPU_R5900
+		/* No memory access behind the tlbp instruction. */
+		"sync.p\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+#endif
 		".set reorder");
 }
 
@@ -1408,7 +1625,19 @@ static inline void tlb_read(void)
 
 	__asm__ __volatile__(
 		".set noreorder\n\t"
+#ifdef CONFIG_CPU_R5900
+		/* instruction must not be at the end of a page. */
+		".align 8\n\t"
+#endif
 		"tlbr\n\t"
+#ifdef CONFIG_CPU_R5900
+		"sync.p\n\t"
+		/* No branch behind tlbr. */
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+#endif
 		".set reorder");
 
 #if MIPS34K_MISSED_ITLB_WAR
@@ -1429,6 +1658,9 @@ static inline void tlb_write_indexed(voi
 	__asm__ __volatile__(
 		".set noreorder\n\t"
 		"tlbwi\n\t"
+#ifdef CONFIG_CPU_R5900
+		"sync.p\n\t"
+#endif
 		".set reorder");
 }
 
@@ -1437,6 +1669,9 @@ static inline void tlb_write_random(void
 	__asm__ __volatile__(
 		".set noreorder\n\t"
 		"tlbwr\n\t"
+#ifdef CONFIG_CPU_R5900
+		"sync.p\n\t"
+#endif
 		".set reorder");
 }
 
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/module.h linux-2.6.35.4/arch/mips/include/asm/module.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/module.h	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/include/asm/module.h	2014-07-18 22:29:43.530367724 +0200
@@ -100,6 +100,8 @@ search_module_dbetables(unsigned long ad
 #define MODULE_PROC_FAMILY "R5432 "
 #elif defined CONFIG_CPU_R5500
 #define MODULE_PROC_FAMILY "R5500 "
+#elif defined CONFIG_CPU_R5900
+#define MODULE_PROC_FAMILY "R5900 "
 #elif defined CONFIG_CPU_R6000
 #define MODULE_PROC_FAMILY "R6000 "
 #elif defined CONFIG_CPU_NEVADA
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/pgtable.h linux-2.6.35.4/arch/mips/include/asm/pgtable.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/pgtable.h	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/include/asm/pgtable.h	2014-07-18 22:29:43.530367724 +0200
@@ -8,12 +8,16 @@
 #ifndef _ASM_PGTABLE_H
 #define _ASM_PGTABLE_H
 
+#ifdef CONFIG_CPU_R5900
+#include <asm/pgtable-32.h>
+#else
 #ifdef CONFIG_32BIT
 #include <asm/pgtable-32.h>
 #endif
 #ifdef CONFIG_64BIT
 #include <asm/pgtable-64.h>
 #endif
+#endif
 
 #include <asm/io.h>
 #include <asm/pgtable-bits.h>
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/processor.h linux-2.6.35.4/arch/mips/include/asm/processor.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/processor.h	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/include/asm/processor.h	2014-07-18 22:29:43.530367724 +0200
@@ -20,6 +20,7 @@
 #include <asm/mipsregs.h>
 #include <asm/prefetch.h>
 #include <asm/system.h>
+#include <asm/ptrace.h>
 
 /*
  * Return current * instruction pointer ("program counter").
@@ -99,13 +100,21 @@ struct mips_fpu_struct {
 	unsigned int	fcr31;
 };
 
+#ifdef CONFIG_CPU_R5900
+#define NUM_DSP_REGS   2
+
+typedef __u64 dspreg_t;
+#else
 #define NUM_DSP_REGS   6
 
 typedef __u32 dspreg_t;
+#endif
 
 struct mips_dsp_state {
 	dspreg_t        dspr[NUM_DSP_REGS];
+#ifndef CONFIG_CPU_R5900
 	unsigned int    dspcontrol;
+#endif
 };
 
 #define INIT_CPUMASK { \
@@ -192,9 +201,15 @@ struct mips_abi;
  */
 struct thread_struct {
 	/* Saved main processor registers. */
+#ifdef CONFIG_R5900_128BIT_SUPPORT
+	r5900_reg_t reg16;
+	r5900_reg_t reg17, reg18, reg19, reg20, reg21, reg22, reg23;
+	r5900_reg_t reg29, reg30, reg31;
+#else
 	unsigned long reg16;
 	unsigned long reg17, reg18, reg19, reg20, reg21, reg22, reg23;
 	unsigned long reg29, reg30, reg31;
+#endif
 
 	/* Saved cp0 stuff. */
 	unsigned long cp0_status;
@@ -210,6 +225,9 @@ struct thread_struct {
 
 	/* Saved state of the DSP ASE, if available. */
 	struct mips_dsp_state dsp;
+#ifdef CONFIG_CPU_R5900
+	unsigned int sa;
+#endif
 
 	/* Saved watch register state, if available. */
 	union mips_watch_reg_state watch;
@@ -243,10 +261,37 @@ struct thread_struct {
 #define OCTEON_INIT
 #endif /* CONFIG_CPU_CAVIUM_OCTEON */
 
-#define INIT_THREAD  {						\
-        /*							\
-         * Saved main processor registers			\
-         */							\
+#ifdef CONFIG_CPU_R5900
+#define DSP_INIT \
+	.dsp			= {				\
+		.dspr		= {0, },			\
+	},								\
+	.sa				= 0,
+#else
+#define DSP_INIT \
+	.dsp			= {				\
+		.dspr		= {0, },			\
+		.dspcontrol	= 0,				\
+	},
+#endif
+
+#ifdef CONFIG_R5900_128BIT_SUPPORT
+#define REGS_INIT \
+	.reg16 = { .lo = 0, .hi = 0, },				\
+	.reg17 = { .lo = 0, .hi = 0, },				\
+	.reg18 = { .lo = 0, .hi = 0, },				\
+	.reg19 = { .lo = 0, .hi = 0, },				\
+	.reg20 = { .lo = 0, .hi = 0, },				\
+	.reg21 = { .lo = 0, .hi = 0, },				\
+	.reg22 = { .lo = 0, .hi = 0, },				\
+	.reg23 = { .lo = 0, .hi = 0, },				\
+	.reg29 = { .lo = 0, .hi = 0, },				\
+	.reg30 = { .lo = 0, .hi = 0, },				\
+	.reg31 = { .lo = 0, .hi = 0, },
+
+#else
+
+#define REGS_INIT \
 	.reg16			= 0,				\
 	.reg17			= 0,				\
 	.reg18			= 0,				\
@@ -257,7 +302,15 @@ struct thread_struct {
 	.reg23			= 0,				\
 	.reg29			= 0,				\
 	.reg30			= 0,				\
-	.reg31			= 0,				\
+	.reg31			= 0,
+
+#endif
+
+#define INIT_THREAD  {						\
+        /*							\
+         * Saved main processor registers			\
+         */							\
+	REGS_INIT						\
 	/*							\
 	 * Saved cp0 stuff					\
 	 */							\
@@ -276,10 +329,7 @@ struct thread_struct {
 	/*							\
 	 * Saved DSP stuff					\
 	 */							\
-	.dsp			= {				\
-		.dspr		= {0, },			\
-		.dspcontrol	= 0,				\
-	},							\
+	DSP_INIT					\
 	/*							\
 	 * saved watch register stuff				\
 	 */							\
@@ -322,7 +372,7 @@ unsigned long get_wchan(struct task_stru
 			 THREAD_SIZE - 32 - sizeof(struct pt_regs))
 #define task_pt_regs(tsk) ((struct pt_regs *)__KSTK_TOS(tsk))
 #define KSTK_EIP(tsk) (task_pt_regs(tsk)->cp0_epc)
-#define KSTK_ESP(tsk) (task_pt_regs(tsk)->regs[29])
+#define KSTK_ESP(tsk) (MIPS_READ_REG_L(task_pt_regs(tsk)->regs[29]))
 #define KSTK_STATUS(tsk) (task_pt_regs(tsk)->cp0_status)
 
 #define cpu_relax()	barrier()
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/ptrace.h linux-2.6.35.4/arch/mips/include/asm/ptrace.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/ptrace.h	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/include/asm/ptrace.h	2014-07-18 22:29:43.530367724 +0200
@@ -22,6 +22,28 @@
 #define DSP_CONTROL	77
 #define ACX		78
 
+#ifdef CONFIG_R5900_128BIT_SUPPORT
+/* Cast larger R5900 register to smaller 32 bit. */
+#define MIPS_READ_REG_L(reg) ((unsigned long)((reg).lo))
+#define MIPS_READ_REG(reg) ((reg).lo)
+#define MIPS_READ_REG_HIGH(reg) ((reg).hi)
+#define MIPS_READ_REG_S(reg) ((long long)(reg).lo)
+#define MIPS_WRITE_REG(reg) ; ((reg).lo)
+#define MIPS_REG_T unsigned long long
+
+typedef struct __attribute__((aligned(16))) {
+	unsigned long long lo;
+	unsigned long long hi;
+} r5900_reg_t;
+#else
+#define MIPS_READ_REG_L(reg) (reg)
+#define MIPS_READ_REG(reg) (reg)
+#define MIPS_READ_REG_S(reg) ((long) (reg))
+#define MIPS_WRITE_REG(reg) (reg)
+#define MIPS_REG_T unsigned long
+#endif
+
+
 /*
  * This struct defines the way the registers are stored on the stack during a
  * system call/exception. As usual the registers k0/k1 aren't being saved.
@@ -33,12 +55,22 @@ struct pt_regs {
 #endif
 
 	/* Saved main processor registers. */
+#ifdef CONFIG_R5900_128BIT_SUPPORT
+	/* Support for 128 bit. */
+	r5900_reg_t regs[32];
+#else
 	unsigned long regs[32];
+#endif
 
 	/* Saved special registers. */
 	unsigned long cp0_status;
+#ifdef CONFIG_CPU_R5900
+	unsigned long long hi;
+	unsigned long long lo;
+#else
 	unsigned long hi;
 	unsigned long lo;
+#endif
 #ifdef CONFIG_CPU_HAS_SMARTMIPS
 	unsigned long acx;
 #endif
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/r4kcache.h linux-2.6.35.4/arch/mips/include/asm/r4kcache.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/r4kcache.h	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/include/asm/r4kcache.h	2014-07-18 22:29:43.530367724 +0200
@@ -28,17 +28,56 @@
  *  - We need a properly sign extended address for 64-bit code.  To get away
  *    without ifdefs we let the compiler do it by a type cast.
  */
+#ifdef CONFIG_CPU_R5900
+/* CPU has a bug MSB must be 0 for instruction cache. */
+#define INDEX_BASE	0
+/* Workaround for short loops on R5900. */
+#define R5900_LOOP_WAR() do { \
+		__asm__ __volatile__("nop;nop;\n"); \
+	} while(0)
+#else
 #define INDEX_BASE	CKSEG0
+#define R5900_LOOP_WAR() do { } while(0)
+#endif
 
-#define cache_op(op,addr)						\
+#define cache_op_s(op,addr)						\
+	__asm__ __volatile__(						\
+	"	.set	push					\n"	\
+	"	.set	noreorder				\n"	\
+	"	.set	mips3\n\t				\n"	\
+	"	cache	%0, %1					\n"	\
+	"	.set	pop					\n"	\
+	:								\
+	: "i" (op), "R" (*(unsigned char *)(addr)))
+#ifdef CONFIG_CPU_R5900
+#define cache_op_d(op,addr)						\
 	__asm__ __volatile__(						\
 	"	.set	push					\n"	\
 	"	.set	noreorder				\n"	\
 	"	.set	mips3\n\t				\n"	\
+	"	sync.l							\n"	\
 	"	cache	%0, %1					\n"	\
+	"	sync.l							\n"	\
 	"	.set	pop					\n"	\
 	:								\
 	: "i" (op), "R" (*(unsigned char *)(addr)))
+#define cache_op_i(op,addr)						\
+	__asm__ __volatile__(						\
+	"	.set	push					\n"	\
+	"	.set	noreorder				\n"	\
+	"	.set	mips3\n\t				\n"	\
+	"	sync.p							\n"	\
+	"	cache	%0, %1					\n"	\
+	"	sync.p							\n"	\
+	"	.set	pop					\n"	\
+	:								\
+	: "i" (op), "R" (*(unsigned char *)(addr)))
+#else
+#define cache_op_d cache_op_s
+#define cache_op_i cache_op_s
+#define cache_op cache_op_s
+#endif
+#define cache_op_t cache_op_s
 
 #ifdef CONFIG_MIPS_MT
 /*
@@ -143,72 +182,106 @@ extern void mt_cflush_release(void);
 static inline void flush_icache_line_indexed(unsigned long addr)
 {
 	__iflush_prologue
-	cache_op(Index_Invalidate_I, addr);
+	cache_op_i(Index_Invalidate_I, addr);
 	__iflush_epilogue
 }
 
 static inline void flush_dcache_line_indexed(unsigned long addr)
 {
 	__dflush_prologue
-	cache_op(Index_Writeback_Inv_D, addr);
+	cache_op_d(Index_Writeback_Inv_D, addr);
 	__dflush_epilogue
 }
 
 static inline void flush_scache_line_indexed(unsigned long addr)
 {
-	cache_op(Index_Writeback_Inv_SD, addr);
+	cache_op_s(Index_Writeback_Inv_SD, addr);
 }
 
 static inline void flush_icache_line(unsigned long addr)
 {
 	__iflush_prologue
-	cache_op(Hit_Invalidate_I, addr);
+	cache_op_i(Hit_Invalidate_I, addr);
 	__iflush_epilogue
 }
 
 static inline void flush_dcache_line(unsigned long addr)
 {
 	__dflush_prologue
-	cache_op(Hit_Writeback_Inv_D, addr);
+	cache_op_d(Hit_Writeback_Inv_D, addr);
 	__dflush_epilogue
 }
 
 static inline void invalidate_dcache_line(unsigned long addr)
 {
 	__dflush_prologue
-	cache_op(Hit_Invalidate_D, addr);
+	cache_op_d(Hit_Invalidate_D, addr);
 	__dflush_epilogue
 }
 
 static inline void invalidate_scache_line(unsigned long addr)
 {
-	cache_op(Hit_Invalidate_SD, addr);
+	cache_op_s(Hit_Invalidate_SD, addr);
 }
 
 static inline void flush_scache_line(unsigned long addr)
 {
-	cache_op(Hit_Writeback_Inv_SD, addr);
+	cache_op_s(Hit_Writeback_Inv_SD, addr);
 }
 
-#define protected_cache_op(op,addr)				\
+#define protected_cache_op_s(op,addr)				\
+	__asm__ __volatile__(					\
+	"	.set	push			\n"		\
+	"	.set	noreorder		\n"		\
+	"	.set	mips3			\n"		\
+	"1:	cache	%0, (%1)		\n"		\
+	"2:	.set	pop			\n"		\
+	"	.section __ex_table,\"a\"	\n"		\
+	"	"STR(PTR)" 1b, 2b		\n"		\
+	"	.previous"					\
+	:							\
+	: "i" (op), "r" (addr))
+#ifdef CONFIG_CPU_R5900
+#define protected_cache_op_d(op,addr)				\
 	__asm__ __volatile__(					\
 	"	.set	push			\n"		\
 	"	.set	noreorder		\n"		\
 	"	.set	mips3			\n"		\
+	"	sync.l					\n"		\
 	"1:	cache	%0, (%1)		\n"		\
+	"	sync.l					\n"		\
 	"2:	.set	pop			\n"		\
 	"	.section __ex_table,\"a\"	\n"		\
 	"	"STR(PTR)" 1b, 2b		\n"		\
 	"	.previous"					\
 	:							\
 	: "i" (op), "r" (addr))
+#define protected_cache_op_i(op,addr)				\
+	__asm__ __volatile__(					\
+	"	.set	push			\n"		\
+	"	.set	noreorder		\n"		\
+	"	.set	mips3			\n"		\
+	"	sync.p					\n"		\
+	"1:	cache	%0, (%1)		\n"		\
+	"	sync.p					\n"		\
+	"2:	.set	pop			\n"		\
+	"	.section __ex_table,\"a\"	\n"		\
+	"	"STR(PTR)" 1b, 2b		\n"		\
+	"	.previous"					\
+	:							\
+	: "i" (op), "r" (addr))
+#else
+#define protected_cache_op_i protected_cache_op_s
+#define protected_cache_op_d protected_cache_op_s
+#define protected_cache_op protected_cache_op_s
+#endif
 
 /*
  * The next two are for badland addresses like signal trampolines.
  */
 static inline void protected_flush_icache_line(unsigned long addr)
 {
-	protected_cache_op(Hit_Invalidate_I, addr);
+	protected_cache_op_i(Hit_Invalidate_I, addr);
 }
 
 /*
@@ -219,12 +292,12 @@ static inline void protected_flush_icach
  */
 static inline void protected_writeback_dcache_line(unsigned long addr)
 {
-	protected_cache_op(Hit_Writeback_Inv_D, addr);
+	protected_cache_op_d(Hit_Writeback_Inv_D, addr);
 }
 
 static inline void protected_writeback_scache_line(unsigned long addr)
 {
-	protected_cache_op(Hit_Writeback_Inv_SD, addr);
+	protected_cache_op_s(Hit_Writeback_Inv_SD, addr);
 }
 
 /*
@@ -232,7 +305,7 @@ static inline void protected_writeback_s
  */
 static inline void invalidate_tcache_page(unsigned long addr)
 {
-	cache_op(Page_Invalidate_T, addr);
+	cache_op_t(Page_Invalidate_T, addr);
 }
 
 #define cache16_unroll32(base,op)					\
@@ -312,6 +385,65 @@ static inline void invalidate_tcache_pag
 		:							\
 		: "r" (base),						\
 		  "i" (op));
+#ifdef CONFIG_CPU_R5900
+#define cache64_unroll32_d(base,op)					\
+	__asm__ __volatile__(						\
+	"	.set push					\n"	\
+	"	.set noreorder					\n"	\
+	"	.set mips3					\n"	\
+	"	sync.l						\n" \
+	"	cache %1, 0x000(%0); sync.l; cache %1, 0x040(%0); sync.l	\n"	\
+	"	cache %1, 0x080(%0); sync.l; cache %1, 0x0c0(%0); sync.l	\n"	\
+	"	cache %1, 0x100(%0); sync.l; cache %1, 0x140(%0); sync.l	\n"	\
+	"	cache %1, 0x180(%0); sync.l; cache %1, 0x1c0(%0); sync.l	\n"	\
+	"	cache %1, 0x200(%0); sync.l; cache %1, 0x240(%0); sync.l	\n"	\
+	"	cache %1, 0x280(%0); sync.l; cache %1, 0x2c0(%0); sync.l	\n"	\
+	"	cache %1, 0x300(%0); sync.l; cache %1, 0x340(%0); sync.l	\n"	\
+	"	cache %1, 0x380(%0); sync.l; cache %1, 0x3c0(%0); sync.l	\n"	\
+	"	cache %1, 0x400(%0); sync.l; cache %1, 0x440(%0); sync.l	\n"	\
+	"	cache %1, 0x480(%0); sync.l; cache %1, 0x4c0(%0); sync.l	\n"	\
+	"	cache %1, 0x500(%0); sync.l; cache %1, 0x540(%0); sync.l	\n"	\
+	"	cache %1, 0x580(%0); sync.l; cache %1, 0x5c0(%0); sync.l	\n"	\
+	"	cache %1, 0x600(%0); sync.l; cache %1, 0x640(%0); sync.l	\n"	\
+	"	cache %1, 0x680(%0); sync.l; cache %1, 0x6c0(%0); sync.l	\n"	\
+	"	cache %1, 0x700(%0); sync.l; cache %1, 0x740(%0); sync.l	\n"	\
+	"	cache %1, 0x780(%0); sync.l; cache %1, 0x7c0(%0); sync.l	\n"	\
+	"	.set pop					\n"	\
+		:							\
+		: "r" (base),						\
+		  "i" (op));
+
+#define cache64_unroll32_i(base,op)					\
+	__asm__ __volatile__(						\
+	"	.set push					\n"	\
+	"	.set noreorder					\n"	\
+	"	.set mips3					\n"	\
+	"	sync.p						\n" \
+	"	cache %1, 0x000(%0); cache %1, 0x040(%0)	\n"	\
+	"	cache %1, 0x080(%0); cache %1, 0x0c0(%0)	\n"	\
+	"	cache %1, 0x100(%0); cache %1, 0x140(%0)	\n"	\
+	"	cache %1, 0x180(%0); cache %1, 0x1c0(%0)	\n"	\
+	"	cache %1, 0x200(%0); cache %1, 0x240(%0)	\n"	\
+	"	cache %1, 0x280(%0); cache %1, 0x2c0(%0)	\n"	\
+	"	cache %1, 0x300(%0); cache %1, 0x340(%0)	\n"	\
+	"	cache %1, 0x380(%0); cache %1, 0x3c0(%0)	\n"	\
+	"	cache %1, 0x400(%0); cache %1, 0x440(%0)	\n"	\
+	"	cache %1, 0x480(%0); cache %1, 0x4c0(%0)	\n"	\
+	"	cache %1, 0x500(%0); cache %1, 0x540(%0)	\n"	\
+	"	cache %1, 0x580(%0); cache %1, 0x5c0(%0)	\n"	\
+	"	cache %1, 0x600(%0); cache %1, 0x640(%0)	\n"	\
+	"	cache %1, 0x680(%0); cache %1, 0x6c0(%0)	\n"	\
+	"	cache %1, 0x700(%0); cache %1, 0x740(%0)	\n"	\
+	"	cache %1, 0x780(%0); cache %1, 0x7c0(%0)	\n"	\
+	"	sync.p						\n" \
+	"	.set pop					\n"	\
+		:							\
+		: "r" (base),						\
+		  "i" (op));
+#else
+#define cache64_unroll32_i cache64_unroll32
+#define cache64_unroll32_d cache64_unroll32
+#endif
 
 #define cache128_unroll32(base,op)					\
 	__asm__ __volatile__(						\
@@ -340,7 +472,7 @@ static inline void invalidate_tcache_pag
 		  "i" (op));
 
 /* build blast_xxx, blast_xxx_page, blast_xxx_page_indexed */
-#define __BUILD_BLAST_CACHE(pfx, desc, indexop, hitop, lsize) \
+#define __BUILD_BLAST_CACHE(fn_pfx, pfx, desc, indexop, hitop, lsize) \
 static inline void blast_##pfx##cache##lsize(void)			\
 {									\
 	unsigned long start = INDEX_BASE;				\
@@ -354,7 +486,7 @@ static inline void blast_##pfx##cache##l
 									\
 	for (ws = 0; ws < ws_end; ws += ws_inc)				\
 		for (addr = start; addr < end; addr += lsize * 32)	\
-			cache##lsize##_unroll32(addr|ws, indexop);	\
+			cache##lsize##_unroll32##fn_pfx(addr|ws, indexop);	\
 									\
 	__##pfx##flush_epilogue						\
 }									\
@@ -367,7 +499,7 @@ static inline void blast_##pfx##cache##l
 	__##pfx##flush_prologue						\
 									\
 	do {								\
-		cache##lsize##_unroll32(start, hitop);			\
+		cache##lsize##_unroll32##fn_pfx(start, hitop);			\
 		start += lsize * 32;					\
 	} while (start < end);						\
 									\
@@ -388,31 +520,31 @@ static inline void blast_##pfx##cache##l
 									\
 	for (ws = 0; ws < ws_end; ws += ws_inc)				\
 		for (addr = start; addr < end; addr += lsize * 32)	\
-			cache##lsize##_unroll32(addr|ws, indexop);	\
+			cache##lsize##_unroll32##fn_pfx(addr|ws, indexop);	\
 									\
 	__##pfx##flush_epilogue						\
 }
 
-__BUILD_BLAST_CACHE(d, dcache, Index_Writeback_Inv_D, Hit_Writeback_Inv_D, 16)
-__BUILD_BLAST_CACHE(i, icache, Index_Invalidate_I, Hit_Invalidate_I, 16)
-__BUILD_BLAST_CACHE(s, scache, Index_Writeback_Inv_SD, Hit_Writeback_Inv_SD, 16)
-__BUILD_BLAST_CACHE(d, dcache, Index_Writeback_Inv_D, Hit_Writeback_Inv_D, 32)
-__BUILD_BLAST_CACHE(i, icache, Index_Invalidate_I, Hit_Invalidate_I, 32)
-__BUILD_BLAST_CACHE(s, scache, Index_Writeback_Inv_SD, Hit_Writeback_Inv_SD, 32)
-__BUILD_BLAST_CACHE(d, dcache, Index_Writeback_Inv_D, Hit_Writeback_Inv_D, 64)
-__BUILD_BLAST_CACHE(i, icache, Index_Invalidate_I, Hit_Invalidate_I, 64)
-__BUILD_BLAST_CACHE(s, scache, Index_Writeback_Inv_SD, Hit_Writeback_Inv_SD, 64)
-__BUILD_BLAST_CACHE(s, scache, Index_Writeback_Inv_SD, Hit_Writeback_Inv_SD, 128)
-
-__BUILD_BLAST_CACHE(inv_d, dcache, Index_Writeback_Inv_D, Hit_Invalidate_D, 16)
-__BUILD_BLAST_CACHE(inv_d, dcache, Index_Writeback_Inv_D, Hit_Invalidate_D, 32)
-__BUILD_BLAST_CACHE(inv_s, scache, Index_Writeback_Inv_SD, Hit_Invalidate_SD, 16)
-__BUILD_BLAST_CACHE(inv_s, scache, Index_Writeback_Inv_SD, Hit_Invalidate_SD, 32)
-__BUILD_BLAST_CACHE(inv_s, scache, Index_Writeback_Inv_SD, Hit_Invalidate_SD, 64)
-__BUILD_BLAST_CACHE(inv_s, scache, Index_Writeback_Inv_SD, Hit_Invalidate_SD, 128)
+__BUILD_BLAST_CACHE(, d, dcache, Index_Writeback_Inv_D, Hit_Writeback_Inv_D, 16)
+__BUILD_BLAST_CACHE(, i, icache, Index_Invalidate_I, Hit_Invalidate_I, 16)
+__BUILD_BLAST_CACHE(, s, scache, Index_Writeback_Inv_SD, Hit_Writeback_Inv_SD, 16)
+__BUILD_BLAST_CACHE(, d, dcache, Index_Writeback_Inv_D, Hit_Writeback_Inv_D, 32)
+__BUILD_BLAST_CACHE(, i, icache, Index_Invalidate_I, Hit_Invalidate_I, 32)
+__BUILD_BLAST_CACHE(, s, scache, Index_Writeback_Inv_SD, Hit_Writeback_Inv_SD, 32)
+__BUILD_BLAST_CACHE(_d, d, dcache, Index_Writeback_Inv_D, Hit_Writeback_Inv_D, 64)
+__BUILD_BLAST_CACHE(_i, i, icache, Index_Invalidate_I, Hit_Invalidate_I, 64)
+__BUILD_BLAST_CACHE(, s, scache, Index_Writeback_Inv_SD, Hit_Writeback_Inv_SD, 64)
+__BUILD_BLAST_CACHE(, s, scache, Index_Writeback_Inv_SD, Hit_Writeback_Inv_SD, 128)
+
+__BUILD_BLAST_CACHE(, inv_d, dcache, Index_Writeback_Inv_D, Hit_Invalidate_D, 16)
+__BUILD_BLAST_CACHE(, inv_d, dcache, Index_Writeback_Inv_D, Hit_Invalidate_D, 32)
+__BUILD_BLAST_CACHE(, inv_s, scache, Index_Writeback_Inv_SD, Hit_Invalidate_SD, 16)
+__BUILD_BLAST_CACHE(, inv_s, scache, Index_Writeback_Inv_SD, Hit_Invalidate_SD, 32)
+__BUILD_BLAST_CACHE(, inv_s, scache, Index_Writeback_Inv_SD, Hit_Invalidate_SD, 64)
+__BUILD_BLAST_CACHE(, inv_s, scache, Index_Writeback_Inv_SD, Hit_Invalidate_SD, 128)
 
 /* build blast_xxx_range, protected_blast_xxx_range */
-#define __BUILD_BLAST_CACHE_RANGE(pfx, desc, hitop, prot) \
+#define __BUILD_BLAST_CACHE_RANGE(fn_pfx, pfx, desc, hitop, prot) \
 static inline void prot##blast_##pfx##cache##_range(unsigned long start, \
 						    unsigned long end)	\
 {									\
@@ -423,7 +555,8 @@ static inline void prot##blast_##pfx##ca
 	__##pfx##flush_prologue						\
 									\
 	while (1) {							\
-		prot##cache_op(hitop, addr);				\
+		prot##cache_op##fn_pfx(hitop, addr);				\
+		R5900_LOOP_WAR();					\
 		if (addr == aend)					\
 			break;						\
 		addr += lsize;						\
@@ -432,13 +565,13 @@ static inline void prot##blast_##pfx##ca
 	__##pfx##flush_epilogue						\
 }
 
-__BUILD_BLAST_CACHE_RANGE(d, dcache, Hit_Writeback_Inv_D, protected_)
-__BUILD_BLAST_CACHE_RANGE(s, scache, Hit_Writeback_Inv_SD, protected_)
-__BUILD_BLAST_CACHE_RANGE(i, icache, Hit_Invalidate_I, protected_)
-__BUILD_BLAST_CACHE_RANGE(d, dcache, Hit_Writeback_Inv_D, )
-__BUILD_BLAST_CACHE_RANGE(s, scache, Hit_Writeback_Inv_SD, )
+__BUILD_BLAST_CACHE_RANGE(_d, d, dcache, Hit_Writeback_Inv_D, protected_)
+__BUILD_BLAST_CACHE_RANGE(_s, s, scache, Hit_Writeback_Inv_SD, protected_)
+__BUILD_BLAST_CACHE_RANGE(_i, i, icache, Hit_Invalidate_I, protected_)
+__BUILD_BLAST_CACHE_RANGE(_d, d, dcache, Hit_Writeback_Inv_D, )
+__BUILD_BLAST_CACHE_RANGE(_s, s, scache, Hit_Writeback_Inv_SD, )
 /* blast_inv_dcache_range */
-__BUILD_BLAST_CACHE_RANGE(inv_d, dcache, Hit_Invalidate_D, )
-__BUILD_BLAST_CACHE_RANGE(inv_s, scache, Hit_Invalidate_SD, )
+__BUILD_BLAST_CACHE_RANGE(_d, inv_d, dcache, Hit_Invalidate_D, )
+__BUILD_BLAST_CACHE_RANGE(_d, inv_s, scache, Hit_Invalidate_SD, )
 
 #endif /* _ASM_R4KCACHE_H */
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/sigcontext.h linux-2.6.35.4/arch/mips/include/asm/sigcontext.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/sigcontext.h	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/include/asm/sigcontext.h	2014-07-18 22:29:43.530367724 +0200
@@ -33,10 +33,17 @@ struct sigcontext {
 	unsigned long long	sc_mdlo;
 	unsigned long		sc_hi1;		/* Was sc_cause */
 	unsigned long		sc_lo1;		/* Was sc_badvaddr */
+#ifdef CONFIG_CPU_R5900
+	unsigned long		sc_sa;
+	unsigned long		pad1;
+	unsigned long		pad2;
+	unsigned long		pad3;
+#else
 	unsigned long		sc_hi2;		/* Was sc_sigset[4] */
 	unsigned long		sc_lo2;
 	unsigned long		sc_hi3;
 	unsigned long		sc_lo3;
+#endif
 };
 
 #endif /* _MIPS_SIM == _MIPS_SIM_ABI32 */
@@ -59,16 +66,24 @@ struct sigcontext {
 	__u64	sc_fpregs[32];
 	__u64	sc_mdhi;
 	__u64	sc_hi1;
+#ifndef CONFIG_CPU_R5900
 	__u64	sc_hi2;
 	__u64	sc_hi3;
+#endif
 	__u64	sc_mdlo;
 	__u64	sc_lo1;
+#ifndef CONFIG_CPU_R5900
 	__u64	sc_lo2;
 	__u64	sc_lo3;
+#endif
 	__u64	sc_pc;
 	__u32	sc_fpc_csr;
 	__u32	sc_used_math;
+#ifdef CONFIG_CPU_R5900
+	__u32	sc_sa;
+#else
 	__u32	sc_dsp;
+#endif
 	__u32	sc_reserved;
 };
 
@@ -84,15 +99,23 @@ struct sigcontext32 {
 	__u32		sc_fpc_csr;
 	__u32		sc_fpc_eir;	/* Unused */
 	__u32		sc_used_math;
+#ifndef CONFIG_CPU_R5900
 	__u32		sc_dsp;		/* dsp status, was sc_ssflags */
+#endif
 	__u64		sc_mdhi;
 	__u64		sc_mdlo;
+#ifdef CONFIG_CPU_R5900
+	__u64		sc_hi1;		/* Was sc_cause */
+	__u64		sc_lo1;		/* Was sc_badvaddr */
+	__u32		sc_sa;
+#else
 	__u32		sc_hi1;		/* Was sc_cause */
 	__u32		sc_lo1;		/* Was sc_badvaddr */
 	__u32		sc_hi2;		/* Was sc_sigset[4] */
 	__u32		sc_lo2;
 	__u32		sc_hi3;
 	__u32		sc_lo3;
+#endif
 };
 #endif /* __KERNEL__ */
 
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/stackframe.h linux-2.6.35.4/arch/mips/include/asm/stackframe.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/stackframe.h	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/include/asm/stackframe.h	2014-07-18 22:29:43.530367724 +0200
@@ -37,51 +37,51 @@
 		.macro	SAVE_AT
 		.set	push
 		.set	noat
-		LONG_S	$1, PT_R1(sp)
+		LONGD_S	$1, PT_R1(sp)
 		.set	pop
 		.endm
 
 		.macro	SAVE_TEMP
 #ifdef CONFIG_CPU_HAS_SMARTMIPS
 		mflhxu	v1
-		LONG_S	v1, PT_LO(sp)
+		LONGH_S	v1, PT_LO(sp)
 		mflhxu	v1
-		LONG_S	v1, PT_HI(sp)
+		LONGH_S	v1, PT_HI(sp)
 		mflhxu	v1
-		LONG_S	v1, PT_ACX(sp)
+		LONGD_S	v1, PT_ACX(sp)
 #else
 		mfhi	v1
 #endif
 #ifdef CONFIG_32BIT
-		LONG_S	$8, PT_R8(sp)
-		LONG_S	$9, PT_R9(sp)
+		LONGD_S	$8, PT_R8(sp)
+		LONGD_S	$9, PT_R9(sp)
 #endif
-		LONG_S	$10, PT_R10(sp)
-		LONG_S	$11, PT_R11(sp)
-		LONG_S	$12, PT_R12(sp)
+		LONGD_S	$10, PT_R10(sp)
+		LONGD_S	$11, PT_R11(sp)
+		LONGD_S	$12, PT_R12(sp)
 #ifndef CONFIG_CPU_HAS_SMARTMIPS
-		LONG_S	v1, PT_HI(sp)
+		LONGH_S	v1, PT_HI(sp)
 		mflo	v1
 #endif
-		LONG_S	$13, PT_R13(sp)
-		LONG_S	$14, PT_R14(sp)
-		LONG_S	$15, PT_R15(sp)
-		LONG_S	$24, PT_R24(sp)
+		LONGD_S	$13, PT_R13(sp)
+		LONGD_S	$14, PT_R14(sp)
+		LONGD_S	$15, PT_R15(sp)
+		LONGD_S	$24, PT_R24(sp)
 #ifndef CONFIG_CPU_HAS_SMARTMIPS
-		LONG_S	v1, PT_LO(sp)
+		LONGH_S	v1, PT_LO(sp)
 #endif
 		.endm
 
 		.macro	SAVE_STATIC
-		LONG_S	$16, PT_R16(sp)
-		LONG_S	$17, PT_R17(sp)
-		LONG_S	$18, PT_R18(sp)
-		LONG_S	$19, PT_R19(sp)
-		LONG_S	$20, PT_R20(sp)
-		LONG_S	$21, PT_R21(sp)
-		LONG_S	$22, PT_R22(sp)
-		LONG_S	$23, PT_R23(sp)
-		LONG_S	$30, PT_R30(sp)
+		LONGD_S	$16, PT_R16(sp)
+		LONGD_S	$17, PT_R17(sp)
+		LONGD_S	$18, PT_R18(sp)
+		LONGD_S	$19, PT_R19(sp)
+		LONGD_S	$20, PT_R20(sp)
+		LONGD_S	$21, PT_R21(sp)
+		LONGD_S	$22, PT_R22(sp)
+		LONGD_S	$23, PT_R23(sp)
+		LONGD_S	$30, PT_R30(sp)
 		.endm
 
 #ifdef CONFIG_SMP
@@ -99,6 +99,9 @@
 #define CPU_ID_MFC0 MFC0
 #endif
 		.macro	get_saved_sp	/* SMP variation */
+#ifdef CONFIG_CPU_R5900
+		sync.p
+#endif
 		CPU_ID_MFC0	k0, CPU_ID_REG
 #if defined(CONFIG_32BIT) || defined(KBUILD_64BIT_SYM32)
 		lui	k1, %hi(kernelsp)
@@ -109,15 +112,18 @@
 		daddiu	k1, %hi(kernelsp)
 		dsll	k1, 16
 #endif
-		LONG_SRL	k0, PTEBASE_SHIFT
-		LONG_ADDU	k1, k0
-		LONG_L	k1, %lo(kernelsp)(k1)
+		LONGI_SRL	k0, PTEBASE_SHIFT
+		LONGI_ADDU	k1, k0
+		LONGI_L	k1, %lo(kernelsp)(k1)
 		.endm
 
 		.macro	set_saved_sp stackp temp temp2
+#ifdef CONFIG_CPU_R5900
+		sync.p
+#endif
 		CPU_ID_MFC0	\temp, CPU_ID_REG
-		LONG_SRL	\temp, PTEBASE_SHIFT
-		LONG_S	\stackp, kernelsp(\temp)
+		LONGI_SRL	\temp, PTEBASE_SHIFT
+		LONGI_S	\stackp, kernelsp(\temp)
 		.endm
 #else
 		.macro	get_saved_sp	/* Uniprocessor variation */
@@ -139,6 +145,9 @@
 1:		move	ra, k0
 		li	k0, 3
 		mtc0	k0, $22
+#ifdef CONFIG_CPU_R5900
+		sync.p
+#endif
 #endif /* CONFIG_CPU_LOONGSON2F */
 #if defined(CONFIG_32BIT) || defined(KBUILD_64BIT_SYM32)
 		lui	k1, %hi(kernelsp)
@@ -149,11 +158,11 @@
 		daddiu	k1, %hi(kernelsp)
 		dsll	k1, k1, 16
 #endif
-		LONG_L	k1, %lo(kernelsp)(k1)
+		LONGI_L	k1, %lo(kernelsp)(k1)
 		.endm
 
 		.macro	set_saved_sp stackp temp temp2
-		LONG_S	\stackp, kernelsp
+		LONGI_S	\stackp, kernelsp
 		.endm
 #endif
 
@@ -161,6 +170,9 @@
 		.set	push
 		.set	noat
 		.set	reorder
+#ifdef CONFIG_CPU_R5900
+		sync.p
+#endif
 		mfc0	k0, CP0_STATUS
 		sll	k0, 3		/* extract cu0 bit */
 		.set	noreorder
@@ -169,52 +181,71 @@
 		.set	reorder
 		/* Called from user mode, new stack. */
 		get_saved_sp
+8:
+#ifdef CONFIG_R5900_128BIT_SUPPORT
+		/* Align stack to 16 byte. */
+		ori		k1, k1, 16 - 1
+		xori	k1, k1, 16 - 1
+#endif
 #ifndef CONFIG_CPU_DADDI_WORKAROUNDS
-8:		move	k0, sp
+		move	k0, sp
 		PTR_SUBU sp, k1, PT_SIZE
 #else
 		.set	at=k0
-8:		PTR_SUBU k1, PT_SIZE
+		PTR_SUBU k1, PT_SIZE
 		.set	noat
 		move	k0, sp
 		move	sp, k1
 #endif
-		LONG_S	k0, PT_R29(sp)
-		LONG_S	$3, PT_R3(sp)
+		LONGD_S	k0, PT_R29(sp)
+		LONGD_S	$3, PT_R3(sp)
 		/*
 		 * You might think that you don't need to save $0,
 		 * but the FPU emulator and gdb remote debug stub
 		 * need it to operate correctly
 		 */
-		LONG_S	$0, PT_R0(sp)
+		LONGD_S	$0, PT_R0(sp)
+#ifdef CONFIG_CPU_R5900
+		sync.p
+#endif
 		mfc0	v1, CP0_STATUS
-		LONG_S	$2, PT_R2(sp)
+		LONGD_S	$2, PT_R2(sp)
 #ifdef CONFIG_MIPS_MT_SMTC
 		/*
 		 * Ideally, these instructions would be shuffled in
 		 * to cover the pipeline delay.
 		 */
+		.set	push
 		.set	mips32
+#ifdef CONFIG_CPU_R5900
+		sync.p
+#endif
 		mfc0	v1, CP0_TCSTATUS
-		.set	mips0
-		LONG_S	v1, PT_TCSTATUS(sp)
+		.set	pop
+		LONGI_S	v1, PT_TCSTATUS(sp)
 #endif /* CONFIG_MIPS_MT_SMTC */
-		LONG_S	$4, PT_R4(sp)
-		LONG_S	$5, PT_R5(sp)
-		LONG_S	v1, PT_STATUS(sp)
+		LONGD_S	$4, PT_R4(sp)
+		LONGD_S	$5, PT_R5(sp)
+		LONGI_S	v1, PT_STATUS(sp)
+#ifdef CONFIG_CPU_R5900
+		sync.p
+#endif
 		mfc0	v1, CP0_CAUSE
-		LONG_S	$6, PT_R6(sp)
-		LONG_S	$7, PT_R7(sp)
-		LONG_S	v1, PT_CAUSE(sp)
+		LONGD_S	$6, PT_R6(sp)
+		LONGD_S	$7, PT_R7(sp)
+		LONGI_S	v1, PT_CAUSE(sp)
+#ifdef CONFIG_CPU_R5900
+		sync.p
+#endif
 		MFC0	v1, CP0_EPC
 #ifdef CONFIG_64BIT
-		LONG_S	$8, PT_R8(sp)
-		LONG_S	$9, PT_R9(sp)
+		LONGD_S	$8, PT_R8(sp)
+		LONGD_S	$9, PT_R9(sp)
 #endif
-		LONG_S	$25, PT_R25(sp)
-		LONG_S	$28, PT_R28(sp)
-		LONG_S	$31, PT_R31(sp)
-		LONG_S	v1, PT_EPC(sp)
+		LONGD_S	$25, PT_R25(sp)
+		LONGD_S	$28, PT_R28(sp)
+		LONGD_S	$31, PT_R31(sp)
+		LONGI_S	v1, PT_EPC(sp)
 		ori	$28, sp, _THREAD_MASK
 		xori	$28, _THREAD_MASK
 #ifdef CONFIG_CPU_CAVIUM_OCTEON
@@ -225,9 +256,9 @@
 		    instructions. It must be saved before and kernel code might
 		    corrupt it */
 		jal     octeon_mult_save
-		LONG_L  v1, 0($28)  /* Load the current pointer */
+		LONGI_L  v1, 0($28)  /* Load the current pointer */
 			 /* Restore $31(ra) that was changed by the jal */
-		LONG_L  ra, PT_R31(sp)
+		LONGD_L  ra, PT_R31(sp)
 		pref    0, 0(v1)    /* Prefetch the current thread */
 #endif
 		.set	pop
@@ -243,47 +274,47 @@
 		.macro	RESTORE_AT
 		.set	push
 		.set	noat
-		LONG_L	$1,  PT_R1(sp)
+		LONGD_L	$1,  PT_R1(sp)
 		.set	pop
 		.endm
 
 		.macro	RESTORE_TEMP
 #ifdef CONFIG_CPU_HAS_SMARTMIPS
-		LONG_L	$24, PT_ACX(sp)
+		LONGD_L	$24, PT_ACX(sp)
 		mtlhx	$24
-		LONG_L	$24, PT_HI(sp)
+		LONGH_L	$24, PT_HI(sp)
 		mtlhx	$24
-		LONG_L	$24, PT_LO(sp)
+		LONGH_L	$24, PT_LO(sp)
 		mtlhx	$24
 #else
-		LONG_L	$24, PT_LO(sp)
+		LONGH_L	$24, PT_LO(sp)
 		mtlo	$24
-		LONG_L	$24, PT_HI(sp)
+		LONGH_L	$24, PT_HI(sp)
 		mthi	$24
 #endif
 #ifdef CONFIG_32BIT
-		LONG_L	$8, PT_R8(sp)
-		LONG_L	$9, PT_R9(sp)
+		LONGD_L	$8, PT_R8(sp)
+		LONGD_L	$9, PT_R9(sp)
 #endif
-		LONG_L	$10, PT_R10(sp)
-		LONG_L	$11, PT_R11(sp)
-		LONG_L	$12, PT_R12(sp)
-		LONG_L	$13, PT_R13(sp)
-		LONG_L	$14, PT_R14(sp)
-		LONG_L	$15, PT_R15(sp)
-		LONG_L	$24, PT_R24(sp)
+		LONGD_L	$10, PT_R10(sp)
+		LONGD_L	$11, PT_R11(sp)
+		LONGD_L	$12, PT_R12(sp)
+		LONGD_L	$13, PT_R13(sp)
+		LONGD_L	$14, PT_R14(sp)
+		LONGD_L	$15, PT_R15(sp)
+		LONGD_L	$24, PT_R24(sp)
 		.endm
 
 		.macro	RESTORE_STATIC
-		LONG_L	$16, PT_R16(sp)
-		LONG_L	$17, PT_R17(sp)
-		LONG_L	$18, PT_R18(sp)
-		LONG_L	$19, PT_R19(sp)
-		LONG_L	$20, PT_R20(sp)
-		LONG_L	$21, PT_R21(sp)
-		LONG_L	$22, PT_R22(sp)
-		LONG_L	$23, PT_R23(sp)
-		LONG_L	$30, PT_R30(sp)
+		LONGD_L	$16, PT_R16(sp)
+		LONGD_L	$17, PT_R17(sp)
+		LONGD_L	$18, PT_R18(sp)
+		LONGD_L	$19, PT_R19(sp)
+		LONGD_L	$20, PT_R20(sp)
+		LONGD_L	$21, PT_R21(sp)
+		LONGD_L	$22, PT_R22(sp)
+		LONGD_L	$23, PT_R23(sp)
+		LONGD_L	$30, PT_R30(sp)
 		.endm
 
 #if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
@@ -292,34 +323,37 @@
 		.set	push
 		.set	reorder
 		.set	noat
+#ifdef CONFIG_CPU_R5900
+		sync.p
+#endif
 		mfc0	a0, CP0_STATUS
 		li	v1, 0xff00
 		ori	a0, STATMASK
 		xori	a0, STATMASK
 		mtc0	a0, CP0_STATUS
 		and	a0, v1
-		LONG_L	v0, PT_STATUS(sp)
+		LONGI_L	v0, PT_STATUS(sp)
 		nor	v1, $0, v1
 		and	v0, v1
 		or	v0, a0
 		mtc0	v0, CP0_STATUS
-		LONG_L	$31, PT_R31(sp)
-		LONG_L	$28, PT_R28(sp)
-		LONG_L	$25, PT_R25(sp)
-		LONG_L	$7,  PT_R7(sp)
-		LONG_L	$6,  PT_R6(sp)
-		LONG_L	$5,  PT_R5(sp)
-		LONG_L	$4,  PT_R4(sp)
-		LONG_L	$3,  PT_R3(sp)
-		LONG_L	$2,  PT_R2(sp)
+		LONGD_L	$31, PT_R31(sp)
+		LONGD_L	$28, PT_R28(sp)
+		LONGD_L	$25, PT_R25(sp)
+		LONGD_L	$7,  PT_R7(sp)
+		LONGD_L	$6,  PT_R6(sp)
+		LONGD_L	$5,  PT_R5(sp)
+		LONGD_L	$4,  PT_R4(sp)
+		LONGD_L	$3,  PT_R3(sp)
+		LONGD_L	$2,  PT_R2(sp)
 		.set	pop
 		.endm
 
 		.macro	RESTORE_SP_AND_RET
 		.set	push
 		.set	noreorder
-		LONG_L	k0, PT_EPC(sp)
-		LONG_L	sp, PT_R29(sp)
+		LONGI_L	k0, PT_EPC(sp)
+		LONGD_L	sp, PT_R29(sp)
 		jr	k0
 		 rfe
 		.set	pop
@@ -353,9 +387,15 @@
 		 * If you can find a better design, implement it!
 		 *
 		 */
+#ifdef CONFIG_CPU_R5900
+		sync.p
+#endif
 		mfc0	v0, CP0_TCSTATUS
 		ori	v0, TCSTATUS_IXMT
 		mtc0	v0, CP0_TCSTATUS
+#ifdef CONFIG_CPU_R5900
+		sync.p
+#endif
 		_ehb
 		DVPE	5				# dvpe a1
 		jal	mips_ihb
@@ -364,24 +404,36 @@
 		/* Restore the Octeon multiplier state */
 		jal	octeon_mult_restore
 #endif
+#ifdef CONFIG_CPU_R5900
+		sync.p
+#endif
 		mfc0	a0, CP0_STATUS
 		ori	a0, STATMASK
 		xori	a0, STATMASK
 		mtc0	a0, CP0_STATUS
+#ifdef CONFIG_CPU_R5900
+		sync.p
+#endif
 		li	v1, 0xff00
 		and	a0, v1
-		LONG_L	v0, PT_STATUS(sp)
+		LONGI_L	v0, PT_STATUS(sp)
 		nor	v1, $0, v1
 		and	v0, v1
 		or	v0, a0
 		mtc0	v0, CP0_STATUS
+#ifdef CONFIG_CPU_R5900
+		sync.p
+#endif
 #ifdef CONFIG_MIPS_MT_SMTC
 /*
  * Only after EXL/ERL have been restored to status can we
  * restore TCStatus.IXMT.
  */
-		LONG_L	v1, PT_TCSTATUS(sp)
+		LONGI_L	v1, PT_TCSTATUS(sp)
 		_ehb
+#ifdef CONFIG_CPU_R5900
+		sync.p
+#endif
 		mfc0	a0, CP0_TCSTATUS
 		andi	v1, TCSTATUS_IXMT
 		bnez	v1, 0f
@@ -396,18 +448,27 @@
  * the TCContext register to hold 16 bits of offset that we
  * can add in-line to find the queue head.
  */
+#ifdef CONFIG_CPU_R5900
+		sync.p
+#endif
 		mfc0	v0, CP0_TCCONTEXT
 		la	a2, IPIQ
 		srl	v0, v0, 16
 		addu	a2, a2, v0
-		LONG_L	v0, 0(a2)
+		LONGI_L	v0, 0(a2)
 		beqz	v0, 0f
 /*
  * If we have a queue, provoke dispatch within the VPE by setting C_SW1
  */
+#ifdef CONFIG_CPU_R5900
+		sync.p
+#endif
 		mfc0	v0, CP0_CAUSE
 		ori	v0, v0, C_SW1
 		mtc0	v0, CP0_CAUSE
+#ifdef CONFIG_CPU_R5900
+		sync.p
+#endif
 0:
 		/*
 		 * This test should really never branch but
@@ -424,39 +485,48 @@
 		xori	a0, a0, TCSTATUS_IXMT
 		or	a0, a0, v1
 		mtc0	a0, CP0_TCSTATUS
+#ifdef CONFIG_CPU_R5900
+		sync.p
+#endif
 		_ehb
 
+#ifndef CONFIG_CPU_R5900
 		.set	mips0
+#endif
 #endif /* CONFIG_MIPS_MT_SMTC */
-		LONG_L	v1, PT_EPC(sp)
+		LONGI_L	v1, PT_EPC(sp)
 		MTC0	v1, CP0_EPC
-		LONG_L	$31, PT_R31(sp)
-		LONG_L	$28, PT_R28(sp)
-		LONG_L	$25, PT_R25(sp)
+#ifdef CONFIG_CPU_R5900
+		sync.p
+#endif
+		LONGD_L	$31, PT_R31(sp)
+		LONGD_L	$28, PT_R28(sp)
+		LONGD_L	$25, PT_R25(sp)
 #ifdef CONFIG_64BIT
-		LONG_L	$8, PT_R8(sp)
-		LONG_L	$9, PT_R9(sp)
+		LONGD_L	$8, PT_R8(sp)
+		LONGD_L	$9, PT_R9(sp)
 #endif
-		LONG_L	$7,  PT_R7(sp)
-		LONG_L	$6,  PT_R6(sp)
-		LONG_L	$5,  PT_R5(sp)
-		LONG_L	$4,  PT_R4(sp)
-		LONG_L	$3,  PT_R3(sp)
-		LONG_L	$2,  PT_R2(sp)
+		LONGD_L	$7,  PT_R7(sp)
+		LONGD_L	$6,  PT_R6(sp)
+		LONGD_L	$5,  PT_R5(sp)
+		LONGD_L	$4,  PT_R4(sp)
+		LONGD_L	$3,  PT_R3(sp)
+		LONGD_L	$2,  PT_R2(sp)
 		.set	pop
 		.endm
 
 		.macro	RESTORE_SP_AND_RET
-		LONG_L	sp, PT_R29(sp)
+		LONGD_L	sp, PT_R29(sp)
+		.set	push
 		.set	mips3
 		eret
-		.set	mips0
+		.set	pop
 		.endm
 
 #endif
 
 		.macro	RESTORE_SP
-		LONG_L	sp, PT_R29(sp)
+		LONGD_L	sp, PT_R29(sp)
 		.endm
 
 		.macro	RESTORE_ALL
@@ -481,17 +551,26 @@
  */
 		.macro	CLI
 #if !defined(CONFIG_MIPS_MT_SMTC)
+#ifdef CONFIG_CPU_R5900
+		sync.p
+#endif
 		mfc0	t0, CP0_STATUS
 		li	t1, ST0_CU0 | STATMASK
 		or	t0, t1
 		xori	t0, STATMASK
 		mtc0	t0, CP0_STATUS
+#ifdef CONFIG_CPU_R5900
+		sync.p
+#endif
 #else /* CONFIG_MIPS_MT_SMTC */
 		/*
 		 * For SMTC, we need to set privilege
 		 * and disable interrupts only for the
 		 * current TC, using the TCStatus register.
 		 */
+#ifdef CONFIG_CPU_R5900
+		sync.p
+#endif
 		mfc0	t0, CP0_TCSTATUS
 		/* Fortunately CU 0 is in the same place in both registers */
 		/* Set TCU0, TMX, TKSU (for later inversion) and IXMT */
@@ -500,12 +579,21 @@
 		/* Clear TKSU, leave IXMT */
 		xori	t0, 0x00001800
 		mtc0	t0, CP0_TCSTATUS
+#ifdef CONFIG_CPU_R5900
+		sync.p
+#endif
 		_ehb
 		/* We need to leave the global IE bit set, but clear EXL...*/
+#ifdef CONFIG_CPU_R5900
+		sync.p
+#endif
 		mfc0	t0, CP0_STATUS
 		ori	t0, ST0_EXL | ST0_ERL
 		xori	t0, ST0_EXL | ST0_ERL
 		mtc0	t0, CP0_STATUS
+#ifdef CONFIG_CPU_R5900
+		sync.p
+#endif
 #endif /* CONFIG_MIPS_MT_SMTC */
 		irq_disable_hazard
 		.endm
@@ -516,11 +604,17 @@
  */
 		.macro	STI
 #if !defined(CONFIG_MIPS_MT_SMTC)
+#ifdef CONFIG_CPU_R5900
+		sync.p
+#endif
 		mfc0	t0, CP0_STATUS
 		li	t1, ST0_CU0 | STATMASK
 		or	t0, t1
 		xori	t0, STATMASK & ~1
 		mtc0	t0, CP0_STATUS
+#ifdef CONFIG_CPU_R5900
+		sync.p
+#endif
 #else /* CONFIG_MIPS_MT_SMTC */
 		/*
 		 * For SMTC, we need to set privilege
@@ -528,6 +622,9 @@
 		 * current TC, using the TCStatus register.
 		 */
 		_ehb
+#ifdef CONFIG_CPU_R5900
+		sync.p
+#endif
 		mfc0	t0, CP0_TCSTATUS
 		/* Fortunately CU 0 is in the same place in both registers */
 		/* Set TCU0, TKSU (for later inversion) and IXMT */
@@ -536,12 +633,21 @@
 		/* Clear TKSU *and* IXMT */
 		xori	t0, 0x00001c00
 		mtc0	t0, CP0_TCSTATUS
+#ifdef CONFIG_CPU_R5900
+		sync.p
+#endif
 		_ehb
 		/* We need to leave the global IE bit set, but clear EXL...*/
+#ifdef CONFIG_CPU_R5900
+		sync.p
+#endif
 		mfc0	t0, CP0_STATUS
 		ori	t0, ST0_EXL
 		xori	t0, ST0_EXL
 		mtc0	t0, CP0_STATUS
+#ifdef CONFIG_CPU_R5900
+		sync.p
+#endif
 		/* irq_enable_hazard below should expand to EHB for 24K/34K cpus */
 #endif /* CONFIG_MIPS_MT_SMTC */
 		irq_enable_hazard
@@ -565,10 +671,16 @@
 		.set	push
 		.set	mips32r2
 		.set	noreorder
+#ifdef CONFIG_CPU_R5900
+		sync.p
+#endif
 		mfc0	v0, CP0_TCSTATUS
 		andi	v1, v0, TCSTATUS_IXMT
 		ori	v0, TCSTATUS_IXMT
 		mtc0	v0, CP0_TCSTATUS
+#ifdef CONFIG_CPU_R5900
+		sync.p
+#endif
 		_ehb
 		DMT	2				# dmt	v0
 		/*
@@ -579,6 +691,9 @@
 		nop	/* delay slot */
 		move	ra, t0
 #endif /* CONFIG_MIPS_MT_SMTC */
+#ifdef CONFIG_CPU_R5900
+		sync.p
+#endif
 		mfc0	t0, CP0_STATUS
 		li	t1, ST0_CU0 | (STATMASK & ~1)
 #if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
@@ -589,6 +704,9 @@
 		or	t0, t1
 		xori	t0, STATMASK & ~1
 		mtc0	t0, CP0_STATUS
+#ifdef CONFIG_CPU_R5900
+		sync.p
+#endif
 #ifdef CONFIG_MIPS_MT_SMTC
 		_ehb
 		andi	v0, v0, VPECONTROL_TE
@@ -596,12 +714,18 @@
 		nop	/* delay slot */
 		emt
 2:
+#ifdef CONFIG_CPU_R5900
+		sync.p
+#endif
 		mfc0	v0, CP0_TCSTATUS
 		/* Clear IXMT, then OR in previous value */
 		ori	v0, TCSTATUS_IXMT
 		xori	v0, TCSTATUS_IXMT
 		or	v0, v1, v0
 		mtc0	v0, CP0_TCSTATUS
+#ifdef CONFIG_CPU_R5900
+		sync.p
+#endif
 		/*
 		 * irq_disable_hazard below should expand to EHB
 		 * on 24K/34K CPUS
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/thread_info.h linux-2.6.35.4/arch/mips/include/asm/thread_info.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/thread_info.h	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/include/asm/thread_info.h	2014-07-18 22:29:43.530367724 +0200
@@ -83,6 +83,7 @@ register struct thread_info *__current_t
 #define THREAD_SIZE (PAGE_SIZE << THREAD_SIZE_ORDER)
 #define THREAD_MASK (THREAD_SIZE - 1UL)
 
+#if 0 /* TBD: Page alignment problem when CONFIG_SLUB_DEBUG_ON is activated. */
 #define __HAVE_ARCH_THREAD_INFO_ALLOCATOR
 
 #ifdef CONFIG_DEBUG_STACK_USAGE
@@ -92,6 +93,7 @@ register struct thread_info *__current_t
 #endif
 
 #define free_thread_info(info) kfree(info)
+#endif
 
 #endif /* !__ASSEMBLY__ */
 
@@ -120,6 +122,7 @@ register struct thread_info *__current_t
 #define TIF_32BIT_ADDR		23	/* 32-bit address space (o32/n32) */
 #define TIF_FPUBOUND		24	/* thread bound to FPU-full CPU set */
 #define TIF_LOAD_WATCH		25	/* If set, load watch registers */
+#define TIF_R5900FPU		26	/* FPU can be used by thread */
 #define TIF_SYSCALL_TRACE	31	/* syscall trace active */
 
 #ifdef CONFIG_MIPS32_O32
@@ -144,6 +147,7 @@ register struct thread_info *__current_t
 #define _TIF_32BIT_ADDR		(1<<TIF_32BIT_ADDR)
 #define _TIF_FPUBOUND		(1<<TIF_FPUBOUND)
 #define _TIF_LOAD_WATCH		(1<<TIF_LOAD_WATCH)
+#define _TIF_R5900FPU		(1<<TIF_R5900FPU)
 
 /* work to do on interrupt/exception return */
 #define _TIF_WORK_MASK		(0x0000ffef & ~_TIF_SECCOMP)
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/uaccess.h linux-2.6.35.4/arch/mips/include/asm/uaccess.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/uaccess.h	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/include/asm/uaccess.h	2014-07-18 22:29:43.530367724 +0200
@@ -252,11 +252,14 @@ do {									\
 	__gu_err;							\
 })
 
+#ifdef CONFIG_CPU_R5900
 #define __get_user_asm(val, insn, addr)					\
 {									\
 	long __gu_tmp;							\
 									\
 	__asm__ __volatile__(						\
+	/* In an error exception handler the user space could be uncached. */ \
+	"sync.l							\n"	\
 	"1:	" insn "	%1, %3				\n"	\
 	"2:							\n"	\
 	"	.section .fixup,\"ax\"				\n"	\
@@ -271,10 +274,32 @@ do {									\
 									\
 	(val) = (__typeof__(*(addr))) __gu_tmp;				\
 }
+#else
+#define __get_user_asm(val, insn, addr)					\
+{									\
+	long __gu_tmp;							\
+									\
+	__asm__ __volatile__(						\
+	"1:	" insn "	%1, %3				\n"	\
+	"2:							\n"	\
+	"	.section .fixup,\"ax\"				\n"	\
+	"3:	li	%0, %4					\n"	\
+	"	j	2b					\n"	\
+	"	.previous					\n"	\
+	"	.section __ex_table,\"a\"			\n"	\
+	"	"__UA_ADDR "\t1b, 3b				\n"	\
+	"	.previous					\n"	\
+	: "=r" (__gu_err), "=r" (__gu_tmp)				\
+	: "0" (0), "o" (__m(addr)), "i" (-EFAULT));			\
+									\
+	(val) = (__typeof__(*(addr))) __gu_tmp;				\
+}
+#endif
 
 /*
  * Get a long long 64 using 32 bit registers.
  */
+#ifdef CONFIG_CPU_R5900
 #define __get_user_asm_ll32(val, addr)					\
 {									\
 	union {								\
@@ -283,7 +308,11 @@ do {									\
 	} __gu_tmp;							\
 									\
 	__asm__ __volatile__(						\
+	/* In an error exception handler the user space could be uncached. */ \
+	"sync.l							\n"	\
 	"1:	lw	%1, (%3)				\n"	\
+	/* In an error exception handler the user space could be uncached. */ \
+	"sync.l							\n"	\
 	"2:	lw	%D1, 4(%3)				\n"	\
 	"3:	.section	.fixup,\"ax\"			\n"	\
 	"4:	li	%0, %4					\n"	\
@@ -300,6 +329,33 @@ do {									\
 									\
 	(val) = __gu_tmp.t;						\
 }
+#else
+#define __get_user_asm_ll32(val, addr)					\
+{									\
+	union {								\
+		unsigned long long	l;				\
+		__typeof__(*(addr))	t;				\
+	} __gu_tmp;							\
+									\
+	__asm__ __volatile__(						\
+	"1:	lw	%1, (%3)				\n"	\
+	"2:	lw	%D1, 4(%3)				\n"	\
+	"3:	.section	.fixup,\"ax\"			\n"	\
+	"4:	li	%0, %4					\n"	\
+	"	move	%1, $0					\n"	\
+	"	move	%D1, $0					\n"	\
+	"	j	3b					\n"	\
+	"	.previous					\n"	\
+	"	.section	__ex_table,\"a\"		\n"	\
+	"	" __UA_ADDR "	1b, 4b				\n"	\
+	"	" __UA_ADDR "	2b, 4b				\n"	\
+	"	.previous					\n"	\
+	: "=r" (__gu_err), "=&r" (__gu_tmp.l)				\
+	: "0" (0), "r" (addr), "i" (-EFAULT));				\
+									\
+	(val) = __gu_tmp.t;						\
+}
+#endif
 
 /*
  * Yuck.  We need two variants, one for 64bit operation and one
@@ -348,9 +404,12 @@ do {									\
 	__pu_err;							\
 })
 
+#ifdef CONFIG_CPU_R5900
 #define __put_user_asm(insn, ptr)					\
 {									\
 	__asm__ __volatile__(						\
+	/* In an error exception handler the user space could be uncached. */ \
+	"sync.l							\n"	\
 	"1:	" insn "	%z2, %3		# __put_user_asm\n"	\
 	"2:							\n"	\
 	"	.section	.fixup,\"ax\"			\n"	\
@@ -364,11 +423,34 @@ do {									\
 	: "0" (0), "Jr" (__pu_val), "o" (__m(ptr)),			\
 	  "i" (-EFAULT));						\
 }
+#else
+#define __put_user_asm(insn, ptr)					\
+{									\
+	__asm__ __volatile__(						\
+	"1:	" insn "	%z2, %3		# __put_user_asm\n"	\
+	"2:							\n"	\
+	"	.section	.fixup,\"ax\"			\n"	\
+	"3:	li	%0, %4					\n"	\
+	"	j	2b					\n"	\
+	"	.previous					\n"	\
+	"	.section	__ex_table,\"a\"		\n"	\
+	"	" __UA_ADDR "	1b, 3b				\n"	\
+	"	.previous					\n"	\
+	: "=r" (__pu_err)						\
+	: "0" (0), "Jr" (__pu_val), "o" (__m(ptr)),			\
+	  "i" (-EFAULT));						\
+}
+#endif
 
+#ifdef CONFIG_CPU_R5900
 #define __put_user_asm_ll32(ptr)					\
 {									\
 	__asm__ __volatile__(						\
+	/* In an error exception handler the user space could be uncached. */ \
+	"sync.l							\n"	\
 	"1:	sw	%2, (%3)	# __put_user_asm_ll32	\n"	\
+	/* In an error exception handler the user space could be uncached. */ \
+	"sync.l							\n"	\
 	"2:	sw	%D2, 4(%3)				\n"	\
 	"3:							\n"	\
 	"	.section	.fixup,\"ax\"			\n"	\
@@ -383,6 +465,26 @@ do {									\
 	: "0" (0), "r" (__pu_val), "r" (ptr),				\
 	  "i" (-EFAULT));						\
 }
+#else
+#define __put_user_asm_ll32(ptr)					\
+{									\
+	__asm__ __volatile__(						\
+	"1:	sw	%2, (%3)	# __put_user_asm_ll32	\n"	\
+	"2:	sw	%D2, 4(%3)				\n"	\
+	"3:							\n"	\
+	"	.section	.fixup,\"ax\"			\n"	\
+	"4:	li	%0, %4					\n"	\
+	"	j	3b					\n"	\
+	"	.previous					\n"	\
+	"	.section	__ex_table,\"a\"		\n"	\
+	"	" __UA_ADDR "	1b, 4b				\n"	\
+	"	" __UA_ADDR "	2b, 4b				\n"	\
+	"	.previous"						\
+	: "=r" (__pu_err)						\
+	: "0" (0), "r" (__pu_val), "r" (ptr),				\
+	  "i" (-EFAULT));						\
+}
+#endif
 
 extern void __put_user_unknown(void);
 
@@ -515,6 +617,30 @@ do {									\
 	__gu_err;							\
 })
 
+#ifdef CONFIG_CPU_R5900
+#define __get_user_unaligned_asm(val, insn, addr)			\
+{									\
+	long __gu_tmp;							\
+									\
+	__asm__ __volatile__(						\
+	/* In an error exception handler the user space could be uncached. */ \
+	"sync.l							\n"	\
+	"1:	" insn "	%1, %3				\n"	\
+	"2:							\n"	\
+	"	.section .fixup,\"ax\"				\n"	\
+	"3:	li	%0, %4					\n"	\
+	"	j	2b					\n"	\
+	"	.previous					\n"	\
+	"	.section __ex_table,\"a\"			\n"	\
+	"	"__UA_ADDR "\t1b, 3b				\n"	\
+	"	"__UA_ADDR "\t1b + 4, 3b			\n"	\
+	"	.previous					\n"	\
+	: "=r" (__gu_err), "=r" (__gu_tmp)				\
+	: "0" (0), "o" (__m(addr)), "i" (-EFAULT));			\
+									\
+	(val) = (__typeof__(*(addr))) __gu_tmp;				\
+}
+#else
 #define __get_user_unaligned_asm(val, insn, addr)			\
 {									\
 	long __gu_tmp;							\
@@ -535,16 +661,22 @@ do {									\
 									\
 	(val) = (__typeof__(*(addr))) __gu_tmp;				\
 }
+#endif
 
 /*
  * Get a long long 64 using 32 bit registers.
  */
+#ifdef CONFIG_CPU_R5900
 #define __get_user_unaligned_asm_ll32(val, addr)			\
 {									\
         unsigned long long __gu_tmp;					\
 									\
 	__asm__ __volatile__(						\
+	/* In an error exception handler the user space could be uncached. */ \
+	"sync.l							\n"	\
 	"1:	ulw	%1, (%3)				\n"	\
+	/* In an error exception handler the user space could be uncached. */ \
+	"sync.l							\n"	\
 	"2:	ulw	%D1, 4(%3)				\n"	\
 	"	move	%0, $0					\n"	\
 	"3:	.section	.fixup,\"ax\"			\n"	\
@@ -563,6 +695,32 @@ do {									\
 	: "0" (0), "r" (addr), "i" (-EFAULT));				\
 	(val) = (__typeof__(*(addr))) __gu_tmp;				\
 }
+#else
+#define __get_user_unaligned_asm_ll32(val, addr)			\
+{									\
+        unsigned long long __gu_tmp;					\
+									\
+	__asm__ __volatile__(						\
+	"1:	ulw	%1, (%3)				\n"	\
+	"2:	ulw	%D1, 4(%3)				\n"	\
+	"	move	%0, $0					\n"	\
+	"3:	.section	.fixup,\"ax\"			\n"	\
+	"4:	li	%0, %4					\n"	\
+	"	move	%1, $0					\n"	\
+	"	move	%D1, $0					\n"	\
+	"	j	3b					\n"	\
+	"	.previous					\n"	\
+	"	.section	__ex_table,\"a\"		\n"	\
+	"	" __UA_ADDR "	1b, 4b				\n"	\
+	"	" __UA_ADDR "	1b + 4, 4b			\n"	\
+	"	" __UA_ADDR "	2b, 4b				\n"	\
+	"	" __UA_ADDR "	2b + 4, 4b			\n"	\
+	"	.previous					\n"	\
+	: "=r" (__gu_err), "=&r" (__gu_tmp)				\
+	: "0" (0), "r" (addr), "i" (-EFAULT));				\
+	(val) = (__typeof__(*(addr))) __gu_tmp;				\
+}
+#endif
 
 /*
  * Yuck.  We need two variants, one for 64bit operation and one
@@ -609,9 +767,12 @@ do {									\
 	__pu_err;							\
 })
 
+#ifdef CONFIG_CPU_R5900
 #define __put_user_unaligned_asm(insn, ptr)				\
 {									\
 	__asm__ __volatile__(						\
+	/* In an error exception handler the user space could be uncached. */ \
+	"sync.l							\n"	\
 	"1:	" insn "	%z2, %3		# __put_user_unaligned_asm\n" \
 	"2:							\n"	\
 	"	.section	.fixup,\"ax\"			\n"	\
@@ -625,10 +786,31 @@ do {									\
 	: "0" (0), "Jr" (__pu_val), "o" (__m(ptr)),			\
 	  "i" (-EFAULT));						\
 }
+#else
+#define __put_user_unaligned_asm(insn, ptr)				\
+{									\
+	__asm__ __volatile__(						\
+	"1:	" insn "	%z2, %3		# __put_user_unaligned_asm\n" \
+	"2:							\n"	\
+	"	.section	.fixup,\"ax\"			\n"	\
+	"3:	li	%0, %4					\n"	\
+	"	j	2b					\n"	\
+	"	.previous					\n"	\
+	"	.section	__ex_table,\"a\"		\n"	\
+	"	" __UA_ADDR "	1b, 3b				\n"	\
+	"	.previous					\n"	\
+	: "=r" (__pu_err)						\
+	: "0" (0), "Jr" (__pu_val), "o" (__m(ptr)),			\
+	  "i" (-EFAULT));						\
+}
+#endif
 
+#ifdef CONFIG_CPU_R5900
 #define __put_user_unaligned_asm_ll32(ptr)				\
 {									\
 	__asm__ __volatile__(						\
+	/* In an error exception handler the user space could be uncached. */ \
+	"sync.l							\n"	\
 	"1:	sw	%2, (%3)	# __put_user_unaligned_asm_ll32	\n" \
 	"2:	sw	%D2, 4(%3)				\n"	\
 	"3:							\n"	\
@@ -646,6 +828,28 @@ do {									\
 	: "0" (0), "r" (__pu_val), "r" (ptr),				\
 	  "i" (-EFAULT));						\
 }
+#else
+#define __put_user_unaligned_asm_ll32(ptr)				\
+{									\
+	__asm__ __volatile__(						\
+	"1:	sw	%2, (%3)	# __put_user_unaligned_asm_ll32	\n" \
+	"2:	sw	%D2, 4(%3)				\n"	\
+	"3:							\n"	\
+	"	.section	.fixup,\"ax\"			\n"	\
+	"4:	li	%0, %4					\n"	\
+	"	j	3b					\n"	\
+	"	.previous					\n"	\
+	"	.section	__ex_table,\"a\"		\n"	\
+	"	" __UA_ADDR "	1b, 4b				\n"	\
+	"	" __UA_ADDR "	1b + 4, 4b			\n"	\
+	"	" __UA_ADDR "	2b, 4b				\n"	\
+	"	" __UA_ADDR "	2b + 4, 4b			\n"	\
+	"	.previous"						\
+	: "=r" (__pu_err)						\
+	: "0" (0), "r" (__pu_val), "r" (ptr),				\
+	  "i" (-EFAULT));						\
+}
+#endif
 
 extern void __put_user_unaligned_unknown(void);
 
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/uasm.h linux-2.6.35.4/arch/mips/include/asm/uasm.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/uasm.h	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/include/asm/uasm.h	2014-07-18 22:29:43.534367724 +0200
@@ -61,8 +61,10 @@ Ip_u1s2(_bltz);
 Ip_u1s2(_bltzl);
 Ip_u1u2s3(_bne);
 Ip_u2s3u1(_cache);
+#ifndef CONFIG_CPU_R5900
 Ip_u1u2u3(_dmfc0);
 Ip_u1u2u3(_dmtc0);
+#endif
 Ip_u2u1s3(_daddiu);
 Ip_u3u1u2(_daddu);
 Ip_u2u1u3(_dsll);
@@ -104,6 +106,8 @@ Ip_u3u1u2(_xor);
 Ip_u2u1u3(_xori);
 Ip_u2u1msbu3(_dins);
 Ip_u1(_syscall);
+Ip_0(_sync);
+Ip_0(_syncp);
 
 /* Handle labels. */
 struct uasm_label {
@@ -134,8 +138,19 @@ static inline void __cpuinit uasm_l##lb(
 # define UASM_i_SRA(buf, rs, rt, sh) uasm_i_dsra(buf, rs, rt, sh)
 # define UASM_i_SRL(buf, rs, rt, sh) uasm_i_dsrl(buf, rs, rt, sh)
 # define UASM_i_ROTR(buf, rs, rt, sh) uasm_i_drotr(buf, rs, rt, sh)
+#ifndef CONFIG_CPU_R5900
 # define UASM_i_MFC0(buf, rt, rd...) uasm_i_dmfc0(buf, rt, rd)
 # define UASM_i_MTC0(buf, rt, rd...) uasm_i_dmtc0(buf, rt, rd)
+#else
+# define UASM_i_MFC0(buf, rt, rd...) do { \
+		uasm_i_syncp(buf); \
+		uasm_i_mfc0(buf, rt, rd); \
+	} while(0)
+# define UASM_i_MTC0(buf, rt, rd...) do { \
+		uasm_i_mtc0(buf, rt, rd); \
+		uasm_i_syncp(buf); \
+	} while(0)
+#endif
 # define UASM_i_ADDIU(buf, rs, rt, val) uasm_i_daddiu(buf, rs, rt, val)
 # define UASM_i_ADDU(buf, rs, rt, rd) uasm_i_daddu(buf, rs, rt, rd)
 # define UASM_i_SUBU(buf, rs, rt, rd) uasm_i_dsubu(buf, rs, rt, rd)
@@ -148,8 +163,19 @@ static inline void __cpuinit uasm_l##lb(
 # define UASM_i_SRA(buf, rs, rt, sh) uasm_i_sra(buf, rs, rt, sh)
 # define UASM_i_SRL(buf, rs, rt, sh) uasm_i_srl(buf, rs, rt, sh)
 # define UASM_i_ROTR(buf, rs, rt, sh) uasm_i_rotr(buf, rs, rt, sh)
+#ifndef CONFIG_CPU_R5900
 # define UASM_i_MFC0(buf, rt, rd...) uasm_i_mfc0(buf, rt, rd)
 # define UASM_i_MTC0(buf, rt, rd...) uasm_i_mtc0(buf, rt, rd)
+#else
+# define UASM_i_MFC0(buf, rt, rd...) do { \
+		uasm_i_syncp(buf); \
+		uasm_i_mfc0(buf, rt, rd); \
+	} while(0)
+# define UASM_i_MTC0(buf, rt, rd...) do { \
+		uasm_i_mtc0(buf, rt, rd); \
+		uasm_i_syncp(buf); \
+	} while(0)
+#endif
 # define UASM_i_ADDIU(buf, rs, rt, val) uasm_i_addiu(buf, rs, rt, val)
 # define UASM_i_ADDU(buf, rs, rt, rd) uasm_i_addu(buf, rs, rt, rd)
 # define UASM_i_SUBU(buf, rs, rt, rd) uasm_i_subu(buf, rs, rt, rd)
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/unistd.h linux-2.6.35.4/arch/mips/include/asm/unistd.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/unistd.h	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/include/asm/unistd.h	2014-07-18 22:29:43.534367724 +0200
@@ -1054,5 +1054,9 @@
  */
 #define cond_syscall(x) asm(".weak\t" #x "\n" #x "\t=\tsys_ni_syscall")
 
+#ifdef CONFIG_MIPS_N32
+#define COMPAT_UTS_MACHINE	"mips\0\0\0"
+#endif
+
 #endif /* __KERNEL__ */
 #endif /* _ASM_UNISTD_H */
diff -purN linux-2.6.35.4-orig/arch/mips/include/asm/vdso.h linux-2.6.35.4/arch/mips/include/asm/vdso.h
--- linux-2.6.35.4-orig/arch/mips/include/asm/vdso.h	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/include/asm/vdso.h	2014-07-18 22:29:43.534367724 +0200
@@ -16,6 +16,9 @@
 struct mips_vdso {
 	u32 signal_trampoline[2];
 	u32 rt_signal_trampoline[2];
+#ifdef CONFIG_MIPS_N32
+	u32 n32_rt_signal_trampoline[2];
+#endif
 };
 #else  /* !CONFIG_32BIT */
 struct mips_vdso {
diff -purN linux-2.6.35.4-orig/arch/mips/Kconfig linux-2.6.35.4/arch/mips/Kconfig
--- linux-2.6.35.4-orig/arch/mips/Kconfig	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/Kconfig	2014-07-18 22:29:43.522367724 +0200
@@ -11,6 +11,7 @@ config MIPS
 	select HAVE_FTRACE_MCOUNT_RECORD
 	select HAVE_FUNCTION_GRAPH_TRACER
 	select RTC_LIB if !MACH_LOONGSON
+	select GENERIC_ATOMIC64
 
 mainmenu "Linux/MIPS Kernel Configuration"
 
@@ -681,6 +682,23 @@ config CAVIUM_OCTEON_REFERENCE_BOARD
 		Hikari
 	  Say Y here for most Octeon reference boards.
 
+config SONY_PS2
+	bool "Sony Playstation 2"
+	select BOOT_ELF32
+	select IRQ_CPU
+	select SYS_HAS_CPU_R5900
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select DMA_NONCOHERENT
+	select NO_IOPORT
+	select SYS_HAS_EARLY_PRINTK
+	select USB_ARCH_HAS_OHCI
+	select USB_OHCI_LITTLE_ENDIAN
+	select CEVT_R4K
+	select CSRC_R4K
+	help
+	  This enables support for Sony Playstation 2.
+
 endchoice
 
 source "arch/mips/alchemy/Kconfig"
@@ -696,6 +714,14 @@ source "arch/mips/vr41xx/Kconfig"
 source "arch/mips/cavium-octeon/Kconfig"
 source "arch/mips/loongson/Kconfig"
 
+config R5900_128BIT_SUPPORT
+	bool "Support for 128 bit general purpose registers"
+	default y
+	depends on SYS_HAS_CPU_R5900
+	help
+	  Say Y here to support applications which use 64 bit and
+	  128 bit general purpose registers.
+
 endmenu
 
 config RWSEM_GENERIC_SPINLOCK
@@ -737,6 +763,10 @@ config GENERIC_TIME
 	bool
 	default y
 
+config ARCH_USES_GETTIMEOFFSET
+	bool
+	default n
+
 config GENERIC_CMOS_UPDATE
 	bool
 	default y
@@ -1027,7 +1057,7 @@ config BOOT_ELF32
 config MIPS_L1_CACHE_SHIFT
 	int
 	default "4" if MACH_DECSTATION || MIKROTIK_RB532 || PMC_MSP4200_EVAL
-	default "6" if MIPS_CPU_SCACHE
+	default "6" if MIPS_CPU_SCACHE || CPU_R5900
 	default "7" if SGI_IP22 || SGI_IP27 || SGI_IP28 || SNI_RM || CPU_CAVIUM_OCTEON
 	default "5"
 
@@ -1307,6 +1337,15 @@ config CPU_CAVIUM_OCTEON
 	  can have up to 16 Mips64v2 cores and 8 integrated gigabit ethernets.
 	  Full details can be found at http://www.caviumnetworks.com.
 
+config CPU_R5900
+	bool "R5900"
+	depends on SYS_HAS_CPU_R5900
+	select CPU_SUPPORTS_32BIT_KERNEL
+	select CPU_SUPPORTS_64BIT_KERNEL
+	select CPU_HAS_WB
+	help
+	  MIPS Technologies R5900 processor (Emotion Engine in Sony Playstation 2).
+
 endchoice
 
 if CPU_LOONGSON2F
@@ -1401,6 +1440,9 @@ config SYS_HAS_CPU_R5432
 config SYS_HAS_CPU_R5500
 	bool
 
+config SYS_HAS_CPU_R5900
+	bool
+
 config SYS_HAS_CPU_R6000
 	bool
 
@@ -2218,6 +2260,17 @@ config MIPS32_N32
 	help
 	  Select this option if you want to run n32 binaries.  These are
 	  64-bit binaries using 32-bit quantities for addressing and certain
+	  data that would normally be 64-bit.  They are used in special
+	  cases.
+
+	  If unsure, say N.
+
+config MIPS_N32
+	bool "Kernel support for n32 binaries"
+	depends on R5900_128BIT_SUPPORT && !64BIT
+	help
+	  Select this option if you want to run n32 binaries.  These are
+	  64-bit binaries using 32-bit quantities for addressing and certain
 	  data that would normally be 64-bit.  They are used in special
 	  cases.
 
diff -purN linux-2.6.35.4-orig/arch/mips/kernel/asm-offsets.c linux-2.6.35.4/arch/mips/kernel/asm-offsets.c
--- linux-2.6.35.4-orig/arch/mips/kernel/asm-offsets.c	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/kernel/asm-offsets.c	2014-07-18 22:29:43.538367724 +0200
@@ -222,10 +222,12 @@ void output_sc_defines(void)
 	OFFSET(SC_FPC_EIR, sigcontext, sc_fpc_eir);
 	OFFSET(SC_HI1, sigcontext, sc_hi1);
 	OFFSET(SC_LO1, sigcontext, sc_lo1);
+#ifndef CONFIG_CPU_R5900
 	OFFSET(SC_HI2, sigcontext, sc_hi2);
 	OFFSET(SC_LO2, sigcontext, sc_lo2);
 	OFFSET(SC_HI3, sigcontext, sc_hi3);
 	OFFSET(SC_LO3, sigcontext, sc_lo3);
+#endif
 	BLANK();
 }
 #endif
diff -purN linux-2.6.35.4-orig/arch/mips/kernel/binfmt_elfn32.c linux-2.6.35.4/arch/mips/kernel/binfmt_elfn32.c
--- linux-2.6.35.4-orig/arch/mips/kernel/binfmt_elfn32.c	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/kernel/binfmt_elfn32.c	2014-07-18 22:29:43.538367724 +0200
@@ -57,6 +57,11 @@ typedef elf_fpreg_t elf_fpregset_t[ELF_N
 #include <linux/math64.h>
 
 #define elf_prstatus elf_prstatus32
+
+#ifdef CONFIG_32BIT
+#define compat_timeval timeval
+#endif
+
 struct elf_prstatus32
 {
 	struct elf_siginfo pr_info;	/* Info associated with signal */
@@ -116,7 +121,9 @@ MODULE_AUTHOR("Ralf Baechle (ralf@linux-
 #undef MODULE_DESCRIPTION
 #undef MODULE_AUTHOR
 
+#ifndef CONFIG_32BIT
 #undef TASK_SIZE
 #define TASK_SIZE TASK_SIZE32
+#endif
 
 #include "../../../fs/binfmt_elf.c"
diff -purN linux-2.6.35.4-orig/arch/mips/kernel/branch.c linux-2.6.35.4/arch/mips/kernel/branch.c
--- linux-2.6.35.4-orig/arch/mips/kernel/branch.c	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/kernel/branch.c	2014-07-18 22:29:43.538367724 +0200
@@ -23,7 +23,10 @@
 int __compute_return_epc(struct pt_regs *regs)
 {
 	unsigned int __user *addr;
-	unsigned int bit, fcr31, dspcontrol;
+	unsigned int bit, fcr31;
+#ifndef CONFIG_CPU_R5900
+	unsigned int dspcontrol;
+#endif
 	long epc;
 	union mips_instruction insn;
 
@@ -40,7 +43,7 @@ int __compute_return_epc(struct pt_regs
 		return -EFAULT;
 	}
 
-	regs->regs[0] = 0;
+	MIPS_WRITE_REG(regs->regs[0]) = 0;
 	switch (insn.i_format.opcode) {
 	/*
 	 * jr and jalr are in r_format format.
@@ -48,10 +51,10 @@ int __compute_return_epc(struct pt_regs
 	case spec_op:
 		switch (insn.r_format.func) {
 		case jalr_op:
-			regs->regs[insn.r_format.rd] = epc + 8;
+			MIPS_WRITE_REG(regs->regs[insn.r_format.rd]) = epc + 8;
 			/* Fall through */
 		case jr_op:
-			regs->cp0_epc = regs->regs[insn.r_format.rs];
+			regs->cp0_epc = MIPS_READ_REG_L(regs->regs[insn.r_format.rs]);
 			break;
 		}
 		break;
@@ -65,7 +68,7 @@ int __compute_return_epc(struct pt_regs
 		switch (insn.i_format.rt) {
 	 	case bltz_op:
 		case bltzl_op:
-			if ((long)regs->regs[insn.i_format.rs] < 0)
+			if (MIPS_READ_REG_S(regs->regs[insn.i_format.rs]) < 0)
 				epc = epc + 4 + (insn.i_format.simmediate << 2);
 			else
 				epc += 8;
@@ -74,7 +77,7 @@ int __compute_return_epc(struct pt_regs
 
 		case bgez_op:
 		case bgezl_op:
-			if ((long)regs->regs[insn.i_format.rs] >= 0)
+			if (MIPS_READ_REG_S(regs->regs[insn.i_format.rs]) >= 0)
 				epc = epc + 4 + (insn.i_format.simmediate << 2);
 			else
 				epc += 8;
@@ -83,8 +86,8 @@ int __compute_return_epc(struct pt_regs
 
 		case bltzal_op:
 		case bltzall_op:
-			regs->regs[31] = epc + 8;
-			if ((long)regs->regs[insn.i_format.rs] < 0)
+			MIPS_WRITE_REG(regs->regs[31]) = epc + 8;
+			if (MIPS_READ_REG_S(regs->regs[insn.i_format.rs]) < 0)
 				epc = epc + 4 + (insn.i_format.simmediate << 2);
 			else
 				epc += 8;
@@ -93,17 +96,20 @@ int __compute_return_epc(struct pt_regs
 
 		case bgezal_op:
 		case bgezall_op:
-			regs->regs[31] = epc + 8;
-			if ((long)regs->regs[insn.i_format.rs] >= 0)
+			MIPS_WRITE_REG(regs->regs[31]) = epc + 8;
+			if (MIPS_READ_REG_S(regs->regs[insn.i_format.rs]) >= 0)
 				epc = epc + 4 + (insn.i_format.simmediate << 2);
 			else
 				epc += 8;
 			regs->cp0_epc = epc;
 			break;
 		case bposge32_op:
+#ifndef CONFIG_CPU_R5900
 			if (!cpu_has_dsp)
+#endif
 				goto sigill;
 
+#ifndef CONFIG_CPU_R5900
 			dspcontrol = rddsp(0x01);
 
 			if (dspcontrol >= 32) {
@@ -111,6 +117,7 @@ int __compute_return_epc(struct pt_regs
 			} else
 				epc += 8;
 			regs->cp0_epc = epc;
+#endif
 			break;
 		}
 		break;
@@ -119,7 +126,7 @@ int __compute_return_epc(struct pt_regs
 	 * These are unconditional and in j_format.
 	 */
 	case jal_op:
-		regs->regs[31] = regs->cp0_epc + 8;
+		MIPS_WRITE_REG(regs->regs[31]) = regs->cp0_epc + 8;
 	case j_op:
 		epc += 4;
 		epc >>= 28;
@@ -133,8 +140,8 @@ int __compute_return_epc(struct pt_regs
 	 */
 	case beq_op:
 	case beql_op:
-		if (regs->regs[insn.i_format.rs] ==
-		    regs->regs[insn.i_format.rt])
+		if (MIPS_READ_REG(regs->regs[insn.i_format.rs]) ==
+		    MIPS_READ_REG(regs->regs[insn.i_format.rt]))
 			epc = epc + 4 + (insn.i_format.simmediate << 2);
 		else
 			epc += 8;
@@ -143,8 +150,8 @@ int __compute_return_epc(struct pt_regs
 
 	case bne_op:
 	case bnel_op:
-		if (regs->regs[insn.i_format.rs] !=
-		    regs->regs[insn.i_format.rt])
+		if (MIPS_READ_REG(regs->regs[insn.i_format.rs]) !=
+		    MIPS_READ_REG(regs->regs[insn.i_format.rt]))
 			epc = epc + 4 + (insn.i_format.simmediate << 2);
 		else
 			epc += 8;
@@ -154,7 +161,7 @@ int __compute_return_epc(struct pt_regs
 	case blez_op: /* not really i_format */
 	case blezl_op:
 		/* rt field assumed to be zero */
-		if ((long)regs->regs[insn.i_format.rs] <= 0)
+		if (MIPS_READ_REG_S(regs->regs[insn.i_format.rs]) <= 0)
 			epc = epc + 4 + (insn.i_format.simmediate << 2);
 		else
 			epc += 8;
@@ -164,7 +171,7 @@ int __compute_return_epc(struct pt_regs
 	case bgtz_op:
 	case bgtzl_op:
 		/* rt field assumed to be zero */
-		if ((long)regs->regs[insn.i_format.rs] > 0)
+		if (MIPS_READ_REG_S(regs->regs[insn.i_format.rs]) > 0)
 			epc = epc + 4 + (insn.i_format.simmediate << 2);
 		else
 			epc += 8;
@@ -207,7 +214,7 @@ int __compute_return_epc(struct pt_regs
 		break;
 #ifdef CONFIG_CPU_CAVIUM_OCTEON
 	case lwc2_op: /* This is bbit0 on Octeon */
-		if ((regs->regs[insn.i_format.rs] & (1ull<<insn.i_format.rt))
+		if ((MIPS_READ_REG(regs->regs[insn.i_format.rs]) & (1ull<<insn.i_format.rt))
 		     == 0)
 			epc = epc + 4 + (insn.i_format.simmediate << 2);
 		else
@@ -215,7 +222,7 @@ int __compute_return_epc(struct pt_regs
 		regs->cp0_epc = epc;
 		break;
 	case ldc2_op: /* This is bbit032 on Octeon */
-		if ((regs->regs[insn.i_format.rs] &
+		if ((MIPS_READ_REG(regs->regs[insn.i_format.rs]) &
 		    (1ull<<(insn.i_format.rt+32))) == 0)
 			epc = epc + 4 + (insn.i_format.simmediate << 2);
 		else
@@ -223,14 +230,14 @@ int __compute_return_epc(struct pt_regs
 		regs->cp0_epc = epc;
 		break;
 	case swc2_op: /* This is bbit1 on Octeon */
-		if (regs->regs[insn.i_format.rs] & (1ull<<insn.i_format.rt))
+		if (MIPS_READ_REG(regs->regs[insn.i_format.rs]) & (1ull<<insn.i_format.rt))
 			epc = epc + 4 + (insn.i_format.simmediate << 2);
 		else
 			epc += 8;
 		regs->cp0_epc = epc;
 		break;
 	case sdc2_op: /* This is bbit132 on Octeon */
-		if (regs->regs[insn.i_format.rs] &
+		if (MIPS_READ_REG(regs->regs[insn.i_format.rs]) &
 		    (1ull<<(insn.i_format.rt+32)))
 			epc = epc + 4 + (insn.i_format.simmediate << 2);
 		else
diff -purN linux-2.6.35.4-orig/arch/mips/kernel/cpu-probe.c linux-2.6.35.4/arch/mips/kernel/cpu-probe.c
--- linux-2.6.35.4-orig/arch/mips/kernel/cpu-probe.c	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/kernel/cpu-probe.c	2014-07-18 22:29:43.542367724 +0200
@@ -616,6 +616,14 @@ static inline void cpu_probe_legacy(stru
 			     MIPS_CPU_32FPR;
 		c->tlbsize = 64;
 		break;
+	case PRID_IMP_R5900:
+		c->cputype = CPU_R5900;
+		__cpu_name[cpu] = "R5900";
+		c->isa_level = MIPS_CPU_ISA_III;
+		c->tlbsize = 48;
+		c->options = MIPS_CPU_TLB | MIPS_CPU_4K_CACHE | MIPS_CPU_4KEX |
+				MIPS_CPU_DIVEC | MIPS_CPU_FPU | MIPS_CPU_32FPR | MIPS_CPU_COUNTER;
+		break;
 	}
 }
 
diff -purN linux-2.6.35.4-orig/arch/mips/kernel/entry.S linux-2.6.35.4/arch/mips/kernel/entry.S
--- linux-2.6.35.4-orig/arch/mips/kernel/entry.S	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/kernel/entry.S	2014-07-18 22:29:43.542367724 +0200
@@ -34,9 +34,9 @@ FEXPORT(ret_from_exception)
 	b	__ret_from_irq
 #endif
 FEXPORT(ret_from_irq)
-	LONG_S	s0, TI_REGS($28)
+	LONGI_S	s0, TI_REGS($28)
 FEXPORT(__ret_from_irq)
-	LONG_L	t0, PT_STATUS(sp)		# returning to kernel mode?
+	LONGI_L	t0, PT_STATUS(sp)		# returning to kernel mode?
 	andi	t0, t0, KU_USER
 	beqz	t0, resume_kernel
 
@@ -44,7 +44,7 @@ resume_userspace:
 	local_irq_disable		# make sure we dont miss an
 					# interrupt setting need_resched
 					# between sampling and return
-	LONG_L	a2, TI_FLAGS($28)	# current->work
+	LONGI_L	a2, TI_FLAGS($28)	# current->work
 	andi	t0, a2, _TIF_WORK_MASK	# (ignoring syscall_trace)
 	bnez	t0, work_pending
 	j	restore_all
@@ -55,10 +55,10 @@ resume_kernel:
 	lw	t0, TI_PRE_COUNT($28)
 	bnez	t0, restore_all
 need_resched:
-	LONG_L	t0, TI_FLAGS($28)
+	LONGI_L	t0, TI_FLAGS($28)
 	andi	t1, t0, _TIF_NEED_RESCHED
 	beqz	t1, restore_all
-	LONG_L	t0, PT_STATUS(sp)		# Interrupts off?
+	LONGI_L	t0, PT_STATUS(sp)		# Interrupts off?
 	andi	t0, 1
 	beqz	t0, restore_all
 	jal	preempt_schedule_irq
@@ -72,7 +72,7 @@ FEXPORT(syscall_exit)
 	local_irq_disable		# make sure need_resched and
 					# signals dont change between
 					# sampling and return
-	LONG_L	a2, TI_FLAGS($28)	# current->work
+	LONGI_L	a2, TI_FLAGS($28)	# current->work
 	li	t0, _TIF_ALLWORK_MASK
 	and	t0, a2, t0
 	bnez	t0, syscall_exit_work
@@ -108,10 +108,10 @@ FEXPORT(restore_all)			# restore full fr
 	mtc0	t0, CP0_TCCONTEXT
 #endif /* CONFIG_MIPS_MT_SMTC_IM_BACKSTOP */
 /* Detect and execute deferred IPI "interrupts" */
-	LONG_L	s0, TI_REGS($28)
-	LONG_S	sp, TI_REGS($28)
+	LONGI_L	s0, TI_REGS($28)
+	LONGI_S	sp, TI_REGS($28)
 	jal	deferred_smtc_ipi
-	LONG_S	s0, TI_REGS($28)
+	LONGI_S	s0, TI_REGS($28)
 #endif /* CONFIG_MIPS_MT_SMTC */
 	.set	noat
 	RESTORE_TEMP
@@ -122,7 +122,7 @@ FEXPORT(restore_partial)		# restore part
 	SAVE_STATIC
 	SAVE_AT
 	SAVE_TEMP
-	LONG_L	v0, PT_STATUS(sp)
+	LONGI_L	v0, PT_STATUS(sp)
 #if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
 	and	v0, ST0_IEP
 #else
@@ -150,7 +150,7 @@ work_resched:
 	local_irq_disable		# make sure need_resched and
 					# signals dont change between
 					# sampling and return
-	LONG_L	a2, TI_FLAGS($28)
+	LONGI_L	a2, TI_FLAGS($28)
 	andi	t0, a2, _TIF_WORK_MASK	# is there any work to be done
 					# other than syscall tracing?
 	beqz	t0, restore_all
diff -purN linux-2.6.35.4-orig/arch/mips/kernel/genex.S linux-2.6.35.4/arch/mips/kernel/genex.S
--- linux-2.6.35.4-orig/arch/mips/kernel/genex.S	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/kernel/genex.S	2014-07-18 22:29:43.542367724 +0200
@@ -36,11 +36,35 @@
 	__INIT
 
 NESTED(except_vec0_generic, 0, sp)
+#ifdef CONFIG_CPU_R5900
+	nop
+	nop
+#endif
 	PANIC_PIC("Exception vector 0 called")
+#ifdef CONFIG_CPU_R5900
+	/* There should be nothing which looks like a cache instruction. */
+	nop
+	nop
+	nop
+	nop
+	nop
+#endif
 	END(except_vec0_generic)
 
 NESTED(except_vec1_generic, 0, sp)
+#ifdef CONFIG_CPU_R5900
+	nop
+	nop
+#endif
 	PANIC_PIC("Exception vector 1 called")
+#ifdef CONFIG_CPU_R5900
+	/* There should be nothing which looks like a cache instruction. */
+	nop
+	nop
+	nop
+	nop
+	nop
+#endif
 	END(except_vec1_generic)
 
 /*
@@ -52,9 +76,19 @@ NESTED(except_vec1_generic, 0, sp)
 NESTED(except_vec3_generic, 0, sp)
 	.set	push
 	.set	noat
+#ifdef CONFIG_CPU_R5900
+	nop
+	nop
+#endif
 #if R5432_CP0_INTERRUPT_WAR
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	mfc0	k0, CP0_INDEX
 #endif
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	mfc0	k1, CP0_CAUSE
 	andi	k1, k1, 0x7c
 #ifdef CONFIG_64BIT
@@ -62,6 +96,14 @@ NESTED(except_vec3_generic, 0, sp)
 #endif
 	PTR_L	k0, exception_handlers(k1)
 	jr	k0
+#ifdef CONFIG_CPU_R5900
+	/* There should be nothing which looks like a cache instruction. */
+	nop
+	nop
+	nop
+	nop
+	nop
+#endif
 	.set	pop
 	END(except_vec3_generic)
 
@@ -75,6 +117,11 @@ NESTED(except_vec3_r4000, 0, sp)
 	.set	push
 	.set	mips3
 	.set	noat
+#ifdef CONFIG_CPU_R5900
+	nop
+	nop
+	sync.p
+#endif
 	mfc0	k1, CP0_CAUSE
 	li	k0, 31<<2
 	andi	k1, k1, 0x7c
@@ -98,10 +145,16 @@ NESTED(except_vec3_r4000, 0, sp)
 	 * load / store will be re-executed.
 	 */
 handle_vced:
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	MFC0	k0, CP0_BADVADDR
 	li	k1, -4					# Is this ...
 	and	k0, k1					# ... really needed?
 	mtc0	zero, CP0_TAGLO
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	cache	Index_Store_Tag_D, (k0)
 	cache	Hit_Writeback_Inv_SD, (k0)
 #ifdef CONFIG_PROC_FS
@@ -113,6 +166,9 @@ handle_vced:
 	eret
 
 handle_vcei:
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	MFC0	k0, CP0_BADVADDR
 	cache	Hit_Writeback_Inv_SD, (k0)		# also cleans pi
 #ifdef CONFIG_PROC_FS
@@ -132,7 +188,7 @@ LEAF(r4k_wait)
 	.set	push
 	.set	noreorder
 	/* start of rollback region */
-	LONG_L	t0, TI_FLAGS($28)
+	LONGI_L	t0, TI_FLAGS($28)
 	nop
 	andi	t0, _TIF_NEED_RESCHED
 	bnez	t0, 1f
@@ -151,12 +207,18 @@ LEAF(r4k_wait)
 	FEXPORT(rollback_\handler)
 	.set	push
 	.set	noat
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	MFC0	k0, CP0_EPC
 	PTR_LA	k1, r4k_wait
 	ori	k0, 0x1f	/* 32 byte rollback region */
 	xori	k0, 0x1f
 	bne	k0, k1, 9f
 	MTC0	k0, CP0_EPC
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 9:
 	.set pop
 	.endm
@@ -164,6 +226,10 @@ LEAF(r4k_wait)
 	.align  5
 BUILD_ROLLBACK_PROLOGUE handle_int
 NESTED(handle_int, PT_SIZE, sp)
+#ifdef CONFIG_CPU_R5900
+	nop
+	nop
+#endif
 #ifdef CONFIG_TRACE_IRQFLAGS
 	/*
 	 * Check to see if the interrupted code has just disabled
@@ -177,11 +243,17 @@ NESTED(handle_int, PT_SIZE, sp)
 	 */
 	.set	push
 	.set	noat
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	mfc0	k0, CP0_STATUS
 #if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
 	and	k0, ST0_IEP
 	bnez	k0, 1f
 
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	mfc0	k0, CP0_EPC
 	.set	noreorder
 	j	k0
@@ -199,8 +271,8 @@ NESTED(handle_int, PT_SIZE, sp)
 	CLI
 	TRACE_IRQS_OFF
 
-	LONG_L	s0, TI_REGS($28)
-	LONG_S	sp, TI_REGS($28)
+	LONGI_L	s0, TI_REGS($28)
+	LONGI_S	sp, TI_REGS($28)
 	PTR_LA	ra, ret_from_irq
 	j	plat_irq_dispatch
 	END(handle_int)
@@ -239,6 +311,10 @@ NESTED(except_vec_ejtag_debug, 0, sp)
  */
 BUILD_ROLLBACK_PROLOGUE except_vec_vi
 NESTED(except_vec_vi, 0, sp)
+#ifdef CONFIG_CPU_R5900
+	nop
+	nop
+#endif
 	SAVE_SOME
 	SAVE_AT
 	.set	push
@@ -278,15 +354,27 @@ NESTED(except_vec_vi_handler, 0, sp)
 	 * service routine will have cleared the state, and any active
 	 * level represents a new or otherwised unserviced event...
 	 */
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	mfc0	t1, CP0_STATUS
 	and	t0, a0, t1
 #ifdef CONFIG_MIPS_MT_SMTC_IM_BACKSTOP
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	mfc0	t2, CP0_TCCONTEXT
 	or	t2, t0, t2
 	mtc0	t2, CP0_TCCONTEXT
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 #endif /* CONFIG_MIPS_MT_SMTC_IM_BACKSTOP */
 	xor	t1, t1, t0
 	mtc0	t1, CP0_STATUS
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	_ehb
 #endif /* CONFIG_MIPS_MT_SMTC */
 	CLI
@@ -302,8 +390,8 @@ NESTED(except_vec_vi_handler, 0, sp)
 	move	v0, s0
 #endif
 
-	LONG_L	s0, TI_REGS($28)
-	LONG_S	sp, TI_REGS($28)
+	LONGI_L	s0, TI_REGS($28)
+	LONGI_S	sp, TI_REGS($28)
 	PTR_LA	ra, ret_from_irq
 	jr	v0
 	END(except_vec_vi_handler)
@@ -315,21 +403,27 @@ NESTED(ejtag_debug_handler, PT_SIZE, sp)
 	.set	push
 	.set	noat
 	MTC0	k0, CP0_DESAVE
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	mfc0	k0, CP0_DEBUG
 
 	sll	k0, k0, 30	# Check for SDBBP.
 	bgez	k0, ejtag_return
 
 	PTR_LA	k0, ejtag_debug_buffer
-	LONG_S	k1, 0(k0)
+	LONGI_S	k1, 0(k0)
 	SAVE_ALL
 	move	a0, sp
 	jal	ejtag_exception_handler
 	RESTORE_ALL
 	PTR_LA	k0, ejtag_debug_buffer
-	LONG_L	k1, 0(k0)
+	LONGI_L	k1, 0(k0)
 
 ejtag_return:
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	MFC0	k0, CP0_DESAVE
 	.set	mips32
 	deret
@@ -398,6 +492,9 @@ NESTED(nmi_handler, PT_SIZE, sp)
 	.endm
 
 	.macro	__build_clear_ade
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	MFC0	t0, CP0_BADVADDR
 	PTR_S	t0, PT_BVADDR(sp)
 	KMODE
@@ -411,7 +508,7 @@ NESTED(nmi_handler, PT_SIZE, sp)
 	   recognize an unknown escape code.  So make the arguments
 	   start with an n and gas will believe \n is ok ...  */
 	.macro	__BUILD_verbose	nexception
-	LONG_L	a1, PT_EPC(sp)
+	LONGI_L	a1, PT_EPC(sp)
 #ifdef CONFIG_32BIT
 	PRINT("Got \nexception at %08lx\012")
 #endif
@@ -421,9 +518,9 @@ NESTED(nmi_handler, PT_SIZE, sp)
 	.endm
 
 	.macro	__BUILD_count exception
-	LONG_L	t0,exception_count_\exception
+	LONGI_L	t0,exception_count_\exception
 	LONG_ADDIU t0, 1
-	LONG_S	t0,exception_count_\exception
+	LONGI_S	t0,exception_count_\exception
 	.comm	exception_count\exception, 8, 8
 	.endm
 
@@ -431,6 +528,10 @@ NESTED(nmi_handler, PT_SIZE, sp)
 	.align	5
 	NESTED(handle_\exception, PT_SIZE, sp)
 	.set	noat
+#ifdef CONFIG_CPU_R5900
+	nop
+	nop
+#endif
 	SAVE_ALL
 	FEXPORT(handle_\exception\ext)
 	__BUILD_clear_\clear
@@ -480,16 +581,28 @@ NESTED(nmi_handler, PT_SIZE, sp)
 	.set	noat
 	.set	noreorder
 	/* check if TLB contains a entry for EPC */
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	MFC0	k1, CP0_ENTRYHI
 	andi	k1, 0xff	/* ASID_MASK */
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	MFC0	k0, CP0_EPC
 	PTR_SRL	k0, PAGE_SHIFT + 1
 	PTR_SLL	k0, PAGE_SHIFT + 1
 	or	k1, k0
 	MTC0	k1, CP0_ENTRYHI
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	mtc0_tlbw_hazard
 	tlbp
 	tlb_probe_hazard
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	mfc0	k1, CP0_INDEX
 	.set	pop
 	bltz	k1, handle_ri	/* slow path */
@@ -502,6 +615,9 @@ NESTED(nmi_handler, PT_SIZE, sp)
 	.set	noat
 	.set	noreorder
 	/* 0x7c03e83b: rdhwr v1,$29 */
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	MFC0	k1, CP0_EPC
 	lui	k0, 0x7c03
 	lw	k1, (k1)
@@ -511,6 +627,9 @@ NESTED(nmi_handler, PT_SIZE, sp)
 	/* The insn is rdhwr.  No need to check CAUSE.BD here. */
 	get_saved_sp	/* k1 := current_thread_info */
 	.set	noreorder
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	MFC0	k0, CP0_EPC
 #if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
 	ori	k1, _THREAD_MASK
@@ -521,20 +640,32 @@ NESTED(nmi_handler, PT_SIZE, sp)
 	 rfe
 #else
 #ifndef CONFIG_CPU_DADDI_WORKAROUNDS
-	LONG_ADDIU	k0, 4		/* stall on $k0 */
+	LONGI_ADDIU	k0, 4		/* stall on $k0 */
 #else
 	.set	at=v1
-	LONG_ADDIU	k0, 4
+	LONGI_ADDIU	k0, 4
 	.set	noat
 #endif
 	MTC0	k0, CP0_EPC
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	/* I hope three instructions between MTC0 and ERET are enough... */
 	ori	k1, _THREAD_MASK
 	xori	k1, _THREAD_MASK
-	LONG_L	v1, TI_TP_VALUE(k1)
+	LONGI_L	v1, TI_TP_VALUE(k1)
+	.set	push
 	.set	mips3
 	eret
-	.set	mips0
+	.set	pop
+#ifdef CONFIG_CPU_R5900
+	/* There should be nothing which looks like cache instruction. */
+	nop
+	nop
+	nop
+	nop
+	nop
+#endif
 #endif
 	.set	pop
 	END(handle_ri_rdhwr)
diff -purN linux-2.6.35.4-orig/arch/mips/kernel/head.S linux-2.6.35.4/arch/mips/kernel/head.S
--- linux-2.6.35.4-orig/arch/mips/kernel/head.S	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/kernel/head.S	2014-07-18 22:29:43.542367724 +0200
@@ -39,7 +39,12 @@
 	 * 0+DVG in tlblo_1.
 	 */
 	dli	t0, 0xffffffffc0000000
+#ifdef CONFIG_CPU_R5900
+	mtc0	t0, CP0_ENTRYHI
+	sync.p
+#else
 	dmtc0	t0, CP0_ENTRYHI
+#endif
 	li	t0, 0x1c000		# Offset of text into node memory
 	dsll	t1, NASID_SHFT		# Shift text nasid into place
 	dsll	t2, NASID_SHFT		# Same for data nasid
@@ -52,18 +57,36 @@
 	li	t0, ((_PAGE_GLOBAL|_PAGE_VALID| _CACHE_CACHABLE_COW) >> 6)
 	or	t0, t0, t1
 	mtc0	t0, CP0_ENTRYLO0	# physaddr, VG, cach exlwr
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	li	t0, ((_PAGE_GLOBAL|_PAGE_VALID| _PAGE_DIRTY|_CACHE_CACHABLE_COW) >> 6)
 	or	t0, t0, t2
 	mtc0	t0, CP0_ENTRYLO1	# physaddr, DVG, cach exlwr
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	li	t0, 0x1ffe000		# MAPPED_KERN_TLBMASK, TLBPGMASK_16M
 	mtc0	t0, CP0_PAGEMASK
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	li	t0, 0			# KMAP_INX
 	mtc0	t0, CP0_INDEX
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	li	t0, 1
 	mtc0	t0, CP0_WIRED
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	tlbwi
 #else
 	mtc0	zero, CP0_WIRED
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 #endif
 	.endm
 
@@ -80,6 +103,9 @@
 	 * For SMTC, we need to set privilege and disable interrupts only for
 	 * the current TC, using the TCStatus register.
 	 */
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	mfc0	t0, CP0_TCSTATUS
 	/* Fortunately CU 0 is in the same place in both registers */
 	/* Set TCU0, TMX, TKSU (for later inversion) and IXMT */
@@ -88,17 +114,32 @@
 	/* Clear TKSU, leave IXMT */
 	xori	t0, 0x00001800
 	mtc0	t0, CP0_TCSTATUS
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	_ehb
 	/* We need to leave the global IE bit set, but clear EXL...*/
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	mfc0	t0, CP0_STATUS
 	or	t0, ST0_CU0 | ST0_EXL | ST0_ERL | \set | \clr
 	xor	t0, ST0_EXL | ST0_ERL | \clr
 	mtc0	t0, CP0_STATUS
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 #else
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	mfc0	t0, CP0_STATUS
 	or	t0, ST0_CU0|\set|0x1f|\clr
 	xor	t0, 0x1f|\clr
 	mtc0	t0, CP0_STATUS
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	.set	noreorder
 	sll	zero,3				# ehb
 #endif
@@ -167,26 +208,35 @@ NESTED(kernel_entry, 16, sp)			# kernel
 	 */
 	mtc0	zero, CP0_TCCONTEXT
 
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	mfc0	t0, CP0_STATUS
 	ori	t0, t0, 0xff1f
 	xori	t0, t0, 0x001e
 	mtc0	t0, CP0_STATUS
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 #endif /* CONFIG_MIPS_MT_SMTC */
 
 	PTR_LA		t0, __bss_start		# clear .bss
-	LONG_S		zero, (t0)
+	LONGI_S		zero, (t0)
 	PTR_LA		t1, __bss_stop - LONGSIZE
 1:
 	PTR_ADDIU	t0, LONGSIZE
-	LONG_S		zero, (t0)
+	LONGI_S		zero, (t0)
 	bne		t0, t1, 1b
 
-	LONG_S		a0, fw_arg0		# firmware arguments
-	LONG_S		a1, fw_arg1
-	LONG_S		a2, fw_arg2
-	LONG_S		a3, fw_arg3
+	LONGI_S		a0, fw_arg0		# firmware arguments
+	LONGI_S		a1, fw_arg1
+	LONGI_S		a2, fw_arg2
+	LONGI_S		a3, fw_arg3
 
 	MTC0		zero, CP0_CONTEXT	# clear context register
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	PTR_LA		$28, init_thread_union
 	/* Set the SP after an empty pt_regs.  */
 	PTR_LI		sp, _THREAD_SIZE - 32 - PT_SIZE
diff -purN linux-2.6.35.4-orig/arch/mips/kernel/linux64.c linux-2.6.35.4/arch/mips/kernel/linux64.c
--- linux-2.6.35.4-orig/arch/mips/kernel/linux64.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/kernel/linux64.c	2014-07-18 22:29:43.542367724 +0200
@@ -0,0 +1,123 @@
+/*
+ *  Conversion between 64-bit and 32-bit native system calls.
+ *  Convert syscalls from MIPS ABI n32 to o32.
+ *
+ *  Copyright (C) 2012-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/syscalls.h>
+#include <linux/file.h>
+
+#include <asm/sim.h>
+#include <asm/ptrace.h>
+
+asmlinkage int sysn32_pread64(nabi_no_regargs struct pt_regs regs)
+{
+	return sys_pread64(MIPS_READ_REG(regs.regs[4]),
+		(void *) MIPS_READ_REG_L(regs.regs[5]),
+		MIPS_READ_REG(regs.regs[6]),
+		MIPS_READ_REG(regs.regs[7]));
+}
+
+asmlinkage int sysn32_pwrite64(nabi_no_regargs struct pt_regs regs)
+{
+	return sys_pwrite64(MIPS_READ_REG(regs.regs[4]),
+		(void *) MIPS_READ_REG_L(regs.regs[5]),
+		MIPS_READ_REG(regs.regs[6]),
+		MIPS_READ_REG(regs.regs[7]));
+}
+
+asmlinkage int sysn32_lookup_dcookie(nabi_no_regargs struct pt_regs regs)
+{
+	return sys_lookup_dcookie(MIPS_READ_REG(regs.regs[4]),
+		(void *) MIPS_READ_REG_L(regs.regs[5]),
+		MIPS_READ_REG(regs.regs[6]));
+}
+
+asmlinkage int sysn32_sync_file_range(nabi_no_regargs struct pt_regs regs)
+{
+	return sys_sync_file_range(MIPS_READ_REG(regs.regs[4]),
+		MIPS_READ_REG(regs.regs[5]),
+		MIPS_READ_REG(regs.regs[6]),
+		MIPS_READ_REG(regs.regs[7]));
+}
+
+asmlinkage int sysn32_fallocate(nabi_no_regargs struct pt_regs regs)
+{
+	return sys_fallocate(MIPS_READ_REG(regs.regs[4]),
+		MIPS_READ_REG(regs.regs[5]),
+		MIPS_READ_REG(regs.regs[6]),
+		MIPS_READ_REG(regs.regs[7]));
+}
+
+asmlinkage int sysn32_fadvise64_64(nabi_no_regargs struct pt_regs regs)
+{
+	return sys_fadvise64_64(MIPS_READ_REG(regs.regs[4]),
+		MIPS_READ_REG(regs.regs[5]),
+		MIPS_READ_REG(regs.regs[6]),
+		MIPS_READ_REG(regs.regs[7]));
+}
+
+asmlinkage int sysn32_readahead(nabi_no_regargs struct pt_regs regs)
+{
+	return sys_readahead(MIPS_READ_REG(regs.regs[4]),
+		MIPS_READ_REG(regs.regs[5]),
+		MIPS_READ_REG(regs.regs[6]));
+}
+
+static long long n32_lseek(unsigned int fd, loff_t offset, unsigned int origin)
+{
+	loff_t retval;
+	struct file * file;
+	int fput_needed;
+
+	retval = -EBADF;
+	file = fget_light(fd, &fput_needed);
+	if (!file)
+		goto bad;
+
+	retval = -EINVAL;
+	if (origin <= SEEK_MAX) {
+		loff_t res = vfs_llseek(file, offset, origin);
+		retval = res;
+	}
+	fput_light(file, fput_needed);
+bad:
+	return retval;
+}
+
+/*
+ * WARNING: v0 is misused for storing return address in syso64_lseek().
+ * Don't expect a sensible value here.
+ */
+asmlinkage int sysn32_lseek(nabi_no_regargs struct pt_regs regs)
+{
+	return n32_lseek(MIPS_READ_REG(regs.regs[4]), MIPS_READ_REG(regs.regs[5]), MIPS_READ_REG(regs.regs[6]));
+}
+
+asmlinkage int sysn32_mips_mmap(nabi_no_regargs struct pt_regs regs)
+{
+	unsigned long result;
+
+	result = -EINVAL;
+	if (MIPS_READ_REG(regs.regs[9]) & ~PAGE_MASK)
+		goto out;
+
+	result = sys_mmap_pgoff(MIPS_READ_REG(regs.regs[4]), MIPS_READ_REG(regs.regs[5]), MIPS_READ_REG(regs.regs[6]), MIPS_READ_REG(regs.regs[7]), MIPS_READ_REG(regs.regs[8]), MIPS_READ_REG(regs.regs[9]) >> PAGE_SHIFT);
+
+out:
+	return result;
+}
diff -purN linux-2.6.35.4-orig/arch/mips/kernel/Makefile linux-2.6.35.4/arch/mips/kernel/Makefile
--- linux-2.6.35.4-orig/arch/mips/kernel/Makefile	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/kernel/Makefile	2014-07-18 22:29:43.538367724 +0200
@@ -39,6 +39,7 @@ obj-$(CONFIG_CPU_R3000)		+= r2300_fpu.o
 obj-$(CONFIG_CPU_R4300)		+= r4k_fpu.o r4k_switch.o
 obj-$(CONFIG_CPU_R4X00)		+= r4k_fpu.o r4k_switch.o
 obj-$(CONFIG_CPU_R5000)		+= r4k_fpu.o r4k_switch.o
+obj-$(CONFIG_CPU_R5900)		+= r5900_fpu.o r5900_switch.o
 obj-$(CONFIG_CPU_R6000)		+= r6000_fpu.o r4k_switch.o
 obj-$(CONFIG_CPU_R5432)		+= r4k_fpu.o r4k_switch.o
 obj-$(CONFIG_CPU_R5500)		+= r4k_fpu.o r4k_switch.o
@@ -80,6 +81,7 @@ obj-$(CONFIG_32BIT)		+= scall32-o32.o
 obj-$(CONFIG_64BIT)		+= scall64-64.o
 obj-$(CONFIG_MIPS32_COMPAT)	+= linux32.o ptrace32.o signal32.o
 obj-$(CONFIG_MIPS32_N32)	+= binfmt_elfn32.o scall64-n32.o signal_n32.o
+obj-$(CONFIG_MIPS_N32)		+= binfmt_elfn32.o scall32-n32.o linux64.o o32o64converter.o
 obj-$(CONFIG_MIPS32_O32)	+= binfmt_elfo32.o scall64-o32.o
 
 obj-$(CONFIG_KGDB)		+= kgdb.o
@@ -101,6 +103,9 @@ obj-$(CONFIG_HAVE_STD_PC_SERIAL_PORT)	+=
 
 obj-$(CONFIG_MIPS_CPUFREQ)	+= cpufreq/
 
-EXTRA_CFLAGS += -Werror
+# Disable -Werror on GCC 4.09 or higher.
+EXTRA_CFLAGS += $(shell if [ $(call cc-version) -lt 0409 ] ; then \
+			echo $(call cc-option,-Werror); \
+			fi ;)
 
 CPPFLAGS_vmlinux.lds		:= $(KBUILD_CFLAGS)
diff -purN linux-2.6.35.4-orig/arch/mips/kernel/mips_ksyms.c linux-2.6.35.4/arch/mips/kernel/mips_ksyms.c
--- linux-2.6.35.4-orig/arch/mips/kernel/mips_ksyms.c	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/kernel/mips_ksyms.c	2014-07-18 22:29:43.542367724 +0200
@@ -24,6 +24,11 @@ extern long __strlen_user_nocheck_asm(co
 extern long __strlen_user_asm(const char *s);
 extern long __strnlen_user_nocheck_asm(const char *s);
 extern long __strnlen_user_asm(const char *s);
+extern void __muldi3(void);
+extern void __umoddi3(void);
+extern void __divdi3(void);
+extern void __udivdi3(void);
+extern void __moddi3(void);
 
 /*
  * String functions
@@ -56,3 +61,12 @@ EXPORT_SYMBOL(invalid_pte_table);
 /* _mcount is defined in arch/mips/kernel/mcount.S */
 EXPORT_SYMBOL(_mcount);
 #endif
+#ifdef CONFIG_CPU_R5900
+EXPORT_SYMBOL(__muldi3);
+EXPORT_SYMBOL(__umoddi3);
+EXPORT_SYMBOL(__divdi3);
+EXPORT_SYMBOL(__udivdi3);
+EXPORT_SYMBOL(__moddi3);
+#endif
+EXPORT_SYMBOL(copy_page);
+EXPORT_SYMBOL(clear_page);
diff -purN linux-2.6.35.4-orig/arch/mips/kernel/o32o64converter.S linux-2.6.35.4/arch/mips/kernel/o32o64converter.S
--- linux-2.6.35.4-orig/arch/mips/kernel/o32o64converter.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/kernel/o32o64converter.S	2014-07-18 22:29:43.542367724 +0200
@@ -0,0 +1,39 @@
+/*
+ *  Conversion between 64-bit and 32-bit native system calls.
+ *  Convert syscalls from MIPS ABI o64 to o32.
+ *
+ *  Copyright (C) 2012-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <asm/stackframe.h>
+
+.text
+.global syso64_lseek
+.set push
+.set arch=r5900
+
+syso64_lseek:
+	sd	ra, PT_R2(sp)		/* misuse PT_R2 to save return address. */
+	jal	sysn32_lseek
+
+	ld	ra, PT_R2(sp)		/* Restore return address. */
+	/* o32 returns 64 bit value in v0 and v1. Convert it to a 64
+	 * bit value in register v0.
+	 */
+	pextlw	v0, v1, v0
+	jr	ra
+
+.set pop
diff -purN linux-2.6.35.4-orig/arch/mips/kernel/process.c linux-2.6.35.4/arch/mips/kernel/process.c
--- linux-2.6.35.4-orig/arch/mips/kernel/process.c	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/kernel/process.c	2014-07-18 22:29:43.542367724 +0200
@@ -102,7 +102,7 @@ void start_thread(struct pt_regs * regs,
 	if (cpu_has_dsp)
 		__init_dsp();
 	regs->cp0_epc = pc;
-	regs->regs[29] = sp;
+	MIPS_WRITE_REG(regs->regs[29]) = sp;
 	current_thread_info()->addr_limit = USER_DS;
 }
 
@@ -139,21 +139,21 @@ int copy_thread(unsigned long clone_flag
 	/*  Put the stack after the struct pt_regs.  */
 	childksp = (unsigned long) childregs;
 	*childregs = *regs;
-	childregs->regs[7] = 0;	/* Clear error flag */
+	MIPS_WRITE_REG(childregs->regs[7]) = 0;	/* Clear error flag */
 
-	childregs->regs[2] = 0;	/* Child gets zero as return value */
-	regs->regs[2] = p->pid;
+	MIPS_WRITE_REG(childregs->regs[2]) = 0;	/* Child gets zero as return value */
+	MIPS_WRITE_REG(regs->regs[2]) = p->pid;
 
 	if (childregs->cp0_status & ST0_CU0) {
-		childregs->regs[28] = (unsigned long) ti;
-		childregs->regs[29] = childksp;
+		MIPS_WRITE_REG(childregs->regs[28]) = (unsigned long) ti;
+		MIPS_WRITE_REG(childregs->regs[29]) = childksp;
 		ti->addr_limit = KERNEL_DS;
 	} else {
-		childregs->regs[29] = usp;
+		MIPS_WRITE_REG(childregs->regs[29]) = usp;
 		ti->addr_limit = USER_DS;
 	}
-	p->thread.reg29 = (unsigned long) childregs;
-	p->thread.reg31 = (unsigned long) ret_from_fork;
+	MIPS_WRITE_REG(p->thread.reg29) = (unsigned long) childregs;
+	MIPS_WRITE_REG(p->thread.reg31) = (unsigned long) ret_from_fork;
 
 	/*
 	 * New tasks lose permission to use the fpu. This accelerates context
@@ -176,7 +176,7 @@ int copy_thread(unsigned long clone_flag
 #endif /* CONFIG_MIPS_MT_FPAFF */
 
 	if (clone_flags & CLONE_SETTLS)
-		ti->tp_value = regs->regs[7];
+		ti->tp_value = MIPS_READ_REG(regs->regs[7]);
 
 	return 0;
 }
@@ -197,7 +197,7 @@ void elf_dump_regs(elf_greg_t *gp, struc
 		gp[i] = 0;
 	gp[EF_R0] = 0;
 	for (i = 1; i <= 31; i++)
-		gp[EF_R0 + i] = regs->regs[i];
+		gp[EF_R0 + i] = MIPS_READ_REG(regs->regs[i]);
 	gp[EF_R26] = 0;
 	gp[EF_R27] = 0;
 	gp[EF_LO] = regs->lo;
@@ -238,8 +238,8 @@ long kernel_thread(int (*fn)(void *), vo
 
 	memset(&regs, 0, sizeof(regs));
 
-	regs.regs[4] = (unsigned long) arg;
-	regs.regs[5] = (unsigned long) fn;
+	MIPS_WRITE_REG(regs.regs[4]) = (unsigned long) arg;
+	MIPS_WRITE_REG(regs.regs[5]) = (unsigned long) fn;
 	regs.cp0_epc = (unsigned long) kernel_thread_helper;
 	regs.cp0_status = read_c0_status();
 #if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
@@ -365,11 +365,11 @@ unsigned long thread_saved_pc(struct tas
 	struct thread_struct *t = &tsk->thread;
 
 	/* New born processes are a special case */
-	if (t->reg31 == (unsigned long) ret_from_fork)
-		return t->reg31;
+	if (MIPS_READ_REG_L(t->reg31) == (unsigned long) ret_from_fork)
+		return MIPS_READ_REG_L(t->reg31);
 	if (schedule_mfi.pc_offset < 0)
 		return 0;
-	return ((unsigned long *)t->reg29)[schedule_mfi.pc_offset];
+	return ((unsigned long *)MIPS_READ_REG_L(t->reg29))[schedule_mfi.pc_offset];
 }
 
 
@@ -401,8 +401,8 @@ unsigned long unwind_stack(struct task_s
 			regs = (struct pt_regs *)*sp;
 			pc = regs->cp0_epc;
 			if (__kernel_text_address(pc)) {
-				*sp = regs->regs[29];
-				*ra = regs->regs[31];
+				*sp = MIPS_READ_REG_L(regs->regs[29]);
+				*ra = MIPS_READ_REG_L(regs->regs[31]);
 				return pc;
 			}
 		}
@@ -465,7 +465,7 @@ unsigned long get_wchan(struct task_stru
 	pc = thread_saved_pc(task);
 
 #ifdef CONFIG_KALLSYMS
-	sp = task->thread.reg29 + schedule_mfi.frame_size;
+	sp = MIPS_READ_REG_L(task->thread.reg29) + schedule_mfi.frame_size;
 
 	while (in_sched_functions(pc))
 		pc = unwind_stack(task, &sp, pc, &ra);
diff -purN linux-2.6.35.4-orig/arch/mips/kernel/ptrace32.c linux-2.6.35.4/arch/mips/kernel/ptrace32.c
--- linux-2.6.35.4-orig/arch/mips/kernel/ptrace32.c	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/kernel/ptrace32.c	2014-07-18 22:29:43.542367724 +0200
@@ -165,7 +165,11 @@ long compat_arch_ptrace(struct task_stru
 			preempt_enable();
 			break;
 		}
+#ifdef CONFIG_CPU_R5900
+		case DSP_BASE ... DSP_BASE + 1: {
+#else
 		case DSP_BASE ... DSP_BASE + 5: {
+#endif
 			dspreg_t *dregs;
 
 			if (!cpu_has_dsp) {
@@ -177,6 +181,7 @@ long compat_arch_ptrace(struct task_stru
 			tmp = (unsigned long) (dregs[addr - DSP_BASE]);
 			break;
 		}
+#ifndef CONFIG_CPU_R5900
 		case DSP_CONTROL:
 			if (!cpu_has_dsp) {
 				tmp = 0;
@@ -185,6 +190,7 @@ long compat_arch_ptrace(struct task_stru
 			}
 			tmp = child->thread.dsp.dspcontrol;
 			break;
+#endif
 		default:
 			tmp = 0;
 			ret = -EIO;
@@ -265,7 +271,11 @@ long compat_arch_ptrace(struct task_stru
 		case FPC_CSR:
 			child->thread.fpu.fcr31 = data;
 			break;
+#ifdef CONFIG_CPU_R5900
+		case DSP_BASE ... DSP_BASE + 1: {
+#else
 		case DSP_BASE ... DSP_BASE + 5: {
+#endif
 			dspreg_t *dregs;
 
 			if (!cpu_has_dsp) {
@@ -277,6 +287,7 @@ long compat_arch_ptrace(struct task_stru
 			dregs[addr - DSP_BASE] = data;
 			break;
 		}
+#ifndef CONFIG_CPU_R5900
 		case DSP_CONTROL:
 			if (!cpu_has_dsp) {
 				ret = -EIO;
@@ -284,6 +295,7 @@ long compat_arch_ptrace(struct task_stru
 			}
 			child->thread.dsp.dspcontrol = data;
 			break;
+#endif
 		default:
 			/* The rest are not allowed. */
 			ret = -EIO;
diff -purN linux-2.6.35.4-orig/arch/mips/kernel/ptrace.c linux-2.6.35.4/arch/mips/kernel/ptrace.c
--- linux-2.6.35.4-orig/arch/mips/kernel/ptrace.c	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/kernel/ptrace.c	2014-07-18 22:29:43.542367724 +0200
@@ -65,10 +65,17 @@ int ptrace_getregs(struct task_struct *c
 
 	regs = task_pt_regs(child);
 
+	/* TBD: Add 128 bit support. */
 	for (i = 0; i < 32; i++)
-		__put_user((long)regs->regs[i], data + i);
+		__put_user(MIPS_READ_REG_S(regs->regs[i]), data + i);
+#ifdef CONFIG_CPU_R5900
+	/* TBD: Test 64 bit lo access. */
+	__put_user((long long)regs->lo, data + EF_LO - EF_R0);
+	__put_user((long long)regs->hi, data + EF_HI - EF_R0);
+#else
 	__put_user((long)regs->lo, data + EF_LO - EF_R0);
 	__put_user((long)regs->hi, data + EF_HI - EF_R0);
+#endif
 	__put_user((long)regs->cp0_epc, data + EF_CP0_EPC - EF_R0);
 	__put_user((long)regs->cp0_badvaddr, data + EF_CP0_BADVADDR - EF_R0);
 	__put_user((long)regs->cp0_status, data + EF_CP0_STATUS - EF_R0);
@@ -92,8 +99,16 @@ int ptrace_setregs(struct task_struct *c
 
 	regs = task_pt_regs(child);
 
-	for (i = 0; i < 32; i++)
-		__get_user(regs->regs[i], data + i);
+	/* TBD: Add 128 bit support. */
+	for (i = 0; i < 32; i++) {
+		MIPS_REG_T tmp;
+		int rv;
+
+		rv = __get_user(tmp, data + i);
+		if (rv == 0) {
+			MIPS_WRITE_REG(regs->regs[i]) = tmp;
+		}
+	}
 	__get_user(regs->lo, data + EF_LO - EF_R0);
 	__get_user(regs->hi, data + EF_HI - EF_R0);
 	__get_user(regs->cp0_epc, data + EF_CP0_EPC - EF_R0);
@@ -269,14 +284,16 @@ long arch_ptrace(struct task_struct *chi
 	/* Read the word at location addr in the USER area. */
 	case PTRACE_PEEKUSR: {
 		struct pt_regs *regs;
-		unsigned long tmp = 0;
+		/* TBD: Maybe not compatible with existing gdb when 128 bit registers are activated. */
+		MIPS_REG_T tmp = 0;
 
 		regs = task_pt_regs(child);
 		ret = 0;  /* Default return value. */
 
 		switch (addr) {
 		case 0 ... 31:
-			tmp = regs->regs[addr];
+			/* TBD: 128 bit support. */
+			tmp = MIPS_READ_REG(regs->regs[addr]);
 			break;
 		case FPR_BASE ... FPR_BASE + 31:
 			if (tsk_used_math(child)) {
@@ -361,7 +378,11 @@ long arch_ptrace(struct task_struct *chi
 			preempt_enable();
 			break;
 		}
+#ifdef CONFIG_CPU_R5900
+		case DSP_BASE ... DSP_BASE + 1: {
+#else
 		case DSP_BASE ... DSP_BASE + 5: {
+#endif
 			dspreg_t *dregs;
 
 			if (!cpu_has_dsp) {
@@ -373,6 +394,7 @@ long arch_ptrace(struct task_struct *chi
 			tmp = (unsigned long) (dregs[addr - DSP_BASE]);
 			break;
 		}
+#ifndef CONFIG_CPU_R5900
 		case DSP_CONTROL:
 			if (!cpu_has_dsp) {
 				tmp = 0;
@@ -381,6 +403,7 @@ long arch_ptrace(struct task_struct *chi
 			}
 			tmp = child->thread.dsp.dspcontrol;
 			break;
+#endif
 		default:
 			tmp = 0;
 			ret = -EIO;
@@ -403,7 +426,7 @@ long arch_ptrace(struct task_struct *chi
 
 		switch (addr) {
 		case 0 ... 31:
-			regs->regs[addr] = data;
+			MIPS_WRITE_REG(regs->regs[addr]) = data;
 			break;
 		case FPR_BASE ... FPR_BASE + 31: {
 			fpureg_t *fregs = get_fpu_regs(child);
@@ -450,7 +473,11 @@ long arch_ptrace(struct task_struct *chi
 		case FPC_CSR:
 			child->thread.fpu.fcr31 = data;
 			break;
+#ifdef CONFIG_CPU_R5900
+		case DSP_BASE ... DSP_BASE + 1: {
+#else
 		case DSP_BASE ... DSP_BASE + 5: {
+#endif
 			dspreg_t *dregs;
 
 			if (!cpu_has_dsp) {
@@ -462,6 +489,7 @@ long arch_ptrace(struct task_struct *chi
 			dregs[addr - DSP_BASE] = data;
 			break;
 		}
+#ifndef CONFIG_CPU_R5900
 		case DSP_CONTROL:
 			if (!cpu_has_dsp) {
 				ret = -EIO;
@@ -469,6 +497,7 @@ long arch_ptrace(struct task_struct *chi
 			}
 			child->thread.dsp.dspcontrol = data;
 			break;
+#endif
 		default:
 			/* The rest are not allowed. */
 			ret = -EIO;
diff -purN linux-2.6.35.4-orig/arch/mips/kernel/r5900_fpu.S linux-2.6.35.4/arch/mips/kernel/r5900_fpu.S
--- linux-2.6.35.4-orig/arch/mips/kernel/r5900_fpu.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/kernel/r5900_fpu.S	2014-07-18 22:29:43.542367724 +0200
@@ -0,0 +1,221 @@
+/*
+ *  FPU handling on MIPS r5900. Copied from r4k_fpu.c.
+ *
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <asm/asm.h>
+#include <asm/errno.h>
+#include <asm/fpregdef.h>
+#include <asm/mipsregs.h>
+#include <asm/asm-offsets.h>
+#include <asm/regdef.h>
+
+	.macro	EX insn, reg, src
+	.set	push
+	.set	nomacro
+	/* In an error exception handler the user space could be uncached. */
+	sync.l
+.ex\@:	\insn	\reg, \src
+	.set	pop
+	.section __ex_table,"a"
+	PTR	.ex\@, fault
+	.previous
+	.endm
+
+	.set	noreorder
+	.set	mips3
+
+LEAF(_save_fp_context)
+	cfc1	t1, fcr31
+
+	/* Store the 32 32-bit registers */
+	EX	swc1 $f0, SC_FPREGS+0(a0)
+	EX	swc1 $f1, SC_FPREGS+4(a0)
+	EX	swc1 $f2, SC_FPREGS+16(a0)
+	EX	swc1 $f3, SC_FPREGS+20(a0)
+	EX	swc1 $f4, SC_FPREGS+32(a0)
+	EX	swc1 $f5, SC_FPREGS+36(a0)
+	EX	swc1 $f6, SC_FPREGS+48(a0)
+	EX	swc1 $f7, SC_FPREGS+52(a0)
+	EX	swc1 $f8, SC_FPREGS+64(a0)
+	EX	swc1 $f9, SC_FPREGS+68(a0)
+	EX	swc1 $f10, SC_FPREGS+80(a0)
+	EX	swc1 $f11, SC_FPREGS+84(a0)
+	EX	swc1 $f12, SC_FPREGS+96(a0)
+	EX	swc1 $f13, SC_FPREGS+100(a0)
+	EX	swc1 $f14, SC_FPREGS+112(a0)
+	EX	swc1 $f15, SC_FPREGS+116(a0)
+	EX	swc1 $f16, SC_FPREGS+128(a0)
+	EX	swc1 $f17, SC_FPREGS+132(a0)
+	EX	swc1 $f18, SC_FPREGS+144(a0)
+	EX	swc1 $f19, SC_FPREGS+148(a0)
+	EX	swc1 $f20, SC_FPREGS+160(a0)
+	EX	swc1 $f21, SC_FPREGS+164(a0)
+	EX	swc1 $f22, SC_FPREGS+176(a0)
+	EX	swc1 $f23, SC_FPREGS+180(a0)
+	EX	swc1 $f24, SC_FPREGS+192(a0)
+	EX	swc1 $f25, SC_FPREGS+196(a0)
+	EX	swc1 $f26, SC_FPREGS+208(a0)
+	EX	swc1 $f27, SC_FPREGS+212(a0)
+	EX	swc1 $f28, SC_FPREGS+224(a0)
+	EX	swc1 $f29, SC_FPREGS+228(a0)
+	EX	swc1 $f30, SC_FPREGS+240(a0)
+	EX	swc1 $f31, SC_FPREGS+244(a0)
+	EX	sw t1, SC_FPC_CSR(a0)
+	jr	ra
+	 li	v0, 0					# success
+	END(_save_fp_context)
+
+#ifdef CONFIG_MIPS32_COMPAT
+	/* Save 32-bit process floating point context */
+LEAF(_save_fp_context32)
+	cfc1	t1, fcr31
+
+	EX	swc1 $f0, SC32_FPREGS+0(a0)
+	EX	swc1 $f1, SC32_FPREGS+4(a0)
+	EX	swc1 $f2, SC32_FPREGS+16(a0)
+	EX	swc1 $f3, SC32_FPREGS+20(a0)
+	EX	swc1 $f4, SC32_FPREGS+32(a0)
+	EX	swc1 $f5, SC32_FPREGS+36(a0)
+	EX	swc1 $f6, SC32_FPREGS+48(a0)
+	EX	swc1 $f7, SC32_FPREGS+52(a0)
+	EX	swc1 $f8, SC32_FPREGS+64(a0)
+	EX	swc1 $f9, SC32_FPREGS+68(a0)
+	EX	swc1 $f10, SC32_FPREGS+80(a0)
+	EX	swc1 $f11, SC32_FPREGS+84(a0)
+	EX	swc1 $f12, SC32_FPREGS+96(a0)
+	EX	swc1 $f13, SC32_FPREGS+100(a0)
+	EX	swc1 $f14, SC32_FPREGS+112(a0)
+	EX	swc1 $f15, SC32_FPREGS+116(a0)
+	EX	swc1 $f16, SC32_FPREGS+128(a0)
+	EX	swc1 $f17, SC32_FPREGS+132(a0)
+	EX	swc1 $f18, SC32_FPREGS+144(a0)
+	EX	swc1 $f19, SC32_FPREGS+148(a0)
+	EX	swc1 $f20, SC32_FPREGS+160(a0)
+	EX	swc1 $f21, SC32_FPREGS+164(a0)
+	EX	swc1 $f22, SC32_FPREGS+176(a0)
+	EX	swc1 $f23, SC32_FPREGS+180(a0)
+	EX	swc1 $f24, SC32_FPREGS+192(a0)
+	EX	swc1 $f25, SC32_FPREGS+196(a0)
+	EX	swc1 $f26, SC32_FPREGS+208(a0)
+	EX	swc1 $f27, SC32_FPREGS+212(a0)
+	EX	swc1 $f28, SC32_FPREGS+224(a0)
+	EX	swc1 $f29, SC32_FPREGS+228(a0)
+	EX	swc1 $f30, SC32_FPREGS+240(a0)
+	EX	swc1 $f31, SC32_FPREGS+244(a0)
+	EX	sw t1, SC32_FPC_CSR(a0)
+	cfc1	t0, $0				# implementation/version
+	EX	sw t0, SC32_FPC_EIR(a0)
+
+	jr	ra
+	 li	v0, 0					# success
+	END(_save_fp_context32)
+#endif
+
+/*
+ * Restore FPU state:
+ *  - fp gp registers
+ *  - cp1 status/control register
+ */
+LEAF(_restore_fp_context)
+	EX	lw t0, SC_FPC_CSR(a0)
+	EX	lwc1 $f0, SC_FPREGS+0(a0)
+	EX	lwc1 $f1, SC_FPREGS+4(a0)
+	EX	lwc1 $f2, SC_FPREGS+16(a0)
+	EX	lwc1 $f3, SC_FPREGS+20(a0)
+	EX	lwc1 $f4, SC_FPREGS+32(a0)
+	EX	lwc1 $f5, SC_FPREGS+36(a0)
+	EX	lwc1 $f6, SC_FPREGS+48(a0)
+	EX	lwc1 $f7, SC_FPREGS+52(a0)
+	EX	lwc1 $f8, SC_FPREGS+64(a0)
+	EX	lwc1 $f9, SC_FPREGS+68(a0)
+	EX	lwc1 $f10, SC_FPREGS+80(a0)
+	EX	lwc1 $f11, SC_FPREGS+84(a0)
+	EX	lwc1 $f12, SC_FPREGS+96(a0)
+	EX	lwc1 $f13, SC_FPREGS+100(a0)
+	EX	lwc1 $f14, SC_FPREGS+112(a0)
+	EX	lwc1 $f15, SC_FPREGS+116(a0)
+	EX	lwc1 $f16, SC_FPREGS+128(a0)
+	EX	lwc1 $f17, SC_FPREGS+132(a0)
+	EX	lwc1 $f18, SC_FPREGS+144(a0)
+	EX	lwc1 $f19, SC_FPREGS+148(a0)
+	EX	lwc1 $f20, SC_FPREGS+160(a0)
+	EX	lwc1 $f21, SC_FPREGS+164(a0)
+	EX	lwc1 $f22, SC_FPREGS+176(a0)
+	EX	lwc1 $f23, SC_FPREGS+180(a0)
+	EX	lwc1 $f24, SC_FPREGS+192(a0)
+	EX	lwc1 $f25, SC_FPREGS+196(a0)
+	EX	lwc1 $f26, SC_FPREGS+208(a0)
+	EX	lwc1 $f27, SC_FPREGS+212(a0)
+	EX	lwc1 $f28, SC_FPREGS+224(a0)
+	EX	lwc1 $f29, SC_FPREGS+228(a0)
+	EX	lwc1 $f30, SC_FPREGS+240(a0)
+	EX	lwc1 $f31, SC_FPREGS+244(a0)
+	ctc1	t0, fcr31
+	jr	ra
+	 li	v0, 0					# success
+	END(_restore_fp_context)
+
+#ifdef CONFIG_MIPS32_COMPAT
+LEAF(_restore_fp_context32)
+	/* Restore an o32 sigcontext.  */
+	EX	lw t0, SC32_FPC_CSR(a0)
+	EX	lwc1 $f0, SC32_FPREGS+0(a0)
+	EX	lwc1 $f1, SC32_FPREGS+4(a0)
+	EX	lwc1 $f2, SC32_FPREGS+16(a0)
+	EX	lwc1 $f3, SC32_FPREGS+20(a0)
+	EX	lwc1 $f4, SC32_FPREGS+32(a0)
+	EX	lwc1 $f5, SC32_FPREGS+36(a0)
+	EX	lwc1 $f6, SC32_FPREGS+48(a0)
+	EX	lwc1 $f7, SC32_FPREGS+52(a0)
+	EX	lwc1 $f8, SC32_FPREGS+64(a0)
+	EX	lwc1 $f9, SC32_FPREGS+68(a0)
+	EX	lwc1 $f10, SC32_FPREGS+80(a0)
+	EX	lwc1 $f11, SC32_FPREGS+84(a0)
+	EX	lwc1 $f12, SC32_FPREGS+96(a0)
+	EX	lwc1 $f13, SC32_FPREGS+100(a0)
+	EX	lwc1 $f14, SC32_FPREGS+112(a0)
+	EX	lwc1 $f15, SC32_FPREGS+116(a0)
+	EX	lwc1 $f16, SC32_FPREGS+128(a0)
+	EX	lwc1 $f17, SC32_FPREGS+132(a0)
+	EX	lwc1 $f18, SC32_FPREGS+144(a0)
+	EX	lwc1 $f19, SC32_FPREGS+148(a0)
+	EX	lwc1 $f20, SC32_FPREGS+160(a0)
+	EX	lwc1 $f21, SC32_FPREGS+164(a0)
+	EX	lwc1 $f22, SC32_FPREGS+176(a0)
+	EX	lwc1 $f23, SC32_FPREGS+180(a0)
+	EX	lwc1 $f24, SC32_FPREGS+192(a0)
+	EX	lwc1 $f25, SC32_FPREGS+196(a0)
+	EX	lwc1 $f26, SC32_FPREGS+208(a0)
+	EX	lwc1 $f27, SC32_FPREGS+212(a0)
+	EX	lwc1 $f28, SC32_FPREGS+224(a0)
+	EX	lwc1 $f29, SC32_FPREGS+228(a0)
+	EX	lwc1 $f30, SC32_FPREGS+240(a0)
+	EX	lwc1 $f31, SC32_FPREGS+244(a0)
+	ctc1	t0, fcr31
+	jr	ra
+	 li	v0, 0					# success
+	END(_restore_fp_context32)
+#endif
+
+	.set	reorder
+
+	.type	fault@function
+	.ent	fault
+fault:	li	v0, -EFAULT				# failure
+	jr	ra
+	.end	fault
diff -purN linux-2.6.35.4-orig/arch/mips/kernel/r5900_switch.S linux-2.6.35.4/arch/mips/kernel/r5900_switch.S
--- linux-2.6.35.4-orig/arch/mips/kernel/r5900_switch.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/kernel/r5900_switch.S	2014-07-18 22:29:43.542367724 +0200
@@ -0,0 +1,228 @@
+/*
+ *  Context switch on MIPS r5900. Copied from r4k_switch.c.
+ *
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <asm/asm.h>
+#include <asm/cachectl.h>
+#include <asm/fpregdef.h>
+#include <asm/mipsregs.h>
+#include <asm/asm-offsets.h>
+#include <asm/page.h>
+#include <asm/pgtable-bits.h>
+#include <asm/regdef.h>
+#include <asm/stackframe.h>
+#include <asm/thread_info.h>
+
+#include <asm/asmmacro.h>
+
+/*
+ * Offset to the current process status flags, the first 32 bytes of the
+ * stack are not used.
+ */
+#define ST_OFF (_THREAD_SIZE - 32 - PT_SIZE + PT_STATUS)
+
+/*
+ * FPU context is saved iff the process has used it's FPU in the current
+ * time slice as indicated by _TIF_USEDFPU.  In any case, the CU1 bit for user
+ * space STATUS register should be 0, so that a process *always* starts its
+ * userland with FPU disabled after each context switch.
+ *
+ * FPU will be enabled as soon as the process accesses FPU again, through
+ * do_cpu() trap.
+ */
+
+/*
+ * task_struct *resume(task_struct *prev, task_struct *next,
+ *                     struct thread_info *next_ti)
+ */
+	.align	5
+	LEAF(resume)
+	sync.p
+	mfc0	t1, CP0_STATUS
+	LONGI_S	t1, THREAD_STATUS(a0)
+	cpu_save_nonscratch a0
+	LONGD_S	ra, THREAD_REG31(a0)
+
+	/*
+	 * check if we need to save FPU registers
+	 */
+	PTR_L	t3, TASK_THREAD_INFO(a0)
+	LONGI_L	t0, TI_FLAGS(t3)
+	li	t1, _TIF_USEDFPU
+	and	t2, t0, t1
+	beqz	t2, 1f
+	nor	t1, zero, t1
+
+	and	t0, t0, t1
+	LONGI_S	t0, TI_FLAGS(t3)
+
+	/*
+	 * clear saved user stack CU1 bit
+	 */
+	LONGI_L	t0, ST_OFF(t3)
+	li	t1, ~ST0_CU1
+	and	t0, t0, t1
+	LONGI_S	t0, ST_OFF(t3)
+
+	fpu_save_double a0 t0 t1		# c0_status passed in t0
+						# clobbers t1
+1:
+
+	/*
+	 * The order of restoring the registers takes care of the race
+	 * updating $28, $29 and kernelsp without disabling ints.
+	 */
+	move	$28, a2
+	cpu_restore_nonscratch a1
+
+	PTR_ADDU	t0, $28, _THREAD_SIZE - 32
+	set_saved_sp	t0, t1, t2
+#ifdef CONFIG_MIPS_MT_SMTC
+	/* Read-modify-writes of Status must be atomic on a VPE */
+	sync.p
+	mfc0	t2, CP0_TCSTATUS
+	ori	t1, t2, TCSTATUS_IXMT
+	mtc0	t1, CP0_TCSTATUS
+	sync.p
+	andi	t2, t2, TCSTATUS_IXMT
+	_ehb
+	DMT	8				# dmt	t0
+	move	t1,ra
+	jal	mips_ihb
+	move	ra,t1
+#endif /* CONFIG_MIPS_MT_SMTC */
+	sync.p
+	mfc0	t1, CP0_STATUS		/* Do we really need this? */
+	li	a3, 0xff01
+	and	t1, a3
+	LONGI_L	a2, THREAD_STATUS(a1)
+	nor	a3, $0, a3
+	and	a2, a3
+	or	a2, t1
+	mtc0	a2, CP0_STATUS
+	sync.p
+#ifdef CONFIG_MIPS_MT_SMTC
+	_ehb
+	andi	t0, t0, VPECONTROL_TE
+	beqz	t0, 1f
+	emt
+1:
+	sync.p
+	mfc0	t1, CP0_TCSTATUS
+	xori	t1, t1, TCSTATUS_IXMT
+	or	t1, t1, t2
+	mtc0	t1, CP0_TCSTATUS
+	sync.p
+	_ehb
+#endif /* CONFIG_MIPS_MT_SMTC */
+	move	v0, a0
+	jr	ra
+	END(resume)
+
+/*
+ * Save a thread's fp context.
+ */
+LEAF(_save_fp)
+#ifdef CONFIG_64BIT
+	sync.p
+	mfc0	t0, CP0_STATUS
+#endif
+	fpu_save_double a0 t0 t1		# clobbers t1
+	jr	ra
+	END(_save_fp)
+
+/*
+ * Restore a thread's fp context.
+ */
+LEAF(_restore_fp)
+#ifdef CONFIG_64BIT
+	sync.p
+	mfc0	t0, CP0_STATUS
+#endif
+	fpu_restore_double a0 t0 t1		# clobbers t1
+	jr	ra
+	END(_restore_fp)
+
+/*
+ * Load the FPU with signalling NANS.  This bit pattern we're using has
+ * the property that no matter whether considered as single or as double
+ * precision represents signaling NANS.
+ *
+ * We initialize fcr31 to rounding to nearest, no exceptions.
+ */
+
+#define FPU_DEFAULT  0x00000000
+
+LEAF(_init_fpu)
+#ifdef CONFIG_MIPS_MT_SMTC
+	/* Rather than manipulate per-VPE Status, set per-TC bit in TCStatus */
+	sync.p
+	mfc0	t0, CP0_TCSTATUS
+	/* Bit position is the same for Status, TCStatus */
+	li	t1, ST0_CU1
+	or	t0, t1
+	mtc0	t0, CP0_TCSTATUS
+	sync.p
+#else /* Normal MIPS CU1 enable */
+	sync.p
+	mfc0	t0, CP0_STATUS
+	li	t1, ST0_CU1
+	or	t0, t1
+	mtc0	t0, CP0_STATUS
+	sync.p
+#endif /* CONFIG_MIPS_MT_SMTC */
+	enable_fpu_hazard
+
+	li	t1, FPU_DEFAULT
+	ctc1	t1, fcr31
+
+	li	t1, -1				# SNaN
+
+	mtc1	t1, $f0
+	mtc1	t1, $f1
+	mtc1	t1, $f2
+	mtc1	t1, $f3
+	mtc1	t1, $f4
+	mtc1	t1, $f5
+	mtc1	t1, $f6
+	mtc1	t1, $f7
+	mtc1	t1, $f8
+	mtc1	t1, $f9
+	mtc1	t1, $f10
+	mtc1	t1, $f11
+	mtc1	t1, $f12
+	mtc1	t1, $f13
+	mtc1	t1, $f14
+	mtc1	t1, $f15
+	mtc1	t1, $f16
+	mtc1	t1, $f17
+	mtc1	t1, $f18
+	mtc1	t1, $f19
+	mtc1	t1, $f20
+	mtc1	t1, $f21
+	mtc1	t1, $f22
+	mtc1	t1, $f23
+	mtc1	t1, $f24
+	mtc1	t1, $f25
+	mtc1	t1, $f26
+	mtc1	t1, $f27
+	mtc1	t1, $f28
+	mtc1	t1, $f29
+	mtc1	t1, $f30
+	mtc1	t1, $f31
+	jr	ra
+	END(_init_fpu)
diff -purN linux-2.6.35.4-orig/arch/mips/kernel/scall32-n32.S linux-2.6.35.4/arch/mips/kernel/scall32-n32.S
--- linux-2.6.35.4-orig/arch/mips/kernel/scall32-n32.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/kernel/scall32-n32.S	2014-07-18 22:29:43.542367724 +0200
@@ -0,0 +1,478 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1995, 96, 97, 98, 99, 2000, 01 by Ralf Baechle
+ * Copyright (C) 1999, 2000 Silicon Graphics, Inc.
+ * Copyright (C) 2001 MIPS Technologies, Inc.
+ * Copyright (C) 2012-2013 Juergen Urban
+ */
+
+#include <linux/errno.h>
+#include <asm/asm.h>
+#include <asm/asmmacro.h>
+#include <asm/irqflags.h>
+#include <asm/mipsregs.h>
+#include <asm/regdef.h>
+#include <asm/stackframe.h>
+#include <asm/thread_info.h>
+#include <asm/unistd.h>
+
+/* MIPS ABI N32 register names are different to O32. */
+/* Register t0, t1, t2 and t3 should not be used, use t4, t5, t6 and t7 instead. */
+#define a4 t0
+#define a5 t1
+#define a6 t2
+#define a7 t3
+
+
+/* This duplicates the definition from <linux/sched.h> */
+#define PT_TRACESYS	0x00000002	/* tracing system calls */
+
+/* This duplicates the definition from <asm/signal.h> */
+#define SIGILL		4		/* Illegal instruction (ANSI).  */
+
+	.set push
+	.set arch=r5900
+
+	.align  5
+NESTED(handle_sys, PT_SIZE, sp)
+	.set	noat
+#ifdef CONFIG_CPU_R5900
+	nop
+	nop
+#endif
+	SAVE_SOME
+	SAVE_AT
+	SAVE_TEMP			# This will be restored in syscall_exit and n32_syscall_exit.
+	SAVE_STATIC
+					# N32 callers expect a4/t0 to be saved.
+	TRACE_IRQS_ON_RELOAD		# Caution: This can overwrite a4/t0.
+	STI				# Caution: This overwrites a4/t0.
+	.set	at
+
+	dsubu	t4, v0, __NR_N32_Linux	# check syscall number
+	sltiu	t6, t4,	__NR_N32_Linux_syscalls + 1
+
+	ld	t5, PT_EPC(sp)		# skip syscall on return
+	daddiu	t5, 4			# skip to next instruction
+	sd	t5, PT_EPC(sp)
+	beqz	t6, not_n32_scall
+
+	dsll	t4, t4, 3		# offset into table
+	la	t5, sysn32_call_table	# Syscall table address
+	addu	t4, t5
+	lw	t6, 0(t4)		# pointer to syscall function
+	lw	t7, 4(t4)		# >= 0 if we need stack arguments
+
+	sd	a3, PT_R26(sp)		# save a3 for syscall restarting
+	bgez	t7, stackargs
+
+stack_done:
+	li	t5, _TIF_SYSCALL_TRACE | _TIF_SYSCALL_AUDIT
+	LONGI_L	t4, TI_FLAGS($28)	# syscall tracing enabled?
+	and	t4, t5, t4
+	bnez	t4, n32_syscall_trace_entry
+
+	jalr	t6			# Do The Real Thing (TM)
+
+	li	t4, -EMAXERRNO - 1	# error?
+	sltu	t4, t4, v0
+	sd	t4, PT_R7(sp)		# set error flag
+	beqz	t4, 1f
+
+	dnegu	v0			# error
+	sd	v0, PT_R0(sp)		# set flag for syscall restarting
+1:	sd	v0, PT_R2(sp)		# result
+
+.global n32_syscall_exit
+n32_syscall_exit:
+	local_irq_disable		# make sure need_resched and
+					# signals dont change between
+					# sampling and return
+	LONGI_L  a2, TI_FLAGS($28)	# current->work
+	li	t4, _TIF_ALLWORK_MASK
+	and	t4, a2, t4
+	bnez	t4, n32_syscall_exit_work
+
+	j	restore_all
+
+n32_syscall_exit_work:
+	RESTORE_STATIC
+	j	syscall_exit_work_partial
+
+/* ------------------------------------------------------------------------ */
+
+n32_syscall_trace_entry:
+	move	s0, t6
+	move	a0, sp
+	li	a1, 0
+	jal	do_syscall_trace
+
+	move	t4, s0
+	RESTORE_STATIC
+	ld	a0, PT_R4(sp)		# Restore argument registers
+	ld	a1, PT_R5(sp)
+	ld	a2, PT_R6(sp)
+	ld	a3, PT_R7(sp)
+	jalr	t4
+
+	li	t4, -EMAXERRNO - 1	# error?
+	sltu	t4, t4, v0
+	sd	t4, PT_R7(sp)		# set error flag
+	beqz	t4, 1f
+
+	dnegu	v0			# error
+	sd	v0, PT_R0(sp)		# set flag for syscall restarting
+1:	sd	v0, PT_R2(sp)		# result
+
+	j	syscall_exit
+
+/* ------------------------------------------------------------------------ */
+
+	/*
+	 * More than four arguments. Try to deal with it by copying the
+	 * stack arguments from the registers (ABI N32) to the kernel stack (ABI O32).
+	 */
+stackargs:
+	/* Ok, copy the args from the register to the kernel stack.
+	 * t7 is the precomputed number of instruction bytes needed to
+	 * load or store arguments 6-8.
+	 */
+	LONGD_L	a4, PT_R8(sp)
+	la	t5, 1f			# load up to 3 arguments
+	subu	t5, t7
+	sw	a4, 16(sp)		# argument #5 to ksp
+	jr	t5			# Jump to label 1f if t7 is 0 (5 arguments).
+
+	.set    push
+	.set    noreorder
+	.set	nomacro
+	LONGD_L	a7, PT_R11(sp)
+	sw	a7, 28(sp)		# argument #8 to ksp
+	LONGD_L	a6, PT_R10(sp)
+	sw	a6, 24(sp)		# argument #7 to ksp
+	LONGD_L	a5, PT_R9(sp)
+	sw	a5, 20(sp)		# argument #6 to ksp
+1:
+	j	stack_done		# go back
+	 nop
+	.set	pop
+
+not_n32_scall:
+	/* This is not an n32 compatibility syscall, pass it on to
+	   the o32 syscall handlers.  */
+	j	handle_sys32
+
+	END(handle_sys)
+
+	.macro  sys function, nargs
+	PTR	\function
+	LONG	(\nargs << 3) - (5 << 3)
+	.endm
+
+EXPORT(sysn32_call_table)
+	sys	sys_read		3	/* 6000 */
+	sys	sys_write		3
+	sys	sys_open		3
+	sys	sys_close		1
+	sys	sys_stat64		2
+	sys	sys_fstat64		2	/* 6005 */
+	sys	sys_lstat64		2
+	sys	sys_poll		3
+	sys	syso64_lseek		0
+	sys	sysn32_mips_mmap	0
+	sys	sys_mprotect		3	/* 6010 */
+	sys	sys_munmap		2
+	sys	sys_brk			1
+	sys	sys_rt_sigaction	4
+	sys	sys_rt_sigprocmask	4
+	sys	sys_ioctl		3	/* 6015 */
+	sys	sysn32_pread64		0
+	sys	sysn32_pwrite64		0
+	sys	sys_readv		3
+	sys	sys_writev		3
+	sys	sys_access		2	/* 6020 */
+	sys	sysm_pipe		0
+	sys	sys_select		5
+	sys	sys_sched_yield		0
+	sys	sys_mremap		5
+	sys	sys_msync		3	/* 6025 */
+	sys	sys_mincore		3
+	sys	sys_madvise		3
+	sys	sys_shmget		3
+	sys	sys_shmat		3
+	sys	sys_shmctl		3	/* 6030 */
+	sys	sys_dup			1
+	sys	sys_dup2		2
+	sys	sys_pause		0
+	sys	sys_nanosleep		2
+	sys	sys_getitimer		2	/* 6035 */
+	sys	sys_setitimer		3
+	sys	sys_alarm		1
+	sys	sys_getpid		0
+	sys	sys_sendfile		4
+	sys	sys_socket		3	/* 6040 */
+	sys	sys_connect		3
+	sys	sys_accept		3
+	sys	sys_sendto		6
+	sys	sys_recvfrom		6
+	sys	sys_sendmsg		3	/* 6045 */
+	sys	sys_recvmsg		3
+	sys	sys_shutdown		2
+	sys	sys_bind		3
+	sys	sys_listen		2
+	sys	sys_getsockname		3	/* 6050 */
+	sys	sys_getpeername		3
+	sys	sys_socketpair		4
+	sys	sys_setsockopt		5
+	sys	sys_getsockopt		5
+	sys	sysn32_clone		0	/* 6055 */
+	sys	sys_fork		0
+	sys	sys_execve		0
+	sys	sys_exit		1
+	sys	sys_wait4		4
+	sys	sys_kill		2	/* 6060 */
+	sys	sys_newuname		1
+	sys	sys_semget		3
+	sys	sys_semop		3
+	sys	sys_semctl		4
+	sys	sys_shmdt		1	/* 6065 */
+	sys	sys_msgget		2
+	sys	sys_msgsnd		4
+	sys	sys_msgrcv		5
+	sys	sys_msgctl		3
+	sys	sys_fcntl		3	/* 6070 */
+	sys	sys_flock		2
+	sys	sys_fsync		1
+	sys	sys_fdatasync		1
+	sys	sys_truncate		2
+	sys	sys_ftruncate		2	/* 6075 */
+	sys	sys_getdents		3
+	sys	sys_getcwd		2
+	sys	sys_chdir		1
+	sys	sys_fchdir		1
+	sys	sys_rename		2	/* 6080 */
+	sys	sys_mkdir		2
+	sys	sys_rmdir		1
+	sys	sys_creat		2
+	sys	sys_link		2
+	sys	sys_unlink		1	/* 6085 */
+	sys	sys_symlink		2
+	sys	sys_readlink		3
+	sys	sys_chmod		2
+	sys	sys_fchmod		2
+	sys	sys_chown		3	/* 6090 */
+	sys	sys_fchown		3
+	sys	sys_lchown		3
+	sys	sys_umask		1
+	sys	sys_gettimeofday	2
+	sys	sys_getrlimit		2	/* 6095 */
+	sys	sys_getrusage		2
+	sys	sys_sysinfo		1
+	sys	sys_times		1
+	sys	sys_ptrace		4
+	sys	sys_getuid		0	/* 6100 */
+	sys	sys_syslog		3
+	sys	sys_getgid		0
+	sys	sys_setuid		1
+	sys	sys_setgid		1
+	sys	sys_geteuid		0	/* 6105 */
+	sys	sys_getegid		0
+	sys	sys_setpgid		2
+	sys	sys_getppid		0
+	sys	sys_getpgrp		0
+	sys	sys_setsid		0	/* 6110 */
+	sys	sys_setreuid		2
+	sys	sys_setregid		2
+	sys	sys_getgroups		2
+	sys	sys_setgroups		2
+	sys	sys_setresuid		3	/* 6115 */
+	sys	sys_getresuid		3
+	sys	sys_setresgid		3
+	sys	sys_getresgid		3
+	sys	sys_getpgid		1
+	sys	sys_setfsuid		1	/* 6120 */
+	sys	sys_setfsgid		1
+	sys	sys_getsid		1
+	sys	sys_capget		2
+	sys	sys_capset		2
+	sys	sys_rt_sigpending	2	/* 6125 */
+	sys	sys_rt_sigtimedwait	4
+	sys	sys_rt_sigqueueinfo	3
+	sys	sys_rt_sigsuspend	0
+	sys	sys_sigaltstack		0
+	sys	sys_utime		2	/* 6130 */
+	sys	sys_mknod		3
+	sys	sys_personality		1
+	sys	sys_ustat		2
+	sys	sys_statfs		2
+	sys	sys_fstatfs		2	/* 6135 */
+	sys	sys_sysfs		3
+	sys	sys_getpriority		2
+	sys	sys_setpriority		3
+	sys	sys_sched_setparam	2
+	sys	sys_sched_getparam	2	/* 6140 */
+	sys	sys_sched_setscheduler	3
+	sys	sys_sched_getscheduler	1
+	sys	sys_sched_get_priority_max	1
+	sys	sys_sched_get_priority_min	1
+	sys	sys_sched_rr_get_interval	2	/* 6145 */
+	sys	sys_mlock		2
+	sys	sys_munlock		2
+	sys	sys_mlockall		1
+	sys	sys_munlockall		0
+	sys	sys_vhangup		0	/* 6150 */
+	sys	sys_pivot_root		2
+	sys	sys_sysctl		1
+	sys	sys_prctl		5
+	sys	sys_adjtimex		1
+	sys	sys_setrlimit		2	/* 6155 */
+	sys	sys_chroot		1
+	sys	sys_sync		0
+	sys	sys_acct		1
+	sys	sys_settimeofday	2
+	sys	sys_mount		5	/* 6160 */
+	sys	sys_umount		2
+	sys	sys_swapon		2
+	sys	sys_swapoff		1
+	sys	sys_reboot		3
+	sys	sys_sethostname		2	/* 6165 */
+	sys	sys_setdomainname	2
+	sys	sys_ni_syscall		0	/* was create_module */
+	sys	sys_init_module		5
+	sys	sys_delete_module	1
+	sys	sys_ni_syscall		0	/* 6170, was get_kernel_syms */
+	sys	sys_ni_syscall		0	/* was query_module */
+	sys	sys_quotactl		4
+	sys	sys_nfsservctl		3
+	sys	sys_ni_syscall		0	/* res. for getpmsg */
+	sys	sys_ni_syscall		0	/* 6175  for putpmsg */
+	sys	sys_ni_syscall		0	/* res. for afs_syscall */
+	sys	sys_ni_syscall		0	/* res. for security */
+	sys	sys_gettid		0
+	sys	sysn32_readahead	0
+	sys	sys_setxattr		5	/* 6180 */
+	sys	sys_lsetxattr		5
+	sys	sys_fsetxattr		5
+	sys	sys_getxattr		4
+	sys	sys_lgetxattr		4
+	sys	sys_fgetxattr		4	/* 6185 */
+	sys	sys_listxattr		3
+	sys	sys_llistxattr		3
+	sys	sys_flistxattr		3
+	sys	sys_removexattr		2
+	sys	sys_lremovexattr	2	/* 6190 */
+	sys	sys_fremovexattr	2
+	sys	sys_tkill		2
+	sys	sys_ni_syscall		0
+	sys	sys_futex		6
+	sys	sys_sched_setaffinity	3	/* 6195 */
+	sys	sys_sched_getaffinity	3
+	sys	sys_cacheflush		3
+	sys	sys_cachectl		3
+	sys	sys_sysmips		4
+	sys	sys_io_setup		2	/* 6200 */
+	sys	sys_io_destroy		1
+	sys	sys_io_getevents	5
+	sys	sys_io_submit		3
+	sys	sys_io_cancel		3
+	sys	sys_exit_group		1	/* 6205 */
+	sys	sysn32_lookup_dcookie	0
+	sys	sys_epoll_create	1
+	sys	sys_epoll_ctl		4
+	sys	sys_epoll_wait		3
+	sys	sys_remap_file_pages	5	/* 6210 TBD: pgoff, is this a file offset. If yes, it can be larger than 32 bit. */
+	sys	sys_rt_sigreturn	0
+	sys	sys_fcntl64		3
+	sys	sys_set_tid_address	1
+	sys	sys_restart_syscall	0
+	sys	sys_semtimedop		4	/* 6215 */
+	sys	sysn32_fadvise64_64	0
+	sys	sys_statfs64		3
+	sys	sys_fstatfs64		2
+	sys	sys_sendfile64		5
+	sys	sys_timer_create	3	/* 6220 */
+	sys	sys_timer_settime	4
+	sys	sys_timer_gettime	2
+	sys	sys_timer_getoverrun	1
+	sys	sys_timer_delete	1
+	sys	sys_clock_settime	2	/* 6225 */
+	sys	sys_clock_gettime	2
+	sys	sys_clock_getres	2
+	sys	sys_clock_nanosleep	4
+	sys	sys_tgkill		3
+	sys	sys_utimes		2	/* 6230 */
+	sys	sys_ni_syscall		0	/* sys_mbind */
+	sys	sys_ni_syscall		0	/* sys_get_mempolicy */
+	sys	sys_ni_syscall		0	/* sys_set_mempolicy */
+	sys	sys_mq_open		4
+	sys	sys_mq_unlink		1	/* 6235 */
+	sys	sys_mq_timedsend	5
+	sys	sys_mq_timedreceive	5
+	sys	sys_mq_notify		2
+	sys	sys_mq_getsetattr	3
+	sys	sys_ni_syscall		0	/* 6240, sys_vserver */
+	sys	sys_waitid		5
+	sys	sys_ni_syscall		0	/* available, was setaltroot */
+	sys	sys_add_key		5
+	sys	sys_request_key		4
+	sys	sys_keyctl		5	/* 6245 */
+	sys	sys_set_thread_area	1
+	sys	sys_inotify_init	0
+	sys	sys_inotify_add_watch	3
+	sys	sys_inotify_rm_watch	2
+	sys	sys_migrate_pages	4	/* 6250 */
+	sys	sys_openat		4
+	sys	sys_mkdirat		3
+	sys	sys_mknodat		4
+	sys	sys_fchownat		5
+	sys	sys_futimesat		3	/* 6255 */
+	sys	sys_fstatat64		4
+	sys	sys_unlinkat		3
+	sys	sys_renameat		4
+	sys	sys_linkat		5
+	sys	sys_symlinkat		3	/* 6260 */
+	sys	sys_readlinkat		4
+	sys	sys_fchmodat		3
+	sys	sys_faccessat		3
+	sys	sys_pselect6		6
+	sys	sys_ppoll		5	/* 6265 */
+	sys	sys_unshare		1
+	sys	sys_splice		6
+	sys	sysn32_sync_file_range	0
+	sys	sys_tee			4
+	sys	sys_vmsplice		4	/* 6270 */
+	sys	sys_move_pages		6
+	sys	sys_set_robust_list	2
+	sys	sys_get_robust_list	3
+	sys	sys_kexec_load		4
+	sys	sys_getcpu		3	/* 6275 */
+	sys	sys_epoll_pwait		6
+	sys	sys_ioprio_set		3
+	sys	sys_ioprio_get		2
+	sys	sys_utimensat		4
+	sys	sys_signalfd		3	/* 6280 */
+	sys	sys_ni_syscall		0
+	sys	sys_eventfd		1
+	sys	sysn32_fallocate	0
+	sys	sys_timerfd_create	2
+	sys	sys_timerfd_gettime	2	/* 6285 */
+	sys	sys_timerfd_settime	4
+	sys	sys_signalfd4		4
+	sys	sys_eventfd2		2
+	sys	sys_epoll_create1	1
+	sys	sys_dup3		3	/* 6290 */
+	sys	sys_pipe2		2
+	sys	sys_inotify_init1	1
+	sys	sys_preadv		6
+	sys	sys_pwritev		6
+	sys	sys_rt_tgsigqueueinfo	4	/* 6295 */
+	sys	sys_perf_event_open	5
+	sys	sys_accept4		4
+	sys     sys_recvmmsg		5
+	sys     sys_getdents64		3
+	.size	sysn32_call_table,.-sysn32_call_table
+
+	.set pop
diff -purN linux-2.6.35.4-orig/arch/mips/kernel/scall32-o32.S linux-2.6.35.4/arch/mips/kernel/scall32-o32.S
--- linux-2.6.35.4-orig/arch/mips/kernel/scall32-o32.S	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/kernel/scall32-o32.S	2014-07-18 22:29:43.542367724 +0200
@@ -24,20 +24,33 @@
 /* Highest syscall used of any syscall flavour */
 #define MAX_SYSCALL_NO	__NR_O32_Linux + __NR_O32_Linux_syscalls
 
+#ifdef CONFIG_MIPS_N32
+/* There is already an n32 syscall handler installed. */
+#define handle_sys handle_sys32
+#endif
+
+
 	.align  5
 NESTED(handle_sys, PT_SIZE, sp)
+#ifndef CONFIG_MIPS_N32
 	.set	noat
+#ifdef CONFIG_CPU_R5900
+	nop
+	nop
+#endif
 	SAVE_SOME
 	TRACE_IRQS_ON_RELOAD
 	STI
 	.set	at
-
-	lw	t1, PT_EPC(sp)		# skip syscall on return
+#endif
 
 	subu	v0, v0, __NR_O32_Linux	# check syscall number
 	sltiu	t0, v0, __NR_O32_Linux_syscalls + 1
+#ifndef CONFIG_MIPS_N32
+	lw	t1, PT_EPC(sp)		# skip syscall on return
 	addiu	t1, 4			# skip to next instruction
 	sw	t1, PT_EPC(sp)
+#endif
 	beqz	t0, illegal_syscall
 
 	sll	t0, v0, 3
@@ -47,7 +60,7 @@ NESTED(handle_sys, PT_SIZE, sp)
 	lw	t3, 4(t1)		# >= 0 if we need stack arguments
 	beqz	t2, illegal_syscall
 
-	sw	a3, PT_R26(sp)		# save a3 for syscall restarting
+	LONGD_S	a3, PT_R26(sp)		# save a3 for syscall restarting
 	bgez	t3, stackargs
 
 stack_done:
@@ -56,17 +69,25 @@ stack_done:
 	and	t0, t1
 	bnez	t0, syscall_trace_entry	# -> yes
 
+#ifdef CONFIG_R5900_128BIT_SUPPORT
+	SAVE_STATIC
+#endif
+
 	jalr	t2			# Do The Real Thing (TM)
 
+#ifdef CONFIG_R5900_128BIT_SUPPORT
+	RESTORE_STATIC
+#endif
+
 	li	t0, -EMAXERRNO - 1	# error?
 	sltu	t0, t0, v0
-	sw	t0, PT_R7(sp)		# set error flag
+	LONGH_S	t0, PT_R7(sp)		# set error flag
 	beqz	t0, 1f
 
 	negu	v0			# error
-	sw	v0, PT_R0(sp)		# set flag for syscall
+	LONGH_S	v0, PT_R0(sp)		# set flag for syscall
 					# restarting
-1:	sw	v0, PT_R2(sp)		# result
+1:	LONGH_S	v0, PT_R2(sp)		# result
 
 o32_syscall_exit:
 	local_irq_disable		# make sure need_resched and
@@ -93,21 +114,25 @@ syscall_trace_entry:
 
 	move	t0, s0
 	RESTORE_STATIC
-	lw	a0, PT_R4(sp)		# Restore argument registers
-	lw	a1, PT_R5(sp)
-	lw	a2, PT_R6(sp)
-	lw	a3, PT_R7(sp)
+	LONGD_L	a0, PT_R4(sp)		# Restore argument registers
+	LONGD_L	a1, PT_R5(sp)
+	LONGD_L	a2, PT_R6(sp)
+	LONGD_L	a3, PT_R7(sp)
 	jalr	t0
 
+#ifdef CONFIG_R5900_128BIT_SUPPORT
+	RESTORE_STATIC
+#endif
+
 	li	t0, -EMAXERRNO - 1	# error?
 	sltu	t0, t0, v0
-	sw	t0, PT_R7(sp)		# set error flag
+	LONGH_S	t0, PT_R7(sp)		# set error flag
 	beqz	t0, 1f
 
 	negu	v0			# error
-	sw	v0, PT_R0(sp)		# set flag for syscall
+	LONGH_S	v0, PT_R0(sp)		# set flag for syscall
 					# restarting
-1:	sw	v0, PT_R2(sp)		# result
+1:	LONGH_S	v0, PT_R2(sp)		# result
 
 	j	syscall_exit
 
@@ -119,7 +144,7 @@ syscall_trace_entry:
 	 * This Sucks (TM).
 	 */
 stackargs:
-	lw	t0, PT_R29(sp)		# get old user stack pointer
+	LONGH_L	t0, PT_R29(sp)		# get old user stack pointer
 
 	/*
 	 * We intentionally keep the kernel stack a little below the top of
@@ -137,6 +162,11 @@ stackargs:
 
 	la	t1, 5f			# load up to 3 arguments
 	subu	t1, t3
+#ifdef CONFIG_CPU_R5900
+	subu	t1, t3			# Add sync.l instructions to jump calculation
+	/* In an error exception handler the user space could be uncached. */
+	sync.l
+#endif
 1:	lw	t5, 16(t0)		# argument #5 from usp
 	.set    push
 	.set    noreorder
@@ -144,10 +174,26 @@ stackargs:
 	jr	t1
 	 addiu	t1, 6f - 5f
 
+#ifdef CONFIG_CPU_R5900
+	/* In an error exception handler the user space could be uncached. */
+	sync.l
+#endif
 2:	lw	t8, 28(t0)		# argument #8 from usp
+#ifdef CONFIG_CPU_R5900
+	/* In an error exception handler the user space could be uncached. */
+	sync.l
+#endif
 3:	lw	t7, 24(t0)		# argument #7 from usp
+#ifdef CONFIG_CPU_R5900
+	/* In an error exception handler the user space could be uncached. */
+	sync.l
+#endif
 4:	lw	t6, 20(t0)		# argument #6 from usp
-5:	jr	t1
+5:
+#ifdef CONFIG_CPU_R5900
+	addu	t1, t3
+#endif
+	jr	t1
 	 sw	t5, 16(sp)		# argument #5 to ksp
 
 	sw	t8, 28(sp)		# argument #8 to ksp
@@ -170,10 +216,10 @@ stackargs:
 	 */
 bad_stack:
 	negu	v0				# error
-	sw	v0, PT_R0(sp)
-	sw	v0, PT_R2(sp)
+	LONGH_S	v0, PT_R0(sp)
+	LONGH_S	v0, PT_R2(sp)
 	li	t0, 1				# set error flag
-	sw	t0, PT_R7(sp)
+	LONGH_S	t0, PT_R7(sp)
 	j	o32_syscall_exit
 
 	/*
@@ -181,9 +227,9 @@ bad_stack:
 	 */
 illegal_syscall:
 	li	v0, ENOSYS			# error
-	sw	v0, PT_R2(sp)
+	LONGH_S	v0, PT_R2(sp)
 	li	t0, 1				# set error flag
-	sw	t0, PT_R7(sp)
+	LONGH_S	t0, PT_R7(sp)
 	j	o32_syscall_exit
 	END(handle_sys)
 
@@ -210,11 +256,11 @@ illegal_syscall:
 	sw	t4, 16(sp)
 	sw	t5, 20(sp)
 	sw	t6, 24(sp)
-	sw	a0, PT_R4(sp)			# .. and push back a0 - a3, some
-	sw	a1, PT_R5(sp)			# syscalls expect them there
-	sw	a2, PT_R6(sp)
-	sw	a3, PT_R7(sp)
-	sw	a3, PT_R26(sp)			# update a3 for syscall restarting
+	LONGD_S	a0, PT_R4(sp)			# .. and push back a0 - a3, some
+	LONGD_S	a1, PT_R5(sp)			# syscalls expect them there
+	LONGD_S	a2, PT_R6(sp)
+	LONGH_S	a3, PT_R7(sp)
+	LONGH_S	a3, PT_R26(sp)			# update a3 for syscall restarting
 	jr	t2
 	/* Unreached */
 
diff -purN linux-2.6.35.4-orig/arch/mips/kernel/scall64-64.S linux-2.6.35.4/arch/mips/kernel/scall64-64.S
--- linux-2.6.35.4-orig/arch/mips/kernel/scall64-64.S	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/kernel/scall64-64.S	2014-07-18 22:29:43.542367724 +0200
@@ -33,6 +33,10 @@ NESTED(handle_sys64, PT_SIZE, sp)
 	 * already did this.
 	 */
 	.set	noat
+#ifdef CONFIG_CPU_R5900
+	nop
+	nop
+#endif
 	SAVE_SOME
 	TRACE_IRQS_ON_RELOAD
 	STI
diff -purN linux-2.6.35.4-orig/arch/mips/kernel/scall64-n32.S linux-2.6.35.4/arch/mips/kernel/scall64-n32.S
--- linux-2.6.35.4-orig/arch/mips/kernel/scall64-n32.S	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/kernel/scall64-n32.S	2014-07-18 22:29:43.542367724 +0200
@@ -32,6 +32,10 @@
 NESTED(handle_sysn32, PT_SIZE, sp)
 #ifndef CONFIG_MIPS32_O32
 	.set	noat
+#ifdef CONFIG_CPU_R5900
+	nop
+	nop
+#endif
 	SAVE_SOME
 	TRACE_IRQS_ON_RELOAD
 	STI
diff -purN linux-2.6.35.4-orig/arch/mips/kernel/scall64-o32.S linux-2.6.35.4/arch/mips/kernel/scall64-o32.S
--- linux-2.6.35.4-orig/arch/mips/kernel/scall64-o32.S	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/kernel/scall64-o32.S	2014-07-18 22:29:43.542367724 +0200
@@ -27,6 +27,10 @@
 	.align  5
 NESTED(handle_sys, PT_SIZE, sp)
 	.set	noat
+#ifdef CONFIG_CPU_R5900
+	nop
+	nop
+#endif
 	SAVE_SOME
 	TRACE_IRQS_ON_RELOAD
 	STI
@@ -69,9 +73,25 @@ NESTED(handle_sys, PT_SIZE, sp)
 	daddu	t1, t0, 32
 	bltz	t1, bad_stack
 
+#ifdef CONFIG_CPU_R5900
+	/* In an error exception handler the user space could be uncached. */
+	sync.l
+#endif
 1:	lw	a4, 16(t0)		# argument #5 from usp
+#ifdef CONFIG_CPU_R5900
+	/* In an error exception handler the user space could be uncached. */
+	sync.l
+#endif
 2:	lw	a5, 20(t0)		# argument #6 from usp
+#ifdef CONFIG_CPU_R5900
+	/* In an error exception handler the user space could be uncached. */
+	sync.l
+#endif
 3:	lw	a6, 24(t0)		# argument #7 from usp
+#ifdef CONFIG_CPU_R5900
+	/* In an error exception handler the user space could be uncached. */
+	sync.l
+#endif
 4:	lw	a7, 28(t0)		# argument #8 from usp (for indirect syscalls)
 
 	.section __ex_table,"a"
diff -purN linux-2.6.35.4-orig/arch/mips/kernel/setup.c linux-2.6.35.4/arch/mips/kernel/setup.c
--- linux-2.6.35.4-orig/arch/mips/kernel/setup.c	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/kernel/setup.c	2014-07-18 22:29:43.542367724 +0200
@@ -142,7 +142,7 @@ static int __init rd_start_early(char *p
 {
 	unsigned long start = memparse(p, &p);
 
-#ifdef CONFIG_64BIT
+#if defined(CONFIG_64BIT) && !defined(CONFIG_CPU_R5900)
 	/* Guess if the sign extension was forgotten by bootloader */
 	if (start < XKPHYS)
 		start = (int)start;
diff -purN linux-2.6.35.4-orig/arch/mips/kernel/signal32.c linux-2.6.35.4/arch/mips/kernel/signal32.c
--- linux-2.6.35.4-orig/arch/mips/kernel/signal32.c	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/kernel/signal32.c	2014-07-18 22:29:43.542367724 +0200
@@ -152,10 +152,14 @@ static int setup_sigcontext32(struct pt_
 		err |= __put_user(rddsp(DSP_MASK), &sc->sc_dsp);
 		err |= __put_user(mfhi1(), &sc->sc_hi1);
 		err |= __put_user(mflo1(), &sc->sc_lo1);
+#ifdef CONFIG_CPU_R5900
+		err |= __put_user(mfsa(), &sc->sc_sa);
+#else
 		err |= __put_user(mfhi2(), &sc->sc_hi2);
 		err |= __put_user(mflo2(), &sc->sc_lo2);
 		err |= __put_user(mfhi3(), &sc->sc_hi3);
 		err |= __put_user(mflo3(), &sc->sc_lo3);
+#endif
 	}
 
 	used_math = !!used_math();
@@ -200,11 +204,15 @@ static int restore_sigcontext32(struct p
 	if (cpu_has_dsp) {
 		err |= __get_user(treg, &sc->sc_hi1); mthi1(treg);
 		err |= __get_user(treg, &sc->sc_lo1); mtlo1(treg);
+#ifdef CONFIG_CPU_R5900
+		err |= __get_user(treg, &sc->sc_sa); mtsa(treg);
+#else
 		err |= __get_user(treg, &sc->sc_hi2); mthi2(treg);
 		err |= __get_user(treg, &sc->sc_lo2); mtlo2(treg);
 		err |= __get_user(treg, &sc->sc_hi3); mthi3(treg);
 		err |= __get_user(treg, &sc->sc_lo3); mtlo3(treg);
 		err |= __get_user(treg, &sc->sc_dsp); wrdsp(treg, DSP_MASK);
+#endif
 	}
 
 	for (i = 1; i < 32; i++)
diff -purN linux-2.6.35.4-orig/arch/mips/kernel/signal.c linux-2.6.35.4/arch/mips/kernel/signal.c
--- linux-2.6.35.4-orig/arch/mips/kernel/signal.c	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/kernel/signal.c	2014-07-18 22:29:43.542367724 +0200
@@ -36,6 +36,11 @@
 
 #include "signal-common.h"
 
+/*
+ * Including <asm/unistd.h> would give use the 64-bit syscall numbers ...
+ */
+#define __NR_N32_restart_syscall	6214
+
 static int (*save_fp_context)(struct sigcontext __user *sc);
 static int (*restore_fp_context)(struct sigcontext __user *sc);
 
@@ -112,7 +117,7 @@ int setup_sigcontext(struct pt_regs *reg
 
 	err |= __put_user(0, &sc->sc_regs[0]);
 	for (i = 1; i < 32; i++)
-		err |= __put_user(regs->regs[i], &sc->sc_regs[i]);
+		err |= __put_user(MIPS_READ_REG(regs->regs[i]), &sc->sc_regs[i]);
 
 #ifdef CONFIG_CPU_HAS_SMARTMIPS
 	err |= __put_user(regs->acx, &sc->sc_acx);
@@ -122,11 +127,15 @@ int setup_sigcontext(struct pt_regs *reg
 	if (cpu_has_dsp) {
 		err |= __put_user(mfhi1(), &sc->sc_hi1);
 		err |= __put_user(mflo1(), &sc->sc_lo1);
+#ifdef CONFIG_CPU_R5900
+		err |= __put_user(mfsa(), &sc->sc_sa);
+#else
 		err |= __put_user(mfhi2(), &sc->sc_hi2);
 		err |= __put_user(mflo2(), &sc->sc_lo2);
 		err |= __put_user(mfhi3(), &sc->sc_hi3);
 		err |= __put_user(mflo3(), &sc->sc_lo3);
 		err |= __put_user(rddsp(DSP_MASK), &sc->sc_dsp);
+#endif
 	}
 
 	used_math = !!used_math();
@@ -193,15 +202,27 @@ int restore_sigcontext(struct pt_regs *r
 	if (cpu_has_dsp) {
 		err |= __get_user(treg, &sc->sc_hi1); mthi1(treg);
 		err |= __get_user(treg, &sc->sc_lo1); mtlo1(treg);
+#ifdef CONFIG_CPU_R5900
+		err |= __get_user(treg, &sc->sc_sa); mtsa(treg);
+#else
 		err |= __get_user(treg, &sc->sc_hi2); mthi2(treg);
 		err |= __get_user(treg, &sc->sc_lo2); mtlo2(treg);
 		err |= __get_user(treg, &sc->sc_hi3); mthi3(treg);
 		err |= __get_user(treg, &sc->sc_lo3); mtlo3(treg);
 		err |= __get_user(treg, &sc->sc_dsp); wrdsp(treg, DSP_MASK);
+#endif
 	}
 
-	for (i = 1; i < 32; i++)
-		err |= __get_user(regs->regs[i], &sc->sc_regs[i]);
+	for (i = 1; i < 32; i++) {
+		MIPS_REG_T tmp;
+		int rv;
+
+		rv = __get_user(tmp, &sc->sc_regs[i]);
+		err |= rv;
+		if (rv == 0) {
+			MIPS_WRITE_REG(regs->regs[i]) = tmp;
+		}
+	}
 
 	err |= __get_user(used_math, &sc->sc_used_math);
 	conditional_used_math(used_math);
@@ -224,7 +245,7 @@ void __user *get_sigframe(struct k_sigac
 	unsigned long sp;
 
 	/* Default to using normal stack */
-	sp = regs->regs[29];
+	sp = MIPS_READ_REG_L(regs->regs[29]);
 
 	/*
 	 * FPU emulator may have it's own trampoline active just
@@ -250,7 +271,7 @@ asmlinkage int sys_sigsuspend(nabi_no_re
 	sigset_t newset;
 	sigset_t __user *uset;
 
-	uset = (sigset_t __user *) regs.regs[4];
+	uset = (sigset_t __user *) MIPS_READ_REG_L(regs.regs[4]);
 	if (copy_from_user(&newset, uset, sizeof(sigset_t)))
 		return -EFAULT;
 	sigdelsetmask(&newset, ~_BLOCKABLE);
@@ -275,11 +296,11 @@ asmlinkage int sys_rt_sigsuspend(nabi_no
 	size_t sigsetsize;
 
 	/* XXX Don't preclude handling different sized sigset_t's.  */
-	sigsetsize = regs.regs[5];
+	sigsetsize = MIPS_READ_REG(regs.regs[5]);
 	if (sigsetsize != sizeof(sigset_t))
 		return -EINVAL;
 
-	unewset = (sigset_t __user *) regs.regs[4];
+	unewset = (sigset_t __user *) MIPS_READ_REG_L(regs.regs[4]);
 	if (copy_from_user(&newset, unewset, sizeof(newset)))
 		return -EFAULT;
 	sigdelsetmask(&newset, ~_BLOCKABLE);
@@ -339,9 +360,9 @@ SYSCALL_DEFINE3(sigaction, int, sig, con
 
 asmlinkage int sys_sigaltstack(nabi_no_regargs struct pt_regs regs)
 {
-	const stack_t __user *uss = (const stack_t __user *) regs.regs[4];
-	stack_t __user *uoss = (stack_t __user *) regs.regs[5];
-	unsigned long usp = regs.regs[29];
+	const stack_t __user *uss = (const stack_t __user *) MIPS_READ_REG_L(regs.regs[4]);
+	stack_t __user *uoss = (stack_t __user *) MIPS_READ_REG_L(regs.regs[5]);
+	unsigned long usp = MIPS_READ_REG_L(regs.regs[29]);
 
 	return do_sigaltstack(uss, uoss, usp);
 }
@@ -353,7 +374,7 @@ asmlinkage void sys_sigreturn(nabi_no_re
 	sigset_t blocked;
 	int sig;
 
-	frame = (struct sigframe __user *) regs.regs[29];
+	frame = (struct sigframe __user *) MIPS_READ_REG_L(regs.regs[29]);
 	if (!access_ok(VERIFY_READ, frame, sizeof(*frame)))
 		goto badframe;
 	if (__copy_from_user(&blocked, &frame->sf_mask, sizeof(blocked)))
@@ -393,7 +414,7 @@ asmlinkage void sys_rt_sigreturn(nabi_no
 	stack_t st;
 	int sig;
 
-	frame = (struct rt_sigframe __user *) regs.regs[29];
+	frame = (struct rt_sigframe __user *) MIPS_READ_REG_L(regs.regs[29]);
 	if (!access_ok(VERIFY_READ, frame, sizeof(*frame)))
 		goto badframe;
 	if (__copy_from_user(&set, &frame->rs_uc.uc_sigmask, sizeof(set)))
@@ -415,7 +436,7 @@ asmlinkage void sys_rt_sigreturn(nabi_no
 		goto badframe;
 	/* It is more difficult to avoid calling this function than to
 	   call it and ignore errors.  */
-	do_sigaltstack((stack_t __user *)&st, NULL, regs.regs[29]);
+	do_sigaltstack((stack_t __user *)&st, NULL, MIPS_READ_REG_L(regs.regs[29]));
 
 	/*
 	 * Don't let your children do this ...
@@ -457,16 +478,17 @@ static int setup_frame(void *sig_return,
 	 * $25 and c0_epc point to the signal handler, $29 points to the
 	 * struct sigframe.
 	 */
-	regs->regs[ 4] = signr;
-	regs->regs[ 5] = 0;
-	regs->regs[ 6] = (unsigned long) &frame->sf_sc;
-	regs->regs[29] = (unsigned long) frame;
-	regs->regs[31] = (unsigned long) sig_return;
-	regs->cp0_epc = regs->regs[25] = (unsigned long) ka->sa.sa_handler;
+	MIPS_WRITE_REG(regs->regs[ 4]) = signr;
+	MIPS_WRITE_REG(regs->regs[ 5]) = 0;
+	MIPS_WRITE_REG(regs->regs[ 6]) = (unsigned long) &frame->sf_sc;
+	MIPS_WRITE_REG(regs->regs[29]) = (unsigned long) frame;
+	MIPS_WRITE_REG(regs->regs[31]) = (unsigned long) sig_return;
+	MIPS_WRITE_REG(regs->regs[25]) = (unsigned long) ka->sa.sa_handler;
+	regs->cp0_epc = MIPS_READ_REG_L(regs->regs[25]);
 
 	DEBUGP("SIG deliver (%s:%d): sp=0x%p pc=0x%lx ra=0x%lx\n",
 	       current->comm, current->pid,
-	       frame, regs->cp0_epc, regs->regs[31]);
+	       frame, regs->cp0_epc, MIPS_READ_REG_L(regs->regs[31]));
 	return 0;
 
 give_sigsegv:
@@ -494,7 +516,7 @@ static int setup_rt_frame(void *sig_retu
 	err |= __put_user(NULL, &frame->rs_uc.uc_link);
 	err |= __put_user((void __user *)current->sas_ss_sp,
 	                  &frame->rs_uc.uc_stack.ss_sp);
-	err |= __put_user(sas_ss_flags(regs->regs[29]),
+	err |= __put_user(sas_ss_flags(MIPS_READ_REG_L(regs->regs[29])),
 	                  &frame->rs_uc.uc_stack.ss_flags);
 	err |= __put_user(current->sas_ss_size,
 	                  &frame->rs_uc.uc_stack.ss_size);
@@ -514,12 +536,13 @@ static int setup_rt_frame(void *sig_retu
 	 * $25 and c0_epc point to the signal handler, $29 points to
 	 * the struct rt_sigframe.
 	 */
-	regs->regs[ 4] = signr;
-	regs->regs[ 5] = (unsigned long) &frame->rs_info;
-	regs->regs[ 6] = (unsigned long) &frame->rs_uc;
-	regs->regs[29] = (unsigned long) frame;
-	regs->regs[31] = (unsigned long) sig_return;
-	regs->cp0_epc = regs->regs[25] = (unsigned long) ka->sa.sa_handler;
+	MIPS_WRITE_REG(regs->regs[ 4]) = signr;
+	MIPS_WRITE_REG(regs->regs[ 5]) = (unsigned long) &frame->rs_info;
+	MIPS_WRITE_REG(regs->regs[ 6]) = (unsigned long) &frame->rs_uc;
+	MIPS_WRITE_REG(regs->regs[29]) = (unsigned long) frame;
+	MIPS_WRITE_REG(regs->regs[31]) = (unsigned long) sig_return;
+	MIPS_WRITE_REG(regs->regs[25]) = (unsigned long) ka->sa.sa_handler;
+	regs->cp0_epc = MIPS_READ_REG_L(regs->regs[25]);
 
 	DEBUGP("SIG deliver (%s:%d): sp=0x%p pc=0x%lx ra=0x%lx\n",
 	       current->comm, current->pid,
@@ -543,6 +566,15 @@ struct mips_abi mips_abi = {
 	.restart	= __NR_restart_syscall
 };
 
+#ifdef CONFIG_MIPS_N32
+struct mips_abi mips_abi_n32 = {
+	.setup_rt_frame	= setup_rt_frame,
+	.rt_signal_return_offset =
+		offsetof(struct mips_vdso, n32_rt_signal_trampoline),
+	.restart	= __NR_N32_restart_syscall
+};
+#endif
+
 static int handle_signal(unsigned long sig, siginfo_t *info,
 	struct k_sigaction *ka, sigset_t *oldset, struct pt_regs *regs)
 {
@@ -550,25 +582,25 @@ static int handle_signal(unsigned long s
 	struct mips_abi *abi = current->thread.abi;
 	void *vdso = current->mm->context.vdso;
 
-	switch(regs->regs[0]) {
+	switch(MIPS_READ_REG(regs->regs[0])) {
 	case ERESTART_RESTARTBLOCK:
 	case ERESTARTNOHAND:
-		regs->regs[2] = EINTR;
+		MIPS_WRITE_REG(regs->regs[2]) = EINTR;
 		break;
 	case ERESTARTSYS:
 		if (!(ka->sa.sa_flags & SA_RESTART)) {
-			regs->regs[2] = EINTR;
+			MIPS_WRITE_REG(regs->regs[2]) = EINTR;
 			break;
 		}
 	/* fallthrough */
 	case ERESTARTNOINTR:		/* Userland will reload $v0.  */
-		regs->regs[7] = regs->regs[26];
+		MIPS_WRITE_REG(regs->regs[7]) = MIPS_READ_REG(regs->regs[26]);
 		regs->cp0_epc -= 8;
 	}
 
-	regs->regs[0] = 0;		/* Don't deal with this again.  */
+	MIPS_WRITE_REG(regs->regs[0]) = 0;		/* Don't deal with this again.  */
 
-	if (sig_uses_siginfo(ka))
+	if (sig_uses_siginfo(ka) || (abi->setup_frame == NULL))
 		ret = abi->setup_rt_frame(vdso + abi->rt_signal_return_offset,
 					  ka, regs, sig, oldset, info);
 	else
@@ -627,19 +659,19 @@ static void do_signal(struct pt_regs *re
 	 * dies here!!!  The li instruction, a single machine instruction,
 	 * must directly be followed by the syscall instruction.
 	 */
-	if (regs->regs[0]) {
-		if (regs->regs[2] == ERESTARTNOHAND ||
-		    regs->regs[2] == ERESTARTSYS ||
-		    regs->regs[2] == ERESTARTNOINTR) {
-			regs->regs[7] = regs->regs[26];
+	if (MIPS_READ_REG(regs->regs[0])) {
+		if (MIPS_READ_REG(regs->regs[2]) == ERESTARTNOHAND ||
+		    MIPS_READ_REG(regs->regs[2]) == ERESTARTSYS ||
+		    MIPS_READ_REG(regs->regs[2]) == ERESTARTNOINTR) {
+			MIPS_WRITE_REG(regs->regs[7]) = MIPS_READ_REG(regs->regs[26]);
 			regs->cp0_epc -= 8;
 		}
-		if (regs->regs[2] == ERESTART_RESTARTBLOCK) {
-			regs->regs[2] = current->thread.abi->restart;
-			regs->regs[7] = regs->regs[26];
+		if (MIPS_READ_REG(regs->regs[2]) == ERESTART_RESTARTBLOCK) {
+			MIPS_WRITE_REG(regs->regs[2]) = current->thread.abi->restart;
+			MIPS_WRITE_REG(regs->regs[7]) = MIPS_READ_REG(regs->regs[26]);
 			regs->cp0_epc -= 4;
 		}
-		regs->regs[0] = 0;	/* Don't deal with this again.  */
+		MIPS_WRITE_REG(regs->regs[0]) = 0;	/* Don't deal with this again.  */
 	}
 
 	/*
diff -purN linux-2.6.35.4-orig/arch/mips/kernel/smtc-asm.S linux-2.6.35.4/arch/mips/kernel/smtc-asm.S
--- linux-2.6.35.4-orig/arch/mips/kernel/smtc-asm.S	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/kernel/smtc-asm.S	2014-07-18 22:29:43.542367724 +0200
@@ -93,6 +93,9 @@ FEXPORT(__smtc_ipi_vector)
 	_ehb
 	lw	k0,PT_EPC(k1)
 	mtc0	k0,CP0_EPC
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	/* Save all will redundantly recompute the SP, but use it for now */
 	SAVE_ALL
 	CLI
diff -purN linux-2.6.35.4-orig/arch/mips/kernel/stacktrace.c linux-2.6.35.4/arch/mips/kernel/stacktrace.c
--- linux-2.6.35.4-orig/arch/mips/kernel/stacktrace.c	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/kernel/stacktrace.c	2014-07-18 22:29:43.542367724 +0200
@@ -33,9 +33,9 @@ static void save_raw_context_stack(struc
 static void save_context_stack(struct stack_trace *trace,
 	struct task_struct *tsk, struct pt_regs *regs)
 {
-	unsigned long sp = regs->regs[29];
+	unsigned long sp = MIPS_READ_REG_L(regs->regs[29]);
 #ifdef CONFIG_KALLSYMS
-	unsigned long ra = regs->regs[31];
+	unsigned long ra = MIPS_READ_REG_L(regs->regs[31]);
 	unsigned long pc = regs->cp0_epc;
 
 	if (raw_show_trace || !__kernel_text_address(pc)) {
@@ -78,8 +78,8 @@ void save_stack_trace_tsk(struct task_st
 
 	if (tsk != current) {
 		regs->regs[29] = tsk->thread.reg29;
-		regs->regs[31] = 0;
-		regs->cp0_epc = tsk->thread.reg31;
+		MIPS_WRITE_REG(regs->regs[31]) = 0;
+		regs->cp0_epc = MIPS_READ_REG_L(tsk->thread.reg31);
 	} else
 		prepare_frametrace(regs);
 	save_context_stack(trace, tsk, regs);
diff -purN linux-2.6.35.4-orig/arch/mips/kernel/syscall.c linux-2.6.35.4/arch/mips/kernel/syscall.c
--- linux-2.6.35.4-orig/arch/mips/kernel/syscall.c	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/kernel/syscall.c	2014-07-18 22:29:43.542367724 +0200
@@ -58,7 +58,7 @@ asmlinkage int sysm_pipe(nabi_no_regargs
 		res = error;
 		goto out;
 	}
-	regs.regs[3] = fd[1];
+	MIPS_WRITE_REG(regs.regs[3]) = fd[1];
 	res = fd[0];
 out:
 	return res;
@@ -164,7 +164,7 @@ save_static_function(sys_fork);
 static int __used noinline
 _sys_fork(nabi_no_regargs struct pt_regs regs)
 {
-	return do_fork(SIGCHLD, regs.regs[29], &regs, 0, NULL, NULL);
+	return do_fork(SIGCHLD, MIPS_READ_REG_L(regs.regs[29]), &regs, 0, NULL, NULL);
 }
 
 save_static_function(sys_clone);
@@ -175,17 +175,17 @@ _sys_clone(nabi_no_regargs struct pt_reg
 	unsigned long newsp;
 	int __user *parent_tidptr, *child_tidptr;
 
-	clone_flags = regs.regs[4];
-	newsp = regs.regs[5];
+	clone_flags = MIPS_READ_REG(regs.regs[4]);
+	newsp = MIPS_READ_REG(regs.regs[5]);
 	if (!newsp)
-		newsp = regs.regs[29];
-	parent_tidptr = (int __user *) regs.regs[6];
+		newsp = MIPS_READ_REG_L(regs.regs[29]);
+	parent_tidptr = (int __user *) MIPS_READ_REG_L(regs.regs[6]);
 #ifdef CONFIG_32BIT
 	/* We need to fetch the fifth argument off the stack.  */
 	child_tidptr = NULL;
 	if (clone_flags & (CLONE_CHILD_SETTID | CLONE_CHILD_CLEARTID)) {
-		int __user *__user *usp = (int __user *__user *) regs.regs[29];
-		if (regs.regs[2] == __NR_syscall) {
+		int __user *__user *usp = (int __user *__user *) MIPS_READ_REG_L(regs.regs[29]);
+		if (MIPS_READ_REG(regs.regs[2]) == __NR_syscall) {
 			if (get_user (child_tidptr, &usp[5]))
 				return -EFAULT;
 		}
@@ -199,6 +199,27 @@ _sys_clone(nabi_no_regargs struct pt_reg
 	               parent_tidptr, child_tidptr);
 }
 
+#ifdef CONFIG_MIPS_N32
+/* Same as _sys_clone() function above, but without CONFIG_32BIT. */
+save_static_function(sysn32_clone);
+static int __used noinline
+_sysn32_clone(nabi_no_regargs struct pt_regs regs)
+{
+	unsigned long clone_flags;
+	unsigned long newsp;
+	int __user *parent_tidptr, *child_tidptr;
+
+	clone_flags = MIPS_READ_REG(regs.regs[4]);
+	newsp = MIPS_READ_REG(regs.regs[5]);
+	if (!newsp)
+		newsp = MIPS_READ_REG_L(regs.regs[29]);
+	parent_tidptr = (int __user *) MIPS_READ_REG_L(regs.regs[6]);
+	child_tidptr = (int __user *) MIPS_READ_REG_L(regs.regs[8]);
+	return do_fork(clone_flags, newsp, &regs, 0,
+	               parent_tidptr, child_tidptr);
+}
+#endif
+
 /*
  * sys_execve() executes a new program.
  */
@@ -207,12 +228,12 @@ asmlinkage int sys_execve(nabi_no_regarg
 	int error;
 	char * filename;
 
-	filename = getname((char __user *) (long)regs.regs[4]);
+	filename = getname((char __user *) (long)MIPS_READ_REG_L(regs.regs[4]));
 	error = PTR_ERR(filename);
 	if (IS_ERR(filename))
 		goto out;
-	error = do_execve(filename, (char __user *__user *) (long)regs.regs[5],
-	                  (char __user *__user *) (long)regs.regs[6], &regs);
+	error = do_execve(filename, (char __user *__user *) (long)MIPS_READ_REG_L(regs.regs[5]),
+	                  (char __user *__user *) (long)MIPS_READ_REG_L(regs.regs[6]), &regs);
 	putname(filename);
 
 out:
@@ -230,7 +251,7 @@ SYSCALL_DEFINE1(set_thread_area, unsigne
 	return 0;
 }
 
-static inline int mips_atomic_set(struct pt_regs *regs,
+static inline int mips_atomic_set(volatile struct pt_regs *regs,
 	unsigned long addr, unsigned long new)
 {
 	unsigned long old, tmp;
@@ -314,8 +335,8 @@ static inline int mips_atomic_set(struct
 	if (unlikely(err))
 		return err;
 
-	regs->regs[2] = old;
-	regs->regs[7] = 0;	/* No error */
+	MIPS_WRITE_REG(regs->regs[2]) = old;
+	MIPS_WRITE_REG(regs->regs[7]) = 0;	/* No error */
 
 	/*
 	 * Don't let your children do this ...
@@ -336,10 +357,10 @@ _sys_sysmips(nabi_no_regargs struct pt_r
 {
 	long cmd, arg1, arg2, arg3;
 
-	cmd = regs.regs[4];
-	arg1 = regs.regs[5];
-	arg2 = regs.regs[6];
-	arg3 = regs.regs[7];
+	cmd = MIPS_READ_REG(regs.regs[4]);
+	arg1 = MIPS_READ_REG(regs.regs[5]);
+	arg2 = MIPS_READ_REG(regs.regs[6]);
+	arg3 = MIPS_READ_REG(regs.regs[7]);
 
 	switch (cmd) {
 	case MIPS_ATOMIC_SET:
diff -purN linux-2.6.35.4-orig/arch/mips/kernel/traps.c linux-2.6.35.4/arch/mips/kernel/traps.c
--- linux-2.6.35.4-orig/arch/mips/kernel/traps.c	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/kernel/traps.c	2014-07-18 22:29:43.542367724 +0200
@@ -53,6 +53,12 @@
 #include <asm/irq.h>
 #include <asm/uasm.h>
 
+#ifdef CONFIG_R5900_128BIT_SUPPORT
+#define SHOW_REG_MOD 2
+#else
+#define SHOW_REG_MOD 4
+#endif
+
 extern void check_wait(void);
 extern asmlinkage void r4k_wait(void);
 extern asmlinkage void rollback_handle_int(void);
@@ -124,8 +130,8 @@ __setup("raw_show_trace", set_raw_show_t
 
 static void show_backtrace(struct task_struct *task, const struct pt_regs *regs)
 {
-	unsigned long sp = regs->regs[29];
-	unsigned long ra = regs->regs[31];
+	unsigned long sp = MIPS_READ_REG_L(regs->regs[29]);
+	unsigned long ra = MIPS_READ_REG_L(regs->regs[31]);
 	unsigned long pc = regs->cp0_epc;
 
 	if (raw_show_trace || !__kernel_text_address(pc)) {
@@ -150,7 +156,7 @@ static void show_stacktrace(struct task_
 	const int field = 2 * sizeof(unsigned long);
 	long stackdata;
 	int i;
-	unsigned long __user *sp = (unsigned long __user *)regs->regs[29];
+	unsigned long __user *sp = (unsigned long __user *) MIPS_READ_REG_L(regs->regs[29]);
 
 	printk("Stack :");
 	i = 0;
@@ -178,14 +184,14 @@ void show_stack(struct task_struct *task
 {
 	struct pt_regs regs;
 	if (sp) {
-		regs.regs[29] = (unsigned long)sp;
-		regs.regs[31] = 0;
+		MIPS_WRITE_REG(regs.regs[29]) = (unsigned long)sp;
+		MIPS_WRITE_REG(regs.regs[31]) = 0;
 		regs.cp0_epc = 0;
 	} else {
 		if (task && task != current) {
-			regs.regs[29] = task->thread.reg29;
-			regs.regs[31] = 0;
-			regs.cp0_epc = task->thread.reg31;
+			MIPS_WRITE_REG(regs.regs[29]) = MIPS_READ_REG(task->thread.reg29);
+			MIPS_WRITE_REG(regs.regs[31]) = 0;
+			regs.cp0_epc = MIPS_READ_REG_L(task->thread.reg31);
 #ifdef CONFIG_KGDB_KDB
 		} else if (atomic_read(&kgdb_active) != -1 &&
 			   kdb_current_regs) {
@@ -232,35 +238,50 @@ static void show_code(unsigned int __use
 
 static void __show_regs(const struct pt_regs *regs)
 {
+#ifdef CONFIG_R5900_128BIT_SUPPORT
 	const int field = 2 * sizeof(unsigned long);
+#else
+	const int field = 32;
+#endif
 	unsigned int cause = regs->cp0_cause;
 	int i;
 
+
 	printk("Cpu %d\n", smp_processor_id());
 
 	/*
 	 * Saved main processor registers
 	 */
 	for (i = 0; i < 32; ) {
-		if ((i % 4) == 0)
+		if ((i % SHOW_REG_MOD) == 0)
 			printk("$%2d   :", i);
 		if (i == 0)
 			printk(" %0*lx", field, 0UL);
 		else if (i == 26 || i == 27)
 			printk(" %*s", field, "");
 		else
-			printk(" %0*lx", field, regs->regs[i]);
+#ifdef CONFIG_R5900_128BIT_SUPPORT
+			printk(" %016llx%016llx", MIPS_READ_REG_HIGH(regs->regs[i]), MIPS_READ_REG(regs->regs[i]));
+#else
+			printk(" %0*lx", field, MIPS_READ_REG_L(regs->regs[i]));
+#endif
 
 		i++;
-		if ((i % 4) == 0)
+		if ((i % SHOW_REG_MOD) == 0)
 			printk("\n");
 	}
 
 #ifdef CONFIG_CPU_HAS_SMARTMIPS
 	printk("Acx    : %0*lx\n", field, regs->acx);
 #endif
+#ifdef CONFIG_CPU_R5900
+	printk("Hi    : %0*llx\n", field, regs->hi);
+	printk("Lo    : %0*llx\n", field, regs->lo);
+	/* TBD: Print hi1 and lo1. */
+#else
 	printk("Hi    : %0*lx\n", field, regs->hi);
 	printk("Lo    : %0*lx\n", field, regs->lo);
+#endif
 
 	/*
 	 * Saved cp0 registers
@@ -268,8 +289,8 @@ static void __show_regs(const struct pt_
 	printk("epc   : %0*lx %pS\n", field, regs->cp0_epc,
 	       (void *) regs->cp0_epc);
 	printk("    %s\n", print_tainted());
-	printk("ra    : %0*lx %pS\n", field, regs->regs[31],
-	       (void *) regs->regs[31]);
+	printk("ra    : %0*lx %pS\n", field, MIPS_READ_REG_L(regs->regs[31]),
+	       (void *) MIPS_READ_REG_L(regs->regs[31]));
 
 	printk("Status: %08x    ", (uint32_t) regs->cp0_status);
 
@@ -448,7 +469,7 @@ asmlinkage void do_be(struct pt_regs *re
 	 */
 	printk(KERN_ALERT "%s bus error, epc == %0*lx, ra == %0*lx\n",
 	       data ? "Data" : "Instruction",
-	       field, regs->cp0_epc, field, regs->regs[31]);
+	       field, regs->cp0_epc, field, MIPS_READ_REG_L(regs->regs[31]));
 	if (notify_die(DIE_OOPS, "bus error", regs, SIGBUS, 0, 0)
 	    == NOTIFY_STOP)
 		return;
@@ -464,15 +485,22 @@ asmlinkage void do_be(struct pt_regs *re
 #define OPCODE 0xfc000000
 #define BASE   0x03e00000
 #define RT     0x001f0000
+#define RS     0x03e00000
 #define OFFSET 0x0000ffff
 #define LL     0xc0000000
+#define LLD    0xd0000000
 #define SC     0xe0000000
+#define SCD    0xf0000000
 #define SPEC0  0x00000000
 #define SPEC3  0x7c000000
 #define RD     0x0000f800
 #define FUNC   0x0000003f
 #define SYNC   0x0000000f
 #define RDHWR  0x0000003b
+#define DMULT  0x0000001c
+#define DMULTU 0x0000001d
+#define DDIV   0x0000001e
+#define DDIVU  0x0000001f
 
 /*
  * The ll_bit is cleared by r*_switch.S
@@ -497,7 +525,7 @@ static inline int simulate_ll(struct pt_
 	offset >>= 16;
 
 	vaddr = (unsigned long __user *)
-	        ((unsigned long)(regs->regs[(opcode & BASE) >> 21]) + offset);
+	        ((unsigned long)(MIPS_READ_REG_L(regs->regs[(opcode & BASE) >> 21])) + offset);
 
 	if ((unsigned long)vaddr & 3)
 		return SIGBUS;
@@ -515,7 +543,7 @@ static inline int simulate_ll(struct pt_
 
 	preempt_enable();
 
-	regs->regs[(opcode & RT) >> 16] = value;
+	MIPS_WRITE_REG(regs->regs[(opcode & RT) >> 16]) = value;
 
 	return 0;
 }
@@ -537,7 +565,7 @@ static inline int simulate_sc(struct pt_
 	offset >>= 16;
 
 	vaddr = (unsigned long __user *)
-	        ((unsigned long)(regs->regs[(opcode & BASE) >> 21]) + offset);
+	        ((unsigned long)(MIPS_READ_REG_L(regs->regs[(opcode & BASE) >> 21])) + offset);
 	reg = (opcode & RT) >> 16;
 
 	if ((unsigned long)vaddr & 3)
@@ -546,21 +574,103 @@ static inline int simulate_sc(struct pt_
 	preempt_disable();
 
 	if (ll_bit == 0 || ll_task != current) {
-		regs->regs[reg] = 0;
+		MIPS_WRITE_REG(regs->regs[reg]) = 0;
 		preempt_enable();
 		return 0;
 	}
 
 	preempt_enable();
 
-	if (put_user(regs->regs[reg], vaddr))
+	if (put_user(MIPS_READ_REG(regs->regs[reg]), vaddr))
+		return SIGSEGV;
+
+	MIPS_WRITE_REG(regs->regs[reg]) = 1;
+
+	return 0;
+}
+
+#ifdef CONFIG_R5900_128BIT_SUPPORT
+static inline int simulate_lld(struct pt_regs *regs, unsigned int opcode)
+{
+	unsigned long long value, __user *vaddr;
+	long offset;
+
+	/*
+	 * analyse the lld instruction that just caused a ri exception
+	 * and put the referenced address to addr.
+	 */
+
+	/* sign extend offset */
+	offset = opcode & OFFSET;
+	offset <<= 16;
+	offset >>= 16;
+
+	vaddr = (unsigned long __user *)
+	        ((unsigned long)(MIPS_READ_REG_L(regs->regs[(opcode & BASE) >> 21])) + offset);
+
+	if ((unsigned long)vaddr & 7)
+		return SIGBUS;
+	if (get_user(value, vaddr))
 		return SIGSEGV;
 
-	regs->regs[reg] = 1;
+	preempt_disable();
+
+	if (ll_task == NULL || ll_task == current) {
+		ll_bit = 1;
+	} else {
+		ll_bit = 0;
+	}
+	ll_task = current;
+
+	preempt_enable();
+
+	MIPS_WRITE_REG(regs->regs[(opcode & RT) >> 16]) = value;
 
 	return 0;
 }
 
+static inline int simulate_scd(struct pt_regs *regs, unsigned int opcode)
+{
+	unsigned long long __user *vaddr;
+	unsigned long reg;
+	long offset;
+
+	/*
+	 * analyse the sc instruction that just caused a ri exception
+	 * and put the referenced address to addr.
+	 */
+
+	/* sign extend offset */
+	offset = opcode & OFFSET;
+	offset <<= 16;
+	offset >>= 16;
+
+	vaddr = (unsigned long __user *)
+	        ((unsigned long)(MIPS_READ_REG_L(regs->regs[(opcode & BASE) >> 21])) + offset);
+	reg = (opcode & RT) >> 16;
+
+	if ((unsigned long)vaddr & 7)
+		return SIGBUS;
+
+	preempt_disable();
+
+	if (ll_bit == 0 || ll_task != current) {
+		MIPS_WRITE_REG(regs->regs[reg]) = 0;
+		preempt_enable();
+		return 0;
+	}
+
+	preempt_enable();
+
+	if (put_user(MIPS_READ_REG(regs->regs[reg]), vaddr))
+		return SIGSEGV;
+
+	MIPS_WRITE_REG(regs->regs[reg]) = 1;
+
+	return 0;
+}
+#endif
+
 /*
  * ll uses the opcode of lwc0 and sc uses the opcode of swc0.  That is both
  * opcodes are supposed to result in coprocessor unusable exceptions if
@@ -574,6 +684,13 @@ static int simulate_llsc(struct pt_regs
 		return simulate_ll(regs, opcode);
 	if ((opcode & OPCODE) == SC)
 		return simulate_sc(regs, opcode);
+#ifdef CONFIG_R5900_128BIT_SUPPORT
+	/* lld and scd are not supported by r5900, but it supported mips3. */
+	if ((opcode & OPCODE) == LLD)
+		return simulate_lld(regs, opcode);
+	if ((opcode & OPCODE) == SCD)
+		return simulate_scd(regs, opcode);
+#endif
 
 	return -1;			/* Must be something else ... */
 }
@@ -591,27 +708,27 @@ static int simulate_rdhwr(struct pt_regs
 		int rt = (opcode & RT) >> 16;
 		switch (rd) {
 		case 0:		/* CPU number */
-			regs->regs[rt] = smp_processor_id();
+			MIPS_WRITE_REG(regs->regs[rt]) = smp_processor_id();
 			return 0;
 		case 1:		/* SYNCI length */
-			regs->regs[rt] = min(current_cpu_data.dcache.linesz,
+			MIPS_WRITE_REG(regs->regs[rt]) = min(current_cpu_data.dcache.linesz,
 					     current_cpu_data.icache.linesz);
 			return 0;
 		case 2:		/* Read count register */
-			regs->regs[rt] = read_c0_count();
+			MIPS_WRITE_REG(regs->regs[rt]) = read_c0_count();
 			return 0;
 		case 3:		/* Count register resolution */
 			switch (current_cpu_data.cputype) {
 			case CPU_20KC:
 			case CPU_25KF:
-				regs->regs[rt] = 1;
+				MIPS_WRITE_REG(regs->regs[rt]) = 1;
 				break;
 			default:
-				regs->regs[rt] = 2;
+				MIPS_WRITE_REG(regs->regs[rt]) = 2;
 			}
 			return 0;
 		case 29:
-			regs->regs[rt] = ti->tp_value;
+			MIPS_WRITE_REG(regs->regs[rt]) = ti->tp_value;
 			return 0;
 		default:
 			return -1;
@@ -630,6 +747,167 @@ static int simulate_sync(struct pt_regs
 	return -1;			/* Must be something else ... */
 }
 
+#ifdef CONFIG_CPU_R5900
+typedef unsigned int UDItype	__attribute__ ((mode (DI)));
+
+UDItype __udivmoddi4(UDItype n, UDItype d, UDItype *rp);
+
+/** Multiply 64 bit x 64 bit = 128 bit (all unsigned). */
+void dmultu(uint64_t *hi, uint64_t *lo, uint64_t a, uint64_t b)
+{
+	/* Devide input into 32 bit parts. */
+	uint64_t alo = a & 0xFFFFFFFF;
+	uint64_t ahi = (a >> 32) & 0xFFFFFFFF;
+	uint64_t blo = b & 0xFFFFFFFF;
+	uint64_t bhi = (b >> 32) & 0xFFFFFFFF;
+	uint64_t x0; /* bits 32..0 of result including overflow bits. */
+	uint64_t x32; /* bits 63..32 of result including overflow bits. */
+	uint64_t x64; /* bits 127..64 of result. */
+
+	/* Use binomial formula to calculate ((ahi << 32) + alo) * ((bhi << 32) + blo). */
+	x0 = alo * blo;
+	x32 = ahi * blo;
+	x64 = ahi * bhi;
+
+	/* Handle overflow bits of x32. */
+	x64 += x32 >> 32;
+	x32 = (uint32_t) x32;
+
+	/* Handle overflow bits of x0. */
+	x32 += x0 >> 32;
+	x0 = (uint32_t) x0;
+
+	/* Handle overflow bits of x32. */
+	x64 += x32 >> 32;
+	x32 = (uint32_t) x32;
+
+	x32 += alo * bhi;
+
+	/* Handle overflow bits of x32. */
+	x64 += x32 >> 32;
+	x32 = (uint32_t) x32;
+
+	/* Get bits 63..0 */
+	*lo = (x32 << 32) + x0;
+	/* Get bits 127..64 */
+	*hi = x64;
+}
+
+/** Multiply 64 bit x 64 bit = 128 bit (all signed). */
+void dmult(uint64_t *hi, uint64_t *lo, int64_t a, int64_t b)
+{
+	uint64_t ax;
+	uint64_t bx;
+
+	if (a < 0) {
+		/* Value is negative, use positive value for calculation. */
+		ax = -a;
+	} else {
+		ax = a;
+	}
+	if (b < 0) {
+		/* Value is negative, use positive value for calculation. */
+		bx = -b;
+	} else {
+		bx = b;
+	}
+	/* Use multiplication function for unsigned values. */
+	dmultu(hi, lo, ax, bx);
+
+	/* Check if negative and positive value is calculated. Fix sign if so. */
+	if ((a < 0) ^ (b < 0)) {
+		uint64_t x0; /* bits 31..0 of result including overflow. */
+		uint64_t x32; /* bits 63..32 of result including overflow. */
+		uint64_t x64; /* bits 95..64 of result including overflow. */
+		uint64_t x96; /* bits 127..96 of result including overflow. */
+
+		/* Calculate 2's complement. */
+
+		/* Invert all bits. */
+		*hi = ~*hi;
+		*lo = ~*lo;
+
+		x0 = (uint32_t) *lo;
+		x32 = (uint32_t) (*lo >> 32);
+		x64 = (uint32_t) *hi;
+		x96 = (uint32_t) (*hi >> 32);
+
+		/* Add one and handle overflow. */
+		x0 += 1;
+		x32 += x0 >> 32;
+		x0 = (uint32_t) x0;
+		x64 += x32 >> 32;
+		x32 = (uint32_t) x32;
+		x96 += x64 >> 32;
+		x64 = (uint32_t) x64;
+
+		*lo = x0 + (x32 << 32);
+		*hi = x64 + (x96 << 32);
+	}
+}
+
+static int simulate_mips3(struct pt_regs *regs, unsigned int opcode)
+{
+	int rv = -1;
+
+	/* Emulate missing 64 bit instructions. */
+	if ((opcode & OPCODE) == SPEC0) {
+		int rt;
+		int rs;
+
+		rt = (opcode & RT) >> 16;
+		rs = (opcode & RS) >> 21;
+		switch(opcode & FUNC) {
+		case DMULT:
+			/* Emulate 64 bit calculation. */
+			dmult(&regs->hi, &regs->lo,
+				MIPS_READ_REG_S(regs->regs[rt]),
+				MIPS_READ_REG_S(regs->regs[rs]));
+			rv = 0;
+			break;
+
+		case DMULTU:
+			/* Emulate 64 bit calculation. */
+			dmultu(&regs->hi, &regs->lo,
+				MIPS_READ_REG(regs->regs[rt]),
+				MIPS_READ_REG(regs->regs[rs]));
+			rv = 0;
+			break;
+
+		case DDIV:
+			if (MIPS_READ_REG_S(regs->regs[rt]) == 0) {
+				/* The result is undefined. */
+				regs->lo = 0;
+				regs->hi = 0;
+			} else {
+				/* TBD: Optimize, use one function for calculation divisor and remainder at the same time. */
+				regs->lo = MIPS_READ_REG_S(regs->regs[rs]) / MIPS_READ_REG_S(regs->regs[rt]);
+				regs->hi = MIPS_READ_REG_S(regs->regs[rs]) % MIPS_READ_REG_S(regs->regs[rt]);
+			}
+			rv = 0;
+			break;
+
+		case DDIVU:
+			if (MIPS_READ_REG_S(regs->regs[rt]) == 0) {
+				/* The result is undefined. */
+				regs->lo = 0;
+				regs->hi = 0;
+			} else {
+				regs->lo = __udivmoddi4(MIPS_READ_REG(regs->regs[rs]), MIPS_READ_REG(regs->regs[rt]), &regs->hi);
+			}
+			rv = 0;
+			break;
+		default:
+			/* Must be something else ... */
+			rv = -1;
+			break;
+		}
+	}
+
+	return rv;
+}
+#endif
+
 asmlinkage void do_ov(struct pt_regs *regs)
 {
 	siginfo_t info;
@@ -836,6 +1114,38 @@ asmlinkage void do_ri(struct pt_regs *re
 	if (status < 0)
 		status = simulate_sync(regs, opcode);
 
+#ifdef CONFIG_CPU_R5900
+	if (status < 0)
+		status = simulate_mips3(regs, opcode);
+
+	/* R5900 supports 32 bit FPU operation, but no 64 bit instructions. */
+	/* The instructions are reserved on this CPU. */
+	/* We need to emulate it here. */
+	if (status < 0) {
+		/* Undo skip-over.  */
+		regs->cp0_epc = old_epc;
+
+		/* Assume that this is an FPU instruction and prepare FPU.
+		 * If this assumption is wrong, this will only cost time.
+		 */
+		if (used_math())	/* Using the FPU again.  */
+			own_fpu(1);
+		else {			/* First time FPU user.  */
+			init_fpu();
+			set_used_math();
+		}
+
+		/* Ensure 'resume' not overwrite saved fp context again. */
+		lose_fpu(1);
+
+		/* Run the emulator */
+		status = fpu_emulator_cop1Handler(regs, &current->thread.fpu, 1);
+
+		/* Restore the hardware register state */
+		own_fpu(1);	/* Using the FPU again.  */
+	}
+#endif
+
 	if (status < 0)
 		status = SIGILL;
 
@@ -1086,8 +1396,10 @@ asmlinkage void do_mt(struct pt_regs *re
 
 asmlinkage void do_dsp(struct pt_regs *regs)
 {
+#ifndef CONFIG_CPU_R5900
 	if (cpu_has_dsp)
 		panic("Unexpected DSP exception\n");
+#endif
 
 	force_sig(SIGILL, current);
 }
@@ -1301,12 +1613,36 @@ void __init *set_except_vector(int n, vo
 		u32 *buf = (u32 *)(ebase + 0x200);
 		unsigned int k0 = 26;
 		if ((handler & jump_mask) == ((ebase + 0x200) & jump_mask)) {
+#ifdef CONFIG_CPU_R5900
+			uasm_i_nop(&buf);
+			uasm_i_nop(&buf);
+#endif
 			uasm_i_j(&buf, handler & ~jump_mask);
 			uasm_i_nop(&buf);
+#ifdef CONFIG_CPU_R5900
+			/* There are no data allowed which could be interpreted as cache instruction. */
+			uasm_i_nop(&buf);
+			uasm_i_nop(&buf);
+			uasm_i_nop(&buf);
+			uasm_i_nop(&buf);
+			uasm_i_nop(&buf);
+#endif
 		} else {
+#ifdef CONFIG_CPU_R5900
+			uasm_i_nop(&buf);
+			uasm_i_nop(&buf);
+#endif
 			UASM_i_LA(&buf, k0, handler);
 			uasm_i_jr(&buf, k0);
 			uasm_i_nop(&buf);
+#ifdef CONFIG_CPU_R5900
+			/* There are no data allowed which could be interpreted as cache instruction. */
+			uasm_i_nop(&buf);
+			uasm_i_nop(&buf);
+			uasm_i_nop(&buf);
+			uasm_i_nop(&buf);
+			uasm_i_nop(&buf);
+#endif
 		}
 		local_flush_icache_range(ebase + 0x200, (unsigned long)buf);
 	}
diff -purN linux-2.6.35.4-orig/arch/mips/kernel/unaligned.c linux-2.6.35.4/arch/mips/kernel/unaligned.c
--- linux-2.6.35.4-orig/arch/mips/kernel/unaligned.c	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/kernel/unaligned.c	2014-07-18 22:29:43.546367724 +0200
@@ -101,6 +101,9 @@ static u32 unaligned_action;
 #define unaligned_action UNALIGNED_ACTION_QUIET
 #endif
 extern void show_registers(struct pt_regs *regs);
+#ifdef CONFIG_CPU_R5900
+asmlinkage void do_ri(struct pt_regs *regs);
+#endif
 
 static void emulate_load_store_insn(struct pt_regs *regs,
 	void __user *addr, unsigned int __user *pc)
@@ -109,7 +112,7 @@ static void emulate_load_store_insn(stru
 	unsigned long value;
 	unsigned int res;
 
-	regs->regs[0] = 0;
+	MIPS_WRITE_REG(regs->regs[0]) = 0;
 
 	/*
 	 * This load never faults.
@@ -159,7 +162,14 @@ static void emulate_load_store_insn(stru
 			"2:\tlbu\t$1, 1(%2)\n\t"
 #endif
 #ifdef __LITTLE_ENDIAN
+#ifdef CONFIG_CPU_R5900
+			/* In an error exception handler the user space could be uncached. */
+			"sync.l\n\t"
+#endif
 			"1:\tlb\t%0, 1(%2)\n"
+#ifdef CONFIG_CPU_R5900
+			"sync.l\n\t"
+#endif
 			"2:\tlbu\t$1, 0(%2)\n\t"
 #endif
 			"sll\t%0, 0x8\n\t"
@@ -179,7 +189,7 @@ static void emulate_load_store_insn(stru
 		if (res)
 			goto fault;
 		compute_return_epc(regs);
-		regs->regs[insn.i_format.rt] = value;
+		MIPS_WRITE_REG(regs->regs[insn.i_format.rt]) = value;
 		break;
 
 	case lw_op:
@@ -192,7 +202,14 @@ static void emulate_load_store_insn(stru
 			"2:\tlwr\t%0, 3(%2)\n\t"
 #endif
 #ifdef __LITTLE_ENDIAN
+#ifdef CONFIG_CPU_R5900
+			/* In an error exception handler the user space could be uncached. */
+			"sync.l\n\t"
+#endif
 			"1:\tlwl\t%0, 3(%2)\n"
+#ifdef CONFIG_CPU_R5900
+			"sync.l\n\t"
+#endif
 			"2:\tlwr\t%0, (%2)\n\t"
 #endif
 			"li\t%1, 0\n"
@@ -209,7 +226,7 @@ static void emulate_load_store_insn(stru
 		if (res)
 			goto fault;
 		compute_return_epc(regs);
-		regs->regs[insn.i_format.rt] = value;
+		MIPS_WRITE_REG(regs->regs[insn.i_format.rt]) = value;
 		break;
 
 	case lhu_op:
@@ -223,7 +240,14 @@ static void emulate_load_store_insn(stru
 			"2:\tlbu\t$1, 1(%2)\n\t"
 #endif
 #ifdef __LITTLE_ENDIAN
+#ifdef CONFIG_CPU_R5900
+			/* In an error exception handler the user space could be uncached. */
+			"sync.l\n\t"
+#endif
 			"1:\tlbu\t%0, 1(%2)\n"
+#ifdef CONFIG_CPU_R5900
+			"sync.l\n\t"
+#endif
 			"2:\tlbu\t$1, 0(%2)\n\t"
 #endif
 			"sll\t%0, 0x8\n\t"
@@ -243,11 +267,11 @@ static void emulate_load_store_insn(stru
 		if (res)
 			goto fault;
 		compute_return_epc(regs);
-		regs->regs[insn.i_format.rt] = value;
+		MIPS_WRITE_REG(regs->regs[insn.i_format.rt]) = value;
 		break;
 
 	case lwu_op:
-#ifdef CONFIG_64BIT
+#if defined(CONFIG_64BIT) || defined(CONFIG_R5900_128BIT_SUPPORT)
 		/*
 		 * A 32-bit kernel might be running on a 64-bit processor.  But
 		 * if we're on a 32-bit processor and an i-cache incoherency
@@ -259,31 +283,41 @@ static void emulate_load_store_insn(stru
 			goto sigbus;
 
 		__asm__ __volatile__ (
+			".set push\n"
 #ifdef __BIG_ENDIAN
 			"1:\tlwl\t%0, (%2)\n"
 			"2:\tlwr\t%0, 3(%2)\n\t"
 #endif
 #ifdef __LITTLE_ENDIAN
+#ifdef CONFIG_CPU_R5900
+			".set arch=r5900\n\t"
+			/* In an error exception handler the user space could be uncached. */
+			"sync.l\n\t"
+#endif
 			"1:\tlwl\t%0, 3(%2)\n"
+#ifdef CONFIG_CPU_R5900
+			"sync.l\n\t"
+#endif
 			"2:\tlwr\t%0, (%2)\n\t"
 #endif
 			"dsll\t%0, %0, 32\n\t"
 			"dsrl\t%0, %0, 32\n\t"
-			"li\t%1, 0\n"
+			"sd\t%0, 0(%1)\n\t"
+			"li\t%0, 0\n\t"
+			".set pop\n"
 			"3:\t.section\t.fixup,\"ax\"\n\t"
-			"4:\tli\t%1, %3\n\t"
+			"4:\tli\t%0, %3\n\t"
 			"j\t3b\n\t"
 			".previous\n\t"
 			".section\t__ex_table,\"a\"\n\t"
 			STR(PTR)"\t1b, 4b\n\t"
 			STR(PTR)"\t2b, 4b\n\t"
 			".previous"
-			: "=&r" (value), "=r" (res)
-			: "r" (addr), "i" (-EFAULT));
+			: "=&r" (res)
+			: "r"(&MIPS_READ_REG(regs->regs[insn.i_format.rt])), "r" (addr), "i" (-EFAULT));
 		if (res)
 			goto fault;
 		compute_return_epc(regs);
-		regs->regs[insn.i_format.rt] = value;
 		break;
 #endif /* CONFIG_64BIT */
 
@@ -291,7 +325,7 @@ static void emulate_load_store_insn(stru
 		goto sigill;
 
 	case ld_op:
-#ifdef CONFIG_64BIT
+#if defined(CONFIG_64BIT) || defined(CONFIG_R5900_128BIT_SUPPORT)
 		/*
 		 * A 32-bit kernel might be running on a 64-bit processor.  But
 		 * if we're on a 32-bit processor and an i-cache incoherency
@@ -303,29 +337,39 @@ static void emulate_load_store_insn(stru
 			goto sigbus;
 
 		__asm__ __volatile__ (
+			".set push\n"
 #ifdef __BIG_ENDIAN
 			"1:\tldl\t%0, (%2)\n"
 			"2:\tldr\t%0, 7(%2)\n\t"
 #endif
 #ifdef __LITTLE_ENDIAN
+#ifdef CONFIG_CPU_R5900
+			".set arch=r5900\n\t"
+			/* In an error exception handler the user space could be uncached. */
+			"sync.l\n\t"
+#endif
 			"1:\tldl\t%0, 7(%2)\n"
+#ifdef CONFIG_CPU_R5900
+			"sync.l\n\t"
+#endif
 			"2:\tldr\t%0, (%2)\n\t"
 #endif
-			"li\t%1, 0\n"
+			"sd\t%0, 0(%1)\n"
+			"li\t%0, 0\n\t"
+			".set pop\n"
 			"3:\t.section\t.fixup,\"ax\"\n\t"
-			"4:\tli\t%1, %3\n\t"
+			"4:\tli\t%0, %3\n\t"
 			"j\t3b\n\t"
 			".previous\n\t"
 			".section\t__ex_table,\"a\"\n\t"
 			STR(PTR)"\t1b, 4b\n\t"
 			STR(PTR)"\t2b, 4b\n\t"
 			".previous"
-			: "=&r" (value), "=r" (res)
-			: "r" (addr), "i" (-EFAULT));
+			: "=&r" (res)
+			: "r"(&MIPS_READ_REG(regs->regs[insn.i_format.rt])), "r" (addr), "i" (-EFAULT));
 		if (res)
 			goto fault;
 		compute_return_epc(regs);
-		regs->regs[insn.i_format.rt] = value;
 		break;
 #endif /* CONFIG_64BIT */
 
@@ -336,7 +380,7 @@ static void emulate_load_store_insn(stru
 		if (!access_ok(VERIFY_WRITE, addr, 2))
 			goto sigbus;
 
-		value = regs->regs[insn.i_format.rt];
+		value = MIPS_READ_REG(regs->regs[insn.i_format.rt]);
 		__asm__ __volatile__ (
 #ifdef __BIG_ENDIAN
 			".set\tnoat\n"
@@ -347,8 +391,15 @@ static void emulate_load_store_insn(stru
 #endif
 #ifdef __LITTLE_ENDIAN
 			".set\tnoat\n"
+#ifdef CONFIG_CPU_R5900
+			/* In an error exception handler the user space could be uncached. */
+			"sync.l\n\t"
+#endif
 			"1:\tsb\t%1, 0(%2)\n\t"
 			"srl\t$1,%1, 0x8\n"
+#ifdef CONFIG_CPU_R5900
+			"sync.l\n\t"
+#endif
 			"2:\tsb\t$1, 1(%2)\n\t"
 			".set\tat\n\t"
 #endif
@@ -373,14 +424,21 @@ static void emulate_load_store_insn(stru
 		if (!access_ok(VERIFY_WRITE, addr, 4))
 			goto sigbus;
 
-		value = regs->regs[insn.i_format.rt];
+		value = MIPS_READ_REG(regs->regs[insn.i_format.rt]);
 		__asm__ __volatile__ (
 #ifdef __BIG_ENDIAN
 			"1:\tswl\t%1,(%2)\n"
 			"2:\tswr\t%1, 3(%2)\n\t"
 #endif
 #ifdef __LITTLE_ENDIAN
+#ifdef CONFIG_CPU_R5900
+			/* In an error exception handler the user space could be uncached. */
+			"sync.l\n\t"
+#endif
 			"1:\tswl\t%1, 3(%2)\n"
+#ifdef CONFIG_CPU_R5900
+			"sync.l\n\t"
+#endif
 			"2:\tswr\t%1, (%2)\n\t"
 #endif
 			"li\t%0, 0\n"
@@ -401,7 +459,7 @@ static void emulate_load_store_insn(stru
 		break;
 
 	case sd_op:
-#ifdef CONFIG_64BIT
+#if defined(CONFIG_64BIT) || defined(CONFIG_R5900_128BIT_SUPPORT)
 		/*
 		 * A 32-bit kernel might be running on a 64-bit processor.  But
 		 * if we're on a 32-bit processor and an i-cache incoherency
@@ -412,14 +470,23 @@ static void emulate_load_store_insn(stru
 		if (!access_ok(VERIFY_WRITE, addr, 8))
 			goto sigbus;
 
-		value = regs->regs[insn.i_format.rt];
 		__asm__ __volatile__ (
+			".set push\n\t"
+			".set arch=r5900\n\t"
+			"LD %1, 0(%1)\n\t"
 #ifdef __BIG_ENDIAN
 			"1:\tsdl\t%1,(%2)\n"
 			"2:\tsdr\t%1, 7(%2)\n\t"
 #endif
 #ifdef __LITTLE_ENDIAN
+#ifdef CONFIG_CPU_R5900
+			/* In an error exception handler the user space could be uncached. */
+			"sync.l\n\t"
+#endif
 			"1:\tsdl\t%1, 7(%2)\n"
+#ifdef CONFIG_CPU_R5900
+			"sync.l\n\t"
+#endif
 			"2:\tsdr\t%1, (%2)\n\t"
 #endif
 			"li\t%0, 0\n"
@@ -433,7 +500,7 @@ static void emulate_load_store_insn(stru
 			STR(PTR)"\t2b, 4b\n\t"
 			".previous"
 		: "=r" (res)
-		: "r" (value), "r" (addr), "i" (-EFAULT));
+		: "r" (&MIPS_READ_REG(regs->regs[insn.i_format.rt])), "r" (addr), "i" (-EFAULT));
 		if (res)
 			goto fault;
 		compute_return_epc(regs);
@@ -473,6 +540,13 @@ static void emulate_load_store_insn(stru
 		cu2_notifier_call_chain(CU2_SDC2_OP, regs);
 		break;
 
+#ifdef CONFIG_CPU_R5900
+	case spec3_op:
+		/* On R5900 it is possible that illegal opcode generates a fetch exception. */
+		do_ri(regs);
+		return;
+#endif
+
 	default:
 		/*
 		 * Pheeee...  We encountered an yet unknown instruction or
diff -purN linux-2.6.35.4-orig/arch/mips/kernel/vdso.c linux-2.6.35.4/arch/mips/kernel/vdso.c
--- linux-2.6.35.4-orig/arch/mips/kernel/vdso.c	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/kernel/vdso.c	2014-07-18 22:29:43.546367724 +0200
@@ -51,6 +51,10 @@ static int __init init_vdso(void)
 	install_trampoline(vdso->rt_signal_trampoline, __NR_rt_sigreturn);
 #ifdef CONFIG_32BIT
 	install_trampoline(vdso->signal_trampoline, __NR_sigreturn);
+#ifdef CONFIG_MIPS_N32
+	install_trampoline(vdso->n32_rt_signal_trampoline,
+			   __NR_N32_rt_sigreturn);
+#endif
 #else
 	install_trampoline(vdso->n32_rt_signal_trampoline,
 			   __NR_N32_rt_sigreturn);
diff -purN linux-2.6.35.4-orig/arch/mips/lib/csum_partial.S linux-2.6.35.4/arch/mips/lib/csum_partial.S
--- linux-2.6.35.4-orig/arch/mips/lib/csum_partial.S	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/lib/csum_partial.S	2014-07-18 22:29:43.546367724 +0200
@@ -110,7 +110,7 @@ LEAF(csum_partial)
 	 andi	t8, src, 0x2
 
 	lbu	t0, (src)
-	LONG_SUBU	a1, a1, 0x1
+	LONGI_SUBU	a1, a1, 0x1
 #ifdef __MIPSEL__
 	sll	t0, t0, 8
 #endif
@@ -123,7 +123,7 @@ LEAF(csum_partial)
 	 sltiu	t8, a1, 56
 
 	lhu	t0, (src)
-	LONG_SUBU	a1, a1, 0x2
+	LONGI_SUBU	a1, a1, 0x2
 	ADDC(sum, t0)
 	sltiu	t8, a1, 56
 	PTR_ADDU	src, src, 0x2
@@ -137,7 +137,7 @@ LEAF(csum_partial)
 	 andi	t8, src, 0x8
 
 	LOAD32	t0, 0x00(src)
-	LONG_SUBU	a1, a1, 0x4
+	LONGI_SUBU	a1, a1, 0x4
 	ADDC(sum, t0)
 	PTR_ADDU	src, src, 0x4
 	andi	t8, src, 0x8
@@ -148,12 +148,12 @@ LEAF(csum_partial)
 
 #ifdef USE_DOUBLE
 	ld	t0, 0x00(src)
-	LONG_SUBU	a1, a1, 0x8
+	LONGI_SUBU	a1, a1, 0x8
 	ADDC(sum, t0)
 #else
 	lw	t0, 0x00(src)
 	lw	t1, 0x04(src)
-	LONG_SUBU	a1, a1, 0x8
+	LONGI_SUBU	a1, a1, 0x8
 	ADDC(sum, t0)
 	ADDC(sum, t1)
 #endif
@@ -162,7 +162,7 @@ LEAF(csum_partial)
 
 .Loword_align:
 	beqz	t8, .Lbegin_movement
-	 LONG_SRL	t8, a1, 0x7
+	 LONGI_SRL	t8, a1, 0x7
 
 #ifdef USE_DOUBLE
 	ld	t0, 0x00(src)
@@ -172,9 +172,9 @@ LEAF(csum_partial)
 #else
 	CSUM_BIGCHUNK1(src, 0x00, sum, t0, t1, t3, t4)
 #endif
-	LONG_SUBU	a1, a1, 0x10
+	LONGI_SUBU	a1, a1, 0x10
 	PTR_ADDU	src, src, 0x10
-	LONG_SRL	t8, a1, 0x7
+	LONGI_SRL	t8, a1, 0x7
 
 .Lbegin_movement:
 	beqz	t8, 1f
@@ -185,7 +185,7 @@ LEAF(csum_partial)
 	CSUM_BIGCHUNK(src, 0x20, sum, t0, t1, t3, t4)
 	CSUM_BIGCHUNK(src, 0x40, sum, t0, t1, t3, t4)
 	CSUM_BIGCHUNK(src, 0x60, sum, t0, t1, t3, t4)
-	LONG_SUBU	t8, t8, 0x01
+	LONGI_SUBU	t8, t8, 0x01
 	.set	reorder				/* DADDI_WAR */
 	PTR_ADDU	src, src, 0x80
 	bnez	t8, .Lmove_128bytes
@@ -212,11 +212,11 @@ LEAF(csum_partial)
 .Ldo_end_words:
 	beqz	t8, .Lsmall_csumcpy
 	 andi	t2, a1, 0x3
-	LONG_SRL	t8, t8, 0x2
+	LONGI_SRL	t8, t8, 0x2
 
 .Lend_words:
 	LOAD32	t0, (src)
-	LONG_SUBU	t8, t8, 0x1
+	LONGI_SUBU	t8, t8, 0x1
 	ADDC(sum, t0)
 	.set	reorder				/* DADDI_WAR */
 	PTR_ADDU	src, src, 0x4
@@ -327,11 +327,22 @@ LEAF(csum_partial)
  * These handlers do not need to overwrite any data.
  */
 
+#ifdef CONFIG_CPU_R5900
 #define EXC(inst_reg,addr,handler)		\
+	/* In an error exception handler the user space could be uncached. */ \
+	sync.l;						\
 9:	inst_reg, addr;				\
 	.section __ex_table,"a";		\
 	PTR	9b, handler;			\
 	.previous
+#else
+#define EXC(inst_reg,addr,handler)		\
+	/* In an error exception handler the user space could be uncached. */ \
+9:	inst_reg, addr;				\
+	.section __ex_table,"a";		\
+	PTR	9b, handler;			\
+	.previous
+#endif
 
 #ifdef USE_DOUBLE
 
diff -purN linux-2.6.35.4-orig/arch/mips/lib/Makefile linux-2.6.35.4/arch/mips/lib/Makefile
--- linux-2.6.35.4-orig/arch/mips/lib/Makefile	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/lib/Makefile	2014-07-18 22:29:43.546367724 +0200
@@ -19,6 +19,7 @@ obj-$(CONFIG_CPU_R4X00)		+= dump_tlb.o
 obj-$(CONFIG_CPU_R5000)		+= dump_tlb.o
 obj-$(CONFIG_CPU_R5432)		+= dump_tlb.o
 obj-$(CONFIG_CPU_R5500)		+= dump_tlb.o
+obj-$(CONFIG_CPU_R5900)		+= dump_tlb.o
 obj-$(CONFIG_CPU_R6000)		+=
 obj-$(CONFIG_CPU_R8000)		+=
 obj-$(CONFIG_CPU_RM7000)	+= dump_tlb.o
@@ -31,3 +32,4 @@ obj-$(CONFIG_CPU_CAVIUM_OCTEON)	+= dump_
 
 # libgcc-style stuff needed in the kernel
 obj-y += ashldi3.o ashrdi3.o cmpdi2.o lshrdi3.o ucmpdi2.o
+obj-$(CONFIG_CPU_R5900) += muldi3.o udivdi3.o
diff -purN linux-2.6.35.4-orig/arch/mips/lib/memcpy-inatomic.S linux-2.6.35.4/arch/mips/lib/memcpy-inatomic.S
--- linux-2.6.35.4-orig/arch/mips/lib/memcpy-inatomic.S	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/lib/memcpy-inatomic.S	2014-07-18 22:29:43.546367724 +0200
@@ -85,11 +85,21 @@
  * they're not protected.
  */
 
+#ifdef CONFIG_CPU_R5900
 #define EXC(inst_reg,addr,handler)		\
+	/* In an error exception handler the user space could be uncached. */ \
+	sync.l;					\
 9:	inst_reg, addr;				\
 	.section __ex_table,"a";		\
 	PTR	9b, handler;			\
 	.previous
+#else
+#define EXC(inst_reg,addr,handler)		\
+9:	inst_reg, addr;				\
+	.section __ex_table,"a";		\
+	PTR	9b, handler;			\
+	.previous
+#endif
 
 /*
  * Only on the 64-bit kernel we can made use of 64-bit registers.
@@ -437,6 +447,10 @@ EXC(	lb	t0, NBYTES-2(src), .Ll_exc)
 EXC(	lb	t1, 0(src),	.Ll_exc)
 	ADD	src, src, 1
 	sb	t1, 0(dst)	# can't fault -- we're copy_from_user
+#ifdef CONFIG_CPU_R5900
+	nop
+	nop
+#endif
 	.set	reorder				/* DADDI_WAR */
 	ADD	dst, dst, 1
 	bne	src, t0, 1b
diff -purN linux-2.6.35.4-orig/arch/mips/lib/memcpy.S linux-2.6.35.4/arch/mips/lib/memcpy.S
--- linux-2.6.35.4-orig/arch/mips/lib/memcpy.S	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/lib/memcpy.S	2014-07-18 22:29:43.546367724 +0200
@@ -85,11 +85,21 @@
  * they're not protected.
  */
 
+#ifdef CONFIG_CPU_R5900
 #define EXC(inst_reg,addr,handler)		\
+	/* In an error exception handler the user space could be uncached. */ \
+	sync.l;					\
 9:	inst_reg, addr;				\
 	.section __ex_table,"a";		\
 	PTR	9b, handler;			\
 	.previous
+#else
+#define EXC(inst_reg,addr,handler)		\
+9:	inst_reg, addr;				\
+	.section __ex_table,"a";		\
+	PTR	9b, handler;			\
+	.previous
+#endif
 
 /*
  * Only on the 64-bit kernel we can made use of 64-bit registers.
@@ -226,6 +236,13 @@ FEXPORT(__copy_user)
 	 */
 .Lboth_aligned:
 	 SRL	t0, len, LOG_NBYTES+3    # +3 for 8 units/iter
+#ifdef CONFIG_CPU_R5900
+	/* no short loop. */
+	nop
+	nop
+	nop
+	nop
+#endif
 	beqz	t0, .Lcleanup_both_aligned # len < 8*NBYTES
 	 and	rem, len, (8*NBYTES-1)	 # rem = len % (8*NBYTES)
 	PREF(	0, 3*32(src) )
@@ -410,8 +427,9 @@ EXC(	STORE	t0, 0(dst),		.Ls_exc_p1u)
 #define COPY_BYTE(N)			\
 EXC(	lb	t0, N(src), .Ll_exc);	\
 	SUB	len, len, 1;		\
+EXC(	 sb	t0, N(dst), .Ls_exc_p1) \
 	beqz	len, .Ldone;		\
-EXC(	 sb	t0, N(dst), .Ls_exc_p1)
+	nop
 
 	COPY_BYTE(0)
 	COPY_BYTE(1)
@@ -423,8 +441,9 @@ EXC(	 sb	t0, N(dst), .Ls_exc_p1)
 #endif
 EXC(	lb	t0, NBYTES-2(src), .Ll_exc)
 	SUB	len, len, 1
-	jr	ra
 EXC(	 sb	t0, NBYTES-2(dst), .Ls_exc_p1)
+	jr	ra
+	nop
 .Ldone:
 	jr	ra
 	 nop
@@ -450,6 +469,11 @@ EXC(	lb	t1, 0(src),	.Ll_exc)
 	sb	t1, 0(dst)	# can't fault -- we're copy_from_user
 	.set	reorder				/* DADDI_WAR */
 	ADD	dst, dst, 1
+#ifdef CONFIG_CPU_R5900
+	/* no short loop. */
+	nop
+	nop
+#endif
 	bne	src, t0, 1b
 	.set	noreorder
 .Ll_exc:
@@ -475,6 +499,11 @@ EXC(	lb	t1, 0(src),	.Ll_exc)
 	.set	noreorder
 1:	sb	zero, 0(dst)
 	ADD	dst, dst, 1
+#ifdef CONFIG_CPU_R5900
+	nop
+	nop
+	nop
+#endif
 #ifndef CONFIG_CPU_DADDI_WORKAROUNDS
 	bnez	src, 1b
 	 SUB	src, src, 1
@@ -541,6 +570,10 @@ LEAF(__rmemcpy)					/* a0=dst a1=src a2=
 	SUB	a2, a2, 0x1
 	sb	t0, -1(a0)
 	SUB	a1, a1, 0x1
+#ifdef CONFIG_CPU_R5900
+	/* no short loop. */
+	nop
+#endif
 	.set	reorder				/* DADDI_WAR */
 	SUB	a0, a0, 0x1
 	bnez	a2, .Lr_end_bytes
@@ -556,6 +589,10 @@ LEAF(__rmemcpy)					/* a0=dst a1=src a2=
 	SUB	a2, a2, 0x1
 	sb	t0, (a0)
 	ADD	a1, a1, 0x1
+#ifdef CONFIG_CPU_R5900
+	/* no short loop. */
+	nop
+#endif
 	.set	reorder				/* DADDI_WAR */
 	ADD	a0, a0, 0x1
 	bnez	a2, .Lr_end_bytes_up
diff -purN linux-2.6.35.4-orig/arch/mips/lib/memset.S linux-2.6.35.4/arch/mips/lib/memset.S
--- linux-2.6.35.4-orig/arch/mips/lib/memset.S	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/lib/memset.S	2014-07-18 22:29:43.546367724 +0200
@@ -19,30 +19,44 @@
 #define LONG_S_R sdr
 #endif
 
+#ifdef CONFIG_CPU_R5900
 #define EX(insn,reg,addr,handler)			\
+	.set	push;					\
+	.set	noreorder;				\
+	/* In an error exception handler the user space could be uncached. */ \
+	sync.l;						\
 9:	insn	reg, addr;				\
 	.section __ex_table,"a"; 			\
 	PTR	9b, handler; 				\
+	.set	pop;					\
 	.previous
+#else
+#define EX(insn,reg,addr,handler)			\
+9:	insn	reg, addr;				\
+	.section __ex_table,"a"; 			\
+	PTR	9b, handler; 				\
+	.previous
+#endif
 
 	.macro	f_fill64 dst, offset, val, fixup
-	EX(LONG_S, \val, (\offset +  0 * LONGSIZE)(\dst), \fixup)
-	EX(LONG_S, \val, (\offset +  1 * LONGSIZE)(\dst), \fixup)
-	EX(LONG_S, \val, (\offset +  2 * LONGSIZE)(\dst), \fixup)
-	EX(LONG_S, \val, (\offset +  3 * LONGSIZE)(\dst), \fixup)
-	EX(LONG_S, \val, (\offset +  4 * LONGSIZE)(\dst), \fixup)
-	EX(LONG_S, \val, (\offset +  5 * LONGSIZE)(\dst), \fixup)
-	EX(LONG_S, \val, (\offset +  6 * LONGSIZE)(\dst), \fixup)
-	EX(LONG_S, \val, (\offset +  7 * LONGSIZE)(\dst), \fixup)
+	/* TBD: Optimze speed with 128 bit or 64 bit register. */
+	EX(LONGI_S, \val, (\offset +  0 * LONGSIZE)(\dst), \fixup)
+	EX(LONGI_S, \val, (\offset +  1 * LONGSIZE)(\dst), \fixup)
+	EX(LONGI_S, \val, (\offset +  2 * LONGSIZE)(\dst), \fixup)
+	EX(LONGI_S, \val, (\offset +  3 * LONGSIZE)(\dst), \fixup)
+	EX(LONGI_S, \val, (\offset +  4 * LONGSIZE)(\dst), \fixup)
+	EX(LONGI_S, \val, (\offset +  5 * LONGSIZE)(\dst), \fixup)
+	EX(LONGI_S, \val, (\offset +  6 * LONGSIZE)(\dst), \fixup)
+	EX(LONGI_S, \val, (\offset +  7 * LONGSIZE)(\dst), \fixup)
 #if LONGSIZE == 4
-	EX(LONG_S, \val, (\offset +  8 * LONGSIZE)(\dst), \fixup)
-	EX(LONG_S, \val, (\offset +  9 * LONGSIZE)(\dst), \fixup)
-	EX(LONG_S, \val, (\offset + 10 * LONGSIZE)(\dst), \fixup)
-	EX(LONG_S, \val, (\offset + 11 * LONGSIZE)(\dst), \fixup)
-	EX(LONG_S, \val, (\offset + 12 * LONGSIZE)(\dst), \fixup)
-	EX(LONG_S, \val, (\offset + 13 * LONGSIZE)(\dst), \fixup)
-	EX(LONG_S, \val, (\offset + 14 * LONGSIZE)(\dst), \fixup)
-	EX(LONG_S, \val, (\offset + 15 * LONGSIZE)(\dst), \fixup)
+	EX(LONGI_S, \val, (\offset +  8 * LONGSIZE)(\dst), \fixup)
+	EX(LONGI_S, \val, (\offset +  9 * LONGSIZE)(\dst), \fixup)
+	EX(LONGI_S, \val, (\offset + 10 * LONGSIZE)(\dst), \fixup)
+	EX(LONGI_S, \val, (\offset + 11 * LONGSIZE)(\dst), \fixup)
+	EX(LONGI_S, \val, (\offset + 12 * LONGSIZE)(\dst), \fixup)
+	EX(LONGI_S, \val, (\offset + 13 * LONGSIZE)(\dst), \fixup)
+	EX(LONGI_S, \val, (\offset + 14 * LONGSIZE)(\dst), \fixup)
+	EX(LONGI_S, \val, (\offset + 15 * LONGSIZE)(\dst), \fixup)
 #endif
 	.endm
 
@@ -60,12 +74,12 @@ LEAF(memset)
 	 move		v0, a0			/* result */
 
 	andi		a1, 0xff		/* spread fillword */
-	LONG_SLL		t1, a1, 8
+	LONGI_SLL		t1, a1, 8
 	or		a1, t1
-	LONG_SLL		t1, a1, 16
+	LONGI_SLL		t1, a1, 16
 #if LONGSIZE == 8
 	or		a1, t1
-	LONG_SLL		t1, a1, 32
+	LONGI_SLL		t1, a1, 32
 #endif
 	or		a1, t1
 1:
@@ -74,6 +88,12 @@ FEXPORT(__bzero)
 	sltiu		t0, a2, LONGSIZE	/* very small region? */
 	bnez		t0, .Lsmall_memset
 	 andi		t0, a0, LONGMASK	/* aligned? */
+#ifdef CONFIG_CPU_R5900
+	/* no short loops. */
+	nop
+	nop
+	nop
+#endif
 
 #ifndef CONFIG_CPU_DADDI_WORKAROUNDS
 	beqz		t0, 1f
@@ -112,14 +132,29 @@ FEXPORT(__bzero)
 .Lmemset_partial:
 	R10KCBARRIER(0(ra))
 	PTR_LA		t1, 2f			/* where to start */
-#if LONGSIZE == 4
+#ifdef CONFIG_CPU_R5900
+	// Each instruction has a leading sync.l
+#if (LONGSIZE == 4)
+	.set		noat
+	// 2 instructions for 4 Byte.
+	LONGI_SLL	AT, t0, 1
+	PTR_SUBU	t1, AT
+	.set		at
+#else
+	// TBD: Verify memset for MIPS R5900 with 64 bit.
+	// 2 instructions for 8 Byte.
+	PTR_SUBU	t1, t0
+#endif
+#else
+#if (LONGSIZE == 4)
 	PTR_SUBU	t1, t0
 #else
 	.set		noat
-	LONG_SRL		AT, t0, 1
+	LONGI_SRL		AT, t0, 1
 	PTR_SUBU	t1, AT
 	.set		at
 #endif
+#endif
 	jr		t1
 	 PTR_ADDU	a0, t0			/* dest ptr */
 
@@ -148,6 +183,12 @@ FEXPORT(__bzero)
 
 1:	PTR_ADDIU	a0, 1			/* fill bytewise */
 	R10KCBARRIER(0(ra))
+#ifdef CONFIG_CPU_R5900
+	/* no short loops. */
+	nop
+	nop
+	nop
+#endif
 	bne		t1, a0, 1b
 	 sb		a1, -1(a0)
 
@@ -161,19 +202,19 @@ FEXPORT(__bzero)
 
 .Lfwd_fixup:
 	PTR_L		t0, TI_TASK($28)
-	LONG_L		t0, THREAD_BUADDR(t0)
+	LONGI_L		t0, THREAD_BUADDR(t0)
 	andi		a2, 0x3f
-	LONG_ADDU	a2, t1
+	LONGI_ADDU	a2, t1
 	jr		ra
-	 LONG_SUBU	a2, t0
+	 LONGI_SUBU	a2, t0
 
 .Lpartial_fixup:
 	PTR_L		t0, TI_TASK($28)
-	LONG_L		t0, THREAD_BUADDR(t0)
+	LONGI_L		t0, THREAD_BUADDR(t0)
 	andi		a2, LONGMASK
-	LONG_ADDU	a2, t1
+	LONGI_ADDU	a2, t1
 	jr		ra
-	 LONG_SUBU	a2, t0
+	 LONGI_SUBU	a2, t0
 
 .Llast_fixup:
 	jr		ra
diff -purN linux-2.6.35.4-orig/arch/mips/lib/muldi3.c linux-2.6.35.4/arch/mips/lib/muldi3.c
--- linux-2.6.35.4-orig/arch/mips/lib/muldi3.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/lib/muldi3.c	2014-07-18 22:29:43.546367724 +0200
@@ -0,0 +1,61 @@
+/* Code is copied from libgcc. */
+
+#define W_TYPE_SIZE (4 * BITS_PER_UNIT)
+#define Wtype	SItype
+#define UWtype	USItype
+#define HWtype	SItype
+#define UHWtype	USItype
+#define DWtype	DItype
+#define UDWtype	UDItype
+
+#if (__GNUC__ == 4) && (__GNUC_MINOR__ < 9) /* TBD: Not working with newer compiler. */
+#define umul_ppmm(w1, w0, u, v) \
+__asm__ ("multu %2,%3"						\
+   : "=l" ((USItype) (w0)),					\
+     "=h" ((USItype) (w1))					\
+   : "d" ((USItype) (u)),					\
+     "d" ((USItype) (v)))
+#else
+#define umul_ppmm(w1, w0, u, v) \
+__asm__ ("multu %2,%3\n"					\
+	"mfhi %1\n"						\
+   : "=l" ((USItype) (w0)),					\
+     "=d" ((USItype) (w1))					\
+   : "d" ((USItype) (u)),					\
+     "d" ((USItype) (v)))
+#endif
+
+#define __umulsidi3(u, v) \
+  ({DWunion __w;							\
+    umul_ppmm (__w.s.high, __w.s.low, u, v);				\
+    __w.ll; })
+
+typedef 	 int SItype	__attribute__ ((mode (SI)));
+typedef unsigned int USItype	__attribute__ ((mode (SI)));
+typedef		 int DItype	__attribute__ ((mode (DI)));
+typedef unsigned int UDItype	__attribute__ ((mode (DI)));
+
+#ifdef CONFIG_CPU_BIG_ENDIAN
+  struct DWstruct {Wtype high, low;};
+#else
+  struct DWstruct {Wtype low, high;};
+#endif
+
+typedef union
+{
+  struct DWstruct s;
+  DWtype ll;
+} DWunion;
+
+DWtype
+__muldi3 (DWtype u, DWtype v)
+{
+  const DWunion uu = {.ll = u};
+  const DWunion vv = {.ll = v};
+  DWunion w = {.ll = __umulsidi3 (uu.s.low, vv.s.low)};
+
+  w.s.high += ((UWtype) uu.s.low * (UWtype) vv.s.high
+	       + (UWtype) uu.s.high * (UWtype) vv.s.low);
+
+  return w.ll;
+}
diff -purN linux-2.6.35.4-orig/arch/mips/lib/strlen_user.S linux-2.6.35.4/arch/mips/lib/strlen_user.S
--- linux-2.6.35.4-orig/arch/mips/lib/strlen_user.S	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/lib/strlen_user.S	2014-07-18 22:29:43.546367724 +0200
@@ -10,11 +10,21 @@
 #include <asm/asm-offsets.h>
 #include <asm/regdef.h>
 
+#ifdef CONFIG_CPU_R5900
 #define EX(insn,reg,addr,handler)			\
+	/* In an error exception handler the user space could be uncached. */ \
+	sync.l;						\
 9:	insn	reg, addr;				\
 	.section __ex_table,"a";			\
 	PTR	9b, handler;				\
 	.previous
+#else
+#define EX(insn,reg,addr,handler)			\
+9:	insn	reg, addr;				\
+	.section __ex_table,"a";			\
+	PTR	9b, handler;				\
+	.previous
+#endif
 
 /*
  * Return the size of a string (including the ending 0)
@@ -22,7 +32,7 @@
  * Return 0 for error
  */
 LEAF(__strlen_user_asm)
-	LONG_L		v0, TI_ADDR_LIMIT($28)	# pointer ok?
+	LONGI_L		v0, TI_ADDR_LIMIT($28)	# pointer ok?
 	and		v0, a0
 	bnez		v0, .Lfault
 
@@ -30,6 +40,13 @@ FEXPORT(__strlen_user_nocheck_asm)
 	move		v0, a0
 1:	EX(lb, t0, (v0), .Lfault)
 	PTR_ADDIU	v0, 1
+#ifdef CONFIG_CPU_R5900
+	/* no short loops. */
+	nop
+	nop
+	nop
+	nop
+#endif
 	bnez		t0, 1b
 	PTR_SUBU	v0, a0
 	jr		ra
diff -purN linux-2.6.35.4-orig/arch/mips/lib/strncpy_user.S linux-2.6.35.4/arch/mips/lib/strncpy_user.S
--- linux-2.6.35.4-orig/arch/mips/lib/strncpy_user.S	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/lib/strncpy_user.S	2014-07-18 22:29:43.546367724 +0200
@@ -10,11 +10,21 @@
 #include <asm/asm-offsets.h>
 #include <asm/regdef.h>
 
+#ifdef CONFIG_CPU_R5900
 #define EX(insn,reg,addr,handler)			\
+	/* In an error exception handler the user space could be uncached. */ \
+	sync.l;						\
 9:	insn	reg, addr;				\
 	.section __ex_table,"a";			\
 	PTR	9b, handler;				\
 	.previous
+#else
+#define EX(insn,reg,addr,handler)			\
+9:	insn	reg, addr;				\
+	.section __ex_table,"a";			\
+	PTR	9b, handler;				\
+	.previous
+#endif
 
 /*
  * Returns: -EFAULT if exception before terminator, N if the entire
@@ -28,7 +38,7 @@
  */
 
 LEAF(__strncpy_from_user_asm)
-	LONG_L		v0, TI_ADDR_LIMIT($28)	# pointer ok?
+	LONGI_L		v0, TI_ADDR_LIMIT($28)	# pointer ok?
 	and		v0, a1
 	bnez		v0, .Lfault
 
@@ -40,10 +50,14 @@ FEXPORT(__strncpy_from_user_nocheck_asm)
 	PTR_ADDIU	v1, 1
 	R10KCBARRIER(0(ra))
 	beqz		t0, 2f
-	 sb		t0, (a0)
+	sb		t0, (a0)
 	PTR_ADDIU	v0, 1
 	.set		reorder
 	PTR_ADDIU	a0, 1
+#ifdef CONFIG_CPU_R5900
+	/* no short loops. */
+	nop
+#endif
 	bne		v0, a2, 1b
 2:	PTR_ADDU	t0, a1, v0
 	xor		t0, a1
diff -purN linux-2.6.35.4-orig/arch/mips/lib/strnlen_user.S linux-2.6.35.4/arch/mips/lib/strnlen_user.S
--- linux-2.6.35.4-orig/arch/mips/lib/strnlen_user.S	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/lib/strnlen_user.S	2014-07-18 22:29:43.546367724 +0200
@@ -10,11 +10,21 @@
 #include <asm/asm-offsets.h>
 #include <asm/regdef.h>
 
+#ifdef CONFIG_CPU_R5900
 #define EX(insn,reg,addr,handler)			\
+	/* In an error exception handler the user space could be uncached. */ \
+	sync.l;						\
 9:	insn	reg, addr;				\
 	.section __ex_table,"a";			\
 	PTR	9b, handler;				\
 	.previous
+#else
+#define EX(insn,reg,addr,handler)			\
+9:	insn	reg, addr;				\
+	.section __ex_table,"a";			\
+	PTR	9b, handler;				\
+	.previous
+#endif
 
 /*
  * Return the size of a string including the ending NUL character upto a
@@ -26,7 +36,7 @@
  *       the maximum is a tad hairier ...
  */
 LEAF(__strnlen_user_asm)
-	LONG_L		v0, TI_ADDR_LIMIT($28)	# pointer ok?
+	LONGI_L		v0, TI_ADDR_LIMIT($28)	# pointer ok?
 	and		v0, a0
 	bnez		v0, .Lfault
 
@@ -36,6 +46,12 @@ FEXPORT(__strnlen_user_nocheck_asm)
 1:	beq		v0, a1, 1f		# limit reached?
 	EX(lb, t0, (v0), .Lfault)
 	PTR_ADDU	v0, 1
+#ifdef CONFIG_CPU_R5900
+	/* no short loop. */
+	nop
+	nop
+	nop
+#endif
 	bnez		t0, 1b
 1:	PTR_SUBU	v0, a0
 	jr		ra
diff -purN linux-2.6.35.4-orig/arch/mips/lib/udivdi3.c linux-2.6.35.4/arch/mips/lib/udivdi3.c
--- linux-2.6.35.4-orig/arch/mips/lib/udivdi3.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/lib/udivdi3.c	2014-07-18 22:29:43.546367724 +0200
@@ -0,0 +1,408 @@
+/* Code is copied from libgcc. */
+
+/* number of bits in an addressable storage unit */
+#define BITS_PER_UNIT 8
+#define W_TYPE_SIZE (4 * BITS_PER_UNIT)
+#define Wtype	SItype
+#define UWtype	USItype
+#define HWtype	SItype
+#define UHWtype	USItype
+#define DWtype	DItype
+#define UDWtype	UDItype
+
+#define UDIV_NEEDS_NORMALIZATION 1
+#define udiv_qrnnd __udiv_qrnnd_c
+
+#define __BITS4 (W_TYPE_SIZE / 4)
+#define __ll_B ((UWtype) 1 << (W_TYPE_SIZE / 2))
+#define __ll_lowpart(t) ((UWtype) (t) & (__ll_B - 1))
+#define __ll_highpart(t) ((UWtype) (t) >> (W_TYPE_SIZE / 2))
+
+typedef 	 int SItype	__attribute__ ((mode (SI)));
+typedef unsigned int USItype	__attribute__ ((mode (SI)));
+typedef		 int DItype	__attribute__ ((mode (DI)));
+typedef unsigned int UDItype	__attribute__ ((mode (DI)));
+typedef unsigned int UQItype    __attribute__ ((mode (QI)));
+
+#ifdef CONFIG_CPU_BIG_ENDIAN
+  struct DWstruct {Wtype high, low;};
+#else
+  struct DWstruct {Wtype low, high;};
+#endif
+
+#if (__GNUC__ == 4) && (__GNUC_MINOR__ < 9) /* TBD: Not working with newer compiler. */
+#define umul_ppmm(w1, w0, u, v) \
+  __asm__ ("multu %2,%3"						\
+	   : "=l" ((USItype) (w0)),					\
+	     "=h" ((USItype) (w1))					\
+	   : "d" ((USItype) (u)),					\
+	     "d" ((USItype) (v)))
+#else
+#define umul_ppmm(w1, w0, u, v) \
+__asm__ ("multu %2,%3\n"					\
+	"mfhi %1\n"						\
+   : "=l" ((USItype) (w0)),					\
+     "=d" ((USItype) (w1))					\
+   : "d" ((USItype) (u)),					\
+     "d" ((USItype) (v)))
+#endif
+
+#define count_leading_zeros(count, x) \
+  do {									\
+    UWtype __xr = (x);							\
+    UWtype __a;								\
+									\
+    if (W_TYPE_SIZE <= 32)						\
+      {									\
+	__a = __xr < ((UWtype)1<<2*__BITS4)				\
+	  ? (__xr < ((UWtype)1<<__BITS4) ? 0 : __BITS4)			\
+	  : (__xr < ((UWtype)1<<3*__BITS4) ?  2*__BITS4 : 3*__BITS4);	\
+      }									\
+    else								\
+      {									\
+	for (__a = W_TYPE_SIZE - 8; __a > 0; __a -= 8)			\
+	  if (((__xr >> __a) & 0xff) != 0)				\
+	    break;							\
+      }									\
+									\
+    (count) = W_TYPE_SIZE - (__clz_tab[__xr >> __a] + __a);		\
+  } while (0)
+
+
+#define __udiv_qrnnd_c(q, r, n1, n0, d) \
+  do {									\
+    UWtype __d1, __d0, __q1, __q0;					\
+    UWtype __r1, __r0, __m;						\
+    __d1 = __ll_highpart (d);						\
+    __d0 = __ll_lowpart (d);						\
+									\
+    __r1 = (n1) % __d1;							\
+    __q1 = (n1) / __d1;							\
+    __m = (UWtype) __q1 * __d0;						\
+    __r1 = __r1 * __ll_B | __ll_highpart (n0);				\
+    if (__r1 < __m)							\
+      {									\
+	__q1--, __r1 += (d);						\
+	if (__r1 >= (d)) /* i.e. we didn't get carry when adding to __r1 */\
+	  if (__r1 < __m)						\
+	    __q1--, __r1 += (d);					\
+      }									\
+    __r1 -= __m;							\
+									\
+    __r0 = __r1 % __d1;							\
+    __q0 = __r1 / __d1;							\
+    __m = (UWtype) __q0 * __d0;						\
+    __r0 = __r0 * __ll_B | __ll_lowpart (n0);				\
+    if (__r0 < __m)							\
+      {									\
+	__q0--, __r0 += (d);						\
+	if (__r0 >= (d))						\
+	  if (__r0 < __m)						\
+	    __q0--, __r0 += (d);					\
+      }									\
+    __r0 -= __m;							\
+									\
+    (q) = (UWtype) __q1 * __ll_B | __q0;				\
+    (r) = __r0;								\
+  } while (0)
+
+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \
+  do {									\
+    UWtype __x;								\
+    __x = (al) - (bl);							\
+    (sh) = (ah) - (bh) - (__x > (al));					\
+    (sl) = __x;								\
+  } while (0)
+
+typedef union
+{
+  struct DWstruct s;
+  DWtype ll;
+} DWunion;
+
+const UQItype __clz_tab[256] =
+{
+  0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
+  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
+  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
+  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
+  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8
+};
+
+UDWtype
+__udivmoddi4 (UDWtype n, UDWtype d, UDWtype *rp)
+{
+  const DWunion nn = {.ll = n};
+  const DWunion dd = {.ll = d};
+  DWunion ww;
+  DWunion rr;
+  UWtype d0, d1, n0, n1, n2;
+  UWtype q0, q1;
+  UWtype b, bm;
+
+  d0 = dd.s.low;
+  d1 = dd.s.high;
+  n0 = nn.s.low;
+  n1 = nn.s.high;
+
+#if !UDIV_NEEDS_NORMALIZATION
+  if (d1 == 0)
+    {
+      if (d0 > n1)
+	{
+	  /* 0q = nn / 0D */
+
+	  udiv_qrnnd (q0, n0, n1, n0, d0);
+	  q1 = 0;
+
+	  /* Remainder in n0.  */
+	}
+      else
+	{
+	  /* qq = NN / 0d */
+
+	  if (d0 == 0)
+	    d0 = 1 / d0;	/* Divide intentionally by zero.  */
+
+	  udiv_qrnnd (q1, n1, 0, n1, d0);
+	  udiv_qrnnd (q0, n0, n1, n0, d0);
+
+	  /* Remainder in n0.  */
+	}
+
+      if (rp != 0)
+	{
+	  rr.s.low = n0;
+	  rr.s.high = 0;
+	  *rp = rr.ll;
+	}
+    }
+
+#else /* UDIV_NEEDS_NORMALIZATION */
+
+  if (d1 == 0)
+    {
+      if (d0 > n1)
+	{
+	  /* 0q = nn / 0D */
+
+	  count_leading_zeros (bm, d0);
+
+	  if (bm != 0)
+	    {
+	      /* Normalize, i.e. make the most significant bit of the
+		 denominator set.  */
+
+	      d0 = d0 << bm;
+	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
+	      n0 = n0 << bm;
+	    }
+
+	  udiv_qrnnd (q0, n0, n1, n0, d0);
+	  q1 = 0;
+
+	  /* Remainder in n0 >> bm.  */
+	}
+      else
+	{
+	  /* qq = NN / 0d */
+
+	  if (d0 == 0)
+	    d0 = 1 / d0;	/* Divide intentionally by zero.  */
+
+	  count_leading_zeros (bm, d0);
+
+	  if (bm == 0)
+	    {
+	      /* From (n1 >= d0) /\ (the most significant bit of d0 is set),
+		 conclude (the most significant bit of n1 is set) /\ (the
+		 leading quotient digit q1 = 1).
+
+		 This special case is necessary, not an optimization.
+		 (Shifts counts of W_TYPE_SIZE are undefined.)  */
+
+	      n1 -= d0;
+	      q1 = 1;
+	    }
+	  else
+	    {
+	      /* Normalize.  */
+
+	      b = W_TYPE_SIZE - bm;
+
+	      d0 = d0 << bm;
+	      n2 = n1 >> b;
+	      n1 = (n1 << bm) | (n0 >> b);
+	      n0 = n0 << bm;
+
+	      udiv_qrnnd (q1, n1, n2, n1, d0);
+	    }
+
+	  /* n1 != d0...  */
+
+	  udiv_qrnnd (q0, n0, n1, n0, d0);
+
+	  /* Remainder in n0 >> bm.  */
+	}
+
+      if (rp != 0)
+	{
+	  rr.s.low = n0 >> bm;
+	  rr.s.high = 0;
+	  *rp = rr.ll;
+	}
+    }
+#endif /* UDIV_NEEDS_NORMALIZATION */
+
+  else
+    {
+      if (d1 > n1)
+	{
+	  /* 00 = nn / DD */
+
+	  q0 = 0;
+	  q1 = 0;
+
+	  /* Remainder in n1n0.  */
+	  if (rp != 0)
+	    {
+	      rr.s.low = n0;
+	      rr.s.high = n1;
+	      *rp = rr.ll;
+	    }
+	}
+      else
+	{
+	  /* 0q = NN / dd */
+
+	  count_leading_zeros (bm, d1);
+	  if (bm == 0)
+	    {
+	      /* From (n1 >= d1) /\ (the most significant bit of d1 is set),
+		 conclude (the most significant bit of n1 is set) /\ (the
+		 quotient digit q0 = 0 or 1).
+
+		 This special case is necessary, not an optimization.  */
+
+	      /* The condition on the next line takes advantage of that
+		 n1 >= d1 (true due to program flow).  */
+	      if (n1 > d1 || n0 >= d0)
+		{
+		  q0 = 1;
+		  sub_ddmmss (n1, n0, n1, n0, d1, d0);
+		}
+	      else
+		q0 = 0;
+
+	      q1 = 0;
+
+	      if (rp != 0)
+		{
+		  rr.s.low = n0;
+		  rr.s.high = n1;
+		  *rp = rr.ll;
+		}
+	    }
+	  else
+	    {
+	      UWtype m1, m0;
+	      /* Normalize.  */
+
+	      b = W_TYPE_SIZE - bm;
+
+	      d1 = (d1 << bm) | (d0 >> b);
+	      d0 = d0 << bm;
+	      n2 = n1 >> b;
+	      n1 = (n1 << bm) | (n0 >> b);
+	      n0 = n0 << bm;
+
+	      udiv_qrnnd (q0, n1, n2, n1, d1);
+	      umul_ppmm (m1, m0, q0, d0);
+
+	      if (m1 > n1 || (m1 == n1 && m0 > n0))
+		{
+		  q0--;
+		  sub_ddmmss (m1, m0, m1, m0, d1, d0);
+		}
+
+	      q1 = 0;
+
+	      /* Remainder in (n1n0 - m1m0) >> bm.  */
+	      if (rp != 0)
+		{
+		  sub_ddmmss (n1, n0, n1, n0, m1, m0);
+		  rr.s.low = (n1 << b) | (n0 >> bm);
+		  rr.s.high = n1 >> bm;
+		  *rp = rr.ll;
+		}
+	    }
+	}
+    }
+
+  ww.s.low = q0;
+  ww.s.high = q1;
+
+  return ww.ll;
+}
+
+DWtype
+__divdi3 (DWtype u, DWtype v)
+{
+  Wtype c = 0;
+  DWunion uu = {.ll = u};
+  DWunion vv = {.ll = v};
+  DWtype w;
+
+  if (uu.s.high < 0)
+    c = ~c,
+    uu.ll = -uu.ll;
+  if (vv.s.high < 0)
+    c = ~c,
+    vv.ll = -vv.ll;
+
+  w = __udivmoddi4 (uu.ll, vv.ll, (UDWtype *) 0);
+  if (c)
+    w = -w;
+
+  return w;
+}
+
+UDWtype
+__udivdi3 (UDWtype n, UDWtype d)
+{
+  return __udivmoddi4 (n, d, (UDWtype *) 0);
+}
+
+UDWtype
+__umoddi3 (UDWtype u, UDWtype v)
+{
+  UDWtype w;
+
+  (void) __udivmoddi4 (u, v, &w);
+
+  return w;
+}
+
+DWtype
+__moddi3 (DWtype u, DWtype v)
+{
+  Wtype c = 0;
+  DWunion uu = {.ll = u};
+  DWunion vv = {.ll = v};
+  DWtype w;
+
+  if (uu.s.high < 0)
+    c = ~c,
+    uu.ll = -uu.ll;
+  if (vv.s.high < 0)
+    vv.ll = -vv.ll;
+
+  (void) __udivmoddi4 (uu.ll, vv.ll, (UDWtype*)&w);
+  if (c)
+    w = -w;
+
+  return w;
+}
diff -purN linux-2.6.35.4-orig/arch/mips/Makefile linux-2.6.35.4/arch/mips/Makefile
--- linux-2.6.35.4-orig/arch/mips/Makefile	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/Makefile	2014-07-18 22:29:43.522367724 +0200
@@ -35,8 +35,12 @@ endif
 
 ifdef CONFIG_32BIT
 tool-archpref		= $(32bit-tool-archpref)
+ifdef CONFIG_MIPS_N32
+UTS_MACHINE		:= mips64
+else
 UTS_MACHINE		:= mips
 endif
+endif
 ifdef CONFIG_64BIT
 tool-archpref		= $(64bit-tool-archpref)
 UTS_MACHINE		:= mips64
@@ -163,6 +167,8 @@ cflags-$(CONFIG_CPU_R5432)	+= $(call cc-
 			-Wa,--trap
 cflags-$(CONFIG_CPU_R5500)	+= $(call cc-option,-march=r5500,-march=r5000) \
 			-Wa,--trap
+cflags-$(CONFIG_CPU_R5900)	+= -march=r5900 -mtune=r5900 \
+			-Wa,--trap -mno-llsc
 cflags-$(CONFIG_CPU_NEVADA)	+= $(call cc-option,-march=rm5200,-march=r5000) \
 			-Wa,--trap
 cflags-$(CONFIG_CPU_RM7000)	+= $(call cc-option,-march=rm7000,-march=r5000) \
@@ -659,6 +665,13 @@ else
 load-$(CONFIG_CPU_CAVIUM_OCTEON) 	+= 0xffffffff81100000
 endif
 
+#
+# Sony Playstation 2
+#
+core-$(CONFIG_SONY_PS2)	+= arch/mips/ps2/
+cflags-$(CONFIG_SONY_PS2)+= -I$(srctree)/arch/mips/include/asm/mach-ps2
+load-$(CONFIG_SONY_PS2)	+= 0x80010000
+
 cflags-y			+= -I$(srctree)/arch/mips/include/asm/mach-generic
 drivers-$(CONFIG_PCI)		+= arch/mips/pci/
 
diff -purN linux-2.6.35.4-orig/arch/mips/math-emu/cp1emu.c linux-2.6.35.4/arch/mips/math-emu/cp1emu.c
--- linux-2.6.35.4-orig/arch/mips/math-emu/cp1emu.c	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/math-emu/cp1emu.c	2014-07-18 22:29:43.546367724 +0200
@@ -178,9 +178,11 @@ static int isBranchInstr(mips_instructio
  */
 static inline int cop1_64bit(struct pt_regs *xcp)
 {
+#if !defined(CONFIG_R5900_128BIT_SUPPORT)
 	if (cpu_has_fpu)
 		return xcp->cp0_status & ST0_FR;
-#ifdef CONFIG_64BIT
+#endif
+#if defined(CONFIG_64BIT) || defined(CONFIG_R5900_128BIT_SUPPORT)
 	return !test_thread_flag(TIF_32BIT_REGS);
 #else
 	return 0;
@@ -262,7 +264,7 @@ static int cop1Emulate(struct pt_regs *x
 	MIPS_FPU_EMU_INC_STATS(emulated);
 	switch (MIPSInst_OPCODE(ir)) {
 	case ldc1_op:{
-		u64 __user *va = (u64 __user *) (xcp->regs[MIPSInst_RS(ir)] +
+		u64 __user *va = (u64 __user *) (MIPS_READ_REG_L(xcp->regs[MIPSInst_RS(ir)]) +
 			MIPSInst_SIMM(ir));
 		u64 val;
 
@@ -276,7 +278,7 @@ static int cop1Emulate(struct pt_regs *x
 	}
 
 	case sdc1_op:{
-		u64 __user *va = (u64 __user *) (xcp->regs[MIPSInst_RS(ir)] +
+		u64 __user *va = (u64 __user *) (MIPS_READ_REG_L(xcp->regs[MIPSInst_RS(ir)]) +
 			MIPSInst_SIMM(ir));
 		u64 val;
 
@@ -290,7 +292,7 @@ static int cop1Emulate(struct pt_regs *x
 	}
 
 	case lwc1_op:{
-		u32 __user *va = (u32 __user *) (xcp->regs[MIPSInst_RS(ir)] +
+		u32 __user *va = (u32 __user *) (MIPS_READ_REG_L(xcp->regs[MIPSInst_RS(ir)]) +
 			MIPSInst_SIMM(ir));
 		u32 val;
 
@@ -304,7 +306,7 @@ static int cop1Emulate(struct pt_regs *x
 	}
 
 	case swc1_op:{
-		u32 __user *va = (u32 __user *) (xcp->regs[MIPSInst_RS(ir)] +
+		u32 __user *va = (u32 __user *) (MIPS_READ_REG_L(xcp->regs[MIPSInst_RS(ir)]) +
 			MIPSInst_SIMM(ir));
 		u32 val;
 
@@ -320,32 +322,34 @@ static int cop1Emulate(struct pt_regs *x
 	case cop1_op:
 		switch (MIPSInst_RS(ir)) {
 
-#if defined(__mips64)
+#if defined(__mips64) || defined(CONFIG_R5900_128BIT_SUPPORT)
 		case dmfc_op:
 			/* copregister fs -> gpr[rt] */
 			if (MIPSInst_RT(ir) != 0) {
-				DIFROMREG(xcp->regs[MIPSInst_RT(ir)],
-					MIPSInst_RD(ir));
+				MIPS_REG_T tmp;
+				DIFROMREG(tmp, MIPSInst_RD(ir));
+				MIPS_WRITE_REG(xcp->regs[MIPSInst_RT(ir)]) = tmp;
 			}
 			break;
 
 		case dmtc_op:
 			/* copregister fs <- rt */
-			DITOREG(xcp->regs[MIPSInst_RT(ir)], MIPSInst_RD(ir));
+			DITOREG(MIPS_READ_REG(xcp->regs[MIPSInst_RT(ir)]), MIPSInst_RD(ir));
 			break;
 #endif
 
 		case mfc_op:
 			/* copregister rd -> gpr[rt] */
 			if (MIPSInst_RT(ir) != 0) {
-				SIFROMREG(xcp->regs[MIPSInst_RT(ir)],
-					MIPSInst_RD(ir));
+				MIPS_REG_T tmp;
+				SIFROMREG(tmp, MIPSInst_RD(ir));
+				MIPS_WRITE_REG(xcp->regs[MIPSInst_RT(ir)]) = tmp;
 			}
 			break;
 
 		case mtc_op:
 			/* copregister rd <- rt */
-			SITOREG(xcp->regs[MIPSInst_RT(ir)], MIPSInst_RD(ir));
+			SITOREG(MIPS_READ_REG(xcp->regs[MIPSInst_RT(ir)]), MIPSInst_RD(ir));
 			break;
 
 		case cfc_op:{
@@ -367,7 +371,7 @@ static int cop1Emulate(struct pt_regs *x
 			else
 				value = 0;
 			if (MIPSInst_RT(ir))
-				xcp->regs[MIPSInst_RT(ir)] = value;
+				MIPS_WRITE_REG(xcp->regs[MIPSInst_RT(ir)]) = value;
 			break;
 		}
 
@@ -378,7 +382,7 @@ static int cop1Emulate(struct pt_regs *x
 			if (MIPSInst_RT(ir) == 0)
 				value = 0;
 			else
-				value = xcp->regs[MIPSInst_RT(ir)];
+				value = MIPS_READ_REG(xcp->regs[MIPSInst_RT(ir)]);
 
 			/* we only have one writable control reg
 			 */
@@ -447,7 +451,7 @@ static int cop1Emulate(struct pt_regs *x
 				switch (MIPSInst_OPCODE(ir)) {
 				case lwc1_op:
 				case swc1_op:
-#if (__mips >= 2 || defined(__mips64))
+#if (__mips >= 2 || defined(__mips64)) || defined(CONFIG_CPU_R5900)
 				case ldc1_op:
 				case sdc1_op:
 #endif
@@ -518,8 +522,8 @@ static int cop1Emulate(struct pt_regs *x
 			return SIGILL;
 		cond = fpucondbit[MIPSInst_RT(ir) >> 2];
 		if (((ctx->fcr31 & cond) != 0) == ((MIPSInst_RT(ir) & 1) != 0))
-			xcp->regs[MIPSInst_RD(ir)] =
-				xcp->regs[MIPSInst_RS(ir)];
+			MIPS_WRITE_REG(xcp->regs[MIPSInst_RD(ir)]) =
+				MIPS_READ_REG(xcp->regs[MIPSInst_RS(ir)]);
 		break;
 #endif
 
@@ -618,8 +622,8 @@ static int fpux_emu(struct pt_regs *xcp,
 
 		switch (MIPSInst_FUNC(ir)) {
 		case lwxc1_op:
-			va = (void __user *) (xcp->regs[MIPSInst_FR(ir)] +
-				xcp->regs[MIPSInst_FT(ir)]);
+			va = (void __user *) (MIPS_READ_REG_L(xcp->regs[MIPSInst_FR(ir)]) +
+				MIPS_READ_REG_L(xcp->regs[MIPSInst_FT(ir)]));
 
 			MIPS_FPU_EMU_INC_STATS(loads);
 			if (get_user(val, va)) {
@@ -630,8 +634,8 @@ static int fpux_emu(struct pt_regs *xcp,
 			break;
 
 		case swxc1_op:
-			va = (void __user *) (xcp->regs[MIPSInst_FR(ir)] +
-				xcp->regs[MIPSInst_FT(ir)]);
+			va = (void __user *) (MIPS_READ_REG_L(xcp->regs[MIPSInst_FR(ir)]) +
+				MIPS_READ_REG_L(xcp->regs[MIPSInst_FT(ir)]));
 
 			MIPS_FPU_EMU_INC_STATS(stores);
 
@@ -695,8 +699,8 @@ static int fpux_emu(struct pt_regs *xcp,
 
 		switch (MIPSInst_FUNC(ir)) {
 		case ldxc1_op:
-			va = (void __user *) (xcp->regs[MIPSInst_FR(ir)] +
-				xcp->regs[MIPSInst_FT(ir)]);
+			va = (void __user *) (MIPS_READ_REG_L(xcp->regs[MIPSInst_FR(ir)]) +
+				MIPS_READ_REG_L(xcp->regs[MIPSInst_FT(ir)]));
 
 			MIPS_FPU_EMU_INC_STATS(loads);
 			if (get_user(val, va)) {
@@ -707,8 +711,8 @@ static int fpux_emu(struct pt_regs *xcp,
 			break;
 
 		case sdxc1_op:
-			va = (void __user *) (xcp->regs[MIPSInst_FR(ir)] +
-				xcp->regs[MIPSInst_FT(ir)]);
+			va = (void __user *) (MIPS_READ_REG_L(xcp->regs[MIPSInst_FR(ir)]) +
+				MIPS_READ_REG_L(xcp->regs[MIPSInst_FT(ir)]));
 
 			MIPS_FPU_EMU_INC_STATS(stores);
 			DIFROMREG(val, MIPSInst_FS(ir));
@@ -775,7 +779,7 @@ static int fpu_emu(struct pt_regs *xcp,
 		ieee754dp d;
 		ieee754sp s;
 		int w;
-#ifdef __mips64
+#if defined(__mips64) || defined(CONFIG_R5900_128BIT_SUPPORT)
 		s64 l;
 #endif
 	} rv;			/* resulting value */
@@ -804,7 +808,7 @@ static int fpu_emu(struct pt_regs *xcp,
 			goto scopbop;
 
 			/* unary  ops */
-#if __mips >= 2 || defined(__mips64)
+#if __mips >= 2 || defined(__mips64) || defined(CONFIG_CPU_R5900)
 		case fsqrt_op:
 			handler.u = ieee754sp_sqrt;
 			goto scopuop;
@@ -826,12 +830,12 @@ static int fpu_emu(struct pt_regs *xcp,
 			SPFROMREG(rv.s, MIPSInst_FS(ir));
 			break;
 		case fmovz_op:
-			if (xcp->regs[MIPSInst_FT(ir)] != 0)
+			if (MIPS_READ_REG(xcp->regs[MIPSInst_FT(ir)]) != 0)
 				return 0;
 			SPFROMREG(rv.s, MIPSInst_FS(ir));
 			break;
 		case fmovn_op:
-			if (xcp->regs[MIPSInst_FT(ir)] == 0)
+			if (MIPS_READ_REG(xcp->regs[MIPSInst_FT(ir)]) == 0)
 				return 0;
 			SPFROMREG(rv.s, MIPSInst_FS(ir));
 			break;
@@ -899,7 +903,7 @@ static int fpu_emu(struct pt_regs *xcp,
 			goto copcsr;
 		}
 
-#if __mips >= 2 || defined(__mips64)
+#if __mips >= 2 || defined(__mips64) || defined(CONFIG_CPU_R5900)
 		case fround_op:
 		case ftrunc_op:
 		case fceil_op:
@@ -916,7 +920,7 @@ static int fpu_emu(struct pt_regs *xcp,
 		}
 #endif /* __mips >= 2 */
 
-#if defined(__mips64)
+#if defined(__mips64) || defined(CONFIG_R5900_128BIT_SUPPORT)
 		case fcvtl_op:{
 			ieee754sp fs;
 
@@ -989,7 +993,7 @@ static int fpu_emu(struct pt_regs *xcp,
 			goto dcopbop;
 
 			/* unary  ops */
-#if __mips >= 2 || defined(__mips64)
+#if __mips >= 2 || defined(__mips64) || defined(CONFIG_CPU_R5900)
 		case fsqrt_op:
 			handler.u = ieee754dp_sqrt;
 			goto dcopuop;
@@ -1011,12 +1015,12 @@ static int fpu_emu(struct pt_regs *xcp,
 			DPFROMREG(rv.d, MIPSInst_FS(ir));
 			break;
 		case fmovz_op:
-			if (xcp->regs[MIPSInst_FT(ir)] != 0)
+			if (MIPS_READ_REG(xcp->regs[MIPSInst_FT(ir)]) != 0)
 				return 0;
 			DPFROMREG(rv.d, MIPSInst_FS(ir));
 			break;
 		case fmovn_op:
-			if (xcp->regs[MIPSInst_FT(ir)] == 0)
+			if (MIPS_READ_REG(xcp->regs[MIPSInst_FT(ir)]) == 0)
 				return 0;
 			DPFROMREG(rv.d, MIPSInst_FS(ir));
 			break;
@@ -1073,7 +1077,7 @@ static int fpu_emu(struct pt_regs *xcp,
 			goto copcsr;
 		}
 
-#if __mips >= 2 || defined(__mips64)
+#if __mips >= 2 || defined(__mips64) || defined(CONFIG_CPU_R5900)
 		case fround_op:
 		case ftrunc_op:
 		case fceil_op:
@@ -1090,7 +1094,7 @@ static int fpu_emu(struct pt_regs *xcp,
 		}
 #endif
 
-#if defined(__mips64)
+#if defined(__mips64) || defined(CONFIG_R5900_128BIT_SUPPORT)
 		case fcvtl_op:{
 			ieee754dp fs;
 
@@ -1165,7 +1169,7 @@ static int fpu_emu(struct pt_regs *xcp,
 		break;
 	}
 
-#if defined(__mips64)
+#if defined(__mips64) || defined(CONFIG_R5900_128BIT_SUPPORT)
 	case l_fmt:{
 		switch (MIPSInst_FUNC(ir)) {
 		case fcvts_op:
@@ -1227,7 +1231,7 @@ static int fpu_emu(struct pt_regs *xcp,
 	case w_fmt:
 		SITOREG(rv.w, MIPSInst_FD(ir));
 		break;
-#if defined(__mips64)
+#if defined(__mips64) || defined(CONFIG_R5900_128BIT_SUPPORT)
 	case l_fmt:
 		DITOREG(rv.l, MIPSInst_FD(ir));
 		break;
diff -purN linux-2.6.35.4-orig/arch/mips/math-emu/dsemul.c linux-2.6.35.4/arch/mips/math-emu/dsemul.c
--- linux-2.6.35.4-orig/arch/mips/math-emu/dsemul.c	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/math-emu/dsemul.c	2014-07-18 22:29:43.546367724 +0200
@@ -86,7 +86,7 @@ int mips_dsemul(struct pt_regs *regs, mi
 
 	/* Ensure that the two instructions are in the same cache line */
 	fr = (struct emuframe __user *)
-		((regs->regs[29] - sizeof(struct emuframe)) & ~0x7);
+		((MIPS_READ_REG_L(regs->regs[29]) - sizeof(struct emuframe)) & ~0x7);
 
 	/* Verify that the stack pointer is not competely insane */
 	if (unlikely(!access_ok(VERIFY_WRITE, fr, sizeof(struct emuframe))))
diff -purN linux-2.6.35.4-orig/arch/mips/math-emu/Makefile linux-2.6.35.4/arch/mips/math-emu/Makefile
--- linux-2.6.35.4-orig/arch/mips/math-emu/Makefile	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/math-emu/Makefile	2014-07-18 22:29:43.546367724 +0200
@@ -10,4 +10,7 @@ obj-y	:= cp1emu.o ieee754m.o ieee754d.o
 	   sp_scalb.o sp_simple.o sp_tint.o sp_fint.o sp_tlong.o sp_flong.o \
 	   dp_sqrt.o sp_sqrt.o kernel_linkage.o dsemul.o
 
-EXTRA_CFLAGS += -Werror
+# Disable -Werror on GCC 4.09 or higher.
+EXTRA_CFLAGS += $(shell if [ $(call cc-version) -lt 0409 ] ; then \
+			echo $(call cc-option,-Werror); \
+			fi ;)
diff -purN linux-2.6.35.4-orig/arch/mips/mm/cache.c linux-2.6.35.4/arch/mips/mm/cache.c
--- linux-2.6.35.4-orig/arch/mips/mm/cache.c	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/mm/cache.c	2014-07-18 22:29:43.546367724 +0200
@@ -23,6 +23,7 @@
 
 /* Cache operations. */
 void (*flush_cache_all)(void);
+EXPORT_SYMBOL(flush_cache_all);
 void (*__flush_cache_all)(void);
 void (*flush_cache_mm)(struct mm_struct *mm);
 void (*flush_cache_range)(struct vm_area_struct *vma, unsigned long start,
@@ -129,6 +130,15 @@ void __update_cache(struct vm_area_struc
 		if (exec || pages_do_alias(addr, address & PAGE_MASK))
 			flush_data_cache_page(addr);
 		ClearPageDcacheDirty(page);
+	} else {
+		/* Cache can be dirty when page is not writeable, because
+		 * data is copied to page in kernel.
+		 */
+		addr = (unsigned long) page_address(page);
+		if (exec) {
+			flush_data_cache_page(addr);
+			/* TBD: Flush instruction cache also? */
+		}
 	}
 }
 
diff -purN linux-2.6.35.4-orig/arch/mips/mm/cex-gen.S linux-2.6.35.4/arch/mips/mm/cex-gen.S
--- linux-2.6.35.4-orig/arch/mips/mm/cex-gen.S	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/mm/cex-gen.S	2014-07-18 22:29:43.546367724 +0200
@@ -27,11 +27,17 @@
 	 * in the cache, we may not be able to recover.  As a
 	 * first-order desperate measure, turn off KSEG0 cacheing.
 	 */
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	mfc0	k0,CP0_CONFIG
 	li	k1,~CONF_CM_CMASK
 	and	k0,k0,k1
 	ori	k0,k0,CONF_CM_UNCACHED
 	mtc0	k0,CP0_CONFIG
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	/* Give it a few cycles to sink in... */
 	nop
 	nop
diff -purN linux-2.6.35.4-orig/arch/mips/mm/c-r4k.c linux-2.6.35.4/arch/mips/mm/c-r4k.c
--- linux-2.6.35.4-orig/arch/mips/mm/c-r4k.c	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/mm/c-r4k.c	2014-07-18 22:29:43.546367724 +0200
@@ -643,8 +643,8 @@ static void r4k_dma_cache_inv(unsigned l
 			 * hit ops with insufficient alignment.  Solved by
 			 * aligning the address to cache line size.
 			 */
-			cache_op(Hit_Writeback_Inv_SD, addr & almask);
-			cache_op(Hit_Writeback_Inv_SD,
+			cache_op_s(Hit_Writeback_Inv_SD, addr & almask);
+			cache_op_s(Hit_Writeback_Inv_SD,
 				 (addr + size - 1) & almask);
 			blast_inv_scache_range(addr, addr + size);
 		}
@@ -658,8 +658,8 @@ static void r4k_dma_cache_inv(unsigned l
 		unsigned long almask = ~(lsize - 1);
 
 		R4600_HIT_CACHEOP_WAR_IMPL;
-		cache_op(Hit_Writeback_Inv_D, addr & almask);
-		cache_op(Hit_Writeback_Inv_D, (addr + size - 1)  & almask);
+		cache_op_d(Hit_Writeback_Inv_D, addr & almask);
+		cache_op_d(Hit_Writeback_Inv_D, (addr + size - 1)  & almask);
 		blast_inv_dcache_range(addr, addr + size);
 	}
 
@@ -928,6 +928,17 @@ static void __cpuinit probe_pcache(void)
 		c->dcache.waybit = 0;
 		break;
 
+	case CPU_R5900:
+		icache_size = 1 << (12 + ((config & CONF_IC) >> 9));
+		dcache_size = 1 << (12 + ((config & CONF_DC) >> 6));
+		c->icache.linesz = 64;
+		c->icache.ways = 2;
+		c->icache.waybit = 0;
+		c->dcache.ways = 2;
+		c->dcache.linesz = 64;
+		c->dcache.waybit = 0;
+		break;
+
 	default:
 		if (!(config & MIPS_CONF_M))
 			panic("Don't know how to probe P-caches on this cpu.");
@@ -1025,6 +1036,23 @@ static void __cpuinit probe_pcache(void)
 			c->dcache.flags |= MIPS_CACHE_PINDEX;
 			break;
 		}
+
+	case CPU_R5900:
+		if (c->dcache.waysize > 4096)
+			c->dcache.flags |= MIPS_CACHE_ALIASES;
+		/* Sony Playstation 2 has:
+		 * 8 KByte data cache, 2 ways
+		 * 16 KByte instruction cache, 2 ways
+		 * There can be cache aliases in instruction cache.
+		 * If MIPS_CACHE_ALIASES is not set, the CPU
+		 * may execute wrong code. There seems to be a
+		 * missing data cache flush which is fixed when
+		 * setting MIPS_CACHE_ALIASES.
+		 */
+		if (c->icache.waysize > 4096)
+			c->dcache.flags |= MIPS_CACHE_ALIASES;
+		break;
+
 	default:
 		if (c->dcache.waysize > PAGE_SIZE)
 			c->dcache.flags |= MIPS_CACHE_ALIASES;
@@ -1103,15 +1131,15 @@ static int __cpuinit probe_scache(void)
 	write_c0_taglo(0);
 	write_c0_taghi(0);
 	__asm__ __volatile__("nop; nop; nop; nop;"); /* avoid the hazard */
-	cache_op(Index_Store_Tag_I, begin);
-	cache_op(Index_Store_Tag_D, begin);
-	cache_op(Index_Store_Tag_SD, begin);
+	cache_op_i(Index_Store_Tag_I, begin);
+	cache_op_d(Index_Store_Tag_D, begin);
+	cache_op_s(Index_Store_Tag_SD, begin);
 
 	/* Now search for the wrap around point. */
 	pow2 = (128 * 1024);
 	tmp = 0;
 	for (addr = begin + (128 * 1024); addr < end; addr = begin + pow2) {
-		cache_op(Index_Load_Tag_SD, addr);
+		cache_op_s(Index_Load_Tag_SD, addr);
 		__asm__ __volatile__("nop; nop; nop; nop;"); /* hazard... */
 		if (!read_c0_taglo())
 			break;
diff -purN linux-2.6.35.4-orig/arch/mips/mm/fault.c linux-2.6.35.4/arch/mips/mm/fault.c
--- linux-2.6.35.4-orig/arch/mips/mm/fault.c	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/mm/fault.c	2014-07-18 22:29:43.546367724 +0200
@@ -192,7 +192,7 @@ no_context:
 	printk(KERN_ALERT "CPU %d Unable to handle kernel paging request at "
 	       "virtual address %0*lx, epc == %0*lx, ra == %0*lx\n",
 	       raw_smp_processor_id(), field, address, field, regs->cp0_epc,
-	       field,  regs->regs[31]);
+	       field,  MIPS_READ_REG_L(regs->regs[31]));
 	die("Oops", regs);
 
 out_of_memory:
diff -purN linux-2.6.35.4-orig/arch/mips/mm/Makefile linux-2.6.35.4/arch/mips/mm/Makefile
--- linux-2.6.35.4-orig/arch/mips/mm/Makefile	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/mm/Makefile	2014-07-18 22:29:43.546367724 +0200
@@ -3,10 +3,15 @@
 #
 
 obj-y				+= cache.o dma-default.o extable.o fault.o \
-				   init.o tlbex.o tlbex-fault.o uasm.o page.o
+				   init.o tlbex.o tlbex-fault.o uasm.o page.o \
+				   page-funcs.o
 
+ifeq ($(CONFIG_CPU_R5900),y)
+obj-$(CONFIG_CPU_R5900)		+= ioremap.o pgtable-32.o
+else
 obj-$(CONFIG_32BIT)		+= ioremap.o pgtable-32.o
 obj-$(CONFIG_64BIT)		+= pgtable-64.o
+endif
 obj-$(CONFIG_HIGHMEM)		+= highmem.o
 obj-$(CONFIG_HUGETLB_PAGE)	+= hugetlbpage.o
 
@@ -21,6 +26,7 @@ obj-$(CONFIG_CPU_R4X00)		+= c-r4k.o cex-
 obj-$(CONFIG_CPU_R5000)		+= c-r4k.o cex-gen.o tlb-r4k.o
 obj-$(CONFIG_CPU_R5432)		+= c-r4k.o cex-gen.o tlb-r4k.o
 obj-$(CONFIG_CPU_R5500)		+= c-r4k.o cex-gen.o tlb-r4k.o
+obj-$(CONFIG_CPU_R5900)		+= c-r4k.o cex-gen.o tlb-r4k.o
 obj-$(CONFIG_CPU_R8000)		+= c-r4k.o cex-gen.o tlb-r8k.o
 obj-$(CONFIG_CPU_RM7000)	+= c-r4k.o cex-gen.o tlb-r4k.o
 obj-$(CONFIG_CPU_RM9000)	+= c-r4k.o cex-gen.o tlb-r4k.o
@@ -35,4 +41,7 @@ obj-$(CONFIG_R5000_CPU_SCACHE)  += sc-r5
 obj-$(CONFIG_RM7000_CPU_SCACHE)	+= sc-rm7k.o
 obj-$(CONFIG_MIPS_CPU_SCACHE)	+= sc-mips.o
 
-EXTRA_CFLAGS += -Werror
+# Disable -Werror on GCC 4.09 or higher.
+EXTRA_CFLAGS += $(shell if [ $(call cc-version) -lt 0409 ] ; then \
+			echo $(call cc-option,-Werror); \
+			fi ;)
diff -purN linux-2.6.35.4-orig/arch/mips/mm/page.c linux-2.6.35.4/arch/mips/mm/page.c
--- linux-2.6.35.4-orig/arch/mips/mm/page.c	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/mm/page.c	2014-07-18 22:29:43.546367724 +0200
@@ -6,6 +6,7 @@
  * Copyright (C) 2003, 04, 05 Ralf Baechle (ralf@linux-mips.org)
  * Copyright (C) 2007  Maciej W. Rozycki
  * Copyright (C) 2008  Thiemo Seufer
+ * Copyright (C) 2012  MIPS Technologies, Inc.
  */
 #include <linux/init.h>
 #include <linux/kernel.h>
@@ -72,45 +73,6 @@ static struct uasm_reloc __cpuinitdata r
 #define cpu_is_r4600_v1_x()	((read_c0_prid() & 0xfffffff0) == 0x00002010)
 #define cpu_is_r4600_v2_x()	((read_c0_prid() & 0xfffffff0) == 0x00002020)
 
-/*
- * Maximum sizes:
- *
- * R4000 128 bytes S-cache:		0x058 bytes
- * R4600 v1.7:				0x05c bytes
- * R4600 v2.0:				0x060 bytes
- * With prefetching, 16 word strides	0x120 bytes
- */
-
-static u32 clear_page_array[0x120 / 4];
-
-#ifdef CONFIG_SIBYTE_DMA_PAGEOPS
-void clear_page_cpu(void *page) __attribute__((alias("clear_page_array")));
-#else
-void clear_page(void *page) __attribute__((alias("clear_page_array")));
-#endif
-
-EXPORT_SYMBOL(clear_page);
-
-/*
- * Maximum sizes:
- *
- * R4000 128 bytes S-cache:		0x11c bytes
- * R4600 v1.7:				0x080 bytes
- * R4600 v2.0:				0x07c bytes
- * With prefetching, 16 word strides	0x540 bytes
- */
-static u32 copy_page_array[0x540 / 4];
-
-#ifdef CONFIG_SIBYTE_DMA_PAGEOPS
-void
-copy_page_cpu(void *to, void *from) __attribute__((alias("copy_page_array")));
-#else
-void copy_page(void *to, void *from) __attribute__((alias("copy_page_array")));
-#endif
-
-EXPORT_SYMBOL(copy_page);
-
-
 static int pref_bias_clear_store __cpuinitdata;
 static int pref_bias_copy_load __cpuinitdata;
 static int pref_bias_copy_store __cpuinitdata;
@@ -283,10 +245,15 @@ static inline void __cpuinit build_clear
 		}
 }
 
+extern u32 __clear_page_start;
+extern u32 __clear_page_end;
+extern u32 __copy_page_start;
+extern u32 __copy_page_end;
+
 void __cpuinit build_clear_page(void)
 {
 	int off;
-	u32 *buf = (u32 *)&clear_page_array;
+	u32 *buf = &__clear_page_start;
 	struct uasm_label *l = labels;
 	struct uasm_reloc *r = relocs;
 	int i;
@@ -357,17 +324,17 @@ void __cpuinit build_clear_page(void)
 	uasm_i_jr(&buf, RA);
 	uasm_i_nop(&buf);
 
-	BUG_ON(buf > clear_page_array + ARRAY_SIZE(clear_page_array));
+	BUG_ON(buf > &__clear_page_end);
 
 	uasm_resolve_relocs(relocs, labels);
 
 	pr_debug("Synthesized clear page handler (%u instructions).\n",
-		 (u32)(buf - clear_page_array));
+			(u32)(buf - &__clear_page_start));
 
 	pr_debug("\t.set push\n");
 	pr_debug("\t.set noreorder\n");
-	for (i = 0; i < (buf - clear_page_array); i++)
-		pr_debug("\t.word 0x%08x\n", clear_page_array[i]);
+	for (i = 0; i < (buf - &__clear_page_start); i++)
+		pr_debug("\t.word 0x%08x\n", (&__clear_page_start)[i]);
 	pr_debug("\t.set pop\n");
 }
 
@@ -428,7 +395,7 @@ static inline void build_copy_store_pref
 void __cpuinit build_copy_page(void)
 {
 	int off;
-	u32 *buf = (u32 *)&copy_page_array;
+	u32 *buf = &__copy_page_start;
 	struct uasm_label *l = labels;
 	struct uasm_reloc *r = relocs;
 	int i;
@@ -596,21 +563,23 @@ void __cpuinit build_copy_page(void)
 	uasm_i_jr(&buf, RA);
 	uasm_i_nop(&buf);
 
-	BUG_ON(buf > copy_page_array + ARRAY_SIZE(copy_page_array));
+	BUG_ON(buf > &__copy_page_end);
 
 	uasm_resolve_relocs(relocs, labels);
 
 	pr_debug("Synthesized copy page handler (%u instructions).\n",
-		 (u32)(buf - copy_page_array));
+			(u32)(buf - &__copy_page_start));
 
 	pr_debug("\t.set push\n");
 	pr_debug("\t.set noreorder\n");
-	for (i = 0; i < (buf - copy_page_array); i++)
-		pr_debug("\t.word 0x%08x\n", copy_page_array[i]);
+	for (i = 0; i < (buf - &__copy_page_start); i++)
+		pr_debug("\t.word 0x%08x\n", (&__copy_page_start)[i]);
 	pr_debug("\t.set pop\n");
 }
 
 #ifdef CONFIG_SIBYTE_DMA_PAGEOPS
+extern void clear_page_cpu(void *page);
+extern void copy_page_cpu(void *to, void *from);
 
 /*
  * Pad descriptors to cacheline, since each is exclusively owned by a
diff -purN linux-2.6.35.4-orig/arch/mips/mm/page-funcs.S linux-2.6.35.4/arch/mips/mm/page-funcs.S
--- linux-2.6.35.4-orig/arch/mips/mm/page-funcs.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/mm/page-funcs.S	2014-07-18 22:29:43.546367724 +0200
@@ -0,0 +1,49 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Micro-assembler generated clear_page/copy_page functions.
+ *
+ * Copyright (C) 2012  MIPS Technologies, Inc.
+ */
+#include <asm/asm.h>
+#include <asm/regdef.h>
+
+/*
+ * Maximum sizes:
+ *
+ * R4000 128 bytes S-cache:            0x058 bytes
+ * R4600 v1.7:                         0x05c bytes
+ * R4600 v2.0:                         0x060 bytes
+ * With prefetching, 16 word strides   0x120 bytes
+ */
+EXPORT(__clear_page_start)
+#ifdef CONFIG_SIBYTE_DMA_PAGEOPS
+LEAF(clear_page_cpu)
+#else
+LEAF(clear_page)
+#endif
+1:     j       1b              /* Dummy, will be replaced. */
+       .space 288
+END(clear_page)
+EXPORT(__clear_page_end)
+
+/*
+ * Maximum sizes:
+ *
+ * R4000 128 bytes S-cache:            0x11c bytes
+ * R4600 v1.7:                         0x080 bytes
+ * R4600 v2.0:                         0x07c bytes
+ * With prefetching, 16 word strides   0x540 bytes
+ */
+EXPORT(__copy_page_start)
+#ifdef CONFIG_SIBYTE_DMA_PAGEOPS
+LEAF(copy_page_cpu)
+#else
+LEAF(copy_page)
+#endif
+1:     j       1b              /* Dummy, will be replaced. */
+       .space 1344
+END(copy_page)
+EXPORT(__copy_page_end)
diff -purN linux-2.6.35.4-orig/arch/mips/mm/tlbex.c linux-2.6.35.4/arch/mips/mm/tlbex.c
--- linux-2.6.35.4-orig/arch/mips/mm/tlbex.c	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/mm/tlbex.c	2014-07-18 22:29:43.546367724 +0200
@@ -31,6 +31,8 @@
 #include <asm/war.h>
 #include <asm/uasm.h>
 
+#include <asm/mach-ps2/eedev.h>
+
 /*
  * TLB load/store/modify handlers.
  *
@@ -97,6 +99,10 @@ enum label_id {
 #ifdef CONFIG_HUGETLB_PAGE
 	label_tlb_huge_update,
 #endif
+#ifdef CONFIG_CPU_R5900
+	label_scratchpad,
+	label_scratchpad_out,
+#endif
 };
 
 UASM_L_LA(_second_part)
@@ -116,6 +122,10 @@ UASM_L_LA(_large_segbits_fault)
 #ifdef CONFIG_HUGETLB_PAGE
 UASM_L_LA(_tlb_huge_update)
 #endif
+#ifdef CONFIG_CPU_R5900
+UASM_L_LA(_scratchpad)
+UASM_L_LA(_scratchpad_out)
+#endif
 
 /*
  * For debug purposes.
@@ -264,6 +274,15 @@ static void __cpuinit __maybe_unused bui
 		uasm_i_tlbp(p);
 		break;
 
+	case CPU_R5900:
+		uasm_i_tlbp(p);
+		uasm_i_syncp(p);
+		uasm_i_nop(p);
+		uasm_i_nop(p);
+		uasm_i_nop(p);
+		uasm_i_nop(p);
+		break;
+
 	default:
 		uasm_i_tlbp(p);
 		break;
@@ -408,6 +427,10 @@ static void __cpuinit build_tlb_write_en
 		uasm_i_nop(p);
 		tlbw(p);
 		break;
+	case CPU_R5900:
+		tlbw(p);
+		uasm_i_syncp(p);
+		break;
 
 	default:
 		panic("No TLB refill handler yet (CPU type: %d)",
@@ -452,6 +475,9 @@ static __cpuinit void build_restore_page
 		uasm_il_b(p, r, lid);
 		uasm_i_mtc0(p, 0, C0_PAGEMASK);
 	}
+#ifdef CONFIG_CPU_R5900
+	uasm_i_syncp(p);
+#endif
 }
 
 static __cpuinit void build_huge_tlb_write_entry(u32 **p,
@@ -464,6 +490,9 @@ static __cpuinit void build_huge_tlb_wri
 	uasm_i_lui(p, tmp, PM_HUGE_MASK >> 16);
 	uasm_i_ori(p, tmp, tmp, PM_HUGE_MASK & 0xffff);
 	uasm_i_mtc0(p, tmp, C0_PAGEMASK);
+#ifdef CONFIG_CPU_R5900
+	uasm_i_syncp(p);
+#endif
 
 	build_tlb_write_entry(p, l, r, wmode);
 
@@ -547,7 +576,12 @@ build_get_pmde64(u32 **p, struct uasm_la
 	/*
 	 * The vmalloc handling is not in the hotpath.
 	 */
+#ifndef CONFIG_CPU_R5900
 	uasm_i_dmfc0(p, tmp, C0_BADVADDR);
+#else
+	uasm_i_syncp(p);
+	uasm_i_mfc0(p, tmp, C0_BADVADDR);
+#endif
 
 	if (check_for_high_segbits) {
 		/*
@@ -608,7 +642,12 @@ build_get_pmde64(u32 **p, struct uasm_la
 	uasm_i_andi(p, tmp, tmp, (PTRS_PER_PGD - 1)<<3);
 	uasm_i_daddu(p, ptr, ptr, tmp); /* add in pgd offset */
 #ifndef __PAGETABLE_PMD_FOLDED
+#ifndef CONFIG_CPU_R5900
 	uasm_i_dmfc0(p, tmp, C0_BADVADDR); /* get faulting address */
+#else
+	uasm_i_syncp(p);
+	uasm_i_mfc0(p, tmp, C0_BADVADDR); /* get faulting address */
+#endif
 	uasm_i_ld(p, ptr, 0, ptr); /* get pmd pointer */
 	uasm_i_dsrl_safe(p, tmp, tmp, PMD_SHIFT-3); /* get pmd offset in bytes */
 	uasm_i_andi(p, tmp, tmp, (PTRS_PER_PMD - 1)<<3);
@@ -709,6 +748,7 @@ build_get_pgde32(u32 **p, unsigned int t
 #else
 	UASM_i_LA_mostly(p, ptr, pgdc);
 #endif
+	uasm_i_syncp(p);
 	uasm_i_mfc0(p, tmp, C0_BADVADDR); /* get faulting address */
 	uasm_i_lw(p, ptr, uasm_rel_lo(pgdc), ptr);
 	uasm_i_srl(p, tmp, tmp, PGDIR_SHIFT); /* get pgd only bits */
@@ -769,7 +809,7 @@ static void __cpuinit build_get_ptep(u32
 	UASM_i_ADDU(p, ptr, ptr, tmp); /* add in offset */
 }
 
-static void __cpuinit build_update_entries(u32 **p, unsigned int tmp,
+static void __cpuinit build_update_entries(u32 **p, struct uasm_label **l, struct uasm_reloc **r, unsigned int tmp,
 					unsigned int ptep)
 {
 	/*
@@ -778,6 +818,14 @@ static void __cpuinit build_update_entri
 	 */
 #ifdef CONFIG_64BIT_PHYS_ADDR
 	if (cpu_has_64bits) {
+#ifdef CONFIG_CPU_R5900
+		uasm_i_ld(p, tmp, 0, ptep); /* get even pte */
+		uasm_i_dsrl_safe(p, tmp, tmp, ilog2(_PAGE_GLOBAL)); /* convert to entrylo0 */
+		uasm_i_sll(p, tmp, tmp, 6);
+		uasm_il_bltz(p, r, tmp, label_scratchpad); /* Check if scratchpad should be mapped */
+		uasm_i_nop(p); /* branch delay slot */
+
+#endif
 		uasm_i_ld(p, tmp, 0, ptep); /* get even pte */
 		uasm_i_ld(p, ptep, sizeof(pte_t), ptep); /* get odd pte */
 		if (kernel_uses_smartmips_rixi) {
@@ -792,17 +840,75 @@ static void __cpuinit build_update_entri
 			uasm_i_dsrl_safe(p, ptep, ptep, ilog2(_PAGE_GLOBAL)); /* convert to entrylo1 */
 		}
 		UASM_i_MTC0(p, ptep, C0_ENTRYLO1); /* load it */
+#ifdef CONFIG_CPU_R5900
+		uasm_il_b(p, r, label_scratchpad_out); /* continue */
+		uasm_i_nop(p); /* branch delay slot */
+
+		uasm_l_scratchpad(l, *p);
+
+		UASM_i_MFC0(p, tmp, C0_ENTRYHI);
+		uasm_i_ori(p, tmp, tmp, 1 << 13);
+		uasm_i_xori(p, tmp, tmp, 1 << 13); /* VPN must be 16KB aligned */
+		UASM_i_MTC0(p, tmp, C0_ENTRYHI);
+
+		uasm_i_ld(p, ptep, 0, ptep); /* get even pte */
+		uasm_i_dsrl_safe(p, ptep, ptep, ilog2(_PAGE_GLOBAL)); /* convert to entrylo0 */
+		uasm_i_andi(p, ptep, ptep, 0x3f); /* Only keep flags. */
+		uasm_i_lui(p, tmp, (int16_t) (SCRATCHPAD_RAM >> 16));
+		uasm_i_or(p, ptep, ptep, tmp); /* Set highest bit to use scratchpad. */
+		UASM_i_MTC0(p, ptep, C0_ENTRYLO0); /* load it */
+		uasm_i_xor(p, ptep, ptep, tmp); /* Clear highest bit. */
+		UASM_i_MTC0(p, ptep, C0_ENTRYLO1); /* load it */
+
+		uasm_l_scratchpad_out(l, *p);
+#endif
 	} else {
 		int pte_off_even = sizeof(pte_t) / 2;
 		int pte_off_odd = pte_off_even + sizeof(pte_t);
 
 		/* The pte entries are pre-shifted */
+#ifdef CONFIG_CPU_R5900
+		uasm_i_lw(p, tmp, pte_off_even, ptep); /* get even pte */
+		uasm_i_sll(p, tmp, tmp, 6);
+		uasm_il_bltz(p, r, tmp, label_scratchpad); /* Check if scratchpad should be mapped */
+		uasm_i_nop(p); /* branch delay slot */
+
+#endif
 		uasm_i_lw(p, tmp, pte_off_even, ptep); /* get even pte */
 		UASM_i_MTC0(p, tmp, C0_ENTRYLO0); /* load it */
 		uasm_i_lw(p, ptep, pte_off_odd, ptep); /* get odd pte */
 		UASM_i_MTC0(p, ptep, C0_ENTRYLO1); /* load it */
+#ifdef CONFIG_CPU_R5900
+		uasm_il_b(p, r, label_scratchpad_out); /* continue */
+		uasm_i_nop(p); /* branch delay slot */
+
+		uasm_l_scratchpad(l, *p);
+
+		UASM_i_MFC0(p, tmp, C0_ENTRYHI);
+		uasm_i_ori(p, tmp, tmp, 1 << 13);
+		uasm_i_xori(p, tmp, tmp, 1 << 13); /* VPN must be 16KB aligned */
+		UASM_i_MTC0(p, tmp, C0_ENTRYHI);
+
+		uasm_i_lw(p, ptep, pte_off_even, ptep); /* get even pte */
+		uasm_i_andi(p, ptep, ptep, 0x3f); /* Only keep flags. */
+		uasm_i_lui(p, tmp, (int16_t) (SCRATCHPAD_RAM >> 16));
+		uasm_i_or(p, ptep, ptep, tmp); /* Set highest bit to use scratchpad. */
+		UASM_i_MTC0(p, ptep, C0_ENTRYLO0); /* load it */
+		uasm_i_xor(p, ptep, ptep, tmp); /* Clear highest bit. */
+		UASM_i_MTC0(p, ptep, C0_ENTRYLO1); /* load it */
+
+		uasm_l_scratchpad_out(l, *p);
+#endif
 	}
 #else
+#ifdef CONFIG_CPU_R5900
+	uasm_i_lw(p, tmp, 0, ptep); /* get even pte */
+	uasm_i_srl(p, tmp, tmp, ilog2(_PAGE_GLOBAL)); /* convert to entrylo0 */
+	uasm_i_sll(p, tmp, tmp, 6);
+	uasm_il_bltz(p, r, tmp, label_scratchpad); /* Check if scratchpad should be mapped */
+	uasm_i_nop(p); /* branch delay slot */
+
+#endif
 	UASM_i_LW(p, tmp, 0, ptep); /* get even pte */
 	UASM_i_LW(p, ptep, sizeof(pte_t), ptep); /* get odd pte */
 	if (r45k_bvahwbug())
@@ -827,6 +933,28 @@ static void __cpuinit build_update_entri
 	if (r4k_250MHZhwbug())
 		UASM_i_MTC0(p, 0, C0_ENTRYLO1);
 	UASM_i_MTC0(p, ptep, C0_ENTRYLO1); /* load it */
+#ifdef CONFIG_CPU_R5900
+	uasm_il_b(p, r, label_scratchpad_out); /* continue */
+	uasm_i_nop(p); /* branch delay slot */
+
+	uasm_l_scratchpad(l, *p);
+
+	UASM_i_MFC0(p, tmp, C0_ENTRYHI);
+	uasm_i_ori(p, tmp, tmp, 1 << 13);
+	uasm_i_xori(p, tmp, tmp, 1 << 13); /* VPN must be 16KB aligned */
+	UASM_i_MTC0(p, tmp, C0_ENTRYHI);
+
+	uasm_i_lw(p, ptep, 0, ptep); /* get even pte */
+	uasm_i_srl(p, tmp, tmp, ilog2(_PAGE_GLOBAL)); /* convert to entrylo0 */
+	uasm_i_andi(p, ptep, ptep, 0x3f); /* Only keep flags. */
+	uasm_i_lui(p, tmp, (int16_t) (SCRATCHPAD_RAM >> 16));
+	uasm_i_or(p, ptep, ptep, tmp); /* Set highest bit to use scratchpad. */
+	UASM_i_MTC0(p, ptep, C0_ENTRYLO0); /* load it */
+	uasm_i_xor(p, ptep, ptep, tmp); /* Clear highest bit. */
+	UASM_i_MTC0(p, ptep, C0_ENTRYLO1); /* load it */
+
+	uasm_l_scratchpad_out(l, *p);
+#endif
 #endif
 }
 
@@ -851,14 +979,26 @@ static void __cpuinit build_r4000_tlb_re
 	memset(relocs, 0, sizeof(relocs));
 	memset(final_handler, 0, sizeof(final_handler));
 
+#ifdef CONFIG_CPU_R5900
+	uasm_i_nop(&p);
+	uasm_i_nop(&p);
+#endif
+
 	/*
 	 * create the plain linear handler
 	 */
 	if (bcm1250_m3_war()) {
 		unsigned int segbits = 44;
 
+#ifndef CONFIG_CPU_R5900
 		uasm_i_dmfc0(&p, K0, C0_BADVADDR);
 		uasm_i_dmfc0(&p, K1, C0_ENTRYHI);
+#else
+		uasm_i_syncp(&p);
+		uasm_i_mfc0(&p, K0, C0_BADVADDR);
+		uasm_i_syncp(&p);
+		uasm_i_mfc0(&p, K1, C0_ENTRYHI);
+#endif
 		uasm_i_xor(&p, K0, K0, K1);
 		uasm_i_dsrl_safe(&p, K1, K0, 62);
 		uasm_i_dsrl_safe(&p, K0, K0, 12 + 1);
@@ -879,10 +1019,18 @@ static void __cpuinit build_r4000_tlb_re
 #endif
 
 	build_get_ptep(&p, K0, K1);
-	build_update_entries(&p, K0, K1);
+	build_update_entries(&p, &l, &r, K0, K1);
 	build_tlb_write_entry(&p, &l, &r, tlb_random);
 	uasm_l_leave(&l, p);
 	uasm_i_eret(&p); /* return from trap */
+#ifdef CONFIG_CPU_R5900
+	/* There should be nothing which can be interpreted as cache instruction. */
+	uasm_i_nop(&p);
+	uasm_i_nop(&p);
+	uasm_i_nop(&p);
+	uasm_i_nop(&p);
+	uasm_i_nop(&p);
+#endif
 
 #ifdef CONFIG_HUGETLB_PAGE
 	uasm_l_tlb_huge_update(&l, p);
@@ -1318,6 +1466,10 @@ build_r4000_tlbchange_handler_head(u32 *
 				   struct uasm_reloc **r, unsigned int pte,
 				   unsigned int ptr)
 {
+#ifdef CONFIG_CPU_R5900
+	uasm_i_nop(p);
+	uasm_i_nop(p);
+#endif
 #ifdef CONFIG_64BIT
 	build_get_pmde64(p, l, r, pte, ptr); /* get pmd in ptr */
 #else
@@ -1354,10 +1506,18 @@ build_r4000_tlbchange_handler_tail(u32 *
 {
 	uasm_i_ori(p, ptr, ptr, sizeof(pte_t));
 	uasm_i_xori(p, ptr, ptr, sizeof(pte_t));
-	build_update_entries(p, tmp, ptr);
+	build_update_entries(p, l, r, tmp, ptr);
 	build_tlb_write_entry(p, l, r, tlb_indexed);
 	uasm_l_leave(l, *p);
 	uasm_i_eret(p); /* return from trap */
+#ifdef CONFIG_CPU_R5900
+	/* There should be nothing which can be interpreted as cache instruction. */
+	uasm_i_nop(p);
+	uasm_i_nop(p);
+	uasm_i_nop(p);
+	uasm_i_nop(p);
+	uasm_i_nop(p);
+#endif
 
 #ifdef CONFIG_64BIT
 	build_get_pgd_vmalloc64(p, l, r, tmp, ptr, not_refill);
@@ -1377,8 +1537,17 @@ static void __cpuinit build_r4000_tlb_lo
 	if (bcm1250_m3_war()) {
 		unsigned int segbits = 44;
 
+#ifndef CONFIG_CPU_R5900
+		uasm_i_nop(&p);
+		uasm_i_nop(&p);
 		uasm_i_dmfc0(&p, K0, C0_BADVADDR);
 		uasm_i_dmfc0(&p, K1, C0_ENTRYHI);
+#else
+		uasm_i_syncp(&p);
+		uasm_i_mfc0(&p, K0, C0_BADVADDR);
+		uasm_i_syncp(&p);
+		uasm_i_mfc0(&p, K1, C0_ENTRYHI);
+#endif
 		uasm_i_xor(&p, K0, K0, K1);
 		uasm_i_dsrl_safe(&p, K1, K0, 62);
 		uasm_i_dsrl_safe(&p, K0, K0, 12 + 1);
@@ -1403,6 +1572,14 @@ static void __cpuinit build_r4000_tlb_lo
 		uasm_i_nop(&p);
 
 		uasm_i_tlbr(&p);
+#ifdef CONFIG_CPU_R5900
+		uasm_i_syncp(&p);
+		uasm_i_nop(&p);
+		uasm_i_nop(&p);
+		uasm_i_nop(&p);
+		uasm_i_nop(&p);
+#endif
+
 		/* Examine  entrylo 0 or 1 based on ptr. */
 		uasm_i_andi(&p, K0, K1, sizeof(pte_t));
 		uasm_i_beqz(&p, K0, 8);
@@ -1443,6 +1620,14 @@ static void __cpuinit build_r4000_tlb_lo
 		uasm_i_nop(&p);
 
 		uasm_i_tlbr(&p);
+#ifdef CONFIG_CPU_R5900
+		uasm_i_syncp(p);
+		uasm_i_nop(&p);
+		uasm_i_nop(&p);
+		uasm_i_nop(&p);
+		uasm_i_nop(&p);
+#endif
+
 		/* Examine  entrylo 0 or 1 based on ptr. */
 		uasm_i_andi(&p, K0, K1, sizeof(pte_t));
 		uasm_i_beqz(&p, K0, 8);
diff -purN linux-2.6.35.4-orig/arch/mips/mm/tlbex-fault.S linux-2.6.35.4/arch/mips/mm/tlbex-fault.S
--- linux-2.6.35.4-orig/arch/mips/mm/tlbex-fault.S	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/mm/tlbex-fault.S	2014-07-18 22:29:43.546367724 +0200
@@ -14,6 +14,9 @@
 	.macro tlb_do_page_fault, write
 	NESTED(tlb_do_page_fault_\write, PT_SIZE, sp)
 	SAVE_ALL
+#ifdef CONFIG_CPU_R5900
+	sync.p
+#endif
 	MFC0	a2, CP0_BADVADDR
 	KMODE
 	move	a0, sp
diff -purN linux-2.6.35.4-orig/arch/mips/mm/uasm.c linux-2.6.35.4/arch/mips/mm/uasm.c
--- linux-2.6.35.4-orig/arch/mips/mm/uasm.c	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/mm/uasm.c	2014-07-18 22:29:43.546367724 +0200
@@ -67,7 +67,7 @@ enum opcode {
 	insn_mtc0, insn_or, insn_ori, insn_pref, insn_rfe, insn_sc, insn_scd,
 	insn_sd, insn_sll, insn_sra, insn_srl, insn_rotr, insn_subu, insn_sw,
 	insn_tlbp, insn_tlbr, insn_tlbwi, insn_tlbwr, insn_xor, insn_xori,
-	insn_dins, insn_syscall
+	insn_dins, insn_syscall, insn_sync, insn_syncp
 };
 
 struct insn {
@@ -141,6 +141,8 @@ static struct insn insn_table[] __cpuini
 	{ insn_xori,  M(xori_op, 0, 0, 0, 0, 0),  RS | RT | UIMM },
 	{ insn_dins, M(spec3_op, 0, 0, 0, 0, dins_op), RS | RT | RD | RE },
 	{ insn_syscall, M(spec_op, 0, 0, 0, 0, syscall_op), SCIMM},
+	{ insn_sync,  M(spec_op, 0, 0, 0, 0, sync_op),  0 },
+	{ insn_syncp,  M(spec_op, 0, 0, 0, 0x10, sync_op),  0 },
 	{ insn_invalid, 0, 0 }
 };
 
@@ -365,8 +367,10 @@ I_u1s2(_bltz)
 I_u1s2(_bltzl)
 I_u1u2s3(_bne)
 I_u2s3u1(_cache)
+#ifndef CONFIG_CPU_R5900
 I_u1u2u3(_dmfc0)
 I_u1u2u3(_dmtc0)
+#endif
 I_u2u1s3(_daddiu)
 I_u3u1u2(_daddu)
 I_u2u1u3(_dsll)
@@ -408,6 +412,8 @@ I_u3u1u2(_xor)
 I_u2u1u3(_xori)
 I_u2u1msbu3(_dins);
 I_u1(_syscall);
+I_0(_sync)
+I_0(_syncp)
 
 /* Handle labels. */
 void __cpuinit uasm_build_label(struct uasm_label **lab, u32 *addr, int lid)
@@ -420,7 +426,7 @@ void __cpuinit uasm_build_label(struct u
 int __cpuinit uasm_in_compat_space_p(long addr)
 {
 	/* Is this address in 32bit compat space? */
-#ifdef CONFIG_64BIT
+#if defined(CONFIG_64BIT) && !defined(CONFIG_CPU_R5900)
 	return (((addr) & 0xffffffff00000000L) == 0xffffffff00000000L);
 #else
 	return 1;
@@ -429,7 +435,7 @@ int __cpuinit uasm_in_compat_space_p(lon
 
 static int __cpuinit uasm_rel_highest(long val)
 {
-#ifdef CONFIG_64BIT
+#if defined(CONFIG_64BIT) && !defined(CONFIG_CPU_R5900)
 	return ((((val + 0x800080008000L) >> 48) & 0xffff) ^ 0x8000) - 0x8000;
 #else
 	return 0;
@@ -438,7 +444,7 @@ static int __cpuinit uasm_rel_highest(lo
 
 static int __cpuinit uasm_rel_higher(long val)
 {
-#ifdef CONFIG_64BIT
+#if defined(CONFIG_64BIT) && !defined(CONFIG_CPU_R5900)
 	return ((((val + 0x80008000L) >> 32) & 0xffff) ^ 0x8000) - 0x8000;
 #else
 	return 0;
diff -purN linux-2.6.35.4-orig/arch/mips/oprofile/Makefile linux-2.6.35.4/arch/mips/oprofile/Makefile
--- linux-2.6.35.4-orig/arch/mips/oprofile/Makefile	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/arch/mips/oprofile/Makefile	2014-07-18 22:29:43.546367724 +0200
@@ -1,4 +1,4 @@
-EXTRA_CFLAGS := -Werror
+EXTRA_CFLAGS :=
 
 obj-$(CONFIG_OPROFILE) += oprofile.o
 
diff -purN linux-2.6.35.4-orig/arch/mips/ps2/dma.c linux-2.6.35.4/arch/mips/ps2/dma.c
--- linux-2.6.35.4-orig/arch/mips/ps2/dma.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/ps2/dma.c	2014-07-18 22:29:43.550367724 +0200
@@ -0,0 +1,293 @@
+/*
+ *  Playstation 2 DMA functions.
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/completion.h>
+
+#include <asm/types.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/pgtable.h>
+#include <asm/cacheflush.h>
+
+#include <asm/mach-ps2/ps2.h>
+#include <asm/mach-ps2/irq.h>
+#include <asm/mach-ps2/dma.h>
+
+struct dma_channel ps2dma_channels[] = {
+    { IRQ_DMAC_0, 0x10008000, DMA_SENDCH, 0, "VIF0 DMA", },
+    { IRQ_DMAC_1, 0x10009000, DMA_SENDCH, 0, "VIF1 DMA", },
+    { IRQ_DMAC_2, 0x1000a000, DMA_SENDCH, 0, "GIF DMA", },
+    { IRQ_DMAC_3, 0x1000b000, DMA_RECVCH, 0, "fromIPU DMA", },
+    { IRQ_DMAC_4, 0x1000b400, DMA_SENDCH, 0, "toIPU DMA", },
+    { IRQ_DMAC_8, 0x1000d000, DMA_RECVCH, 1, "fromSPR DMA", },
+    { IRQ_DMAC_9, 0x1000d400, DMA_SENDCH, 1, "toSPR DMA", },
+};
+
+irqreturn_t ps2dma_intr_handler(int irq, void *dev_id)
+{
+    unsigned long flags;
+    struct dma_channel *ch = (struct dma_channel *)dev_id;
+    struct dma_request *cur_req, *next_req;
+
+    spin_lock_irqsave(&ch->lock, flags);
+
+    /* to prevent stray interrupt while DMA polling */
+    outl(1 << (irq - IRQ_DMAC), PS2_D_STAT);
+
+    cur_req = ch->tail;
+    if (cur_req == NULL) {
+	spin_unlock_irqrestore(&ch->lock, flags);
+	return IRQ_HANDLED;
+    }
+    next_req = cur_req->next;
+
+    if (cur_req->ops->isdone) {
+	if (!cur_req->ops->isdone(cur_req, ch)) {
+	    spin_unlock_irqrestore(&ch->lock, flags);
+	    return IRQ_HANDLED;
+	}
+    }
+
+    if ((ch->tail = next_req) != NULL)
+	next_req->ops->start(next_req, ch);
+
+    cur_req->ops->free(cur_req, ch);
+
+    spin_unlock_irqrestore(&ch->lock, flags);
+    return IRQ_HANDLED;
+}
+
+void ps2dma_add_queue(struct dma_request *req, struct dma_channel *ch, int flushall)
+{
+    unsigned long flags;
+
+#if 0
+	/* This flushes data and instruction cache. */
+    __flush_cache_all();
+#else
+	/* This functions is only used by graphical routines,
+	 * so only flushing of data cache is needed. This will heavily
+	 * increase the performance.
+	 * TBD: When updating kernel, check if __flush_cache_vmap()
+	 * always flushes the complete data cache and never flushes
+	 * the instruction cache because of the performance penalty.
+	 * TBD: Function would be faster if only the required area is
+	 * flushed.
+	 */
+	if (flushall) {
+		__flush_cache_vmap();
+	}
+#endif
+
+    spin_lock_irqsave(&ch->lock, flags);
+
+    if (ch->tail == NULL) {
+	ch->tail = ch->head = req;
+	req->ops->start(req, ch);
+    } else {
+	ch->head->next = req;
+	ch->head = req;
+    }
+
+    spin_unlock_irqrestore(&ch->lock, flags);
+}
+
+/*
+ *  Wait-for-completion functions
+ */
+
+static inline int dma_sleeping_wait(struct dma_channel *ch, struct dma_completion *x)
+{
+    unsigned long flags;
+    int result = 0;
+
+    spin_lock_irqsave(&x->lock, flags);
+    if (!x->done) {
+	DECLARE_WAITQUEUE(wait, current);
+	add_wait_queue_exclusive(&x->wait, &wait);
+	do {
+	    set_current_state(TASK_UNINTERRUPTIBLE);
+	    spin_unlock_irq(&x->lock);
+	    if (schedule_timeout(DMA_TIMEOUT) == 0)
+		result = -1;
+	    spin_lock_irq(&x->lock);
+	} while (!x->done && result == 0);
+	remove_wait_queue(&x->wait, &wait);
+	if (!x->done) {
+	    /* timeout - DMA force break */
+	    DMABREAK(ch);
+	    /* reset device FIFO */
+	    if (ch->reset != NULL)
+		ch->reset();
+	    /* next request */
+	    ps2dma_intr_handler(ch->irq, ch);
+	}
+    }
+    x->done = 0;
+    spin_unlock_irqrestore(&x->lock, flags);
+    return result;
+}
+
+static inline int dma_polling_wait(struct dma_channel *ch, struct dma_completion *x)
+{
+    unsigned long flags;
+    int result = 0;
+    int count = DMA_POLLING_TIMEOUT;
+
+    spin_lock_irqsave(&x->lock, flags);
+    if (x->done) {
+	x->done = 0;
+	spin_unlock_irqrestore(&x->lock, flags);
+	return result;
+    }
+
+    disable_irq(ch->irq);
+
+    do {
+	spin_unlock_irqrestore(&x->lock, flags);
+	if (!IS_DMA_RUNNING(ch))
+	    ps2dma_intr_handler(ch->irq, ch);
+	if (--count <= 0)
+	    result = -1;
+	spin_lock_irqsave(&x->lock, flags);
+    } while (!x->done && result == 0);
+
+    if (!x->done) {
+	/* timeout - DMA force break */
+	DMABREAK(ch);
+	/* reset device FIFO */
+	if (ch->reset != NULL)
+	    ch->reset();
+	/* next request */
+	ps2dma_intr_handler(ch->irq, ch);
+    }
+    x->done = 0;
+    enable_irq(ch->irq);
+    spin_unlock_irqrestore(&x->lock, flags);
+    return result;
+}
+
+void ps2dma_complete(struct dma_completion *x)
+{
+    unsigned long flags;
+
+    spin_lock_irqsave(&x->lock, flags);
+    x->done = 1;
+    wake_up(&x->wait);
+    spin_unlock_irqrestore(&x->lock, flags);
+}
+
+void ps2dma_init_completion(struct dma_completion *x)
+{
+    x->done = 0;
+    spin_lock_init(&x->lock);
+    init_waitqueue_head(&x->wait);
+}
+
+int ps2dma_intr_safe_wait_for_completion(struct dma_channel *ch, int polling, struct dma_completion *x)
+{
+    if (polling)
+	return dma_polling_wait(ch, x);
+    else
+	return dma_sleeping_wait(ch, x);
+}
+
+/*
+ *  Simple DMA functions
+ */
+
+struct sdma_request {
+    struct dma_request r;
+    unsigned long madr;
+    unsigned long qwc;
+    struct dma_completion c;
+};
+
+static void sdma_send_start(struct dma_request *req, struct dma_channel *ch)
+{
+    struct sdma_request *sreq = (struct sdma_request *)req;
+
+    WRITEDMAREG(ch, PS2_Dn_MADR, sreq->madr);
+    WRITEDMAREG(ch, PS2_Dn_QWC, sreq->qwc);
+    WRITEDMAREG(ch, PS2_Dn_CHCR, CHCR_SENDN);
+}
+
+static void sdma_free(struct dma_request *req, struct dma_channel *ch)
+{
+    struct sdma_request *sreq = (struct sdma_request *)req;
+
+    ps2dma_complete(&sreq->c);
+}
+
+static struct dma_ops sdma_send_ops =
+{ sdma_send_start, NULL, NULL, sdma_free };
+
+int ps2sdma_send(int chno, const void *ptr, int len, int flushall)
+{
+    struct sdma_request sreq;
+    struct dma_channel *ch = &ps2dma_channels[chno];
+    int result;
+
+    init_dma_request(&sreq.r, &sdma_send_ops);
+    sreq.madr = virt_to_bus(ptr);
+    sreq.qwc = len >> 4;
+    ps2dma_init_completion(&sreq.c);
+
+    ps2dma_add_queue((struct dma_request *)&sreq, ch, flushall);
+    do {
+	result = ps2dma_intr_safe_wait_for_completion(ch, in_interrupt(), &sreq.c);
+	if (result)
+	    ps2_printf("ps2dma: %s timeout\n", ch->device);
+    } while (result != 0);
+    return 0;
+}
+
+/*
+ * Initialize DMA handlers
+ */
+
+void __init ps2dma_init(void)
+{
+    int i;
+
+    for (i = 0; i < sizeof(ps2dma_channels) / sizeof(ps2dma_channels[0]); i++) {
+    	spin_lock_init(&ps2dma_channels[i].lock);
+
+	if (request_irq(ps2dma_channels[i].irq, ps2dma_intr_handler,
+			0, ps2dma_channels[i].device,
+			&ps2dma_channels[i]))
+	    printk("unable to get irq %d\n", i);
+    }
+}
+
+EXPORT_SYMBOL(ps2dma_channels);
+EXPORT_SYMBOL(ps2dma_intr_handler);
+EXPORT_SYMBOL(ps2dma_add_queue);
+EXPORT_SYMBOL(ps2dma_complete);
+EXPORT_SYMBOL(ps2dma_init_completion);
+EXPORT_SYMBOL(ps2dma_intr_safe_wait_for_completion);
+EXPORT_SYMBOL(ps2sdma_send);
diff -purN linux-2.6.35.4-orig/arch/mips/ps2/gs.c linux-2.6.35.4/arch/mips/ps2/gs.c
--- linux-2.6.35.4-orig/arch/mips/ps2/gs.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/ps2/gs.c	2014-07-18 22:29:43.550367724 +0200
@@ -0,0 +1,996 @@
+/*
+ *  PlayStation 2 miscellaneous Graphics Synthesizer functions
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/ps2/dev.h>
+#include <linux/ps2/gs.h>
+
+#include <asm/io.h>
+
+#include <asm/mach-ps2/ps2.h>
+#include <asm/mach-ps2/irq.h>
+#include <asm/mach-ps2/dma.h>
+#include <asm/mach-ps2/gsfunc.h>
+#include <asm/mach-ps2/eedev.h>
+#include <asm/mach-ps2/sysconf.h>
+#include <asm/mach-ps2/sbios.h>
+
+/** Aligment for GS packets. */
+#define DMA_ALIGN_SIZE 16
+
+typedef struct gsreg_packet {
+	ps2_giftag giftag;			/* 128bit */
+	u64 param[2];
+} gsreg_packet_t;
+
+static u64 gssreg[0x10];
+
+static int gs_mode = -1;
+
+static int gs_pmode;
+
+static int gs_dx[2], gs_dy[2];
+
+static struct ps2_crtmode current_crtmode;
+
+static struct ps2_display current_display[2];
+
+static struct ps2_dispfb current_dispfb[2];
+
+static struct ps2_pmode current_pmode;
+
+static struct ps2_screeninfo current_screeninfo;
+
+
+/*
+ *  GS register read / write
+ */
+
+int ps2gs_set_gssreg(int reg, u64 val)
+{
+	if (reg >= PS2_GSSREG_PMODE && reg <= PS2_GSSREG_BGCOLOR) {
+		gssreg[reg] = val;
+		outq(val, GSSREG1(reg));
+	} else if (reg == PS2_GSSREG_CSR) {
+		val &= 1 << 8;
+		outq(val, GSSREG2(reg));
+	} else if (reg == PS2_GSSREG_SIGLBLID) {
+		outq(val, GSSREG2(reg));
+	} else
+		return -1;				/* bad register no. */
+	return 0;
+}
+
+static int ps2gs_set_gssreg_dummy(int reg, u64 val)
+{
+	if (reg >= PS2_GSSREG_PMODE && reg <= PS2_GSSREG_BGCOLOR) {
+		gssreg[reg] = val;
+	} else
+		return -1;				/* bad register no. */
+	return 0;
+}
+
+int ps2gs_get_gssreg(int reg, u64 * val)
+{
+	if (reg == PS2_GSSREG_CSR || reg == PS2_GSSREG_SIGLBLID) {
+		/* readable register */
+		*val = inq(GSSREG2(reg));
+	} else if (reg >= 0 && reg <= 0x0e) {
+		/* write only register .. return saved value */
+		*val = gssreg[reg];
+	} else
+		return -1;				/* bad register no. */
+	return 0;
+}
+
+int ps2gs_set_gsreg(int reg, u64 val)
+{
+	unsigned char buffer[sizeof(gsreg_packet_t) + DMA_ALIGN_SIZE];
+
+	/* Align packet to 16 byte on stack. */
+	gsreg_packet_t *packet =
+		(void *) ((((unsigned int) buffer) + DMA_ALIGN_SIZE -
+			1) & ~(DMA_ALIGN_SIZE - 1));
+
+	PS2_GIFTAG_CLEAR_TAG(&(packet->giftag));
+	packet->giftag.NLOOP = 1;
+	packet->giftag.EOP = 1;
+	packet->giftag.PRE = 0;
+	packet->giftag.PRIM = 0;
+	packet->giftag.FLG = PS2_GIFTAG_FLG_PACKED;
+	packet->giftag.NREG = 1;
+	packet->giftag.REGS0 = PS2_GIFTAG_REGS_AD;
+	packet->param[0] = val;
+	packet->param[1] = reg;
+
+	ps2sdma_send(DMA_GIF, packet, sizeof(*packet), 1 /* TBD: optimize */ );
+	return 0;
+}
+
+/*
+ *  PCRTC sync parameters
+ */
+
+#define vSMODE1(VHP,VCKSEL,SLCK2,NVCK,CLKSEL,PEVS,PEHS,PVS,PHS,GCONT,SPML,PCK2,XPCK,SINT,PRST,EX,CMOD,SLCK,T1248,LC,RC)	\
+	(((u64)(VHP)<<36)   | ((u64)(VCKSEL)<<34) | ((u64)(SLCK2)<<33) | \
+	 ((u64)(NVCK)<<32)  | ((u64)(CLKSEL)<<30) | ((u64)(PEVS)<<29)  | \
+	 ((u64)(PEHS)<<28)  | ((u64)(PVS)<<27)    | ((u64)(PHS)<<26)   | \
+	 ((u64)(GCONT)<<25) | ((u64)(SPML)<<21)   | ((u64)(PCK2)<<19)  | \
+	 ((u64)(XPCK)<<18)  | ((u64)(SINT)<<17)   | ((u64)(PRST)<<16)  | \
+	 ((u64)(EX)<<15)    | ((u64)(CMOD)<<13)   | ((u64)(SLCK)<<12)  | \
+	 ((u64)(T1248)<<10) | ((u64)(LC)<<3)      | ((u64)(RC)<<0))
+#define vSYNCH1(HS,HSVS,HSEQ,HBP,HFP)	\
+	(((u64)(HS)<<43) | ((u64)(HSVS)<<32) | ((u64)(HSEQ)<<22) | \
+	 ((u64)(HBP)<<11) | ((u64)(HFP)<<0))
+#define vSYNCH2(HB,HF) \
+	(((u64)(HB)<<11) | ((u64)(HF)<<0))
+#define vSYNCV(VS,VDP,VBPE,VBP,VFPE,VFP) \
+	(((u64)(VS)<<53) | ((u64)(VDP)<<42) | ((u64)(VBPE)<<32) | \
+	 ((u64)(VBP)<<20) | ((u64)(VFPE)<<10) | ((u64)(VFP)<<0))
+
+struct rdisplay {
+	int magv, magh, dy, dx;
+};
+
+#define vDISPLAY(DH,DW,MAGV,MAGH,DY,DX) \
+	{ (MAGV), (MAGH), (DY), (DX) }
+#define wDISPLAY(DH,DW,MAGV,MAGH,DY,DX) \
+	(((u64)(DH)<<44) | ((u64)(DW)<<32) | ((u64)(MAGV)<<27) | \
+	 ((u64)(MAGH)<<23) | ((u64)(DY)<<12) | ((u64)(DX)<<0))
+
+struct syncparam {
+	int width, height, rheight, dvemode;
+	u64 smode1, smode2, srfsh, synch1, synch2, syncv;
+	struct rdisplay display;
+};
+
+
+static const struct syncparam syncdata0[] = {
+	/* 0: NTSC-NI (640x240(224)) */
+	{640, 240, 224, 0,
+			vSMODE1(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 4, 0, 0, 1, 1, 0, 2, 0, 1, 32,
+				4), 0, 8,
+			vSYNCH1(254, 1462, 124, 222, 64), vSYNCH2(1652, 1240),
+		vSYNCV(6, 480, 6, 26, 6, 2), vDISPLAY(239, 2559, 0, 3, 25, 632)},
+
+	/* 1: NTSC-I (640x480(448)) */
+	{640, 480, 448, 0,
+			vSMODE1(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 4, 0, 0, 1, 1, 0, 2, 0, 1, 32,
+				4), 1, 8,
+			vSYNCH1(254, 1462, 124, 222, 64), vSYNCH2(1652, 1240),
+		vSYNCV(6, 480, 6, 26, 6, 1), vDISPLAY(479, 2559, 0, 3, 50, 632)},
+
+
+	/* 2: PAL-NI (640x288(256)) */
+	{640, 288, 256, 1,
+			vSMODE1(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 4, 0, 0, 1, 1, 0, 3, 0, 1, 32,
+				4), 0, 8,
+			vSYNCH1(254, 1474, 127, 262, 48), vSYNCH2(1680, 1212),
+		vSYNCV(5, 576, 5, 33, 5, 4), vDISPLAY(287, 2559, 0, 3, 36, 652)},
+
+	/* 3: PAL-I (640x576(512)) */
+	{640, 576, 512, 1,
+			vSMODE1(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 4, 0, 0, 1, 1, 0, 3, 0, 1, 32,
+				4), 1, 8,
+			vSYNCH1(254, 1474, 127, 262, 48), vSYNCH2(1680, 1212),
+		vSYNCV(5, 576, 5, 33, 5, 1), vDISPLAY(575, 2559, 0, 3, 72, 652)},
+
+
+	/* 4: VESA-1A (640x480 59.940Hz) */
+	{640, 480, -1, 2,
+			vSMODE1(1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 0, 0, 0, 1, 15,
+				2), 0, 4,
+			vSYNCH1(192, 608, 192, 84, 32), vSYNCH2(768, 524),
+		vSYNCV(2, 480, 0, 33, 0, 10), vDISPLAY(479, 1279, 0, 1, 34, 276)},
+
+	/* 5: VESA-1C (640x480 75.000Hz) */
+	{640, 480, -1, 2,
+			vSMODE1(1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 0, 0, 0, 1, 28,
+				3), 0, 4,
+			vSYNCH1(128, 712, 128, 228, 32), vSYNCH2(808, 484),
+		vSYNCV(3, 480, 0, 16, 0, 1), vDISPLAY(479, 1279, 0, 1, 18, 356)},
+
+
+	/* 6:  VESA-2B (800x600 60.317Hz) */
+	{800, 600, -1, 2,
+			vSMODE1(1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 0, 0, 0, 1, 71,
+				6), 0, 4,
+			vSYNCH1(256, 800, 256, 164, 80), vSYNCH2(976, 636),
+		vSYNCV(4, 600, 0, 23, 0, 1), vDISPLAY(599, 1599, 0, 1, 26, 420)},
+
+	/* 7: VESA-2D (800x600 75.000Hz) */
+	{800, 600, -1, 2,
+			vSMODE1(1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 0, 0, 0, 1, 44,
+				3), 0, 4,
+			vSYNCH1(160, 896, 160, 308, 32), vSYNCH2(1024, 588),
+		vSYNCV(3, 600, 0, 21, 0, 1), vDISPLAY(599, 1599, 0, 1, 23, 468)},
+
+
+	/* 8: VESA-3B (1024x768 60.004Hz) */
+	{1024, 768, -1, 2,
+			vSMODE1(1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 0, 0, 0, 0, 58,
+				6), 0, 4,
+			vSYNCH1(272, 1072, 272, 308, 48), vSYNCH2(1296, 764),
+		vSYNCV(6, 768, 0, 29, 0, 3), vDISPLAY(767, 2047, 0, 1, 34, 580)},
+
+	/* 9: VESA-3D (1024x768 75.029Hz) */
+	{1024, 768, -1, 2,
+			vSMODE1(1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 35,
+				3), 0, 2,
+			vSYNCH1(96, 560, 96, 164, 16), vSYNCH2(640, 396),
+		vSYNCV(3, 768, 0, 28, 0, 1), vDISPLAY(767, 1023, 0, 0, 30, 260)},
+
+
+	/* 10: VESA-4A (1280x1024 60.020Hz) */
+	{1280, 1024, -1, 2,
+			vSMODE1(1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 8,
+				1), 0, 2,
+			vSYNCH1(112, 732, 112, 236, 16), vSYNCH2(828, 496),
+		vSYNCV(3, 1024, 0, 38, 0, 1), vDISPLAY(1023, 1279, 0, 0, 40, 348)},
+
+	/* 11: VESA-4B (1280x1024 75.025Hz) */
+	{1280, 1024, -1, 2,
+			vSMODE1(1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 10,
+				1), 0, 2,
+			vSYNCH1(144, 700, 144, 236, 16), vSYNCH2(828, 464),
+		vSYNCV(3, 1024, 0, 38, 0, 1), vDISPLAY(1023, 1279, 0, 0, 40, 380)},
+
+
+	/* 12: DTV-480P (720x480) */
+	{720, 480, -1, 3,
+			vSMODE1(1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 2, 0, 0, 1, 1, 0, 0, 0, 1, 32,
+				4), 0, 4,
+			vSYNCH1(128, 730, 128, 104, 32), vSYNCH2(826, 626),
+		vSYNCV(6, 483, 0, 30, 0, 6), vDISPLAY(479, 1439, 0, 1, 35, 232)},
+
+	/* 13: DTV-1080I (1920x1080) */
+	{1920, 1080, -1, 4,
+			vSMODE1(0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 22,
+				2), 1, 4,
+			vSYNCH1(104, 1056, 44, 134, 30), vSYNCH2(1064, 868),
+		vSYNCV(10, 1080, 2, 28, 0, 5), vDISPLAY(1079, 1919, 0, 0, 40, 238)},
+
+	/* 14: DTV-720P (1280x720) */
+	{1280, 720, -1, 5,
+			vSMODE1(1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 22,
+				2), 0, 4,
+			vSYNCH1(104, 785, 40, 198, 62), vSYNCH2(763, 529),
+		vSYNCV(5, 720, 0, 20, 0, 5), vDISPLAY(719, 1279, 0, 0, 24, 302)},
+};
+
+
+/* GS rev.19 or later */
+static const struct syncparam syncdata1[] = {
+	/* 0: NTSC-NI (640x240(224)) */
+	{640, 240, 224, 0,
+			vSMODE1(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 4, 0, 0, 1, 1, 0, 2, 0, 1, 32,
+				4), 0, 8,
+			vSYNCH1(254, 1462, 124, 222, 64), vSYNCH2(1652, 1240),
+		vSYNCV(6, 480, 6, 26, 6, 2), vDISPLAY(239, 2559, 0, 3, 25, 632)},
+
+	/* 1: NTSC-I (640x480(448)) */
+	{640, 480, 448, 0,
+			vSMODE1(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 4, 0, 0, 1, 1, 0, 2, 0, 1, 32,
+				4), 1, 8,
+			vSYNCH1(254, 1462, 124, 222, 64), vSYNCH2(1652, 1240),
+		vSYNCV(6, 480, 6, 26, 6, 1), vDISPLAY(479, 2559, 0, 3, 50, 632)},
+
+
+	/* 2: PAL-NI (640x288(256)) */
+	{640, 288, 256, 1,
+			vSMODE1(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 4, 0, 0, 1, 1, 0, 3, 0, 1, 32,
+				4), 0, 8,
+			vSYNCH1(254, 1474, 127, 262, 48), vSYNCH2(1680, 1212),
+		vSYNCV(5, 576, 5, 33, 5, 4), vDISPLAY(287, 2559, 0, 3, 36, 652)},
+
+	/* 3: PAL-I (640x576(512)) */
+	{640, 576, 512, 1,
+			vSMODE1(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 4, 0, 0, 1, 1, 0, 3, 0, 1, 32,
+				4), 1, 8,
+			vSYNCH1(254, 1474, 127, 262, 48), vSYNCH2(1680, 1212),
+		vSYNCV(5, 576, 5, 33, 5, 1), vDISPLAY(575, 2559, 0, 3, 72, 652)},
+
+
+	/* 4: VESA-1A (640x480 59.940Hz) */
+	{640, 480, -1, 2,
+			vSMODE1(1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 0, 0, 0, 1, 15,
+				2), 0, 4,
+			vSYNCH1(192, 608, 192, 81, 47), vSYNCH2(753, 527),
+		vSYNCV(2, 480, 0, 33, 0, 10), vDISPLAY(479, 1279, 0, 1, 34, 272)},
+
+	/* 5: VESA-1C (640x480 75.000Hz) */
+	{640, 480, -1, 2,
+			vSMODE1(1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 0, 0, 0, 1, 28,
+				3), 0, 4,
+			vSYNCH1(128, 712, 128, 225, 47), vSYNCH2(793, 487),
+		vSYNCV(3, 480, 0, 16, 0, 1), vDISPLAY(479, 1279, 0, 1, 18, 352)},
+
+
+	/* 6:  VESA-2B (800x600 60.317Hz) */
+	{800, 600, -1, 2,
+			vSMODE1(1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 0, 0, 0, 1, 71,
+				6), 0, 4,
+			vSYNCH1(256, 800, 256, 161, 95), vSYNCH2(961, 639),
+		vSYNCV(4, 600, 0, 23, 0, 1), vDISPLAY(599, 1599, 0, 1, 26, 416)},
+
+	/* 7: VESA-2D (800x600 75.000Hz) */
+	{800, 600, -1, 2,
+			vSMODE1(1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 0, 0, 0, 1, 44,
+				3), 0, 4,
+			vSYNCH1(160, 896, 160, 305, 47), vSYNCH2(1009, 591),
+		vSYNCV(3, 600, 0, 21, 0, 1), vDISPLAY(599, 1599, 0, 1, 23, 464)},
+
+
+	/* 8: VESA-3B (1024x768 60.004Hz) */
+	{1024, 768, -1, 2,
+			vSMODE1(1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 0, 0, 0, 0, 58,
+				6), 0, 4,
+			vSYNCH1(272, 1072, 272, 305, 63), vSYNCH2(1281, 767),
+		vSYNCV(6, 768, 0, 29, 0, 3), vDISPLAY(767, 2047, 0, 1, 34, 576)},
+
+	/* 9: VESA-3D (1024x768 75.029Hz) */
+	{1024, 768, -1, 2,
+			vSMODE1(1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 35,
+				3), 0, 2,
+			vSYNCH1(96, 560, 96, 161, 31), vSYNCH2(625, 399),
+		vSYNCV(3, 768, 0, 28, 0, 1), vDISPLAY(767, 1023, 0, 0, 30, 256)},
+
+
+	/* 10: VESA-4A (1280x1024 60.020Hz) */
+	{1280, 1024, -1, 2,
+			vSMODE1(1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 8,
+				1), 0, 2,
+			vSYNCH1(112, 732, 112, 233, 63), vSYNCH2(781, 499),
+		vSYNCV(3, 1024, 0, 38, 0, 1), vDISPLAY(1023, 1279, 0, 0, 40, 344)},
+
+	/* 11: VESA-4B (1280x1024 75.025Hz) */
+	{1280, 1024, -1, 2,
+			vSMODE1(1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 10,
+				1), 0, 2,
+			vSYNCH1(144, 700, 144, 233, 31), vSYNCH2(813, 467),
+		vSYNCV(3, 1024, 0, 38, 0, 1), vDISPLAY(1023, 1279, 0, 0, 40, 376)},
+
+
+	/* 12: DTV-480P (720x480) */
+	{720, 480, -1, 3,
+			vSMODE1(1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 2, 0, 0, 1, 1, 0, 0, 0, 1, 32,
+				4), 0, 4,
+			vSYNCH1(128, 730, 128, 101, 47), vSYNCH2(811, 629),
+		vSYNCV(6, 483, 0, 30, 0, 6), vDISPLAY(479, 1439, 0, 1, 35, 228)},
+
+	/* 13: DTV-1080I (1920x1080) */
+	{1920, 1080, -1, 4,
+			vSMODE1(0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 22,
+				2), 1, 4,
+			vSYNCH1(104, 1056, 44, 131, 45), vSYNCH2(1012, 908),
+		vSYNCV(10, 1080, 2, 28, 0, 5), vDISPLAY(1079, 1919, 0, 0, 40, 234)},
+
+	/* 14: DTV-720P (1280x720) */
+	{1280, 720, -1, 5,
+			vSMODE1(1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 22,
+				2), 0, 4,
+			vSYNCH1(104, 785, 40, 195, 71), vSYNCH2(715, 565),
+		vSYNCV(5, 720, 0, 20, 0, 5), vDISPLAY(719, 1279, 0, 0, 24, 298)},
+};
+
+static const struct syncparam *syncdata = syncdata0;
+
+struct syncindex {
+	int index;
+	int modes;
+	const struct syncindex *submode;
+};
+
+static const struct syncindex vesaindex[] = {
+	{4, 2, NULL},				/* 0: 640x480 */
+	{6, 2, NULL},				/* 1: 800x600 */
+	{8, 2, NULL},				/* 2: 1024x768 */
+	{10, 2, NULL},				/* 3: 1280x1024 */
+};
+
+static const struct syncindex dtvindex[] = {
+	{12, 1, NULL},				/* 0: 480P */
+	{13, 1, NULL},				/* 1: 1080I */
+	{14, 1, NULL},				/* 2: 720P */
+};
+
+static const struct syncindex syncindex[] = {
+	{4, 4, vesaindex},			/* 0: VESA */
+	{12, 3, dtvindex},			/* 1: DTV */
+	{0, 2, NULL},				/* 2: NTSC */
+	{2, 2, NULL},				/* 3: PAL */
+};
+
+static const int gscrtmode[] = {
+	0x02,						/* 0: NTSC-NI (640x240(224)) */
+	0x02,						/* 1: NTSC-I (640x480(448)) */
+	0x03,						/* 2: PAL-NI (640x288(256)) */
+	0x03,						/* 3: PAL-I (640x576(512)) */
+	0x1a,						/* 4: VESA-1A (640x480 59.940Hz) */
+	0x1c,						/* 5: VESA-1C (640x480 75.000Hz) */
+	0x2b,						/* 6: VESA-2B (800x600 60.317Hz) */
+	0x2d,						/* 7: VESA-2D (800x600 75.000Hz) */
+	0x3b,						/* 8: VESA-3B (1024x768 60.004Hz) */
+	0x3d,						/* 9: VESA-3D (1024x768 75.029Hz) */
+	0x4a,						/* 10: VESA-4A (1280x1024 60.020Hz) */
+	0x4b,						/* 11: VESA-4B (1280x1024 75.025Hz) */
+	0x50,						/* 12: DTV-480P (720x480) */
+	0x51,						/* 13: DTV-1080I (1920x1080) */
+	0x52,						/* 14: DTV-720P (1280x720) */
+};
+
+/*
+ *  SBIOS call
+ */
+
+static inline void setdve(int mode)
+{
+	struct sb_setdve_arg arg;
+
+	arg.mode = mode;
+	sbios(SB_SETDVE, &arg);
+}
+
+static inline int setgscrt(int inter, int omode, int ffmode, int *dx1, int *dy1,
+	int *dx2, int *dy2, int rgbyc)
+{
+	struct sb_setgscrt_arg arg;
+
+	struct sb_setrgbyc_arg argr;
+
+	argr.rgbyc = rgbyc;
+	sbios(SB_SETRGBYC, &argr);
+	arg.inter = inter;
+	arg.omode = omode;
+	arg.ffmode = ffmode;
+	arg.dx1 = dx1;
+	arg.dy1 = dy1;
+	arg.dx2 = dx2;
+	arg.dy2 = dy2;
+	return sbios(SB_SETGSCRT, &arg);
+}
+
+/*
+ *  low-level PCRTC initialize
+ */
+
+static void setcrtc_old(int mode, int ffmd, int noreset)
+{
+	u64 smode1 = syncdata[mode].smode1;
+
+	if (syncdata[mode].dvemode != 2)	/* not VESA */
+		smode1 |= (u64) (ps2_sysconf->video & 1) << 25;	/* RGBYC */
+
+	if (!noreset)
+		ps2gs_set_gssreg(PS2_GSSREG_SMODE1, smode1 | ((u64) 1 << 16));
+	ps2gs_set_gssreg(PS2_GSSREG_SYNCH1, syncdata[mode].synch1);
+	ps2gs_set_gssreg(PS2_GSSREG_SYNCH2, syncdata[mode].synch2);
+	ps2gs_set_gssreg(PS2_GSSREG_SYNCV, syncdata[mode].syncv);
+	ps2gs_set_gssreg(PS2_GSSREG_SMODE2, syncdata[mode].smode2 + (ffmd << 1));
+	ps2gs_set_gssreg(PS2_GSSREG_SRFSH, syncdata[mode].srfsh);
+
+	if (!noreset && (syncdata[mode].dvemode == 2 || syncdata[mode].dvemode == 4 || syncdata[mode].dvemode == 5)) {	/* for VESA, DTV1080I,720P */
+		/* PLL on */
+		ps2gs_set_gssreg(PS2_GSSREG_SMODE1, smode1 & ~((u64) 1 << 16));
+		udelay(2500);			/* wait 2.5ms */
+	}
+
+	/* sync start */
+	ps2gs_set_gssreg(PS2_GSSREG_SMODE1,
+		smode1 & ~((u64) 1 << 16) & ~((u64) 1 << 17));
+	if (!noreset)
+		setdve(syncdata[mode].dvemode);
+
+	/* get DISPLAY register offset */
+	gs_dx[0] = gs_dx[1] = syncdata[mode].display.dx;
+	gs_dy[0] = gs_dy[1] = syncdata[mode].display.dy;
+}
+
+static int setcrtc_new(int mode, int ffmd, int noreset)
+{
+	int dx1, dy1, dx2, dy2;
+
+	int result;
+
+	u64 smode1 = syncdata[mode].smode1;
+
+	int rmode = gscrtmode[mode];
+
+#ifdef CONFIG_PS2_SBIOS_VER_CHECK
+	if (sbios(SB_GETVER, NULL) < 0x0250) {
+		return -1;
+	}
+#endif
+
+	if (noreset && (rmode == 0x02 || rmode == 0x03))
+		rmode += 0x70;
+
+	if (syncdata[mode].dvemode != 2)	/* not VESA */
+		smode1 |= (u64) (ps2_sysconf->video & 1) << 25;	/* RGBYC */
+
+	/* set gssreg dummy value */
+	ps2gs_set_gssreg_dummy(PS2_GSSREG_SYNCH1, syncdata[mode].synch1);
+	ps2gs_set_gssreg_dummy(PS2_GSSREG_SYNCH2, syncdata[mode].synch2);
+	ps2gs_set_gssreg_dummy(PS2_GSSREG_SYNCV, syncdata[mode].syncv);
+	ps2gs_set_gssreg_dummy(PS2_GSSREG_SMODE2,
+		syncdata[mode].smode2 + (ffmd << 1));
+	ps2gs_set_gssreg_dummy(PS2_GSSREG_SRFSH, syncdata[mode].srfsh);
+	ps2gs_set_gssreg_dummy(PS2_GSSREG_SMODE1,
+		smode1 & ~((u64) 1 << 16) & ~((u64) 1 << 17));
+
+	/* PCRTC real initialize */
+	result = setgscrt(syncdata[mode].smode2 & 1, rmode, ffmd,
+		&dx1, &dy1, &dx2, &dy2, ps2_sysconf->video & 1);
+
+	/* get DISPLAY register offset */
+	if (mode < 4) {
+		/* NTSC, PAL mode */
+		gs_dx[0] = gs_dx[1] = syncdata[mode].display.dx;
+		gs_dy[0] = gs_dy[1] = syncdata[mode].display.dy;
+	} else {
+		/* VESA, DTV mode */
+		gs_dx[0] = syncdata0[mode].display.dx + dx1;
+		gs_dy[0] = syncdata0[mode].display.dy + dy1;
+		gs_dx[1] = syncdata0[mode].display.dx + dx2;
+		gs_dy[1] = syncdata0[mode].display.dy + dy2;
+	}
+
+	return result;
+}
+
+static void setcrtc(int mode, int ffmd, int noreset)
+{
+	u64 val;
+
+	if (!noreset) {
+		ps2gs_get_gssreg(PS2_GSSREG_PMODE, &val);
+		ps2gs_set_gssreg(PS2_GSSREG_PMODE, val & ~(u64) 3);
+	}
+
+	if (setcrtc_new(mode, ffmd, noreset) < 0)
+		setcrtc_old(mode, ffmd, noreset);
+
+	if (!noreset)
+		ps2gs_set_gssreg(PS2_GSSREG_PMODE, val);
+}
+
+/*
+ *  PCRTC mode set functions
+ */
+
+static int setcrtmode(int check, int mode, int res)
+{
+	u64 csr;
+	int param;
+	int res0 = res & 0xff;		/* resolution */
+	int res1 = (res >> 8) & 0xff;	/* sync select */
+	int res2 = (res >> 16) & 0x01;	/* ffmd */
+	int noreset = 0;
+
+	if (res < 0) {
+		/* set current mode */
+		if (mode == PS2_GS_NTSC || mode == PS2_GS_PAL) {
+			gs_mode = syncindex[mode].index + 1;	/* interlace */
+		}
+		return 0;
+	}
+
+	/* GS revision check */
+	ps2gs_get_gssreg(PS2_GSSREG_CSR, &csr);
+	if (((csr >> 16) & 0xff) < 0x19)
+		syncdata = syncdata0;
+	else
+		syncdata = syncdata1;
+
+	if (mode < 0 ||
+		mode >= sizeof(syncindex) / sizeof(*syncindex) ||
+		syncindex[mode].index < 0)
+		return -1;
+	if (res0 >= syncindex[mode].modes)
+		return -1;
+	if (syncindex[mode].submode == NULL) {
+		param = syncindex[mode].index + res0;
+	} else {
+		if (res1 == 0)			/* highest sync rate */
+			param = (syncindex[mode].submode)[res0].index +
+				(syncindex[mode].submode)[res0].modes - 1;
+		else if (res1 <= (syncindex[mode].submode)[res0].modes)
+			param = (syncindex[mode].submode)[res0].index + res1 - 1;
+		else
+			return -1;
+	}
+	if (gs_mode >= 0 && gs_mode <= 3 && gs_mode == param) {
+		noreset = 1;
+	}
+
+	if (!check) {
+		gs_mode = param;
+		setcrtc(param, res2, noreset);
+	}
+	return 0;
+}
+
+static int setdisplay(int check, int ch, int w, int h, int dx, int dy)
+{
+	const struct syncparam *p = &syncdata[gs_mode];
+
+	u64 display;
+
+	int magh, magv;
+
+	int pdh, pdw, pmagv, pmagh, pdy, pdx;
+
+	if (w <= 0 || w >= 2048 || h <= 0 || h >= 2048 || ch < 0 || ch > 1)
+		return -1;
+
+	magh = p->display.magh + 1;
+	magv = p->display.magv + 1;
+	pmagh = p->width * magh / w;
+	pmagv = p->height * magv / h;
+
+	if (pmagh == 0 || pmagv == 0 || pmagh > 16 || pmagv > 4)
+		return -1;
+
+	pdh = h * pmagv;
+	if (p->rheight > 0) {
+		if (p->rheight * magv > pdh)
+			pdy = gs_dy[ch] + (p->rheight * magv - pdh) / 2 + dy * pmagv;
+		else
+			pdy = gs_dy[ch] + dy * pmagv;
+	} else {
+		pdy = gs_dy[ch] + (p->height * magv - pdh) / 2 + dy * pmagv;
+	}
+
+	pdw = w * pmagh;
+	pdx = gs_dx[ch] + (p->width * magh - pdw) / 2 + dx * pmagh;
+
+	if (pdx < 0 || pdy < 0)
+		return -1;
+
+	display = wDISPLAY((pdh - 1) & 0x7ff, (pdw - 1) & 0xfff,
+		pmagv - 1, pmagh - 1, pdy & 0x7ff, pdx & 0xfff);
+
+	if (ch == 0 || ch == 1) {
+		if (!check)
+			ps2gs_set_gssreg((ch == 0) ?
+				PS2_GSSREG_DISPLAY1 : PS2_GSSREG_DISPLAY2, display);
+	} else {
+		return -1;
+	}
+
+	return 0;
+}
+
+static int setdispfb(int check, int ch, int fbp, int fbw, int psm, int dbx,
+	int dby)
+{
+	u64 dispfb;
+
+	dispfb = (fbp & 0x1ff) + ((fbw & 0x3f) << 9) +
+		((psm & 0x1f) << 15) +
+		((u64) (dbx & 0x7ff) << 32) + ((u64) (dby & 0x7ff) << 43);
+
+	if (ch == 0 || ch == 1) {
+		if (!check)
+			ps2gs_set_gssreg((ch == 0) ?
+				PS2_GSSREG_DISPFB1 : PS2_GSSREG_DISPFB2, dispfb);
+	} else {
+		return -1;
+	}
+
+	return 0;
+}
+
+static int setpmode(int check, int sw, int mmod, int amod, int slbg, int alp)
+{
+	u64 pmode;
+
+	pmode = ((u64) sw & 0x3) | ((u64) 1 << 2) | (((u64) mmod & 1) << 5) |
+		(((u64) amod & 1) << 6) | (((u64) slbg & 1) << 7) |
+		(((u64) alp & 0xff) << 8);
+	if (!check) {
+		ps2gs_set_gssreg(PS2_GSSREG_PMODE, pmode);
+		gs_pmode = pmode;
+	}
+
+	return 0;
+}
+
+/*
+ *  Interface functions
+ */
+
+int ps2gs_crtmode(struct ps2_crtmode *crtmode, struct ps2_crtmode *old)
+{
+	if (old != NULL)
+		*old = current_crtmode;
+	if (crtmode == NULL)
+		return 0;
+
+	if (setcrtmode(0, crtmode->mode, crtmode->res) < 0)
+		return -1;
+	current_crtmode = *crtmode;
+	return 0;
+}
+
+int ps2gs_display(int ch, struct ps2_display *display, struct ps2_display *old)
+{
+	if (ch != 0 && ch != 1)
+		return -1;
+	if (old != NULL)
+		*old = current_display[ch];
+	if (display == NULL)
+		return 0;
+
+	if (setdisplay(0, ch, display->w, display->h, display->dx, display->dy) < 0)
+		return -1;
+	current_display[ch] = *display;
+	current_display[ch].ch = ch;
+	return 0;
+}
+
+int ps2gs_dispfb(int ch, struct ps2_dispfb *dispfb, struct ps2_dispfb *old)
+{
+	if (ch != 0 && ch != 1)
+		return -1;
+	if (old != NULL)
+		*old = current_dispfb[ch];
+	if (dispfb == NULL)
+		return 0;
+
+	if (setdispfb(0, ch, dispfb->fbp, dispfb->fbw, dispfb->psm, dispfb->dbx,
+			dispfb->dby) < 0)
+		return -1;
+	current_dispfb[ch] = *dispfb;
+	current_dispfb[ch].ch = ch;
+	return 0;
+}
+
+int ps2gs_pmode(struct ps2_pmode *pmode, struct ps2_pmode *old)
+{
+	if (old != NULL)
+		*old = current_pmode;
+	if (pmode == NULL)
+		return 0;
+
+	if (setpmode(0, pmode->sw, pmode->mmod, pmode->amod, pmode->slbg,
+			pmode->alp) < 0)
+		return -1;
+	current_pmode = *pmode;
+	return 0;
+}
+
+void (*ps2gs_screeninfo_hook) (struct ps2_screeninfo * info) = NULL;
+
+int ps2gs_screeninfo(struct ps2_screeninfo *info, struct ps2_screeninfo *old)
+{
+	int ch = 0, ctx = 0;
+	struct ps2_crtmode crtmode;
+	struct ps2_display display;
+	struct ps2_dispfb dispfb;
+	struct ps2_pmode pmode;
+
+	int result;
+
+	if (old != NULL)
+		*old = current_screeninfo;
+	if (info == NULL)
+		return 0;
+
+	crtmode.mode = info->mode;
+	crtmode.res = info->res;
+	display.ch = ch;
+	display.w = info->w;
+	display.h = info->h;
+	display.dx = display.dy = 0;
+	dispfb.ch = ch;
+	dispfb.fbp = info->fbp;
+	dispfb.fbw = (info->w + 63) / 64;
+	dispfb.psm = info->psm;
+	dispfb.dbx = dispfb.dby = 0;
+	pmode.sw = 1 << ch;
+	pmode.mmod = 1;
+	pmode.amod = 0;
+	pmode.slbg = 0;
+	pmode.alp = 0xff;
+
+	result = ps2gs_reset(PS2_GSRESET_GS);
+	if (ps2gs_crtmode(&crtmode, NULL) < 0 ||
+		ps2gs_display(0, &display, NULL) < 0 ||
+		ps2gs_display(1, &display, NULL) < 0 ||
+		ps2gs_dispfb(0, &dispfb, NULL) < 0 ||
+		ps2gs_dispfb(1, &dispfb, NULL) < 0) {
+		/* TBD: Synchronize with framebuffer driver. */
+		ps2gs_screeninfo(&current_screeninfo, NULL);
+		return -1;
+	}
+
+	/* set GS registers */
+	ps2gs_set_gsreg(PS2_GS_FRAME_1 + ctx,
+		PS2_GS_SETREG_FRAME(info->fbp & 0x1ff,
+			((info->w + 63) / 64) & 0x3f, info->psm & 0x3f, 0));
+	ps2gs_set_gsreg(PS2_GS_ZBUF_1 + ctx,
+		PS2_GS_SETREG_ZBUF(info->fbp & 0x1ff, 0, 1));
+	ps2gs_set_gsreg(PS2_GS_XYOFFSET_1 + ctx, PS2_GS_SETREG_XYOFFSET(0, 0));
+	ps2gs_set_gsreg(PS2_GS_SCISSOR_1 + ctx,
+		PS2_GS_SETREG_SCISSOR(0, info->w - 1, 0, info->h - 1));
+	ps2gs_set_gsreg(PS2_GS_TEST_1 + ctx,
+		PS2_GS_SETREG_TEST(0, 0, 0, 0, 0, 0, 1, 1));
+	ps2gs_set_gsreg(PS2_GS_FBA_1 + ctx, PS2_GS_SETREG_FBA(0));
+
+	ps2gs_set_gsreg(PS2_GS_SCANMSK, PS2_GS_SETREG_SCANMSK(0));
+	ps2gs_set_gsreg(PS2_GS_PRMODECONT, PS2_GS_SETREG_PRMODECONT(1));
+	ps2gs_set_gsreg(PS2_GS_COLCLAMP, PS2_GS_SETREG_COLCLAMP(1));
+	ps2gs_set_gsreg(PS2_GS_PABE, PS2_GS_SETREG_PABE(0));
+	ps2gs_set_gsreg(PS2_GS_DTHE, PS2_GS_SETREG_DTHE(0));
+
+	/* clear screen */
+	ps2gs_set_gsreg(PS2_GS_PRIM,
+		PS2_GS_SETREG_PRIM(6, 0, 0, 0, 0, 0, 0, ctx, 0));
+	ps2gs_set_gsreg(PS2_GS_RGBAQ, PS2_GS_SETREG_RGBAQ(0, 0, 0, 0, 0));
+	ps2gs_set_gsreg(PS2_GS_XYZ2, PS2_GS_SETREG_XYZ(0, 0, 0));
+	ps2gs_set_gsreg(PS2_GS_XYZ2,
+		PS2_GS_SETREG_XYZ(info->w << 4, info->h << 4, 0));
+
+	/* turn on display */
+	ps2gs_pmode(&pmode, NULL);
+	current_screeninfo = *info;
+
+	if (ps2gs_screeninfo_hook)
+		ps2gs_screeninfo_hook(info);
+	if (result)
+		ps2_printf("ps2gs: DMA timeout\n");
+	return 0;
+}
+
+int ps2gs_setdpms(int mode)
+{
+	u64 val;
+
+	if (syncdata[gs_mode].dvemode == 2) {
+		/* VESA mode */
+		ps2gs_get_gssreg(PS2_GSSREG_SMODE2, &val);
+		val = (val & 0x3) + ((mode & 0x3) << 2);
+		ps2gs_set_gssreg(PS2_GSSREG_SMODE2, val);
+	}
+	return 0;
+}
+
+int ps2gs_blank(int onoff)
+{
+	u64 val;
+
+	ps2gs_get_gssreg(PS2_GSSREG_PMODE, &val);
+	val &= ~3;					/* ch. off */
+	if (!onoff)
+		val |= gs_pmode & 3;	/* restore pmode */
+	ps2gs_set_gssreg(PS2_GSSREG_PMODE, val);
+	return 0;
+}
+
+/*
+ *  GS reset
+ */
+
+struct gsreset_info;
+
+struct gsreset_request {
+	struct dma_request r;
+	struct gsreset_info *info;
+	struct dma_completion c;
+};
+
+struct gsreset_info {
+	struct gsreset_request ggreq, gvreq;
+	atomic_t count;
+	int mode;
+};
+
+static void gsreset_start(struct dma_request *req, struct dma_channel *ch)
+{
+	struct gsreset_request *greq = (struct gsreset_request *) req;
+
+	void ps2_setup_gs_imr(void);
+
+	if (atomic_inc_return(&greq->info->count) > 1) {
+		switch (greq->info->mode) {
+		case PS2_GSRESET_FULL:
+			outq(0x0200ULL, GSSREG2(PS2_GSSREG_CSR));
+			ps2_setup_gs_imr();
+			/* fall through */
+		case PS2_GSRESET_GS:
+			outq(0x0100ULL, GSSREG2(PS2_GSSREG_CSR));
+			/* fall through */
+		case PS2_GSRESET_GIF:
+			SET_GIFREG(PS2_GIFREG_CTRL, 0x00000001);
+			break;
+		}
+	}
+
+	ps2dma_complete(&greq->c);
+}
+
+static void gsreset_free(struct dma_request *req, struct dma_channel *ch)
+{
+	/* nothing to do */
+}
+
+static struct dma_ops gsreset_ops = { gsreset_start, NULL, NULL, gsreset_free };
+
+int ps2gs_reset(int mode)
+{
+	struct gsreset_info info;
+
+	struct dma_channel *gifch, *vifch;
+
+	int result;
+
+	gifch = &ps2dma_channels[DMA_GIF];
+	vifch = &ps2dma_channels[DMA_VIF1];
+
+	atomic_set(&info.count, 0);
+	info.mode = mode;
+
+	init_dma_request(&info.ggreq.r, &gsreset_ops);
+	info.ggreq.info = &info;
+	ps2dma_init_completion(&info.ggreq.c);
+	init_dma_request(&info.gvreq.r, &gsreset_ops);
+	info.gvreq.info = &info;
+	ps2dma_init_completion(&info.gvreq.c);
+
+	ps2dma_add_queue((struct dma_request *) &info.ggreq, gifch, 1);
+	do {
+		result =
+			ps2dma_intr_safe_wait_for_completion(gifch, in_interrupt(),
+			&info.ggreq.c);
+	} while (result != 0);
+
+	ps2dma_add_queue((struct dma_request *) &info.gvreq, vifch, 1);
+	do {
+		result =
+			ps2dma_intr_safe_wait_for_completion(vifch, in_interrupt(),
+			&info.gvreq.c);
+	} while (result != 0);
+
+	ps2dma_intr_handler(gifch->irq, gifch);
+	ps2dma_intr_handler(vifch->irq, vifch);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(ps2gs_set_gssreg);
+EXPORT_SYMBOL(ps2gs_get_gssreg);
+EXPORT_SYMBOL(ps2gs_set_gsreg);
+
+EXPORT_SYMBOL(ps2gs_crtmode);
+EXPORT_SYMBOL(ps2gs_display);
+EXPORT_SYMBOL(ps2gs_dispfb);
+EXPORT_SYMBOL(ps2gs_pmode);
+EXPORT_SYMBOL(ps2gs_screeninfo);
+EXPORT_SYMBOL(ps2gs_setdpms);
+EXPORT_SYMBOL(ps2gs_blank);
+EXPORT_SYMBOL(ps2gs_reset);
+EXPORT_SYMBOL(ps2gs_screeninfo_hook);
diff -purN linux-2.6.35.4-orig/arch/mips/ps2/identify.c linux-2.6.35.4/arch/mips/ps2/identify.c
--- linux-2.6.35.4-orig/arch/mips/ps2/identify.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/ps2/identify.c	2014-07-18 22:29:43.550367724 +0200
@@ -0,0 +1,26 @@
+/*
+ *  PS2 system identification.
+ *
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+
+const char *get_system_type(void)
+{
+	return "Sony Playstation 2";
+}
diff -purN linux-2.6.35.4-orig/arch/mips/ps2/iopheap.c linux-2.6.35.4/arch/mips/ps2/iopheap.c
--- linux-2.6.35.4-orig/arch/mips/ps2/iopheap.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/ps2/iopheap.c	2014-07-18 22:29:43.550367724 +0200
@@ -0,0 +1,102 @@
+/*
+ *  Playstation 2 IOP memory heap management.
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/semaphore.h>
+
+#include <asm/mach-ps2/ps2.h>
+#include <asm/mach-ps2/sifdefs.h>
+#include <asm/mach-ps2/sbios.h>
+
+static DECLARE_MUTEX(iopheap_sem);
+
+EXPORT_SYMBOL(ps2sif_allociopheap);
+EXPORT_SYMBOL(ps2sif_freeiopheap);
+EXPORT_SYMBOL(ps2sif_phystobus);
+EXPORT_SYMBOL(ps2sif_bustophys);
+
+int __init ps2sif_initiopheap(void)
+{
+    volatile int i;
+    int result;
+    int err;
+
+    while (1) {
+	down(&iopheap_sem);
+	err = sbios_rpc(SBR_IOPH_INIT, NULL, &result);
+	up(&iopheap_sem);
+
+	if (err < 0)
+	    return -1;
+	if (result == 0)
+	    break;
+	i = 0x100000;
+	while (i--)
+	    ;
+    }
+    return 0;
+}
+
+dma_addr_t ps2sif_allociopheap(int size)
+{
+    struct sbr_ioph_alloc_arg arg;
+    int result;
+    int err;
+    
+    arg.size = size;
+
+    down(&iopheap_sem);
+    err = sbios_rpc(SBR_IOPH_ALLOC, &arg, &result);
+    up(&iopheap_sem);
+
+    if (err < 0)
+		return 0;
+    return result;
+}
+
+int ps2sif_freeiopheap(dma_addr_t addr)
+{
+    struct sbr_ioph_free_arg arg;
+    int result;
+    int err;
+    
+    arg.addr = addr;
+
+    down(&iopheap_sem);
+    err = sbios_rpc(SBR_IOPH_FREE, &arg, &result);
+    up(&iopheap_sem);
+
+    if (err < 0)
+		return -1;
+    return result;
+}
+
+dma_addr_t ps2sif_phystobus(phys_addr_t a)
+{
+	return((unsigned int)a - PS2_IOP_HEAP_BASE);
+}
+
+phys_addr_t ps2sif_bustophys(dma_addr_t a)
+{
+	return(a + PS2_IOP_HEAP_BASE);
+}
diff -purN linux-2.6.35.4-orig/arch/mips/ps2/irq.c linux-2.6.35.4/arch/mips/ps2/irq.c
--- linux-2.6.35.4-orig/arch/mips/ps2/irq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/ps2/irq.c	2014-07-18 22:29:43.550367724 +0200
@@ -0,0 +1,574 @@
+/*
+ *  Playstation 2 IRQ handling.
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+
+#include <asm/bootinfo.h>
+#include <asm/io.h>
+#include <asm/mipsregs.h>
+#include <asm/system.h>
+#include <asm/irq_cpu.h>
+
+#include <asm/mach-ps2/irq.h>
+#include <asm/mach-ps2/speed.h>
+#include <asm/mach-ps2/ps2.h>
+
+#define INTC_STAT	0x1000f000
+#define INTC_MASK	0x1000f010
+#define DMAC_STAT	0x1000e010
+#define DMAC_MASK	0x1000e010
+#define GS_CSR		0x12001000
+#define GS_IMR		0x12001010
+
+#define SBUS_SMFLG	0x1000f230
+#define SBUS_AIF_INTSR	0x18000004
+#define SBUS_AIF_INTEN	0x18000006
+#define SBUS_PCIC_EXC1	0x1f801476
+#define SBUS_PCIC_CSC1	0x1f801464
+#define SBUS_PCIC_IMR1	0x1f801468
+#define SBUS_PCIC_TIMR	0x1f80147e
+#define SBUS_PCIC3_TIMR	0x1f801466
+
+/*
+ * INTC
+ */
+static volatile unsigned long intc_mask = 0;
+
+static inline void intc_enable_irq(unsigned int irq_nr)
+{
+	if (!(intc_mask & (1 << irq_nr))) {
+		intc_mask |= (1 << irq_nr);
+		outl(1 << irq_nr, INTC_MASK);
+	}
+}
+
+static inline void intc_disable_irq(unsigned int irq_nr)
+{
+	if ((intc_mask & (1 << irq_nr))) {
+		intc_mask &= ~(1 << irq_nr);
+		outl(1 << irq_nr, INTC_MASK);
+	}
+}
+
+static unsigned int intc_startup_irq(unsigned int irq_nr)
+{
+	intc_enable_irq(irq_nr);
+	return 0;
+}
+
+static void intc_shutdown_irq(unsigned int irq_nr)
+{
+	intc_disable_irq(irq_nr);
+}
+
+static void intc_ack_irq(unsigned int irq_nr)
+{
+	intc_disable_irq(irq_nr);
+	outl(1 << irq_nr, INTC_STAT);
+}
+
+static void intc_end_irq(unsigned int irq_nr)
+{
+	if (!(irq_desc[irq_nr].status & (IRQ_DISABLED|IRQ_INPROGRESS))) {
+		intc_enable_irq(irq_nr);
+	} else {
+		printk("warning: end_irq %d did not enable (%x)\n", 
+				irq_nr, irq_desc[irq_nr].status);
+	}
+}
+
+static struct irq_chip intc_irq_type = {
+	.name		= "EE INTC",
+	.startup	= intc_startup_irq,
+	.shutdown	= intc_shutdown_irq,
+	.unmask		= intc_enable_irq,
+	.mask		= intc_disable_irq,
+	.mask_ack	= intc_ack_irq,
+	.end		= intc_end_irq,
+};
+
+/*
+ * DMAC
+ */
+static volatile unsigned long dmac_mask = 0;
+
+static inline void dmac_enable_irq(unsigned int irq_nr)
+{
+	unsigned int dmac_irq_nr = irq_nr - IRQ_DMAC;
+
+	if (!(dmac_mask & (1 << dmac_irq_nr))) {
+		dmac_mask |= (1 << dmac_irq_nr);
+		outl(1 << (dmac_irq_nr + 16), DMAC_MASK);
+	}
+}
+
+static inline void dmac_disable_irq(unsigned int irq_nr)
+{
+	unsigned int dmac_irq_nr = irq_nr - IRQ_DMAC;
+
+	if ((dmac_mask & (1 << dmac_irq_nr))) {
+		dmac_mask &= ~(1 << dmac_irq_nr);
+		outl(1 << (dmac_irq_nr + 16), DMAC_MASK);
+	}
+}
+
+static unsigned int dmac_startup_irq(unsigned int irq_nr)
+{
+	dmac_enable_irq(irq_nr);
+	return 0;
+}
+
+static void dmac_shutdown_irq(unsigned int irq_nr)
+{
+	dmac_disable_irq(irq_nr);
+}
+
+static void dmac_ack_irq(unsigned int irq_nr)
+{
+	unsigned int dmac_irq_nr = irq_nr - IRQ_DMAC;
+
+	dmac_disable_irq(irq_nr);
+	outl(1 << dmac_irq_nr, DMAC_STAT);
+}
+
+static void dmac_end_irq(unsigned int irq_nr)
+{
+	if (!(irq_desc[irq_nr].status & (IRQ_DISABLED|IRQ_INPROGRESS))) {
+		dmac_enable_irq(irq_nr);
+	} else {
+		printk("warning: end_irq %d did not enable (%x)\n", 
+				irq_nr, irq_desc[irq_nr].status);
+	}
+}
+
+static struct irq_chip dmac_irq_type = {
+	.name		= "EE DMAC",
+	.startup	= dmac_startup_irq,
+	.shutdown	= dmac_shutdown_irq,
+	.unmask		= dmac_enable_irq,
+	.mask		= dmac_disable_irq,
+	.mask_ack	= dmac_ack_irq,
+	.end		= dmac_end_irq,
+};
+
+/*
+ * GS
+ */
+static volatile unsigned long gs_mask = 0;
+
+void ps2_setup_gs_imr(void)
+{
+	outl(0xff00, GS_IMR);
+	outl(1 << IRQ_INTC_GS, INTC_STAT);
+	outl((~gs_mask & 0x7f) << 8, GS_IMR);
+}
+
+static inline void gs_enable_irq(unsigned int irq_nr)
+{
+	unsigned int gs_irq_nr = irq_nr - IRQ_GS;
+
+	gs_mask |= (1 << gs_irq_nr);
+	ps2_setup_gs_imr();
+}
+
+static inline void gs_disable_irq(unsigned int irq_nr)
+{
+	unsigned int gs_irq_nr = irq_nr - IRQ_GS;
+
+	gs_mask &= ~(1 << gs_irq_nr);
+	ps2_setup_gs_imr();
+}
+
+static unsigned int gs_startup_irq(unsigned int irq_nr)
+{
+	gs_enable_irq(irq_nr);
+	return 0;
+}
+
+static void gs_shutdown_irq(unsigned int irq_nr)
+{
+	gs_disable_irq(irq_nr);
+}
+
+static void gs_ack_irq(unsigned int irq_nr)
+{
+	unsigned int gs_irq_nr = irq_nr - IRQ_GS;
+
+	outl(0xff00, GS_IMR);
+	outl(1 << IRQ_INTC_GS, INTC_STAT);
+	outl(1 << gs_irq_nr, GS_CSR);
+}
+
+static void gs_end_irq(unsigned int irq_nr)
+{
+	outl((~gs_mask & 0x7f) << 8, GS_IMR);
+	if (!(irq_desc[irq_nr].status & (IRQ_DISABLED|IRQ_INPROGRESS))) {
+		gs_enable_irq(irq_nr);
+	} else {
+		printk("warning: end_irq %d did not enable (%x)\n", 
+				irq_nr, irq_desc[irq_nr].status);
+	}
+}
+
+static struct irq_chip gs_irq_type = {
+	.name		= "GS",
+	.startup	= gs_startup_irq,
+	.shutdown	= gs_shutdown_irq,
+	.unmask		= gs_enable_irq,
+	.mask		= gs_disable_irq,
+	.mask_ack	= gs_ack_irq,
+	.end		= gs_end_irq,
+};
+
+/*
+ * SBUS
+ */
+static volatile unsigned long sbus_mask = 0;
+
+static inline unsigned long sbus_enter_irq(void)
+{
+	unsigned long istat = 0;
+
+	intc_ack_irq(IRQ_INTC_SBUS);
+	if (inl(SBUS_SMFLG) & (1 << 8)) {
+		outl(1 << 8, SBUS_SMFLG);
+		switch (ps2_pcic_type) {
+		case 1:
+			if (inw(SBUS_PCIC_CSC1) & 0x0080) {
+				outw(0xffff, SBUS_PCIC_CSC1);
+				istat |= 1 << (IRQ_SBUS_PCIC - IRQ_SBUS);
+			}
+			break;
+		case 2:
+			if (inw(SBUS_PCIC_CSC1) & 0x0080) {
+				outw(0xffff, SBUS_PCIC_CSC1);
+				istat |= 1 << (IRQ_SBUS_PCIC - IRQ_SBUS);
+			}
+			break;
+		case 3:
+			istat |= 1 << (IRQ_SBUS_PCIC - IRQ_SBUS);
+			break;
+		}
+	}
+
+	if (inl(SBUS_SMFLG) & (1 << 10)) {
+		outl(1 << 10, SBUS_SMFLG);
+		istat |= 1 << (IRQ_SBUS_USB - IRQ_SBUS);
+	}
+	return istat;
+}
+
+static inline void sbus_leave_irq(void)
+{
+	unsigned short mask;
+
+	if (ps2_pccard_present == 0x0100) {
+		mask = inw(SPD_R_INTR_ENA);
+		outw(0, SPD_R_INTR_ENA);
+		outw(mask, SPD_R_INTR_ENA);
+	}
+
+	switch (ps2_pcic_type) {
+	case 1: case 2:
+		mask = inw(SBUS_PCIC_TIMR);
+		outw(1, SBUS_PCIC_TIMR);
+		outw(mask, SBUS_PCIC_TIMR);
+		break;
+	case 3:
+		mask = inw(SBUS_PCIC3_TIMR);
+		outw(1, SBUS_PCIC3_TIMR);
+		outw(mask, SBUS_PCIC3_TIMR);
+		break;
+	}
+
+	intc_enable_irq(IRQ_INTC_SBUS);
+}
+
+static inline void sbus_enable_irq(unsigned int irq_nr)
+{
+	unsigned int sbus_irq_nr = irq_nr - IRQ_SBUS;
+
+	sbus_mask |= (1 << sbus_irq_nr);
+
+	switch (irq_nr) {
+	case IRQ_SBUS_PCIC:
+		switch (ps2_pcic_type) {
+		case 1:
+			outw(0xff7f, SBUS_PCIC_IMR1);
+			break;
+		case 2:
+			outw(0, SBUS_PCIC_TIMR);
+			break;
+		case 3:
+			outw(0, SBUS_PCIC3_TIMR);
+			break;
+		}
+		break;
+	case IRQ_SBUS_USB:
+		break;
+	}
+}
+
+static inline void sbus_disable_irq(unsigned int irq_nr)
+{
+	unsigned int sbus_irq_nr = irq_nr - IRQ_SBUS;
+
+	sbus_mask &= ~(1 << sbus_irq_nr);
+
+	switch (irq_nr) {
+	case IRQ_SBUS_PCIC:
+		switch (ps2_pcic_type) {
+		case 1:
+			outw(0xffff, SBUS_PCIC_IMR1);
+			break;
+		case 2:
+			outw(1, SBUS_PCIC_TIMR);
+			break;
+		case 3:
+			outw(1, SBUS_PCIC3_TIMR);
+			break;
+		}
+		break;
+	case IRQ_SBUS_USB:
+		break;
+	}
+}
+
+static unsigned int sbus_startup_irq(unsigned int irq_nr)
+{
+	sbus_enable_irq(irq_nr);
+	return 0;
+}
+
+static void sbus_shutdown_irq(unsigned int irq_nr)
+{
+	sbus_disable_irq(irq_nr);
+}
+
+static void sbus_ack_irq(unsigned int irq_nr)
+{
+}
+
+static void sbus_end_irq(unsigned int irq_nr)
+{
+	if (!(irq_desc[irq_nr].status & (IRQ_DISABLED|IRQ_INPROGRESS))) {
+	} else {
+		printk("warning: end_irq %d did not enable (%x)\n", 
+				irq_nr, irq_desc[irq_nr].status);
+	}
+}
+
+static struct irq_chip sbus_irq_type = {
+	.name		= "IOP",
+	.startup	= sbus_startup_irq,
+	.shutdown	= sbus_shutdown_irq,
+	.unmask		= sbus_enable_irq,
+	.mask		= sbus_disable_irq,
+	.mask_ack	= sbus_ack_irq,
+	.end		= sbus_end_irq,
+};
+
+static struct irqaction cascade_gs_irqaction = {
+	.handler = no_action,
+	.name = "GS cascade",
+};
+
+static struct irqaction cascade_sbus_irqaction = {
+	.handler = no_action,
+	.name = "SBUS cascade",
+};
+
+static struct irqaction cascade_intc_irqaction = {
+	.handler = no_action,
+	.name = "INTC cascade",
+};
+
+static struct irqaction cascade_dmac_irqaction = {
+	.handler = no_action,
+	.name = "DMAC cascade",
+};
+
+void __init arch_init_irq(void)
+{
+	int i;
+	int rv;
+
+	/* init CPU irqs */
+	mips_cpu_irq_init();
+
+	for (i = 0; i < MIPS_CPU_IRQ_BASE; i++) {
+		struct irq_chip *handler;
+
+		if (i < IRQ_DMAC) {
+			handler = &intc_irq_type;
+		} else if (i < IRQ_GS) {
+			handler = &dmac_irq_type;
+		} else if (i < IRQ_SBUS) {
+			handler = &gs_irq_type;
+		} else {
+			handler = &sbus_irq_type;
+		}
+		set_irq_chip_and_handler(i, handler, handle_level_irq);
+	}
+
+	/* initialize interrupt mask */
+	intc_mask = 0;
+	outl(inl(INTC_MASK), INTC_MASK);
+	outl(inl(INTC_STAT), INTC_STAT);
+	dmac_mask = 0;
+	outl(inl(DMAC_MASK), DMAC_MASK);
+	gs_mask = 0;
+	outl(0xff00, GS_IMR);
+	outl(0x00ff, GS_CSR);
+	sbus_mask = 0;
+	outl((1 << 8) | (1 << 10), SBUS_SMFLG);
+
+	/* Enable cascaded GS IRQ. */
+	rv = setup_irq(IRQ_INTC_GS, &cascade_gs_irqaction);
+	if (rv) {
+		printk("Failed to setup GS IRQ (rv = %d).\n", rv);
+	}
+
+	/* Enable cascaded SBUS IRQ. */
+	rv = setup_irq(IRQ_INTC_SBUS, &cascade_sbus_irqaction);
+	if (rv) {
+		printk("Failed to setup SBUS IRQ (rv = %d).\n", rv);
+	}
+
+	/* Enable INTC interrupt. */
+	rv = setup_irq(IRQ_C0_INTC, &cascade_intc_irqaction);
+	if (rv) {
+		printk("Failed to setup INTC (rv = %d).\n", rv);
+	}
+
+	/* Enable DMAC interrupt. */
+	rv = setup_irq(IRQ_C0_DMAC, &cascade_dmac_irqaction);
+	if (rv) {
+		printk("Failed to setup DMAC (rv = %d).\n", rv);
+	}
+}
+
+static void gs_irqdispatch(void);
+static void sbus_irqdispatch(void);
+
+/*
+ * INT0 (INTC interrupt)
+ * interrupts 0 - 15
+ */
+void int0_irqdispatch(void)
+{
+	int i;
+	unsigned long int0 = inl(INTC_STAT) & intc_mask;
+
+	if (int0 & (1 << IRQ_INTC_GS)) {
+		gs_irqdispatch();
+		return;
+	} else if (int0 & (1 << IRQ_INTC_SBUS)) {
+		sbus_irqdispatch();
+		return;
+	}
+
+	for (i = 2; i < 16; i++) {
+		if ((int0 & (1 << i))) {
+			do_IRQ(IRQ_INTC + i);
+			break;
+		}
+	}
+}
+
+/*
+ * INT1 (DMAC interrupt)
+ * interrupts 16 - 31
+ */
+static void int1_irqdispatch(void)
+{
+	int i;
+	unsigned long int1 = inl(DMAC_STAT) & dmac_mask;
+
+	for (i = 0; i < 16; i++) {
+		if ((int1 & (1 << i))) {
+			do_IRQ(IRQ_DMAC + i);
+			break;
+		}
+	}
+}
+
+/*
+ * GS interrupt (INT0 cascade)
+ * interrupts 32 - 39
+ */
+static void gs_irqdispatch(void)
+{
+	int i;
+	unsigned long gs_int = inl(GS_CSR) & gs_mask;
+
+	for (i = 0; i < 7; i++) {
+		if ((gs_int & (1 << i))) {
+			do_IRQ(IRQ_GS + i);
+			break;
+		}
+	}
+}
+
+/*
+ * SBUS interrupt (INT0 cascade)
+ * interrupts 40 - 47
+ */
+static void sbus_irqdispatch(void)
+{
+	int i;
+	unsigned long sbus_int;
+
+	preempt_disable();
+	sbus_int = sbus_enter_irq() & sbus_mask;
+	for (i = 0; i < 7; i++) {
+		if ((sbus_int & (1 << i))) {
+			do_IRQ(IRQ_SBUS + i);
+		}
+	}
+	sbus_leave_irq();
+	preempt_enable_no_resched();
+}
+
+asmlinkage void plat_irq_dispatch(void)
+{
+	unsigned int pending = read_c0_status() & read_c0_cause();
+
+	/*
+	 * First we check for r4k counter/timer IRQ.
+	 */
+	if (pending & CAUSEF_IP2) {
+		/* INTC interrupt. */
+		int0_irqdispatch();
+	} else if (pending & CAUSEF_IP3) {
+		/* DMAC interrupt. */
+		int1_irqdispatch();
+	} else if (pending & CAUSEF_IP7) {
+		/* Timer interrupt. */
+		do_IRQ(IRQ_C0_IRQ7);
+	} else {
+		printk("plat_irq_dispatch: unknown interrupt 0x%08x pending.\n", pending);
+	}
+}
diff -purN linux-2.6.35.4-orig/arch/mips/ps2/Makefile linux-2.6.35.4/arch/mips/ps2/Makefile
--- linux-2.6.35.4-orig/arch/mips/ps2/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/ps2/Makefile	2014-07-18 22:29:43.546367724 +0200
@@ -0,0 +1,19 @@
+obj-y		+= sbios.o
+obj-y		+= setup.o
+obj-y		+= prom.o
+obj-y		+= irq.o
+obj-y		+= time.o
+obj-y		+= identify.o
+obj-y		+= sbios-console.o
+obj-y		+= ps2dma.o
+obj-y		+= ps2dev.o
+obj-y		+= gs.o
+obj-y		+= ps2image.o
+obj-y		+= ps2event.o
+obj-y		+= dma.o
+obj-y		+= ps2mem.o
+obj-y		+= sbcall.o
+obj-y		+= iopheap.o
+obj-y		+= rtc.o
+obj-y		+= siflock.o
+obj-y		+= powerbutton.o
diff -purN linux-2.6.35.4-orig/arch/mips/ps2/powerbutton.c linux-2.6.35.4/arch/mips/ps2/powerbutton.c
--- linux-2.6.35.4-orig/arch/mips/ps2/powerbutton.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/ps2/powerbutton.c	2014-07-18 22:29:43.550367724 +0200
@@ -0,0 +1,171 @@
+/*
+ *  Playstation 2 ower button handling
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/semaphore.h>
+
+#include <asm/signal.h>
+
+#include <asm/mach-ps2/ps2.h>
+#include <asm/mach-ps2/sifdefs.h>
+#include <asm/mach-ps2/sbios.h>
+
+#define POWEROFF_SID 0x9090900
+
+#define PWRBTN_MODE_SHUTDOWN             0x01
+#define PWRBTN_MODE_ENABLE_AUTO_SHUTOFF  0x02
+
+
+static ps2sif_clientdata_t cd_poweroff_rpc;
+static int rpc_initialized;
+DECLARE_MUTEX(poweroff_rpc_sema);
+
+static void ps2_powerbutton_handler(void *);
+
+static void poweroff_rpcend_notify(void *arg)
+{
+	complete((struct completion *)arg);
+	return;
+}
+
+/* Install powerhook with RTE (module CDVDFSV).
+ * This will not work with TGE.
+ */
+static int __init rte_powerhook(void)
+{
+	int res;
+	struct sb_cdvd_powerhook_arg arg;
+
+	/*
+	 * XXX, you should get the CD/DVD lock.
+	 * But it might be OK because this routine will be called
+	 * in early stage of boot sequence.
+	 */
+
+	/* initialize CD/DVD */
+	do {
+		if (sbios_rpc(SBR_CDVD_INIT, NULL, &res) < 0)
+			return -1;
+	} while (res == -1);
+
+	/* install power button hook */
+	arg.func = ps2_powerbutton_handler;
+	arg.arg = NULL;
+	sbios(SB_CDVD_POWERHOOK, &arg);
+
+	return 0;
+}
+
+/* Install powerhook with TGE (module poweroff.irx).
+ * This will not work with RTE.
+ */
+static int __init tge_powerhook(void)
+{
+	int loop;
+	struct completion compl;
+	int rv;
+	volatile int j;
+
+	init_completion(&compl);
+
+	/* bind poweroff.irx module */
+	for (loop = 100; loop; loop--) {
+		rv = ps2sif_bindrpc(&cd_poweroff_rpc, POWEROFF_SID,
+			SIF_RPCM_NOWAIT, poweroff_rpcend_notify, (void *)&compl);
+		if (rv < 0) {
+			printk("poweroff.irx: bind rv = %d.\n", rv);
+			break;
+		}
+		wait_for_completion(&compl);
+		if (cd_poweroff_rpc.serve != 0)
+			break;
+		j = 0x010000;
+		while (j--) ;
+	}
+	if (cd_poweroff_rpc.serve == 0) {
+		printk("poweroff.irx bind error 1, power button will not work.\n");
+		return -1;
+	}
+	rpc_initialized = -1;
+	return 0;
+}
+
+int ps2_powerbutton_enable_auto_shutoff(int enable_auto_shutoff)
+{
+	struct completion compl;
+	int rv;
+	static u32 rpc_data[16] __attribute__ ((aligned(64)));
+
+	if (!rpc_initialized) {
+		return -1;
+	}
+
+	init_completion(&compl);
+	down(&poweroff_rpc_sema);
+	rpc_data[0] = enable_auto_shutoff;
+	do {
+		rv = ps2sif_callrpc(&cd_poweroff_rpc, PWRBTN_MODE_ENABLE_AUTO_SHUTOFF,
+			SIF_RPCM_NOWAIT,
+			rpc_data, 4,
+			rpc_data, 4,
+			poweroff_rpcend_notify,
+			&compl);
+	} while (rv == -E_SIF_PKT_ALLOC);
+	if (rv != 0) {
+		printk("ps2_powerbutton_enable_auto_shutoff callrpc failed, (%d)\n", rv);
+	} else {
+		wait_for_completion(&compl);
+	}
+	up(&poweroff_rpc_sema);
+	return rv;
+}
+
+
+int __init ps2_powerbutton_init(void)
+{
+	int rte_rv;
+	int tge_rv;
+
+	rpc_initialized = 0;
+
+#ifdef CONFIG_PS2_SBIOS_VER_CHECK
+	if (sbios(SB_GETVER, NULL) < 0x0201)
+	    	return (-1);
+#endif
+
+	rte_rv = rte_powerhook();
+	tge_rv = tge_powerhook();
+
+	if ((rte_rv == 0) || (tge_rv ==0)) {
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+static void ps2_powerbutton_handler(void *arg)
+{
+	/* give a SIGPWR signal to init proc */
+	kill_cad_pid(SIGPWR, 0);
+}
diff -purN linux-2.6.35.4-orig/arch/mips/ps2/prom.c linux-2.6.35.4/arch/mips/ps2/prom.c
--- linux-2.6.35.4-orig/arch/mips/ps2/prom.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/ps2/prom.c	2014-07-18 22:29:43.550367724 +0200
@@ -0,0 +1,96 @@
+/*
+ *  Playstation 2 SBIOS/PROM handling.
+ *
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/bootmem.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+#include <asm/addrspace.h>
+#include <asm/bootinfo.h>
+#include <asm/sections.h>
+
+#include <asm/mach-ps2/bootinfo.h>
+#include <asm/mach-ps2/ps2.h>
+#include <asm/mach-ps2/sbios.h>
+
+#define SBIOS_BASE	0x80001000
+#define SBIOS_SIGNATURE	4
+
+int ps2_pccard_present;
+int ps2_pcic_type;
+struct ps2_sysconf *ps2_sysconf;
+
+EXPORT_SYMBOL(ps2_sysconf);
+EXPORT_SYMBOL(ps2_pcic_type);
+EXPORT_SYMBOL(ps2_pccard_present);
+
+static struct ps2_bootinfo ps2_bootinfox;
+struct ps2_bootinfo *ps2_bootinfo = &ps2_bootinfox;
+
+static void sbios_prints(const char *text)
+{
+	printk("SBIOS: %s", text);
+}
+
+void __init prom_init(void)
+{
+	struct ps2_bootinfo *bootinfo;
+	int version;
+
+	memset(&ps2_bootinfox, 0, sizeof(struct ps2_bootinfo));
+	ps2_bootinfox.sbios_base = SBIOS_BASE;
+
+	if (*(uint32_t *)(SBIOS_BASE + SBIOS_SIGNATURE) == 0x62325350) {
+	    bootinfo = (struct ps2_bootinfo *)phys_to_virt(PS2_BOOTINFO_OLDADDR);
+	    memcpy(ps2_bootinfo, bootinfo, PS2_BOOTINFO_OLDSIZE);
+	}
+
+	/* get command line parameters */
+	if (ps2_bootinfo->opt_string != 0) {
+	    strncpy(arcs_cmdline, (const char *) ((uintptr_t) ps2_bootinfo->opt_string), COMMAND_LINE_SIZE);
+	    arcs_cmdline[COMMAND_LINE_SIZE - 1] = '\0';
+	}
+
+	ps2_pccard_present = ps2_bootinfo->pccard_type;
+	ps2_pcic_type = ps2_bootinfo->pcic_type;
+	ps2_sysconf = &ps2_bootinfo->sysconf;
+
+	version = sbios(SB_GETVER, 0);
+	printk("PlayStation 2 SIF BIOS: %04x\n", version);
+
+	sbios(SB_SET_PRINTS_CALLBACK, sbios_prints);
+
+	/* Remove restriction to /BWLINUX path in mc calls. */
+	/* This patches the string in SBIOS. */
+	if (version == 0x200) {
+		/* Patch beta kit */
+		*((volatile unsigned char *)0x80007c20) = 0;
+	} else if (version == 0x250) {
+		/* Patch 1.0 kit */
+		*((volatile unsigned char *)0x800081b0) = 0;
+	}
+}
+
+void __init prom_free_prom_memory(void)
+{
+}
diff -purN linux-2.6.35.4-orig/arch/mips/ps2/ps2dev.c linux-2.6.35.4/arch/mips/ps2/ps2dev.c
--- linux-2.6.35.4-orig/arch/mips/ps2/ps2dev.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/ps2/ps2dev.c	2014-07-18 22:29:43.550367724 +0200
@@ -0,0 +1,1240 @@
+/*
+ *  PlayStation 2 integrated device driver
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/mm.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/poll.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/major.h>
+#include <linux/device.h>
+#include <linux/cdev.h>
+#include <linux/vmalloc.h>
+#include <linux/ps2/dev.h>
+#include <linux/ps2/gs.h>
+
+#include <asm/types.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/pgtable.h>
+#include <asm/mipsregs.h>
+#include <asm/processor.h>
+#include <asm/cop2.h>
+
+#include <asm/mach-ps2/dma.h>
+#include <asm/mach-ps2/eedev.h>
+#include <asm/mach-ps2/gsfunc.h>
+
+#include "ps2dev.h"
+
+#define MINOR_UNIT(x)	((MINOR(x) - ps2dev_minor) & 0x0f)
+#define FN2MINOR(x) (x << 4)
+
+#define PS2DEV_NR_OFDEVS 6
+#define PS2DEV_COUNT    (PS2DEV_NR_OFDEVS * 16)
+#define PS2MEM_FUNC	0
+#define PS2EVENT_FUNC	1
+#define PS2GS_FUNC	2
+#define PS2VPU_FUNC	3
+#define PS2IPU_FUNC	4
+#define PS2SPR_FUNC	5
+
+static struct class *ps2dev_class;
+static int ps2dev_major = PS2DEV_MAJOR;
+static int ps2dev_minor = 0;
+void *ps2spr_vaddr;		/* scratchpad RAM virtual address */
+static struct cdev ps2dev_cdev[PS2DEV_NR_OFDEVS];
+
+/*
+ *  common DMA device functions
+ */
+
+static int ps2dev_send_ioctl(struct dma_device *dev,
+			     unsigned int cmd, unsigned long arg)
+{
+    struct ps2_packet pkt;
+    struct ps2_packet *pkts;
+    struct ps2_plist plist;
+    struct ps2_pstop pstop;
+    struct ps2_pchain pchain;
+    int result;
+    u32 ff, oldff;
+    int val;
+    wait_queue_t wait;
+
+    switch (cmd) {
+    case PS2IOC_SEND:
+    case PS2IOC_SENDA:
+	if (copy_from_user(&pkt, (void *)arg, sizeof(pkt)))
+	    return -EFAULT;
+	return ps2dma_send(dev, &pkt, cmd == PS2IOC_SENDA);
+    case PS2IOC_SENDL:
+	if (copy_from_user(&plist, (void *)arg, sizeof(plist)))
+	    return -EFAULT;
+	if (plist.num < 0)
+	    return -EINVAL;
+	if ((pkts = kmalloc(sizeof(struct ps2_packet) * plist.num, GFP_KERNEL) ) == NULL)
+	    return -ENOMEM;
+	if (copy_from_user(pkts, plist.packet, sizeof(struct ps2_packet) * plist.num)) {
+	    kfree(pkts);
+	    return -EFAULT;
+	}
+	result = ps2dma_send_list(dev, plist.num, pkts);
+	kfree(pkts);
+	return result;
+    case PS2IOC_SENDQCT:
+	return ps2dma_get_qct(dev, DMA_SENDCH, arg);
+    case PS2IOC_SENDSTOP:
+	ps2dma_stop(dev, DMA_SENDCH, &pstop);
+	return copy_to_user((void *)arg, &pstop, sizeof(pstop)) ? -EFAULT : 0;
+    case PS2IOC_SENDLIMIT:
+	return ps2dma_set_qlimit(dev, DMA_SENDCH, arg);
+
+    case PS2IOC_SENDC:
+	if (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))
+	    return -EPERM;
+	if (copy_from_user(&pchain, (void *)arg, sizeof(pchain)))
+	    return -EFAULT;
+	return ps2dma_send_chain(dev, &pchain);
+
+    case PS2IOC_ENABLEEVENT:
+	oldff = dev->intr_mask;
+	if ((int)arg >= 0) {
+	    spin_lock_irq(&dev->lock);
+	    ff = dev->intr_mask ^ arg;
+	    dev->intr_flag &= ~ff;
+	    dev->intr_mask = arg;
+	    spin_unlock_irq(&dev->lock);
+	}
+	return oldff;
+    case PS2IOC_GETEVENT:
+	spin_lock_irq(&dev->lock);
+	oldff = dev->intr_flag;
+	if ((int)arg > 0)
+	    dev->intr_flag &= ~arg;
+	spin_unlock_irq(&dev->lock);
+	return oldff;
+    case PS2IOC_WAITEVENT:
+	init_waitqueue_entry(&wait, current);
+	add_wait_queue(&dev->empty, &wait);
+	while (1) {
+	    set_current_state(TASK_INTERRUPTIBLE);
+	    if (dev->intr_flag & arg) {
+		spin_lock_irq(&dev->lock);
+		oldff = dev->intr_flag;
+		dev->intr_flag &= ~arg;
+		spin_unlock_irq(&dev->lock);
+		break;
+	    }
+	    schedule();
+	    if (signal_pending(current)) {
+		oldff = -ERESTARTSYS;	/* signal arrived */
+		break;
+	    }
+	}
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&dev->empty, &wait);
+	return oldff;
+    case PS2IOC_SETSIGNAL:
+	val = dev->sig;
+	if ((int)arg >= 0)
+	    dev->sig = arg;
+	return val;
+    }
+    return -ENOIOCTLCMD;
+}
+
+static int ps2dev_recv_ioctl(struct dma_device *dev,
+			     unsigned int cmd, unsigned long arg)
+{
+    struct ps2_packet pkt;
+    struct ps2_packet *pkts;
+    struct ps2_plist plist;
+    struct ps2_pstop pstop;
+    int result;
+
+    switch (cmd) {
+    case PS2IOC_RECV:
+    case PS2IOC_RECVA:
+	if (copy_from_user(&pkt, (void *)arg, sizeof(pkt)))
+	    return -EFAULT;
+	return ps2dma_recv(dev, &pkt, cmd == PS2IOC_RECVA);
+    case PS2IOC_RECVL:
+	if (copy_from_user(&plist, (void *)arg, sizeof(plist)))
+	    return -EFAULT;
+	if (plist.num < 0)
+	    return -EINVAL;
+	if ((pkts = kmalloc(sizeof(struct ps2_packet) * plist.num, GFP_KERNEL) ) == NULL)
+	    return -ENOMEM;
+	if (copy_from_user(pkts, plist.packet, sizeof(struct ps2_packet) * plist.num)) {
+	    kfree(pkts);
+	    return -EFAULT;
+	}
+	result = ps2dma_recv_list(dev, plist.num, pkts);
+	kfree(pkts);
+	return result;
+    case PS2IOC_RECVQCT:
+	return ps2dma_get_qct(dev, DMA_RECVCH, arg);
+    case PS2IOC_RECVSTOP:
+	ps2dma_stop(dev, DMA_RECVCH, &pstop);
+	return copy_to_user((void *)arg, &pstop, sizeof(pstop)) ? -EFAULT : 0;
+    case PS2IOC_RECVLIMIT:
+	return ps2dma_set_qlimit(dev, DMA_RECVCH, arg);
+
+    }
+    return -ENOIOCTLCMD;
+}
+
+static ssize_t ps2dev_read(struct file *file, char *buf, size_t count, loff_t *ppos)
+{
+    struct dma_device *dev = (struct dma_device *)file->private_data;
+    struct ps2_packet pkt;
+    int result;
+
+    pkt.ptr = buf;
+    pkt.len = count;
+    if ((result = ps2dma_recv(dev, &pkt, 0)) < 0)
+	return result;
+
+    return count;
+}
+
+static ssize_t ps2dev_write(struct file *file, const char *buf, size_t count, loff_t *ppos)
+{
+    struct dma_device *dev = (struct dma_device *)file->private_data;
+    struct ps2_packet pkt;
+
+    pkt.ptr = (char *)buf;
+    pkt.len = count;
+    return ps2dma_write(dev, &pkt, file->f_flags & O_NONBLOCK);
+}
+
+static int ps2dev_fsync(struct file *file, int datasync)
+{
+    struct dma_device *dev = (struct dma_device *)file->private_data;
+
+    return ps2dma_get_qct(dev, DMA_SENDCH, 1);
+}
+
+int ps2dev_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
+{
+    return VM_FAULT_SIGBUS;
+}
+
+static struct vm_operations_struct ps2dev_vmops = {
+    fault:	ps2dev_fault,
+};
+
+
+/*
+ *  Graphics Synthesizer (/dev/ps2gs) driver
+ */
+
+static int vb_gssreg_num = 0;
+static struct ps2_gssreg *vb_gssreg_p = NULL;
+
+void ps2gs_sgssreg_vb(void)
+{
+    int i;
+
+    if (vb_gssreg_num) {
+	if (vb_gssreg_p != NULL) {
+		for (i = 0; i < vb_gssreg_num; i++)
+		    ps2gs_set_gssreg(vb_gssreg_p[i].reg, vb_gssreg_p[i].val);
+		kfree(vb_gssreg_p);
+		vb_gssreg_p = NULL;
+	} else {
+		printk("ps2gs: error: vb_gssreg_p is NULL.\n");
+	}
+	__asm__("":::"memory");
+	vb_gssreg_num = 0;
+    }
+}
+
+static int ps2gs_ioctl(struct inode *inode, struct file *file,
+			unsigned int cmd, unsigned long arg)
+{
+    int result;
+    struct dma_device *dev = (struct dma_device *)file->private_data;
+    struct ps2_gsinfo gsinfo;
+    struct ps2_image image;
+    struct ps2_gssreg gssreg;
+    struct ps2_gsreg gsreg;
+    struct ps2_gifreg gifreg;
+    struct ps2_screeninfo screeninfo;
+    struct ps2_crtmode crtmode;
+    struct ps2_display display;
+    struct ps2_dispfb dispfb;
+    struct ps2_pmode pmode;
+    struct ps2_sgssreg_vb sgssreg_vb;
+    int val;
+
+    if ((result = ps2dev_send_ioctl(dev, cmd, arg)) != -ENOIOCTLCMD)
+	return result;
+    switch (cmd) {
+    case PS2IOC_GSINFO:
+	gsinfo.size = GSFB_SIZE;
+	return copy_to_user((void *)arg, &gsinfo, sizeof(gsinfo)) ? -EFAULT : 0;
+    case PS2IOC_GSRESET:
+	val = arg;
+	ps2gs_reset(val);
+	return 0;
+
+    case PS2IOC_LOADIMAGE:
+    case PS2IOC_LOADIMAGEA:
+	if (copy_from_user(&image, (void *)arg, sizeof(image)))
+	    return -EFAULT;
+	return ps2gs_loadimage(&image, dev, cmd == PS2IOC_LOADIMAGEA);
+    case PS2IOC_STOREIMAGE:
+	if (copy_from_user(&image, (void *)arg, sizeof(image)))
+	    return -EFAULT;
+	return ps2gs_storeimage(&image, dev);
+
+    case PS2IOC_SGSSREG:
+	if (copy_from_user(&gssreg, (void *)arg, sizeof(gssreg)))
+	    return -EFAULT;
+	if (ps2gs_set_gssreg(gssreg.reg, gssreg.val) < 0)
+	    return -EINVAL;
+	return 0;
+    case PS2IOC_GGSSREG:
+	if (copy_from_user(&gssreg, (void *)arg, sizeof(gssreg)))
+	    return -EFAULT;
+	if (ps2gs_get_gssreg(gssreg.reg, &gssreg.val) < 0)
+	    return -EINVAL;
+	return copy_to_user((void *)arg, &gssreg, sizeof(gssreg)) ? -EFAULT : 0;
+    case PS2IOC_SGSREG:
+	if (copy_from_user(&gsreg, (void *)arg, sizeof(gsreg)))
+	    return -EFAULT;
+	if (ps2gs_set_gsreg(gsreg.reg, gsreg.val) < 0)
+	    return -EINVAL;
+	return 0;
+    case PS2IOC_SGIFREG:
+	if (copy_from_user(&gifreg, (void *)arg, sizeof(gifreg)))
+	    return -EFAULT;
+	if (gifreg.reg == PS2_GIFREG_CTRL ||
+	    gifreg.reg == PS2_GIFREG_MODE)
+	    SET_GIFREG(gifreg.reg, gifreg.val);
+	else
+	    return -EINVAL;
+	return 0;
+    case PS2IOC_GGIFREG:
+	if (copy_from_user(&gifreg, (void *)arg, sizeof(gifreg)))
+	    return -EFAULT;
+	if (gifreg.reg == PS2_GIFREG_STAT ||
+	    (gifreg.reg >= PS2_GIFREG_TAG0 && gifreg.reg <= PS2_GIFREG_P3TAG)) {
+	    if (gifreg.reg != PS2_GIFREG_STAT)
+		SET_GIFREG(PS2_GIFREG_CTRL, 1 << 3);
+	    gifreg.val = GIFREG(gifreg.reg);
+	    if (gifreg.reg != PS2_GIFREG_STAT)
+		SET_GIFREG(PS2_GIFREG_CTRL, 0);
+	} else {
+	    return -EINVAL;
+	}
+	return copy_to_user((void *)arg, &gifreg, sizeof(gifreg)) ? -EFAULT : 0;
+
+    case PS2IOC_SSCREENINFO:
+	if (copy_from_user(&screeninfo, (void *)arg, sizeof(screeninfo)))
+	    return -EFAULT;
+	if (ps2gs_screeninfo(&screeninfo, NULL) < 0)
+	    return -EINVAL;
+	return 0;
+    case PS2IOC_GSCREENINFO:
+	if (ps2gs_screeninfo(NULL, &screeninfo) < 0)
+	    return -EINVAL;
+	return copy_to_user((void *)arg, &screeninfo, sizeof(screeninfo)) ? -EFAULT : 0;
+    case PS2IOC_SCRTMODE:
+	if (copy_from_user(&crtmode, (void *)arg, sizeof(crtmode)))
+	    return -EFAULT;
+	if (ps2gs_crtmode(&crtmode, NULL) < 0)
+	    return -EINVAL;
+	return 0;
+    case PS2IOC_GCRTMODE:
+	if (ps2gs_crtmode(NULL, &crtmode) < 0)
+	    return -EINVAL;
+	return copy_to_user((void *)arg, &crtmode, sizeof(crtmode)) ? -EFAULT : 0;
+    case PS2IOC_SDISPLAY:
+	if (copy_from_user(&display, (void *)arg, sizeof(display)))
+	    return -EFAULT;
+	if (ps2gs_display(display.ch, &display, NULL) < 0)
+	    return -EINVAL;
+	return 0;
+    case PS2IOC_GDISPLAY:
+	if (copy_from_user(&display, (void *)arg, sizeof(display)))
+	    return -EFAULT;
+	if (ps2gs_display(display.ch, NULL, &display) < 0)
+	    return -EINVAL;
+	return copy_to_user((void *)arg, &display, sizeof(display)) ? -EFAULT : 0;
+    case PS2IOC_SDISPFB:
+	if (copy_from_user(&dispfb, (void *)arg, sizeof(dispfb)))
+	    return -EFAULT;
+	if (ps2gs_dispfb(dispfb.ch, &dispfb, NULL) < 0)
+	    return -EINVAL;
+	return 0;
+    case PS2IOC_GDISPFB:
+	if (copy_from_user(&dispfb, (void *)arg, sizeof(dispfb)))
+	    return -EFAULT;
+	if (ps2gs_dispfb(dispfb.ch, NULL, &dispfb) < 0)
+	    return -EINVAL;
+	return copy_to_user((void *)arg, &dispfb, sizeof(dispfb)) ? -EFAULT : 0;
+    case PS2IOC_SPMODE:
+	if (copy_from_user(&pmode, (void *)arg, sizeof(pmode)))
+	    return -EFAULT;
+	if (ps2gs_pmode(&pmode, NULL) < 0)
+	    return -EINVAL;
+	return 0;
+    case PS2IOC_GPMODE:
+	if (ps2gs_pmode(NULL, &pmode) < 0)
+	    return -EINVAL;
+	return copy_to_user((void *)arg, &pmode, sizeof(pmode)) ? -EFAULT : 0;
+
+    case PS2IOC_DPMS:
+	val = arg;
+	if (ps2gs_setdpms(val) < 0)
+	    return -EINVAL;
+	return 0;
+
+    case PS2IOC_SGSSREG_VB:
+	if (vb_gssreg_num)
+	    return -EBUSY;
+	if (copy_from_user(&sgssreg_vb, (void *)arg, sizeof(sgssreg_vb)))
+	    return -EFAULT;
+	if (sgssreg_vb.num <= 0)
+	    return -EINVAL;
+	if ((vb_gssreg_p = kmalloc(sizeof(struct ps2_gssreg) * sgssreg_vb.num, GFP_KERNEL)) == NULL)
+	    return -ENOMEM;
+	if (copy_from_user(vb_gssreg_p, sgssreg_vb.gssreg, sizeof(struct ps2_gssreg) * sgssreg_vb.num)) {
+	    kfree(vb_gssreg_p);
+	    return -EFAULT;
+	}
+	__asm__("":::"memory");
+	vb_gssreg_num = sgssreg_vb.num;
+	return 0;
+    }
+    return -EINVAL;
+}
+
+static void ps2gif_reset(void)
+{
+    int apath;
+
+    apath = (GIFREG(PS2_GIFREG_STAT) >> 10) & 3;
+    SET_GIFREG(PS2_GIFREG_CTRL, 0x00000001);	/* reset GIF */
+    if (apath == 3)
+	outq(0x0100ULL, GSSREG2(PS2_GSSREG_CSR));	/* reset GS */
+}
+
+static int ps2gs_open_count = 0;	/* only one process can open */
+
+static int ps2gs_open(struct inode *inode, struct file *file)
+{
+    struct dma_device *dev;
+
+    if (ps2gs_open_count)
+	return -EBUSY;
+    ps2gs_open_count++;
+
+    if ((dev = ps2dma_dev_init(DMA_GIF, -1)) == NULL) {
+	ps2gs_open_count--;
+	return -ENOMEM;
+    }
+    file->private_data = dev;
+    return 0;
+}
+
+static int ps2gs_release(struct inode *inode, struct file *file)
+{
+    struct dma_device *dev = (struct dma_device *)file->private_data;
+
+    if (ps2dma_finish(dev) != 0)
+	printk("ps2gs: DMA timeout\n");
+    kfree(dev);
+    ps2gs_open_count--;
+    return 0;
+}
+
+/*
+ *  Vector Processing Unit (/dev/ps2vpu0, /dev/ps2vpu1) driver
+ */
+
+static const struct {
+    unsigned long ubase, ulen;
+    unsigned long vubase, vulen;
+} vumap[2] = {
+    { 0x11000000,  4096, 0x11004000,  4096 },
+    { 0x11008000, 16384, 0x1100c000, 16384 },
+};
+
+static int ps2vpu_ioctl(struct inode *inode, struct file *file,
+			unsigned int cmd, unsigned long arg)
+{
+    int result;
+    struct dma_device *dev = (struct dma_device *)file->private_data;
+    int vusw = (int)dev->data;
+    struct ps2_vpuinfo vpuinfo;
+    struct ps2_vifreg vifreg;
+
+    if ((result = ps2dev_send_ioctl(dev, cmd, arg)) != -ENOIOCTLCMD)
+	return result;
+    switch (cmd) {
+    case PS2IOC_VPUINFO:
+	vpuinfo.umemsize = vumap[vusw].ulen;
+	vpuinfo.vumemsize = vumap[vusw].vulen;
+	return copy_to_user((void *)arg, &vpuinfo, sizeof(vpuinfo)) ? -EFAULT : 0;
+    case PS2IOC_SVIFREG:
+	if (copy_from_user(&vifreg, (void *)arg, sizeof(vifreg)))
+	    return -EFAULT;
+	if (vifreg.reg == PS2_VIFREG_MARK ||
+	    vifreg.reg == PS2_VIFREG_FBRST ||
+	    vifreg.reg == PS2_VIFREG_ERR)
+	    SET_VIFnREG(vusw, vifreg.reg, vifreg.val);
+	else
+	    return -EINVAL;
+	return 0;
+    case PS2IOC_GVIFREG:
+	if (copy_from_user(&vifreg, (void *)arg, sizeof(vifreg)))
+	    return -EFAULT;
+	if (vifreg.reg == PS2_VIFREG_STAT ||
+	    (vifreg.reg >= PS2_VIFREG_ERR && vifreg.reg <= PS2_VIFREG_ITOPS) ||
+	    vifreg.reg == PS2_VIFREG_ITOP ||
+	    (vifreg.reg >= PS2_VIFREG_R0 && vifreg.reg <= PS2_VIFREG_C3) ||
+	    (vusw == 1 &&
+	     (vifreg.reg >= PS2_VIFREG_BASE && vifreg.reg <= PS2_VIFREG_TOP)))
+	    vifreg.val = VIFnREG(vusw, vifreg.reg);
+	else
+	    return -EINVAL;
+	return copy_to_user((void *)arg, &vifreg, sizeof(vifreg)) ? -EFAULT : 0;
+    }
+    return -EINVAL;
+}
+
+static u32 init_vif0code[] __attribute__((aligned(DMA_TRUNIT))) = {
+    PS2_VIF_SET_CODE(0x0404, 0, PS2_VIF_STCYCL, 0),
+    PS2_VIF_SET_CODE(0,      0, PS2_VIF_STMASK, 0),
+    0,
+    PS2_VIF_SET_CODE(0,      0, PS2_VIF_STMOD, 0),
+    PS2_VIF_SET_CODE(0,      0, PS2_VIF_ITOP, 0),
+    PS2_VIF_SET_CODE(0,      0, PS2_VIF_NOP, 0),
+    PS2_VIF_SET_CODE(0,      0, PS2_VIF_NOP, 0),
+    PS2_VIF_SET_CODE(0,      0, PS2_VIF_NOP, 0),
+};
+
+static void ps2vpu0_reset(void)
+{
+    SET_VIF0REG(PS2_VIFREG_MARK, 0);
+    SET_VIF0REG(PS2_VIFREG_ERR, 2);
+    SET_VIF0REG(PS2_VIFREG_FBRST, 1);		/* reset VIF0 */
+    set_c0_status(ST0_CU2);
+    __asm__ __volatile__(
+	"	sync.l\n"
+	"	cfc2	$8, $28\n"
+	"	ori	$8, $8, 0x0002\n"
+	"	ctc2	$8, $28\n"
+	"	sync.p\n"
+	::: "$8");				/* reset VU0 */
+    clear_c0_status(ST0_CU2);
+    move_quad(KSEG1ADDR(VIF0_FIFO), (unsigned long)&init_vif0code[0]);
+    move_quad(KSEG1ADDR(VIF0_FIFO), (unsigned long)&init_vif0code[4]);
+}
+
+static u32 init_vif1code[] __attribute__((aligned(DMA_TRUNIT))) = {
+    PS2_VIF_SET_CODE(0x0404, 0, PS2_VIF_STCYCL, 0),
+    PS2_VIF_SET_CODE(0,      0, PS2_VIF_STMASK, 0),
+    0,
+    PS2_VIF_SET_CODE(0,      0, PS2_VIF_STMOD, 0),
+    PS2_VIF_SET_CODE(0,      0, PS2_VIF_MSKPATH3, 0),
+    PS2_VIF_SET_CODE(0,      0, PS2_VIF_BASE, 0),
+    PS2_VIF_SET_CODE(0,      0, PS2_VIF_OFFSET, 0),
+    PS2_VIF_SET_CODE(0,      0, PS2_VIF_ITOP, 0),
+};
+
+static void ps2vpu1_reset(void)
+{
+    int apath;
+
+    SET_VIF1REG(PS2_VIFREG_MARK, 0);
+    SET_VIF1REG(PS2_VIFREG_ERR, 2);
+    SET_VIF1REG(PS2_VIFREG_FBRST, 1);		/* reset VIF1 */
+    set_c0_status(ST0_CU2);
+    __asm__ __volatile__(
+	"	sync.l\n"
+	"	cfc2	$8, $28\n"
+	"	ori	$8, $8, 0x0200\n"
+	"	ctc2	$8, $28\n"
+	"	sync.p\n"
+	::: "$8");				/* reset VU1 */
+    clear_c0_status(ST0_CU2);
+    move_quad(KSEG1ADDR(VIF1_FIFO), (unsigned long)&init_vif1code[0]);
+    move_quad(KSEG1ADDR(VIF1_FIFO), (unsigned long)&init_vif1code[4]);
+
+    apath = (GIFREG(PS2_GIFREG_STAT) >> 10) & 3;
+    if (apath == 1 || apath == 2) {
+	SET_GIFREG(PS2_GIFREG_CTRL, 0x00000001);	/* reset GIF */
+	outq(0x0100ULL, GSSREG2(PS2_GSSREG_CSR));	/* reset GS */
+    }
+}
+
+static void set_cop2_usable(int onoff)
+{
+    if (onoff)
+        KSTK_STATUS(current) |= ST0_CU2;
+    else
+        KSTK_STATUS(current) &= ~ST0_CU2;
+}
+
+static int ps2vpu_open_count[2];	/* only one process can open */
+
+static int ps2vpu_open(struct inode *inode, struct file *file)
+{
+    struct dma_device *dev;
+    int vusw = MINOR_UNIT(inode->i_rdev);
+
+    if (vusw < 0 || vusw > 1)
+	return -ENODEV;
+    if (ps2vpu_open_count[vusw])
+	return -EBUSY;
+    ps2vpu_open_count[vusw]++;
+
+    if ((dev = ps2dma_dev_init(DMA_VIF0 + vusw, -1)) == NULL) {
+	ps2vpu_open_count[vusw]--;
+	return -ENOMEM;
+    }
+    file->private_data = dev;
+    dev->data = (void *)vusw;
+
+    if (vusw == 0) {
+	ps2vpu0_reset();
+	set_cop2_usable(1);
+    } else if (vusw == 1) {
+	ps2vpu1_reset();
+    }
+    return 0;
+}
+
+static int ps2vpu_release(struct inode *inode, struct file *file)
+{
+    struct dma_device *dev = (struct dma_device *)file->private_data;
+    int vusw = (int)dev->data;
+
+    if (ps2dma_finish(dev) != 0)
+	printk("ps2vpu%d: DMA timeout\n", vusw);
+    kfree(dev);
+
+    if (vusw == 0)
+	set_cop2_usable(0);
+    ps2vpu_open_count[vusw]--;
+    return 0;
+}
+
+static int ps2vpu_mmap(struct file *file, struct vm_area_struct *vma)
+{
+    struct dma_device *dev = (struct dma_device *)file->private_data;
+    int vusw = (int)dev->data;
+    unsigned long start, offset, len, mlen;
+
+    if (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))
+        return -EINVAL;
+
+    start = vma->vm_start;
+    offset = vma->vm_pgoff << PAGE_SHIFT;
+    len = vma->vm_end - vma->vm_start;
+    if (offset + len > vumap[vusw].ulen + vumap[vusw].vulen)
+	return -EINVAL;
+
+#ifdef __mips__
+    pgprot_val(vma->vm_page_prot) = (pgprot_val(vma->vm_page_prot) & ~_CACHE_MASK) | _CACHE_UNCACHED;
+#else
+#error "for MIPS CPU only"
+#endif
+    vma->vm_flags |= VM_IO;
+
+    /* map micro Mem */
+    if (offset < vumap[vusw].ulen) {
+	mlen = vumap[vusw].ulen - offset;
+	if (mlen > len)
+	    mlen = len;
+	if (io_remap_pfn_range(vma, start, (vumap[vusw].ubase + offset) >> PAGE_SHIFT, mlen,
+			     vma->vm_page_prot))
+	    return -EAGAIN;
+	start += mlen;
+	len -= mlen;
+	offset = vumap[vusw].ulen;
+    }
+
+    /* map VU Mem */
+    if (len > 0) {
+	offset -= vumap[vusw].ulen;
+	if (io_remap_pfn_range(vma, start, (vumap[vusw].vubase + offset) >> PAGE_SHIFT, len, 
+			     vma->vm_page_prot))
+	    return -EAGAIN;
+    }
+
+    vma->vm_ops = &ps2dev_vmops;
+    return 0;
+}
+
+/*
+ *  Image Processing Unit (/dev/ps2ipu) driver
+ */
+
+static int ps2ipu_ioctl(struct inode *inode, struct file *file,
+			unsigned int cmd, unsigned long arg)
+{
+    int result;
+    struct dma_device *dev = (struct dma_device *)file->private_data;
+    u32 val32;
+    u64 val64;
+    static struct ps2_fifo fifo __attribute__((aligned(16)));
+
+    if ((result = ps2dev_send_ioctl(dev, cmd, arg)) != -ENOIOCTLCMD)
+	return result;
+    if ((result = ps2dev_recv_ioctl(dev, cmd, arg)) != -ENOIOCTLCMD)
+	return result;
+    switch (cmd) {
+    case PS2IOC_SIPUCMD:
+	if (copy_from_user(&val32, (void *)arg, sizeof(val32)))
+	    return -EFAULT;
+	outl(val32, IPUREG_CMD);
+	return 0;
+    case PS2IOC_GIPUCMD:
+	val64 = inq(IPUREG_CMD);
+	if (val64 & ((u64)1 << 63))
+	    return -EBUSY;		/* data is not valid */
+	val32 = (u32)val64;
+	return copy_to_user((void *)arg, &val32, sizeof(val32)) ? -EFAULT : 0;
+    case PS2IOC_SIPUCTRL:
+	if (copy_from_user(&val32, (void *)arg, sizeof(val32)))
+	    return -EFAULT;
+	outl(val32, IPUREG_CTRL);
+	return 0;
+    case PS2IOC_GIPUCTRL:
+	val32 = inl(IPUREG_CTRL);
+	return copy_to_user((void *)arg, &val32, sizeof(val32)) ? -EFAULT : 0;
+    case PS2IOC_GIPUTOP:
+	val64 = inq(IPUREG_TOP);
+	if (val64 & ((u64)1 << 63))
+	    return -EBUSY;		/* data is not valid */
+	val32 = (u32)val64;
+	return copy_to_user((void *)arg, &val32, sizeof(val32)) ? -EFAULT : 0;
+    case PS2IOC_GIPUBP:
+	val32 = inl(IPUREG_BP);
+	return copy_to_user((void *)arg, &val32, sizeof(val32)) ? -EFAULT : 0;
+    case PS2IOC_SIPUFIFO:
+	if (copy_from_user(&fifo, (void *)arg, sizeof(fifo)))
+	    return -EFAULT;
+	move_quad(KSEG1ADDR(IPU_I_FIFO), (unsigned long)&fifo);
+	return 0;
+    case PS2IOC_GIPUFIFO:
+	move_quad((unsigned long)&fifo, KSEG1ADDR(IPU_O_FIFO));
+	return copy_to_user((void *)arg, &fifo, sizeof(fifo)) ? -EFAULT : 0;
+    }
+    return -EINVAL;
+}
+
+static u32 init_ipu_iq[] __attribute__((aligned(DMA_TRUNIT))) = {
+    0x13101008, 0x16161310, 0x16161616, 0x1b1a181a,
+    0x1a1a1b1b, 0x1b1b1a1a, 0x1d1d1d1b, 0x1d222222,
+    0x1b1b1d1d, 0x20201d1d, 0x26252222, 0x22232325,
+    0x28262623, 0x30302828, 0x38382e2e, 0x5345453a,
+    0x10101010, 0x10101010, 0x10101010, 0x10101010,
+};
+
+static u32 init_ipu_vq[] __attribute__((aligned(DMA_TRUNIT))) = {
+    0x04210000, 0x03e00842, 0x14a51084, 0x1ce718c6,
+    0x2529001f, 0x7c00294a, 0x35ad318c, 0x39ce7fff
+};
+
+static void wait_ipu_ready(void)
+{
+    while (inl(IPUREG_CTRL) < 0)
+	;
+}
+
+static void ps2ipu_reset(void)
+{
+    outl(1 << 30, IPUREG_CTRL);		/* reset IPU */
+    wait_ipu_ready();
+    outl(0x00000000, IPUREG_CMD);		/* BCLR */
+    wait_ipu_ready();
+
+    move_quad(KSEG1ADDR(IPU_I_FIFO), (unsigned long)&init_ipu_iq[0]);
+    move_quad(KSEG1ADDR(IPU_I_FIFO), (unsigned long)&init_ipu_iq[4]);
+    move_quad(KSEG1ADDR(IPU_I_FIFO), (unsigned long)&init_ipu_iq[8]);
+    move_quad(KSEG1ADDR(IPU_I_FIFO), (unsigned long)&init_ipu_iq[12]);
+    move_quad(KSEG1ADDR(IPU_I_FIFO), (unsigned long)&init_ipu_iq[16]);
+    move_quad(KSEG1ADDR(IPU_I_FIFO), (unsigned long)&init_ipu_iq[16]);
+    move_quad(KSEG1ADDR(IPU_I_FIFO), (unsigned long)&init_ipu_iq[16]);
+    move_quad(KSEG1ADDR(IPU_I_FIFO), (unsigned long)&init_ipu_iq[16]);
+    outl(0x50000000, IPUREG_CMD);		/* SETIQ (I) */
+    wait_ipu_ready();
+    outl(0x58000000, IPUREG_CMD);		/* SETIQ (NI) */
+    wait_ipu_ready();
+
+    move_quad(KSEG1ADDR(IPU_I_FIFO), (unsigned long)&init_ipu_vq[0]);
+    move_quad(KSEG1ADDR(IPU_I_FIFO), (unsigned long)&init_ipu_vq[4]);
+    outl(0x60000000, IPUREG_CMD);		/* SETVQ */
+    wait_ipu_ready();
+
+    outl(0x90000000, IPUREG_CMD);		/* SETTH */
+    wait_ipu_ready();
+
+    outl(1 << 30, IPUREG_CTRL);		/* reset IPU */
+    wait_ipu_ready();
+    outl(0x00000000, IPUREG_CMD);		/* BCLR */
+    wait_ipu_ready();
+}
+
+static int ps2ipu_open_count = 0;	/* only one process can open */
+
+static int ps2ipu_open(struct inode *inode, struct file *file)
+{
+    struct dma_device *dev;
+
+    if (ps2ipu_open_count)
+	return -EBUSY;
+    ps2ipu_open_count++;
+
+    if ((dev = ps2dma_dev_init(DMA_IPU_to, DMA_IPU_from)) == NULL) {
+	ps2ipu_open_count--;
+	return -ENOMEM;
+    }
+    file->private_data = dev;
+    ps2ipu_reset();
+    return 0;
+}
+
+static int ps2ipu_release(struct inode *inode, struct file *file)
+{
+    struct dma_device *dev = (struct dma_device *)file->private_data;
+
+    if (ps2dma_finish(dev) != 0)
+	printk("ps2ipu: DMA timeout\n");
+    kfree(dev);
+    ps2ipu_open_count--;
+    return 0;
+}
+
+static int ps2ipu_mmap(struct file *file, struct vm_area_struct *vma)
+{
+    unsigned long start, offset, len;
+
+    if (vma->vm_pgoff >= 2)
+        return -EINVAL;
+
+    start = vma->vm_start;
+    offset = vma->vm_pgoff << PAGE_SHIFT;
+    len = vma->vm_end - vma->vm_start;
+    if (offset + len > PAGE_SIZE * 2)
+	return -EINVAL;
+
+#ifdef __mips__
+    pgprot_val(vma->vm_page_prot) = (pgprot_val(vma->vm_page_prot) & ~_CACHE_MASK) | _CACHE_UNCACHED;
+#else
+#error "for MIPS CPU only"
+#endif
+    vma->vm_flags |= VM_IO;
+
+    /* map IPU registers */
+    if (offset < PAGE_SIZE) {
+	if (io_remap_pfn_range(vma, vma->vm_start, 0x10002000 >> PAGE_SHIFT,
+			     PAGE_SIZE, vma->vm_page_prot))
+	    return -EAGAIN;
+	start += PAGE_SIZE;
+	len -= PAGE_SIZE;
+    }
+    /* map IPU FIFO */
+    if (len > 0) {
+	if (io_remap_pfn_range(vma, vma->vm_start, 0x10007000 >> PAGE_SHIFT,
+			     PAGE_SIZE, vma->vm_page_prot))
+	    return -EAGAIN;
+    }
+
+    vma->vm_ops = &ps2dev_vmops;
+    return 0;
+}
+
+/*
+ *  Scratchpad RAM (/dev/ps2spr) driver
+ */
+
+static int ps2spr_ioctl(struct inode *inode, struct file *file,
+			unsigned int cmd, unsigned long arg)
+{
+    int result;
+    struct dma_device *dev = (struct dma_device *)file->private_data;
+    struct ps2_sprinfo sprinfo;
+
+    if ((result = ps2dev_send_ioctl(dev, cmd, arg)) != -ENOIOCTLCMD)
+	return result;
+    if ((result = ps2dev_recv_ioctl(dev, cmd, arg)) != -ENOIOCTLCMD)
+	return result;
+    switch (cmd) {
+    case PS2IOC_SPRINFO:
+	sprinfo.size = SPR_SIZE;
+	return copy_to_user((void *)arg, &sprinfo, sizeof(sprinfo)) ? -EFAULT : 0;
+    }
+    return -EINVAL;
+}
+
+static int ps2spr_open_count = 0;	/* only one process can open */
+
+static int ps2spr_open(struct inode *inode, struct file *file)
+{
+    struct dma_device *dev;
+
+    if (ps2spr_open_count)
+	return -EBUSY;
+    ps2spr_open_count++;
+
+    if ((dev = ps2dma_dev_init(DMA_SPR_to, DMA_SPR_from)) == NULL) {
+	ps2spr_open_count--;
+	return -ENOMEM;
+    }
+    file->private_data = dev;
+    return 0;
+}
+
+static int ps2spr_release(struct inode *inode, struct file *file)
+{
+    struct dma_device *dev = (struct dma_device *)file->private_data;
+
+    if (ps2dma_finish(dev) != 0)
+	printk("ps2spr: DMA timeout\n");
+    kfree(dev);
+    ps2spr_open_count--;
+    return 0;
+}
+
+#define SPR_MASK		(~(SPR_SIZE - 1))
+#define SPR_ALIGN(addr)		((typeof(addr))((((unsigned long) (addr)) + SPR_SIZE - 1) & SPR_MASK))
+
+static int ps2spr_mmap(struct file *file, struct vm_area_struct *vma)
+{
+    if (vma->vm_pgoff != 0)
+	return -ENXIO;
+    if (vma->vm_end - vma->vm_start != SPR_SIZE)
+	return -EINVAL;
+
+    /* The virtual address must be an even virtual address. */
+    if (vma->vm_start != SPR_ALIGN(vma->vm_start))
+	return -EINVAL;
+
+#ifdef __mips__
+    pgprot_val(vma->vm_page_prot) = (pgprot_val(vma->vm_page_prot) & ~_CACHE_MASK) | _CACHE_UNCACHED;
+#else
+#error "for MIPS CPU only"
+#endif
+    vma->vm_flags |= VM_IO;
+
+    /* Map scratchpad. SPR_PHYS_ADDR is not a valid physical address, this is
+     * just used to detect scratchpad in the TLB refill handler.
+     */
+    if (io_remap_pfn_range(vma, vma->vm_start, SPR_PHYS_ADDR >> PAGE_SHIFT, SPR_SIZE, vma->vm_page_prot))
+	return -EAGAIN;
+
+    vma->vm_ops = &ps2dev_vmops;
+    return 0;
+}
+
+static unsigned long ps2spr_get_unmapped_area(struct file *file, unsigned long addr, unsigned long len, unsigned long pgoff, unsigned long flags)
+{
+    struct vm_area_struct *vma;
+
+    /* SPRAM must be 16KB aligned. */
+
+    if (len > TASK_SIZE)
+	return -ENOMEM;
+
+    if (addr) {
+	addr = SPR_ALIGN(addr);
+	vma = find_vma(current->mm, addr);
+	if (TASK_SIZE - len >= addr &&
+	    (!vma || addr + len <= vma->vm_start))
+		return addr;
+    }
+    addr = SPR_ALIGN(TASK_UNMAPPED_BASE);
+
+    for (vma = find_vma(current->mm, addr); ; vma = vma->vm_next) {
+	/* At this point:  (!vma || addr < vma->vm_end). */
+	if (TASK_SIZE - len < addr)
+	    return -ENOMEM;
+	if (!vma || addr + len <= vma->vm_start)
+	    return addr;
+	addr = SPR_ALIGN(vma->vm_end);
+    }
+}
+
+/*
+ *  file operations structures
+ */
+
+struct file_operations ps2gs_fops = {
+    llseek:		no_llseek,
+    write:		ps2dev_write,
+    ioctl:		ps2gs_ioctl,
+    open:		ps2gs_open,
+    release:		ps2gs_release,
+    fsync:		ps2dev_fsync,
+};
+
+struct file_operations ps2vpu_fops = {
+    llseek:		no_llseek,
+    write:		ps2dev_write,
+    ioctl:		ps2vpu_ioctl,
+    mmap:		ps2vpu_mmap,
+    open:		ps2vpu_open,
+    release:		ps2vpu_release,
+    fsync:		ps2dev_fsync,
+};
+
+struct file_operations ps2ipu_fops = {
+    llseek:		no_llseek,
+    read:		ps2dev_read,
+    write:		ps2dev_write,
+    ioctl:		ps2ipu_ioctl,
+    mmap:		ps2ipu_mmap,
+    open:		ps2ipu_open,
+    release:		ps2ipu_release,
+    fsync:		ps2dev_fsync,
+};
+
+struct file_operations ps2spr_fops = {
+    llseek:		no_llseek,
+    ioctl:		ps2spr_ioctl,
+    mmap:		ps2spr_mmap,
+    open:		ps2spr_open,
+    release:		ps2spr_release,
+    fsync:		ps2dev_fsync,
+    get_unmapped_area:	ps2spr_get_unmapped_area,
+};
+
+static int ps2dev_initialized;
+
+static int ps2dev_add_device(unsigned int func, int offset, int count, const char *name, const char *devname)
+{
+    dev_t dev_id;
+    int rv;
+    int i;
+
+    BUG_ON(func >= PS2DEV_NR_OFDEVS);
+    dev_id = MKDEV(ps2dev_major, ps2dev_minor + FN2MINOR(func) + offset);
+    rv = cdev_add(&ps2dev_cdev[func], dev_id, count - offset);
+    if (rv < 0)
+        return rv;
+
+    if (devname == NULL)
+        devname = name;
+    for (i = offset; i < count; i++) {
+        struct device *d;
+        char buffer[16];
+
+        snprintf(buffer, sizeof(buffer), devname, i);
+        dev_id = MKDEV(ps2dev_major, ps2dev_minor + FN2MINOR(func) + i);
+        d = device_create(ps2dev_class, NULL, dev_id, NULL, buffer);
+        if (IS_ERR(d)) {
+            return PTR_ERR(d);
+        }
+    }
+    return 0;
+}
+
+static int ps2dev_remove_device(unsigned int func, int offset, int count)
+{
+    dev_t dev_id;
+    int i;
+
+    BUG_ON(func >= PS2DEV_NR_OFDEVS);
+
+    for (i = offset; i < count; i++) {
+        dev_id = MKDEV(ps2dev_major, ps2dev_minor + FN2MINOR(func) + i);
+        device_destroy(ps2dev_class, dev_id);
+    }
+    cdev_del(&ps2dev_cdev[func]);
+    return 0;
+}
+
+static void ps2_dev_remove_devices(void)
+{
+    ps2dev_remove_device(PS2MEM_FUNC, 1, 2);
+    ps2dev_remove_device(PS2GS_FUNC, 0, 1);
+    ps2dev_remove_device(PS2VPU_FUNC, 0, 2);
+    ps2dev_remove_device(PS2IPU_FUNC, 0, 1);
+    ps2dev_remove_device(PS2SPR_FUNC, 0, 1);
+}
+
+static int ps2_dev_add_devices(void)
+{
+    int rv;
+
+    cdev_init(&ps2dev_cdev[PS2MEM_FUNC], &ps2mem_fops);
+    cdev_init(&ps2dev_cdev[PS2EVENT_FUNC], &ps2ev_fops);
+    cdev_init(&ps2dev_cdev[PS2GS_FUNC], &ps2gs_fops);
+    cdev_init(&ps2dev_cdev[PS2VPU_FUNC], &ps2vpu_fops);
+    cdev_init(&ps2dev_cdev[PS2IPU_FUNC], &ps2ipu_fops);
+    cdev_init(&ps2dev_cdev[PS2SPR_FUNC], &ps2spr_fops);
+
+    rv = ps2dev_add_device(PS2MEM_FUNC, 1, 2, "ps2mem", NULL);
+    rv |= ps2dev_add_device(PS2EVENT_FUNC, 0, 1, "ps2event", NULL);
+    rv |= ps2dev_add_device(PS2GS_FUNC, 0, 1, "ps2gs", NULL);
+    rv |= ps2dev_add_device(PS2VPU_FUNC, 0, 2, "ps2vpu", "ps2vpu%d");
+    rv |= ps2dev_add_device(PS2IPU_FUNC, 0, 1, "ps2ipu", NULL);
+    rv |= ps2dev_add_device(PS2SPR_FUNC, 0, 1, "ps2spr", NULL);
+
+    if (rv) {
+        ps2_dev_remove_devices();
+        return -ENOMEM;
+    }
+
+    return 0;
+
+}
+
+static int vpu_usage(struct notifier_block *nfb, unsigned long action,
+	void *data)
+{
+	switch (action) {
+	case CU2_EXCEPTION:
+                printk("error: CU2_EXCEPTION at 0x%08lx (VPU not enabled?).\n", KSTK_EIP(current));
+                break;
+
+        case CU2_LWC2_OP:
+                printk("error: CU2_LWC2_OP at 0x%08lx\n", KSTK_EIP(current));
+                break;
+
+        case CU2_LDC2_OP:
+                printk("error: CU2_LDC2_OP at 0x%08lx\n", KSTK_EIP(current));
+                break;
+
+        case CU2_SWC2_OP:
+                printk("error: CU2_SWC2_OP at 0x%08lx\n", KSTK_EIP(current));
+                break;
+
+        case CU2_SDC2_OP:
+                printk("error: CU2_SDC2_OP at 0x%08lx\n", KSTK_EIP(current));
+                break;
+	}
+
+	return NOTIFY_OK;		/* Let default notifier send signals */
+}
+
+static struct notifier_block vpu_notifier = {
+	.notifier_call = vpu_usage,
+};
+
+int __init ps2dev_init(void)
+{
+    u64 gs_revision;
+    dev_t dev_id;
+    struct vm_struct *area;
+    int rv;
+
+    if (ps2dev_major) {
+        dev_id = MKDEV(ps2dev_major, ps2dev_minor);
+        rv = register_chrdev_region(dev_id, PS2DEV_COUNT, "ps2dev");
+    } else {
+        rv = alloc_chrdev_region(&dev_id, 0, PS2DEV_COUNT, "ps2dev");
+        ps2dev_major = MAJOR(dev_id);
+        ps2dev_minor = MINOR(dev_id);
+    }
+    if (rv) {
+        printk(KERN_ERR "ps2dev: unable to register chrdev region.\n");
+        return rv;
+    }
+
+    ps2dev_class = class_create(THIS_MODULE, "ps2dev");
+    if (IS_ERR(ps2dev_class)) {
+        unregister_chrdev_region(dev_id, PS2DEV_COUNT);
+        printk(KERN_ERR "ps2dev: unable to register class.\n");
+        return PTR_ERR(ps2dev_class);
+    }
+
+    rv = ps2_dev_add_devices();
+    if (rv) {
+        unregister_chrdev_region(dev_id, PS2DEV_COUNT);
+        class_destroy(ps2dev_class);
+        ps2dev_class = NULL;
+        printk(KERN_ERR "ps2dev: unable to allocate devices.\n");
+        return rv;
+    }
+
+    ps2ev_init();
+    spin_lock_irq(&ps2dma_channels[DMA_GIF].lock);
+    ps2dma_channels[DMA_GIF].reset = ps2gif_reset;
+    ps2dma_channels[DMA_VIF0].reset = ps2vpu0_reset;
+    ps2dma_channels[DMA_VIF1].reset = ps2vpu1_reset;
+    ps2dma_channels[DMA_IPU_to].reset = ps2ipu_reset;
+    spin_unlock_irq(&ps2dma_channels[DMA_GIF].lock);
+    ps2gs_get_gssreg(PS2_GSSREG_CSR, &gs_revision);
+
+    /* map scratchpad RAM */
+    area = __get_vm_area(2 * SPR_SIZE, VM_IOREMAP, VMALLOC_START, VMALLOC_END);
+    if (area != NULL) {
+	    /* Ensure that virtual address is aligned. */
+	    ps2spr_vaddr = SPR_ALIGN(area->addr + SPR_SIZE);
+
+	    /* This maps 16KByte, even if PM_4K is used. */
+	    add_wired_entry(SCRATCHPAD_RAM | 0x17, 0x17, (unsigned long) ps2spr_vaddr, PM_4K);
+
+	    /* TBD: Unmapping SPR is not possible in ps2dev_cleanup(). */
+    }
+
+    printk("PlayStation 2 device support: GIF, VIF, GS, VU, IPU, SPR\n");
+    printk("Graphics Synthesizer revision: %08x\n",
+	   ((u32)gs_revision >> 16) & 0xffff);
+
+    register_cu2_notifier(&vpu_notifier);
+
+    ps2dev_initialized = 1;
+
+    return 0;
+}
+
+void ps2dev_cleanup(void)
+{
+    dev_t dev_id;
+
+    if (!ps2dev_initialized)
+	return;
+
+    ps2_dev_remove_devices();
+    dev_id = MKDEV(ps2dev_major, ps2dev_minor);
+    unregister_chrdev_region(dev_id, PS2DEV_COUNT);
+    class_destroy(ps2dev_class);
+
+    spin_lock_irq(&ps2dma_channels[DMA_GIF].lock);
+    ps2dma_channels[DMA_GIF].reset = NULL;
+    ps2dma_channels[DMA_VIF0].reset = NULL;
+    ps2dma_channels[DMA_VIF1].reset = NULL;
+    ps2dma_channels[DMA_IPU_to].reset = NULL;
+    spin_unlock_irq(&ps2dma_channels[DMA_GIF].lock);
+    ps2ev_cleanup();
+
+}
+
+module_init(ps2dev_init);
+module_exit(ps2dev_cleanup);
+
+MODULE_AUTHOR("Sony Computer Entertainment Inc.");
+MODULE_DESCRIPTION("PlayStation 2 integrated device driver");
+MODULE_LICENSE("GPL");
diff -purN linux-2.6.35.4-orig/arch/mips/ps2/ps2dev.h linux-2.6.35.4/arch/mips/ps2/ps2dev.h
--- linux-2.6.35.4-orig/arch/mips/ps2/ps2dev.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/ps2/ps2dev.h	2014-07-18 22:29:43.550367724 +0200
@@ -0,0 +1,150 @@
+/*
+ *  PlayStation 2 timer functions
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __PS2DEV_H
+#define __PS2DEV_H
+
+#include <linux/sched.h>
+#include <linux/param.h>
+#include <linux/ps2/dev.h>
+
+#include <asm/types.h>
+#include <asm/io.h>
+
+#include <asm/mach-ps2/dma.h>
+
+#define BUFTYPE_MEM	0	/* DMA buffer is allocated by ps2mem */
+#define BUFTYPE_SPR	1	/* DMA buffer is scratchpad RAM */
+#define BUFTYPE_USER	2	/* copy from/to user address space */
+
+#define DMA_QUEUE_LIMIT_MAX	16
+#define DMA_USER_LIMIT	(1 * 1024 * 1024)
+
+/* structure defines */
+
+struct page_list {
+    int pages;
+    struct page *page[0];
+};
+
+struct dma_devch {
+    struct dma_channel *channel;
+    struct dma_device *device;
+    volatile int qct;
+    volatile int qsize;
+    int qlimit;
+    wait_queue_head_t done;
+};
+
+struct dma_device {
+    struct dma_devch devch[2];
+    wait_queue_head_t empty;
+    u32 intr_flag;
+    u32 intr_mask;
+    struct task_struct *ts;
+    int sig;
+    void *data;
+    spinlock_t lock;
+};
+
+struct dma_dev_request {
+    struct dma_request r;
+    struct dma_devch *devch;		/* request device */
+    int qsize;				/* request data size */
+    void (*free)(struct dma_request *, struct dma_channel *);
+};
+
+#define init_dma_dev_request(_req, _ops, _devch, _qsize, _free)	\
+    do { init_dma_request(&(_req)->r, (_ops)); \
+	 (_req)->devch = (_devch); (_req)->qsize = (_qsize); \
+	 (_req)->free = (_free); } while (0)
+
+/* user mode DMA request */
+
+struct udma_request {
+    struct dma_dev_request r;
+    struct dma_tag *tag;		/* DMA tag */
+    unsigned long vaddr;		/* start virtual addr */
+    unsigned long saddr;		/* scratchpad RAM addr */
+    struct page_list *mem;		/* allocated buffer */
+    volatile int *done;			/* pointer to DMA done flag */
+};
+
+struct udma_chain_request {
+    struct dma_dev_request r;
+    unsigned long taddr;		/* DMA tag addr */
+    int tte;				/* tag transfer enable flag */
+};
+
+struct udma_sendl_request {
+    struct dma_dev_request r;
+    struct dma_tag *tag_head, *tag_tail;
+    struct dma_tag *tag;
+    void *mem_head, *mem_tail;
+    unsigned long saddr;
+};
+
+struct udma_request_list {
+    struct dma_dev_request r;
+    int reqs, index;
+    struct udma_request *ureq[0];
+};
+
+/* function prototypes */
+
+/* ps2mem.c */
+extern struct vm_area_struct *ps2mem_vma_cache;
+extern struct file_operations ps2mem_fops;
+
+/* ps2event.c */
+extern struct file_operations ps2ev_fops;
+void ps2ev_init(void);
+void ps2ev_cleanup(void);
+
+/* ps2image.c */
+int ps2gs_loadimage(struct ps2_image *img, struct dma_device *dev, int async);
+int ps2gs_storeimage(struct ps2_image *img, struct dma_device *dev);
+
+/* ps2dma.c */
+struct page_list *ps2pl_alloc(int pages);
+struct page_list *ps2pl_realloc(struct page_list *list, int newpages);
+void ps2pl_free(struct page_list *list);
+int ps2pl_copy_from_user(struct page_list *list, void *from, long len);
+int ps2pl_copy_to_user(void *to, struct page_list *list, long len);
+
+int ps2dma_make_tag(unsigned long start, int len, struct dma_tag **tagp, struct dma_tag **lastp, struct page_list **memp);
+void ps2dma_dev_end(struct dma_request *req, struct dma_channel *ch);
+int ps2dma_check_and_add_queue(struct dma_dev_request *req, int nonblock);
+
+int ps2dma_write(struct dma_device *dev, struct ps2_packet *pkt, int nonblock);
+int ps2dma_send(struct dma_device *dev, struct ps2_packet *pkt, int async);
+int ps2dma_send_list(struct dma_device *dev, int num, struct ps2_packet *pkts);
+int ps2dma_send_chain(struct dma_device *dev, struct ps2_pchain *pchain);
+
+int ps2dma_recv(struct dma_device *dev, struct ps2_packet *pkt, int async);
+int ps2dma_recv_list(struct dma_device *dev, int num, struct ps2_packet *pkts);
+
+int ps2dma_stop(struct dma_device *dev, int dir, struct ps2_pstop *pstop);
+int ps2dma_get_qct(struct dma_device *dev, int dir, int param);
+int ps2dma_set_qlimit(struct dma_device *dev, int dir, int param);
+struct dma_device *ps2dma_dev_init(int send, int recv);
+int ps2dma_finish(struct dma_device *dev);
+
+#endif /* __PS2DEV_H */
diff -purN linux-2.6.35.4-orig/arch/mips/ps2/ps2dma.c linux-2.6.35.4/arch/mips/ps2/ps2dma.c
--- linux-2.6.35.4-orig/arch/mips/ps2/ps2dma.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/ps2/ps2dma.c	2014-07-18 22:29:43.550367724 +0200
@@ -0,0 +1,1296 @@
+/*
+ *  PlayStation 2 integrated device driver
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/ps2/dev.h>
+
+#include <asm/types.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/pgtable.h>
+#include <asm/irq.h>
+#include <asm/page.h>
+
+#include <asm/mach-ps2/irq.h>
+#include <asm/mach-ps2/dma.h>
+
+#include "ps2dev.h"
+
+extern struct file_operations ps2spr_fops, ps2mem_fops;
+
+/*
+ *  memory page list management functions
+ */
+
+struct page_list *ps2pl_alloc(int pages)
+{
+    int i;
+    struct page_list *list;
+
+    list = kmalloc(sizeof(*list) +
+        ((unsigned long) &list->page[pages]) - ((unsigned long) &list->page[0]), GFP_KERNEL);
+    if (list == NULL)
+	return NULL;
+    list->pages = pages;
+
+    for (i = 0; i < list->pages; i++) {
+	list->page[i] = alloc_page(GFP_KERNEL);
+	if (list->page[i] == NULL) {
+	    /* out of memory */
+	    while (--i >= 0)
+		put_page(list->page[i]);
+	    kfree(list);
+	    return NULL;
+	}
+	DPRINT("ps2pl_alloc: %p\n", page_address(list->page[i]));
+    }
+    return list;
+}
+
+struct page_list *ps2pl_realloc(struct page_list *list, int newpages)
+{
+    int i;
+    struct page_list *newlist;
+
+    if (list->pages >= newpages)
+	return list;
+    newlist = kmalloc(sizeof(*newlist) +
+        ((unsigned long) &list->page[list->pages]) - ((unsigned long) &list->page[0]), GFP_KERNEL);
+    if (newlist == NULL)
+	return NULL;
+
+    memcpy(&newlist->page[0], &list->page[0],
+        ((unsigned long) &list->page[list->pages]) - ((unsigned long) &list->page[0]));
+    newlist->pages = newpages;
+    for (i = list->pages; i < newpages; i++) {
+	newlist->page[i] = alloc_page(GFP_KERNEL);
+	if (newlist->page[i] == NULL) {
+	    /* out of memory */
+	    while (--i >= list->pages)
+		put_page(newlist->page[i]);
+	    kfree(newlist);
+	    return NULL;
+	}
+    }
+    kfree(list);
+    return newlist;
+}
+
+void ps2pl_free(struct page_list *list)
+{
+    int i;
+
+    for (i = 0; i < list->pages; i++) {
+	put_page(list->page[i]);
+	DPRINT("ps2pl_free: %p\n", page_address(list->page[i]));
+    }
+    kfree(list);
+}
+
+int ps2pl_copy_from_user(struct page_list *list, void *from, long len)
+{
+    int size;
+    int index = 0;
+
+    if (list->pages < ((len + ~PAGE_MASK) >> PAGE_SHIFT))
+	return -EINVAL;
+
+    while (len) {
+	size = len > PAGE_SIZE ? PAGE_SIZE : len;
+	DPRINT("ps2pl_copy_from_user: %p<-%p 0x%08x\n", page_address(list->page[index]), from, size);
+	if (copy_from_user(page_address(list->page[index++]), from, size))
+	    return -EFAULT;
+	from = (void *)((unsigned long)from + size);
+	len -= size;
+    }
+    return 0;
+}
+
+int ps2pl_copy_to_user(void *to, struct page_list *list, long len)
+{
+    int size;
+    int index = 0;
+
+    if (list->pages < ((len + ~PAGE_MASK) >> PAGE_SHIFT))
+	return -EINVAL;
+
+    while (len) {
+	size = len > PAGE_SIZE ? PAGE_SIZE : len;
+	DPRINT("ps2pl_copy_to_user: %p->%p %08x\n", page_address(list->page[index]), to, size);
+	if (copy_to_user(to, page_address(list->page[index++]), size))
+	    return -EFAULT;
+	to = (void *)((unsigned long)to + size);
+	len -= size;
+    }
+    return 0;
+}
+
+/*
+ *  make DMA tag
+ */
+
+static int ps2dma_make_tag_spr(unsigned long offset, int len, struct dma_tag **tagp, struct dma_tag **lastp)
+{
+    struct dma_tag *tag;
+
+    DPRINT("ps2dma_make_tag_spr: %08X %08X\n", offset, len);
+    if ((tag = kmalloc(sizeof(struct dma_tag) * 2, GFP_KERNEL)) == NULL)
+	return -ENOMEM;
+    *tagp = tag;
+
+    tag->id = DMATAG_REF;
+    tag->qwc = len >> 4;
+    tag->addr = offset | (1 << 31);	/* SPR address */
+    tag++;
+
+    if (lastp)
+	*lastp = tag;
+
+    tag->id = DMATAG_END;
+    tag->qwc = 0;
+
+    return BUFTYPE_SPR;
+}
+
+static int ps2dma_make_tag_mem(unsigned long offset, int len, struct dma_tag **tagp, struct dma_tag **lastp, struct page_list *mem)
+{
+    struct dma_tag *tag;
+    int sindex, eindex;
+    unsigned long vaddr, next, end;
+
+    DPRINT("ps2dma_make_tag_mem: %08X %08X\n", offset, len);
+    end = offset + len;
+    sindex = offset >> PAGE_SHIFT;
+    eindex = (end - 1) >> PAGE_SHIFT;
+    tag = kmalloc(sizeof(struct dma_tag) * (eindex - sindex + 2), GFP_KERNEL);
+    if (tag == NULL)
+	return -ENOMEM;
+    if ((((unsigned long)tag) & (DMA_TRUNIT - 1)) != 0)  {
+	printk(KERN_ERR "ps2dma_make_tag_mem: tag is not DMA aligned.\n");
+	return -ENOMEM;
+    }
+    *tagp = tag;
+
+    while (sindex <= eindex) {
+	vaddr = ((unsigned long) page_address(mem->page[sindex])) + (offset & ~PAGE_MASK);
+	next = (offset + PAGE_SIZE) & PAGE_MASK;
+	tag->id = DMATAG_REF;
+	tag->qwc = (next < end ? next - offset : end - offset) >> 4;
+	tag->addr = virt_to_bus((void *)vaddr);
+	DPRINT("ps2dma_make_tag_mem: tag %08X %08X\n", tag->addr, tag->qwc);
+	tag++;
+	offset = next;
+	sindex++;
+    }
+
+    if (lastp)
+	*lastp = tag;
+
+    tag->id = DMATAG_END;
+    tag->qwc = 0;
+
+    return BUFTYPE_MEM;
+}
+
+static int ps2dma_make_tag_user(unsigned long start, int len, struct dma_tag **tagp, struct dma_tag **lastp, struct page_list **memp)
+{
+    struct page_list *mem;
+
+    DPRINT("ps2dma_make_tag_user: %08X %08X\n", start, len);
+    if (memp == NULL)
+	return -EINVAL;
+    if ((mem = ps2pl_alloc((len + PAGE_SIZE - 1) >> PAGE_SHIFT)) == NULL)
+	return -ENOMEM;
+    if (ps2dma_make_tag_mem(0, len, tagp, lastp, mem) < 0) {
+	ps2pl_free(mem);
+	return -ENOMEM;
+    }
+    *memp = mem;
+    return BUFTYPE_USER;
+}
+
+int ps2dma_make_tag(unsigned long start, int len, struct dma_tag **tagp, struct dma_tag **lastp, struct page_list **memp)
+{
+    struct vm_area_struct *vma;
+    unsigned long offset;
+
+    DPRINT("ps2dma_make_tag: %08X %08X\n", start, len);
+
+    /* alignment check */
+    if ((start & (DMA_TRUNIT - 1)) != 0 ||
+	(len & (DMA_TRUNIT - 1)) != 0 || len <= 0)
+	return -EINVAL;
+
+    if (ps2mem_vma_cache != NULL &&
+	ps2mem_vma_cache->vm_mm == current->mm &&
+	ps2mem_vma_cache->vm_start <= start &&
+	ps2mem_vma_cache->vm_end > start + len) {
+	/* hit vma cache */
+	vma = ps2mem_vma_cache;
+	offset = start - vma->vm_start + (vma->vm_pgoff << PAGE_SHIFT);
+	return ps2dma_make_tag_mem(offset, len, tagp, lastp, (struct page_list *)vma->vm_file->private_data);
+    }
+    if ((vma = find_vma(current->mm, start)) == NULL)
+	return -EINVAL;
+    if (vma->vm_start > start)
+        return -EINVAL;
+    DPRINT("ps2dma_make_tag: vma %08X-%08X\n", vma->vm_start, vma->vm_end);
+
+    /* get buffer type */
+    if (vma->vm_file != NULL) {
+	if (vma->vm_file->f_op == &ps2spr_fops) {
+	    if (start + len > vma->vm_end)
+		return -EINVAL;			/* illegal address range */
+	    offset = start - vma->vm_start + (vma->vm_pgoff << PAGE_SHIFT);
+	    return ps2dma_make_tag_spr(offset, len, tagp, lastp);
+	}
+	if (vma->vm_file->f_op == &ps2mem_fops) {
+	    ps2mem_vma_cache = vma;
+	    if (start + len > vma->vm_end)
+		return -EINVAL;			/* illegal address range */
+	    offset = start - vma->vm_start + (vma->vm_pgoff << PAGE_SHIFT);
+	    return ps2dma_make_tag_mem(offset, len, tagp, lastp, (struct page_list *)vma->vm_file->private_data);
+	}
+    }
+
+    return ps2dma_make_tag_user(start, len, tagp, lastp, memp);
+}
+
+
+void ps2dma_dev_end(struct dma_request *req, struct dma_channel *ch)
+{
+    struct dma_dev_request *dreq = container_of(req, struct dma_dev_request, r);
+    unsigned long flags;
+    struct dma_devch *devch = dreq->devch;
+    struct dma_device *dev = dreq->devch->device;
+
+    spin_lock_irqsave(&dev->lock, flags);
+
+    DPRINT("ps2dma_dev_end: qct=%d\n", devch->qct);
+    devch->qsize -= dreq->qsize;
+    if (--devch->qct <= 0) {        /* request queue empty */
+	wake_up(&dev->empty);
+	if (dev->intr_mask & (1 << ch->direction)) {
+	    dev->intr_flag |= 1 << ch->direction;
+	    if (dev->sig)
+		send_sig(dev->sig, dev->ts, 1);
+	}
+    }
+    wake_up(&devch->done);
+
+    dreq->free(req, ch);
+
+    spin_unlock_irqrestore(&dev->lock, flags);
+}
+
+/*
+ * DMA operations for send
+ */
+
+static void dma_send_start(struct dma_request *req, struct dma_channel *ch)
+{
+    struct udma_request *ureq = container_of(container_of(req, struct dma_dev_request, r), struct udma_request, r);
+
+    DPRINT("dma_send_start: %08X %08X\n", ureq->tag->addr, ureq->tag->qwc);
+    WRITEDMAREG(ch, PS2_Dn_TADR, virt_to_bus(ureq->tag));
+    WRITEDMAREG(ch, PS2_Dn_QWC, 0);
+    WRITEDMAREG(ch, PS2_Dn_CHCR, CHCR_SENDC);
+}
+
+static void dma_send_spr_start(struct dma_request *req, struct dma_channel *ch)
+{
+    struct udma_request *ureq = container_of(container_of(req, struct dma_dev_request, r), struct udma_request, r);
+
+    DPRINT("dma_send_spr_start: %08X %08X %08X\n", ureq->tag->addr, ureq->tag->qwc, ureq->saddr);
+    WRITEDMAREG(ch, PS2_Dn_SADR, ureq->saddr);
+    WRITEDMAREG(ch, PS2_Dn_TADR, virt_to_bus(ureq->tag));
+    WRITEDMAREG(ch, PS2_Dn_QWC, 0);
+    WRITEDMAREG(ch, PS2_Dn_CHCR, CHCR_SENDC);
+}
+
+static unsigned long dma_stop(struct dma_request *req, struct dma_channel *ch)
+{
+    struct udma_request *ureq = container_of(container_of(req, struct dma_dev_request, r), struct udma_request, r);
+    unsigned long vaddr = ureq->vaddr;
+    struct dma_tag *tag = ureq->tag;
+    unsigned long eaddr;
+    unsigned long maddr, qwc;
+    struct dma_tag *taddr;
+
+
+    /* DMA force break */
+    DMABREAK(ch);
+    maddr = READDMAREG(ch, PS2_Dn_MADR);
+    qwc = READDMAREG(ch, PS2_Dn_QWC);
+    taddr = (struct dma_tag *)bus_to_virt(READDMAREG(ch, PS2_Dn_TADR));
+    DPRINT("dma_stop :%08X %08X %08X\n", maddr, qwc, (long)taddr);
+
+    while (tag->qwc) {
+	if (taddr == tag && qwc == 0)
+	    return vaddr;
+
+	eaddr = tag->addr + (tag->qwc << 4);
+	if ((qwc != 0 && maddr == tag->addr) ||
+	    (maddr > tag->addr && maddr < eaddr) ||
+	    (qwc == 0 && maddr == eaddr)) {
+	    /* if maddr points the last address of DMA request,
+	       the request is already finished */
+	    if (maddr == eaddr && tag[1].qwc == 0)
+		return 0;
+	    return vaddr + (maddr - tag->addr);
+	}
+	vaddr += tag->qwc << 4;
+	tag++;
+    }
+    return 0;		/* cannot get virtual address */
+}
+
+static void dma_free(struct dma_request *req, struct dma_channel *ch)
+{
+    struct udma_request *ureq = container_of(container_of(req, struct dma_dev_request, r), struct udma_request, r);
+
+    DPRINT("dma_free %08X\n", ureq->mem);
+    if (ureq->mem)
+	ps2pl_free(ureq->mem);
+    if (ureq->done)
+	*ureq->done = 1;
+    kfree(ureq->tag);
+    kfree(ureq);
+}
+
+static struct dma_ops dma_send_ops =
+{ dma_send_start, NULL, dma_stop, ps2dma_dev_end };
+static struct dma_ops dma_send_spr_ops =
+{ dma_send_spr_start, NULL, dma_stop, ps2dma_dev_end };
+
+/*
+ * DMA operations for send (chain mode)
+ */
+
+static void dma_send_chain_start(struct dma_request *req, struct dma_channel *ch)
+{
+    struct udma_chain_request *ucreq = container_of(container_of(req, struct dma_dev_request, r), struct udma_chain_request, r);
+
+    DPRINT("dma_send_chain_start: %08X %d\n", ucreq->taddr, ucreq->tte);
+    WRITEDMAREG(ch, PS2_Dn_TADR, ucreq->taddr);
+    WRITEDMAREG(ch, PS2_Dn_QWC, 0);
+    WRITEDMAREG(ch, PS2_Dn_CHCR, ucreq->tte ? CHCR_SENDC_TTE : CHCR_SENDC);
+}
+
+static unsigned long dma_send_chain_stop(struct dma_request *req, struct dma_channel *ch)
+{
+    DMABREAK(ch);
+    return 0;
+}
+
+static void dma_send_chain_free(struct dma_request *req, struct dma_channel *ch)
+{
+    struct udma_chain_request *ucreq = container_of(container_of(req, struct dma_dev_request, r), struct udma_chain_request, r);
+
+    DPRINT("dma_send_chain_free\n");
+    kfree(ucreq);
+}
+
+static struct dma_ops dma_send_chain_ops =
+{ dma_send_chain_start, NULL, dma_send_chain_stop, ps2dma_dev_end };
+
+/*
+ * DMA operations for receive
+ */
+
+static void dma_recv_start(struct dma_request *req, struct dma_channel *ch)
+{
+    struct udma_request *ureq = container_of(container_of(req, struct dma_dev_request, r), struct udma_request, r);
+
+    ch->tagp = ureq->tag;
+    DPRINT("dma_recv_start: %08X %08X\n", ch->tagp->addr, ch->tagp->qwc);
+    WRITEDMAREG(ch, PS2_Dn_MADR, ch->tagp->addr);
+    WRITEDMAREG(ch, PS2_Dn_QWC, ch->tagp->qwc);
+    WRITEDMAREG(ch, PS2_Dn_CHCR, CHCR_RECVN);
+    ch->tagp++;
+}
+
+static void dma_recv_spr_start(struct dma_request *req, struct dma_channel *ch)
+{
+    struct udma_request *ureq = container_of(container_of(req, struct dma_dev_request, r), struct udma_request, r);
+
+    ch->tagp = ureq->tag;
+    DPRINT("dma_recv_spr_start: %08X %08X %08X\n", ch->tagp->addr, ch->tagp->qwc, ureq->saddr);
+    WRITEDMAREG(ch, PS2_Dn_SADR, ureq->saddr);
+    WRITEDMAREG(ch, PS2_Dn_MADR, ch->tagp->addr);
+    WRITEDMAREG(ch, PS2_Dn_QWC, ch->tagp->qwc);
+    WRITEDMAREG(ch, PS2_Dn_CHCR, CHCR_RECVN);
+    ch->tagp++;
+}
+
+static int dma_recv_isdone(struct dma_request *req, struct dma_channel *ch)
+{
+    DPRINT("dma_recv_isdone: %08X %08X\n", ch->tagp->addr, ch->tagp->qwc);
+    if (ch->tagp->qwc <= 0)
+	return 1;		/* chain DMA is finished */
+
+    WRITEDMAREG(ch, PS2_Dn_MADR, ch->tagp->addr);
+    WRITEDMAREG(ch, PS2_Dn_QWC, ch->tagp->qwc);
+    WRITEDMAREG(ch, PS2_Dn_CHCR, CHCR_RECVN);
+    ch->tagp++;
+    return 0;			/* chain DMA is not finished */
+}
+
+static struct dma_ops dma_recv_ops =
+{ dma_recv_start, dma_recv_isdone, dma_stop, ps2dma_dev_end };
+static struct dma_ops dma_recv_spr_ops =
+{ dma_recv_spr_start, dma_recv_isdone, dma_stop, ps2dma_dev_end };
+
+/*
+ * DMA operations for send request list
+ */
+
+static void dma_sendl_start(struct dma_request *req, struct dma_channel *ch)
+{
+    struct udma_sendl_request *usreq = container_of(container_of(req, struct dma_dev_request, r), struct udma_sendl_request, r);
+
+    DPRINT("dma_sendl_start: %08X\n", usreq->tag);
+
+    WRITEDMAREG(ch, PS2_Dn_TADR, virt_to_bus(usreq->tag));
+    WRITEDMAREG(ch, PS2_Dn_QWC, 0);
+    WRITEDMAREG(ch, PS2_Dn_CHCR, CHCR_SENDC);
+}
+
+static void dma_sendl_spr_start(struct dma_request *req, struct dma_channel *ch)
+{
+    struct udma_sendl_request *usreq = container_of(container_of(req, struct dma_dev_request, r), struct udma_sendl_request, r);
+
+    DPRINT("dma_sendl_spr_start: %08X %08X\n", usreq->tag, usreq->saddr);
+
+    WRITEDMAREG(ch, PS2_Dn_SADR, usreq->saddr);
+    WRITEDMAREG(ch, PS2_Dn_TADR, virt_to_bus(usreq->tag));
+    WRITEDMAREG(ch, PS2_Dn_QWC, 0);
+    WRITEDMAREG(ch, PS2_Dn_CHCR, CHCR_SENDC);
+}
+
+static unsigned long dma_sendl_stop(struct dma_request *req, struct dma_channel *ch)
+{
+    DMABREAK(ch);
+    return 0;
+}
+
+static void dma_sendl_free(struct dma_request *req, struct dma_channel *ch)
+{
+    struct udma_sendl_request *usreq = container_of(container_of(req, struct dma_dev_request, r), struct udma_sendl_request, r);
+    void *p, *q;
+
+    DPRINT("dma_sendl_free\n");
+    p = usreq->mem_tail;
+    while (p) {
+	q = *(void **)p;
+	free_page((unsigned long)p);
+	p = q;
+    }
+    p = usreq->tag_tail;
+    while (p) {
+	q = *(void **)p;
+	free_page((unsigned long)p);
+	p = q;
+    }
+    kfree(usreq);
+}
+
+static struct dma_ops dma_sendl_ops =
+{ dma_sendl_start, NULL, dma_sendl_stop, ps2dma_dev_end };
+static struct dma_ops dma_sendl_spr_ops =
+{ dma_sendl_spr_start, NULL, dma_sendl_stop, ps2dma_dev_end };
+
+/*
+ * DMA operations for receive request list
+ */
+
+static void dma_list_start(struct dma_request *req, struct dma_channel *ch)
+{
+    struct udma_request_list *ureql = container_of(container_of(req, struct dma_dev_request, r), struct udma_request_list, r);
+
+    ureql->index = 0;
+    ureql->ureq[ureql->index]->r.r.ops->start((struct dma_request *)ureql->ureq[ureql->index], ch);
+}
+
+static int dma_list_isdone(struct dma_request *req, struct dma_channel *ch)
+{
+    struct udma_request_list *ureql = container_of(container_of(req, struct dma_dev_request, r), struct udma_request_list, r);
+    struct udma_request *ureq = ureql->ureq[ureql->index];
+
+    if (ureq->r.r.ops->isdone)
+	if (!ureq->r.r.ops->isdone((struct dma_request *)ureq, ch))
+	    return 0;		/* not finished */
+
+    if (++ureql->index < ureql->reqs) {
+	ureql->ureq[ureql->index]->r.r.ops->start(&ureql->ureq[ureql->index]->r.r, ch);
+	return 0;		/* not finished */
+    }
+    return 1;			/* finished */
+}
+
+static unsigned long dma_list_stop(struct dma_request *req, struct dma_channel *ch)
+{
+    struct udma_request_list *ureql = container_of(container_of(req, struct dma_dev_request, r), struct udma_request_list, r);
+    struct udma_request *ureq = ureql->ureq[ureql->index];
+
+    return ureq->r.r.ops->stop(&ureq->r.r, ch);
+}
+
+static void dma_list_free(struct dma_request *req, struct dma_channel *ch)
+{
+    struct udma_request_list *ureql = container_of(container_of(req, struct dma_dev_request, r), struct udma_request_list, r);
+    int i;
+
+    for (i = 0; i < ureql->reqs; i++)
+	ureql->ureq[i]->r.free(&ureql->ureq[i]->r.r, ch);
+    kfree(ureql);
+}
+
+static struct dma_ops dma_recv_list_ops =
+{ dma_list_start, dma_list_isdone, dma_list_stop, ps2dma_dev_end };
+
+/*
+ *  User mode DMA functions
+ */
+
+int ps2dma_check_and_add_queue(struct dma_dev_request *req, int nonblock)
+{
+    unsigned long flags;
+    struct dma_devch *devch = req->devch;
+
+#define QUEUEABLE(_devch, _qsize)	\
+	((_devch)->qct < (_devch)->qlimit && \
+	 ((_devch)->qsize + (_qsize) <= DMA_USER_LIMIT || \
+	  (_devch)->qsize == 0))
+
+    spin_lock_irqsave(&devch->device->lock, flags);
+
+    if (!QUEUEABLE(devch, req->qsize)) {
+	if (nonblock) {
+	    spin_unlock_irqrestore(&devch->device->lock, flags);
+	    return -EAGAIN;
+	} else {
+	    DECLARE_WAITQUEUE(wait, current);
+
+	    add_wait_queue(&devch->done, &wait);
+	    while (!QUEUEABLE(devch, req->qsize) & !signal_pending(current)) {
+		set_current_state(TASK_INTERRUPTIBLE);
+		spin_unlock_irq(&devch->device->lock);
+		schedule();
+		spin_lock_irq(&devch->device->lock);
+	    }
+	    remove_wait_queue(&devch->done, &wait);
+
+	    if (signal_pending(current)) {
+		spin_unlock_irqrestore(&devch->device->lock, flags);
+		return -ERESTARTSYS;		/* signal arrived */
+	    }
+	}
+    }
+
+    devch->qct++;
+    devch->qsize += req->qsize;
+
+    ps2dma_add_queue(&req->r, devch->channel, 1);
+
+    spin_unlock_irqrestore(&devch->device->lock, flags);
+
+    return 0;
+}
+
+int ps2dma_write(struct dma_device *dev, struct ps2_packet *pkt, int nonblock)
+{
+    struct udma_request *ureq;
+    struct dma_devch *devch = &dev->devch[DMA_SENDCH];
+    int result;
+
+    DPRINT("dma_write %08X %08X %d\n", pkt->ptr, pkt->len, nonblock);
+
+    /* alignment check */
+    if (((unsigned long)pkt->ptr & (DMA_TRUNIT - 1)) != 0 ||
+	(pkt->len & (DMA_TRUNIT - 1)) != 0 || pkt->len <= 0)
+	return -EINVAL;
+
+    if ((ureq = kmalloc(sizeof(struct udma_request), GFP_KERNEL)) == NULL)
+	return -ENOMEM;
+    init_dma_dev_request(&ureq->r, &dma_send_ops, devch, pkt->len, dma_free);
+    ureq->vaddr = (unsigned long)pkt->ptr;
+    ureq->done = NULL;
+
+    if ((result = ps2dma_make_tag_user((unsigned long)pkt->ptr, pkt->len, &ureq->tag, NULL, &ureq->mem)) < 0) {
+	kfree(ureq);
+	return result;
+    }
+    if ((result = ps2pl_copy_from_user(ureq->mem, pkt->ptr, pkt->len))) {
+	kfree(ureq);
+	return result;
+    }
+    result = ps2dma_check_and_add_queue(&ureq->r, nonblock);
+    if (result < 0) {
+	ps2pl_free(ureq->mem);
+	kfree(ureq->tag);
+	kfree(ureq);
+	return result;
+    }
+    return pkt->len;
+}
+
+static int make_send_request(struct udma_request **ureqp,
+			     struct dma_device *dev, struct dma_channel *ch,
+			     struct ps2_packet *pkt, struct dma_tag **lastp)
+{
+    struct udma_request *ureq;
+    struct dma_devch *devch = &dev->devch[DMA_SENDCH];
+    int result, len;
+
+    if ((ureq = kmalloc(sizeof(struct udma_request), GFP_KERNEL)) == NULL)
+	return -ENOMEM;
+    init_dma_dev_request(&ureq->r, &dma_send_ops, devch, 0, dma_free);
+    ureq->vaddr = (unsigned long)pkt->ptr;
+    ureq->mem = NULL;
+    ureq->done = NULL;
+
+    if (!ch->isspr) {
+	len = pkt->len;
+    } else {
+	DPRINT("make_send_request : SPR\n");
+	ureq->r.r.ops = &dma_send_spr_ops;
+	ureq->saddr = ((struct ps2_packet_spr *)pkt)->offset;
+	len = ((struct ps2_packet_spr *)pkt)->len;
+    }
+    switch (result = ps2dma_make_tag((unsigned long)pkt->ptr, len, &ureq->tag, lastp, &ureq->mem)) {
+    case BUFTYPE_MEM:
+	DPRINT("make_send_request : BUFTYPE_MEM\n");
+	break;
+    case BUFTYPE_SPR:
+	DPRINT("make_send_request : BUFTYPE_SPR\n");
+	if (!ch->isspr)
+	    break;
+	/* both src and dest are SPR */
+	kfree(ureq->tag);
+	kfree(ureq);
+	return -EINVAL;
+    case BUFTYPE_USER:
+	DPRINT("make_send_request : BUFTYPE_USER\n");
+	if ((result = ps2pl_copy_from_user(ureq->mem, pkt->ptr, len))) {
+	    ps2pl_free(ureq->mem);
+	    kfree(ureq->tag);
+	    kfree(ureq);
+	    return result;
+	}
+	ureq->r.qsize = len;
+	break;
+    default:
+	kfree(ureq);
+	return result;
+    }
+
+    *ureqp = ureq;
+    return 0;
+}
+
+int ps2dma_send(struct dma_device *dev, struct ps2_packet *pkt, int async)
+{
+    struct udma_request *ureq = NULL;
+    struct dma_devch *devch = &dev->devch[DMA_SENDCH];
+    struct dma_channel *ch = devch->channel;
+    volatile int done = 0;
+    int result;
+
+    DPRINT("dma_send %08X %08X %d\n", pkt->ptr, pkt->len, async);
+    if ((result = make_send_request(&ureq, dev, ch, pkt, NULL)))
+	return result;
+
+    if (!async)
+	ureq->done = &done;
+
+    result = ps2dma_check_and_add_queue(&ureq->r, 0);
+    if (result < 0) {
+	dma_free(&ureq->r.r, ch);
+	return result;
+    }
+
+    if (!async && !done) {
+	DECLARE_WAITQUEUE(wait, current);
+	DPRINT("dma_send: sleep\n");
+
+	add_wait_queue(&devch->done, &wait);
+	while (1) {
+	    set_current_state(TASK_INTERRUPTIBLE);
+	    if (done || signal_pending(current))
+		break;
+	    schedule();
+	}
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&devch->done, &wait);
+
+	if (signal_pending(current))
+	    result = -ERESTARTNOHAND; /* already queued - don't restart */
+
+	spin_lock_irq(&devch->device->lock);
+	if (!done)
+	    ureq->done = NULL;
+	spin_unlock_irq(&devch->device->lock);
+	DPRINT("dma_send: done\n");
+    }
+    return result;
+}
+
+int ps2dma_send_list(struct dma_device *dev, int num, struct ps2_packet *pkts)
+{
+    struct udma_sendl_request *usreq;
+    struct dma_devch *devch = &dev->devch[DMA_SENDCH];
+    struct dma_channel *ch = devch->channel;
+    struct dma_tag *tag, *tag_bottom;
+    int i;
+    int result;
+
+    DPRINT("dma_send_list\n");
+    if (num <= 0)
+	return -EINVAL;
+    if ((usreq = kmalloc(sizeof(struct udma_sendl_request), GFP_KERNEL)) == NULL)
+	return -ENOMEM;
+    init_dma_dev_request(&usreq->r, &dma_sendl_ops, devch, 0, dma_sendl_free);
+
+    if ((usreq->tag_head = (struct dma_tag *)get_zeroed_page(GFP_KERNEL)) /* TBD: check page reference counter */
+	== NULL) {
+	kfree(usreq);
+	return -ENOMEM;
+    }
+    usreq->tag_tail = usreq->tag_head;
+    *(void **)usreq->tag_head = NULL;
+    tag = usreq->tag = &(usreq->tag_head[1]);
+    tag_bottom = &(usreq->tag_head[(PAGE_SIZE / DMA_TRUNIT) - 1]);
+    usreq->mem_head = usreq->mem_tail = NULL;
+    
+    for (i = 0; i < num; i++) {
+	unsigned long start;
+	int len;
+	struct vm_area_struct *vma;
+	unsigned long offset;
+
+	start = (unsigned long)pkts[i].ptr;
+	len = pkts[i].len;
+	DPRINT(" request %d %08X %08X\n", i, start, len);
+
+	/* alignment check */
+	if ((start & (DMA_TRUNIT - 1)) != 0 ||
+	    (len & (DMA_TRUNIT - 1)) != 0 || len <= 0) {
+	    dma_sendl_free(&usreq->r.r, ch);
+	    return -EINVAL;
+	}
+
+	if (!(ps2mem_vma_cache != NULL &&
+	      ps2mem_vma_cache->vm_mm == current->mm &&
+	      ps2mem_vma_cache->vm_start <= start &&
+	      ps2mem_vma_cache->vm_end > start + len)) {
+	    /* vma cache miss - get buffer type */
+	    ps2mem_vma_cache = NULL;
+	    if ((vma = find_vma(current->mm, start)) == NULL) {
+		dma_sendl_free(&usreq->r.r, ch);
+		return -EINVAL;
+	    }
+	    if (vma->vm_file != NULL) {
+		if (vma->vm_file->f_op == &ps2mem_fops) {
+		    if (start + len >= vma->vm_end) {
+			dma_sendl_free(&usreq->r.r, ch);
+			return -EINVAL;		/* illegal address range */
+		    }
+		    ps2mem_vma_cache = vma;
+		}
+	    }
+	}
+
+	if (ps2mem_vma_cache != NULL) {
+	    struct page_list *mem;
+	    int sindex, eindex;
+	    unsigned long vaddr, next, end;
+
+	    vma = ps2mem_vma_cache;
+	    offset = start - vma->vm_start + (vma->vm_pgoff << PAGE_SHIFT);
+	    mem = (struct page_list *)vma->vm_file->private_data;
+	    end = offset + len;
+	    sindex = offset >> PAGE_SHIFT;
+	    eindex = (end - 1) >> PAGE_SHIFT;
+
+	    while (sindex <= eindex) {
+		vaddr = ((unsigned long) page_address(mem->page[sindex])) + (offset & ~PAGE_MASK);
+		next = (offset + PAGE_SIZE) & PAGE_MASK;
+		tag->id = DMATAG_REF;
+		tag->qwc = (next < end ? next - offset : end - offset) >> 4;
+		tag->addr = virt_to_bus((void *)vaddr);
+		DPRINT(" tag %08X %08X %08X\n", tag, tag->addr, tag->qwc);
+		offset = next;
+		sindex++;
+		tag++;
+
+		if (tag >= tag_bottom) {
+		    struct dma_tag *nexthead, *nexttag;
+
+		    if ((nexthead = (struct dma_tag *)get_zeroed_page(GFP_KERNEL)) == NULL) { /* TBD: check page reference counter */
+			dma_sendl_free((struct dma_request *)usreq, ch);
+			return -ENOMEM;
+		    }
+		    DPRINT(" alloc tag %08X\n", nexthead);
+		    *(void **)usreq->tag_head = nexthead;
+		    *(void **)nexthead = NULL;
+		    usreq->tag_head = nexthead;
+		    nexttag = &(usreq->tag_head[1]);
+		    tag_bottom = &(usreq->tag_head[(PAGE_SIZE / DMA_TRUNIT) - 1]);
+		    DPRINT(" tag next %08X -> %08X\n", tag, nexttag);
+		    tag->id = DMATAG_NEXT;
+		    tag->qwc = 0;
+		    tag->addr = virt_to_bus((void *)nexttag);
+		    tag = nexttag;
+		}
+	    }
+	} else {
+	    while (len > 0) {
+		int size = (len > PAGE_SIZE - DMA_TRUNIT) ? PAGE_SIZE - DMA_TRUNIT : len;
+		void *nextmem;
+		
+		if ((nextmem = (void *)get_zeroed_page(GFP_KERNEL)) == NULL) { /* TBD: check page reference counter */
+		    dma_sendl_free(&usreq->r.r, ch);
+		    return -ENOMEM;
+		}
+		if (usreq->mem_head != NULL)
+		    *(void **)usreq->mem_head = nextmem;
+		*(void **)nextmem = NULL;
+		usreq->mem_head = nextmem;
+		if (usreq->mem_tail == NULL)
+		    usreq->mem_tail = usreq->mem_head;
+		nextmem += DMA_TRUNIT;
+
+		DPRINT(" copy_from_user: %08X <- %08X %08X\n", nextmem, start, size);
+		if (copy_from_user(nextmem, (void *)start, size)) {
+		    dma_sendl_free(&usreq->r.r, ch);
+		    return -EFAULT;
+		}
+		tag->id = DMATAG_REF;
+		tag->qwc = size >> 4;
+		tag->addr = virt_to_bus(nextmem);
+		DPRINT(" tag %08X %08X %08X\n", tag, tag->addr, tag->qwc);
+		start += size;
+		len -= size;
+		tag++;
+
+		if (tag >= tag_bottom) {
+		    struct dma_tag *nexthead, *nexttag;
+
+		    if ((nexthead = (struct dma_tag *)get_zeroed_page(GFP_KERNEL)) == NULL) { /* TBD: check page reference counter */
+			dma_sendl_free(&usreq->r.r, ch);
+			return -ENOMEM;
+		    }
+		    DPRINT(" alloc tag %08X\n", nexthead);
+		    *(void **)usreq->tag_head = nexthead;
+		    *(void **)nexthead = NULL;
+		    usreq->tag_head = nexthead;
+		    nexttag = &(usreq->tag_head[1]);
+		    tag_bottom = &(usreq->tag_head[(PAGE_SIZE / DMA_TRUNIT) - 1]);
+		    DPRINT(" tag next %08X -> %08X\n", tag, nexttag);
+		    tag->id = DMATAG_NEXT;
+		    tag->qwc = 0;
+		    tag->addr = virt_to_bus((void *)nexttag);
+		    tag = nexttag;
+		}
+	    }
+	}
+    }
+
+    tag->id = DMATAG_END;
+    tag->qwc = 0;
+    DPRINT(" tag finish %08X\n", tag);
+
+    result = ps2dma_check_and_add_queue(&usreq->r, 0);
+    if (result < 0) {
+	dma_sendl_free(&usreq->r.r, ch);
+	return result;
+    }
+    return 0;
+}
+
+int ps2dma_send_chain(struct dma_device *dev, struct ps2_pchain *pchain)
+{
+    struct udma_chain_request *ucreq;
+    struct dma_devch *devch = &dev->devch[DMA_SENDCH];
+    struct dma_channel *ch = devch->channel;
+    unsigned long taddr = (unsigned long)pchain->ptr;
+    struct vm_area_struct *vma;
+    struct page_list *mem;
+    unsigned long offset;
+    int result;
+
+    DPRINT("dma_send_chain %08X %d\n", taddr, pchain->tte);
+
+    if ((taddr & (DMA_TRUNIT - 1)) != 0)
+	return -EINVAL;
+
+    /* taddr must point to ps2mem */
+    if ((vma = find_vma(current->mm, taddr)) == NULL ||
+	vma->vm_file == NULL ||
+	vma->vm_file->f_op != &ps2mem_fops)
+	return -EINVAL;
+    mem = (struct page_list *)vma->vm_file->private_data;
+
+    if ((ucreq = kmalloc(sizeof(struct udma_chain_request), GFP_KERNEL)) == NULL)
+	return -ENOMEM;
+    init_dma_dev_request(&ucreq->r, &dma_send_chain_ops, devch, 0, dma_send_chain_free);
+    ucreq->tte = pchain->tte;
+
+    offset = taddr - vma->vm_start + (vma->vm_pgoff << PAGE_SHIFT);
+    ucreq->taddr = virt_to_bus((void *)(page_address(mem->page[offset >> PAGE_SHIFT]) + (offset & ~PAGE_MASK)));
+
+    result = ps2dma_check_and_add_queue(&ucreq->r, 0);
+    if (result < 0) {
+	dma_send_chain_free(&ucreq->r.r, ch);
+	return result;
+    }
+    return result;
+}
+
+static int make_recv_request(struct udma_request **ureqp,
+			     struct dma_device *dev, struct dma_channel *ch,
+			     struct ps2_packet *pkt, 
+			     struct page_list **memp, int async)
+{
+    struct udma_request *ureq;
+    int result, len;
+    struct dma_devch *devch = &dev->devch[DMA_RECVCH];
+
+    if ((ureq = kmalloc(sizeof(struct udma_request), GFP_KERNEL)) == NULL)
+	return -ENOMEM;
+    init_dma_dev_request(&ureq->r, &dma_recv_ops, devch, 0, dma_free);
+    ureq->vaddr = (unsigned long)pkt->ptr;
+    ureq->mem = NULL;
+    ureq->done = NULL;
+
+    if (!ch->isspr) {
+	len = pkt->len;
+    } else {
+	ureq->r.r.ops = &dma_recv_spr_ops;
+	ureq->saddr = ((struct ps2_packet_spr *)pkt)->offset;
+	len = ((struct ps2_packet_spr *)pkt)->len;
+	DPRINT("make_recv_request : SPR\n");
+    }
+    switch (result = ps2dma_make_tag((unsigned long)pkt->ptr, len, &ureq->tag, NULL, memp)) {
+    case BUFTYPE_MEM:
+	DPRINT("make_recv_request : BUFTYPE_MEM\n");
+	break;
+    case BUFTYPE_SPR:
+	DPRINT("make_recv_request : BUFTYPE_SPR\n");
+	if (!ch->isspr)
+	    break;
+	/* both src and dest are SPR */
+	kfree(ureq->tag);
+	kfree(ureq);
+	return -EINVAL;
+    case BUFTYPE_USER:
+	DPRINT("make_recv_request : BUFTYPE_USER\n");
+	if (async) {
+	    /* no asynchronous copy_to_user function */
+	    kfree(ureq->tag);
+	    kfree(ureq);
+	    ps2pl_free(*memp);
+	    return -EINVAL;
+	}
+	ureq->r.qsize = len;
+	break;
+    default:
+	kfree(ureq);
+	return result;
+    }
+
+    *ureqp = ureq;
+    return 0;
+}
+
+int ps2dma_recv(struct dma_device *dev, struct ps2_packet *pkt, int async)
+{
+    struct udma_request *ureq;
+    struct dma_devch *devch = &dev->devch[DMA_RECVCH];
+    struct dma_channel *ch = devch->channel;
+    struct page_list *recv_mem = NULL;
+    volatile int done = 0;
+    int result;
+
+    DPRINT("dma_recv %08X %08X %d\n", pkt->ptr, pkt->len, async);
+    if ((result = make_recv_request(&ureq, dev, ch, pkt, &recv_mem, async)))
+	return result;
+
+    if (!async)
+	ureq->done = &done;
+
+    result = ps2dma_check_and_add_queue(&ureq->r, 0);
+    if (result < 0) {
+	dma_free(&ureq->r.r, ch);
+	return result;
+    }
+
+    if (!async && !done) {
+	DECLARE_WAITQUEUE(wait, current);
+	DPRINT("dma_recv: sleep\n");
+
+	add_wait_queue(&devch->done, &wait);
+	while (1) {
+	    set_current_state(TASK_INTERRUPTIBLE);
+	    if (done || signal_pending(current))
+		break;
+	    schedule();
+	}
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&devch->done, &wait);
+
+	if (signal_pending(current))
+	    result = -ERESTARTNOHAND; /* already queued - don't restart */
+
+	spin_lock_irq(&devch->device->lock);
+	if (!done)
+	    ureq->done = NULL;
+	spin_unlock_irq(&devch->device->lock);
+	DPRINT("dma_recv: done\n");
+
+	if (recv_mem != NULL && result == 0) {
+	    if (!ch->isspr)
+		result = ps2pl_copy_to_user(pkt->ptr, recv_mem, pkt->len);
+	    else
+		result = ps2pl_copy_to_user(pkt->ptr, recv_mem, ((struct ps2_packet_spr *)pkt)->len);
+	    ps2pl_free(recv_mem);
+	}
+    }
+    return result;
+}
+
+int ps2dma_recv_list(struct dma_device *dev, int num, struct ps2_packet *pkts)
+{
+    struct udma_request_list *ureql;
+    struct dma_devch *devch = &dev->devch[DMA_RECVCH];
+    struct dma_channel *ch = devch->channel;
+    int result, i;
+
+    if (num <= 0)
+	return -EINVAL;
+    if ((ureql = kmalloc(sizeof(struct udma_request_list) + sizeof(struct udma_request *) * num, GFP_KERNEL)) == NULL)
+	return -ENOMEM;
+    init_dma_dev_request(&ureql->r, &dma_recv_list_ops, devch, 0, dma_list_free);
+    ureql->reqs = num;
+    ureql->index = 0;
+
+    for (i = 0; i < num; i++) {
+	if ((result = make_recv_request(&ureql->ureq[i], dev, ch, &pkts[i], NULL, 1))) {
+	    while (--i >= 0)
+		dma_free(&ureql->ureq[i]->r.r, ch);
+	    kfree(ureql);
+	    return result;
+	}
+    }
+
+    result = ps2dma_check_and_add_queue(&ureql->r, 0);
+    if (result < 0) {
+	dma_list_free(&ureql->r.r, ch);
+	return result;
+    }
+    return 0;
+}
+
+int ps2dma_stop(struct dma_device *dev, int dir, struct ps2_pstop *pstop)
+{
+    unsigned long flags;
+    struct dma_channel *ch = dev->devch[dir].channel;
+    struct dma_request *hreq, **reqp, *next;
+    int stop = 0;
+
+    if (ch == NULL)
+	return -1;
+
+    pstop->ptr = NULL;
+    pstop->qct = 0;
+
+    spin_lock_irq(&dev->lock);
+    spin_lock_irqsave(&ch->lock, flags);
+
+    /* delete all DMA requests from the queue */
+    reqp = &ch->tail;
+    hreq = NULL;
+    while (*reqp != NULL) {
+    	struct dma_dev_request *dreq = container_of(*reqp, struct dma_dev_request, r);
+	if ((*reqp)->ops->free == ps2dma_dev_end &&
+	    dreq->devch->device == dev) {
+	    if (!stop && reqp == &ch->tail) {
+		/* the request is processing now - stop DMA */
+		if ((pstop->ptr = (void *)(*reqp)->ops->stop(*reqp, ch)))
+		    stop = 1;
+	    } else {
+		if (pstop->ptr == NULL &&
+		    (*reqp)->ops->stop == dma_stop) {
+		    struct udma_request *ureq = container_of(dreq, struct udma_request, r);
+		    pstop->ptr = (void *)ureq->vaddr;
+		}
+	    }
+	    pstop->qct++;
+
+	    next = (*reqp)->next;
+	    dreq->free(*reqp, ch);
+	    *reqp = next;
+	} else {
+	    hreq = *reqp;
+	    reqp = &(*reqp)->next;
+	}
+    }
+    ch->head = hreq;
+    dev->devch[dir].qct = 0;
+    dev->devch[dir].qsize = 0;
+
+    spin_unlock_irqrestore(&ch->lock, flags);
+
+    if (stop)
+	ps2dma_intr_handler(ch->irq, ch);
+
+    spin_unlock_irq(&dev->lock);
+
+    return 0;
+}
+
+int ps2dma_get_qct(struct dma_device *dev, int dir, int param)
+{
+    int qct;
+    struct dma_devch *devch = &dev->devch[dir];
+
+    spin_lock_irq(&devch->device->lock);
+
+    if (param <= 0) {
+	qct = devch->qct;
+    } else {
+	DECLARE_WAITQUEUE(wait, current);
+
+	add_wait_queue(&devch->done, &wait);
+	while ((qct = devch->qct) >= param) {
+	    set_current_state(TASK_INTERRUPTIBLE);
+	    spin_unlock_irq(&devch->device->lock);
+	    schedule();
+	    spin_lock_irq(&devch->device->lock);
+	}
+	remove_wait_queue(&devch->done, &wait);
+
+	if (signal_pending(current)) {
+	    qct = -ERESTARTSYS;			/* signal arrived */
+	}
+    }
+
+    spin_unlock_irq(&devch->device->lock);
+
+    return qct;
+}
+
+int ps2dma_set_qlimit(struct dma_device *dev, int dir, int param)
+{
+    int oldlimit;
+    struct dma_devch *devch = &dev->devch[dir];
+
+    if (param <= 0 || param > DMA_QUEUE_LIMIT_MAX)
+	return -EINVAL;
+
+    oldlimit = devch->qlimit;
+    devch->qlimit = param;
+    return oldlimit;
+}
+
+struct dma_device *ps2dma_dev_init(int send, int recv)
+{
+    struct dma_device *dev;
+
+    if ((dev = kmalloc(sizeof(struct dma_device), GFP_KERNEL)) == NULL)
+	return NULL;
+    memset(dev, 0, sizeof(struct dma_device));
+    dev->ts = current;
+    spin_lock_init(&dev->lock);
+    init_waitqueue_head(&dev->empty);
+
+    if (send >= 0) {
+	dev->devch[DMA_SENDCH].channel = &ps2dma_channels[send];
+	dev->devch[DMA_SENDCH].qlimit = DMA_QUEUE_LIMIT_MAX;
+	dev->devch[DMA_SENDCH].device = dev;
+	init_waitqueue_head(&dev->devch[DMA_SENDCH].done);
+    }
+    if (recv >= 0) {
+	dev->devch[DMA_RECVCH].channel = &ps2dma_channels[recv];
+	dev->devch[DMA_RECVCH].qlimit = DMA_QUEUE_LIMIT_MAX;
+	dev->devch[DMA_RECVCH].device = dev;
+	init_waitqueue_head(&dev->devch[DMA_RECVCH].done);
+    }
+
+    return dev;
+}
+
+int ps2dma_finish(struct dma_device *dev)
+{
+    struct ps2_pstop pstop;
+    long timeout;
+
+    DPRINT("finish\n");
+
+    if (dev->devch[DMA_SENDCH].qct != 0 ||
+	dev->devch[DMA_RECVCH].qct != 0) {
+	DECLARE_WAITQUEUE(wait, current);
+
+	add_wait_queue(&dev->empty, &wait);
+	while (1) {
+	    set_current_state(TASK_INTERRUPTIBLE);
+
+	    if (current->flags & PF_SIGNALED) {
+		/* closed by a signal */
+		DPRINT("closed by a signal\n");
+		flush_signals(current);
+	    }
+
+	    if (dev->devch[DMA_SENDCH].qct == 0 &&
+		dev->devch[DMA_RECVCH].qct == 0)
+		break;
+
+	    timeout = schedule_timeout(DMA_TIMEOUT);
+
+	    if (signal_pending(current) ||
+		(current->flags & PF_SIGNALED && timeout == 0)) {
+		set_current_state(TASK_RUNNING);
+		remove_wait_queue(&dev->empty, &wait);
+
+		/* reset device FIFO */
+		if (dev->devch[DMA_SENDCH].channel->reset != NULL)
+		    dev->devch[DMA_SENDCH].channel->reset();
+		/* force break by a signal */
+		ps2dma_stop(dev, DMA_SENDCH, &pstop);
+		ps2dma_stop(dev, DMA_RECVCH, &pstop);
+
+		return -1;
+	    }
+	}
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&dev->empty, &wait);
+    }
+    return 0;
+}
diff -purN linux-2.6.35.4-orig/arch/mips/ps2/ps2event.c linux-2.6.35.4/arch/mips/ps2/ps2event.c
--- linux-2.6.35.4-orig/arch/mips/ps2/ps2event.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/ps2/ps2event.c	2014-07-18 22:29:43.550367724 +0200
@@ -0,0 +1,385 @@
+/*
+ *  PlayStation 2 event handling device driver (/dev/ps2event)
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/mm.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/wait.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/ps2/dev.h>
+
+#include <asm/uaccess.h>
+
+#include <asm/mach-ps2/irq.h>
+
+#include "ps2dev.h"
+
+/* TBD: Convert Linux 2.4 module to 2.6 */
+
+struct ps2ev_data {
+    struct ps2ev_data *next;
+    u32 intr_flag;
+    u32 intr_mask;
+    unsigned int intr_count[PS2EV_N_MAX];
+    unsigned int hsync_active;
+    wait_queue_head_t wq;
+    struct fasync_struct *fa;
+    struct pid *pid;
+    int sig;
+};
+
+struct ev_list {
+    int event;
+    int irq;
+    irqreturn_t (*handler)(int, void *);
+    char *device;
+};
+
+static spinlock_t ps2ev_lock = SPIN_LOCK_UNLOCKED;
+static struct ps2ev_data *ps2ev_data = NULL;
+static u32 intr_mask = 0;
+static volatile unsigned int hsync_count;
+
+static inline void ev_check(struct ps2ev_data *p, int event, u32 evbit)
+{
+    if (p->intr_mask & evbit) {
+	p->intr_flag |= evbit;
+	p->intr_count[event]++;
+	if (waitqueue_active(&p->wq))
+	    wake_up_interruptible(&p->wq);
+	if (p->fa)
+	    kill_fasync(&p->fa, SIGIO, POLL_IN);
+	if (p->sig)
+	    kill_pid(p->pid, p->sig, 1);
+    }
+}
+
+static irqreturn_t ev_handler(int irq, void *dev_id)
+{
+    struct ps2ev_data *p;
+    int event = ((struct ev_list *)dev_id)->event;
+    u32 evbit = 1 << event;
+
+    for (p = ps2ev_data; p != NULL; p = p->next)
+	ev_check(p, event, evbit);
+    return IRQ_HANDLED;
+}
+
+/* TBD: Check return values of interrupt handlers. */
+static irqreturn_t ev_finish_handler(int irq, void *dev_id)
+{
+    struct ps2ev_data *p;
+    extern int ps2gs_storeimage_finish(void);
+
+    /* for storeimage */
+    if (ps2gs_storeimage_finish())
+	return IRQ_HANDLED;
+
+    for (p = ps2ev_data; p != NULL; p = p->next)
+	ev_check(p, PS2EV_N_FINISH, PS2EV_FINISH);
+    return IRQ_HANDLED;
+}
+
+static irqreturn_t ev_hsync_handler(int irq, void *dev_id)
+{
+    struct ps2ev_data *p;
+
+    hsync_count++;
+    for (p = ps2ev_data; p != NULL; p = p->next) {
+	if (p->hsync_active != hsync_count)
+	    continue;
+	ev_check(p, PS2EV_N_HSYNC, PS2EV_HSYNC);
+    }
+    return IRQ_HANDLED;
+}
+
+static irqreturn_t ev_vsync_handler(int irq, void *dev_id)
+{
+    struct ps2ev_data *p;
+
+    hsync_count = 0;
+    for (p = ps2ev_data; p != NULL; p = p->next)
+	ev_check(p, PS2EV_N_VSYNC, PS2EV_VSYNC);
+    return IRQ_HANDLED;
+}
+
+static irqreturn_t ev_vbstart_handler(int irq, void *dev_id)
+{
+    struct ps2ev_data *p;
+    extern void ps2gs_sgssreg_vb(void);
+
+    ps2gs_sgssreg_vb();
+    for (p = ps2ev_data; p != NULL; p = p->next)
+	ev_check(p, PS2EV_N_VBSTART, PS2EV_VBSTART);
+    return IRQ_HANDLED;
+}
+
+static struct ev_list ev_list[] = {
+    { PS2EV_N_VBSTART, IRQ_INTC_VB_ON,  ev_vbstart_handler, "V-Blank start" },
+    { PS2EV_N_VBEND,   IRQ_INTC_VB_OFF, ev_handler,         "V-Blank end" },
+    { PS2EV_N_VIF0,    IRQ_INTC_VIF0,   ev_handler,         "VIF0" },
+    { PS2EV_N_VIF1,    IRQ_INTC_VIF1,   ev_handler,         "VIF1" },
+    { PS2EV_N_VU0,     IRQ_INTC_VU0,    ev_handler,         "VU0" },
+    { PS2EV_N_VU1,     IRQ_INTC_VU1,    ev_handler,         "VU1" },
+    { PS2EV_N_IPU,     IRQ_INTC_IPU,    ev_handler,         "IPU" },
+    { PS2EV_N_SIGNAL,  IRQ_GS_SIGNAL,   ev_handler,         "GS SIGNAL" },
+    { PS2EV_N_FINISH,  IRQ_GS_FINISH,   ev_finish_handler,  "GS FINISH" },
+    { PS2EV_N_HSYNC,   IRQ_GS_HSYNC,    ev_hsync_handler,   "GS HSYNC" },
+    { PS2EV_N_VSYNC,   IRQ_GS_VSYNC,    ev_vsync_handler,   "GS VSYNC" },
+    { PS2EV_N_EDW,     IRQ_GS_EDW,      ev_handler,         "GS EDW" },
+    { -1, -1, NULL, NULL }
+};
+
+static void register_intr_handler(int free)
+{
+    struct ps2ev_data *p;
+    struct ev_list *ep;
+    u32 intr_mask_new;
+    u32 ev_bit;
+
+    if (free) {
+	intr_mask_new = 0;
+    } else {
+	/* storeimage needs FINISH event */
+	/* sgssreg_vb needs VBSTART event */
+	intr_mask_new = PS2EV_FINISH | PS2EV_VBSTART;
+	for (p = ps2ev_data; p != NULL; p = p->next)
+	    intr_mask_new |= p->intr_mask;
+
+	/* hsync needs vsync handler for counter reset */
+	if (intr_mask_new & PS2EV_HSYNC)
+	    intr_mask_new |= PS2EV_VSYNC;
+    }
+
+    for (ep = ev_list; ep->event >= 0; ep++) {
+	ev_bit = 1 << ep->event;
+	if (intr_mask_new & ev_bit) {
+	    if (!(intr_mask & ev_bit)) {
+		if (request_irq(ep->irq, ep->handler, IRQF_SHARED,
+				ep->device, ep)) {
+		    printk("unable to get irq %d\n", ep->irq);
+		    intr_mask_new &= ~ev_bit;
+		}
+	    }
+	} else {
+	    if (intr_mask & ev_bit) {
+		free_irq(ep->irq, ep);
+	    }
+	}
+    }
+    intr_mask = intr_mask_new;
+}
+
+static int ps2ev_ioctl(struct inode *inode, struct file *file,
+			unsigned int cmd, unsigned long arg)
+{
+    struct ps2ev_data *data;
+    u32 ff, oldff;
+    int val;
+    int i;
+
+    switch (cmd) {
+    case PS2IOC_ENABLEEVENT:
+	data = (struct ps2ev_data *)file->private_data;
+	oldff = data->intr_mask;
+	if ((int)arg >= 0) {
+	    spin_lock_irq(&ps2ev_lock);
+	    ff = data->intr_mask ^ arg;
+	    data->intr_flag &= ~ff;
+	    for (i = 0; i < PS2EV_N_MAX; i++)
+		if (ff & (1 << i))
+		    data->intr_count[i] = 0;
+	    data->intr_mask = arg;
+	    register_intr_handler(0);
+	    spin_unlock_irq(&ps2ev_lock);
+	}
+	return oldff;
+    case PS2IOC_GETEVENT:
+	data = (struct ps2ev_data *)file->private_data;
+	spin_lock_irq(&ps2ev_lock);
+	oldff = data->intr_flag;
+	if ((int)arg > 0)
+	    data->intr_flag &= ~arg;
+	spin_unlock_irq(&ps2ev_lock);
+	return oldff;
+    case PS2IOC_WAITEVENT:
+	data = (struct ps2ev_data *)file->private_data;
+	if (wait_event_interruptible(data->wq, (data->intr_flag & arg))) {
+	    return -ERESTARTSYS;	/* signal arrived */
+	}
+	spin_lock_irq(&ps2ev_lock);
+	oldff = data->intr_flag;
+	data->intr_flag &= ~arg;
+	spin_unlock_irq(&ps2ev_lock);
+	return oldff;
+    case PS2IOC_EVENTCOUNT:
+	data = (struct ps2ev_data *)file->private_data;
+	if ((long)arg < 0) {		/* clear all event counters */
+	    spin_lock_irq(&ps2ev_lock);
+	    for (i = 0; i < PS2EV_N_MAX; i++)
+		data->intr_count[i] = 0;
+	    spin_unlock_irq(&ps2ev_lock);
+	    return 0;
+	}
+	if (arg >= PS2EV_N_MAX)
+	    return -EINVAL;
+	spin_lock_irq(&ps2ev_lock);
+	val = data->intr_count[arg];
+	data->intr_count[arg] = 0;
+	spin_unlock_irq(&ps2ev_lock);
+	return val;
+    case PS2IOC_HSYNCACT:
+	data = (struct ps2ev_data *)file->private_data;
+	val = data->hsync_active;
+	if ((long)arg >= 0)
+	    data->hsync_active = arg;
+	return val;
+    case PS2IOC_GETHSYNC:
+	return hsync_count;
+    case PS2IOC_SETSIGNAL:
+	data = (struct ps2ev_data *)file->private_data;
+	val = data->sig;
+	if ((int)arg >= 0)
+	    data->sig = arg;
+	return val;
+    default:
+	return -EINVAL;
+    }
+
+    return 0;
+}
+
+static ssize_t ps2ev_read(struct file *file, char *buf, size_t count, loff_t *ppos)
+{
+    struct ps2ev_data *data = file->private_data;
+    u32 ff;
+    int len;
+
+    if (file->f_flags & O_NONBLOCK) {
+	if (!(data->intr_flag & data->intr_mask)) {
+	    return -EAGAIN;
+	}
+    } else {
+	if (wait_event_interruptible(data->wq,
+				     (data->intr_flag & data->intr_mask))) {
+	    return -ERESTARTSYS;	/* signal arrived */
+	}
+    }
+
+    spin_lock_irq(&ps2ev_lock);
+    ff = data->intr_flag;
+    data->intr_flag &= ~data->intr_mask;
+    spin_unlock_irq(&ps2ev_lock);
+
+    len = count > sizeof(ff) ? sizeof(ff) : count;
+    if (copy_to_user(buf, &ff, len))
+	return -EFAULT;
+    return len;
+}
+
+static unsigned int ps2ev_poll(struct file *file, poll_table *wait)
+{
+    struct ps2ev_data *data = file->private_data;
+
+    poll_wait(file, &data->wq, wait);
+    if (data->intr_flag & data->intr_mask)
+	return POLLIN | POLLRDNORM;
+    return 0;
+}
+
+static int ps2ev_fasync(int fd, struct file *file, int on)
+{
+    int retval;
+    struct ps2ev_data *data = file->private_data;
+
+    retval = fasync_helper(fd, file, on, &data->fa);
+    if (retval < 0)
+	return retval;
+    return 0;
+}
+
+static int ps2ev_open(struct inode *inode, struct file *file)
+{
+    struct ps2ev_data *data;
+
+    if ((data = kmalloc(sizeof(struct ps2ev_data), GFP_KERNEL)) == NULL)
+	return -ENOMEM;
+    memset(data, 0, sizeof(struct ps2ev_data));
+    init_waitqueue_head(&data->wq);
+    data->pid = get_pid(task_pid(current));
+
+    file->private_data = data;
+    spin_lock_irq(&ps2ev_lock);
+    data->next = ps2ev_data;
+    ps2ev_data = data;
+    spin_unlock_irq(&ps2ev_lock);
+    return 0;
+}
+
+static int ps2ev_release(struct inode *inode, struct file *file)
+{
+    struct ps2ev_data *data, **p;
+
+    data = (struct ps2ev_data *)file->private_data;
+    ps2ev_fasync(-1, file, 0);
+
+    spin_lock_irq(&ps2ev_lock);
+    data->intr_mask = 0;
+    register_intr_handler(0);
+    p = &ps2ev_data;
+    while (*p != NULL) {
+	if (*p == data) {
+	    *p = data->next;
+	    break;
+	}
+	p = &(*p)->next;
+    }
+    spin_unlock_irq(&ps2ev_lock);
+    put_pid(data->pid);
+    kfree(data);
+    return 0;
+}
+
+struct file_operations ps2ev_fops = {
+    llseek:		no_llseek,
+    read:		ps2ev_read,
+    poll:		ps2ev_poll,
+    ioctl:		ps2ev_ioctl,
+    open:		ps2ev_open,
+    release:		ps2ev_release,	
+    fasync:		ps2ev_fasync,
+};
+
+void ps2ev_init(void)
+{
+    register_intr_handler(0);
+}
+
+void ps2ev_cleanup(void)
+{
+    register_intr_handler(-1);
+}
diff -purN linux-2.6.35.4-orig/arch/mips/ps2/ps2image.c linux-2.6.35.4/arch/mips/ps2/ps2image.c
--- linux-2.6.35.4-orig/arch/mips/ps2/ps2image.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/ps2/ps2image.c	2014-07-18 22:29:43.550367724 +0200
@@ -0,0 +1,734 @@
+/*
+ *  PlayStation 2 image data transfer functions
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/mm.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/completion.h>
+#include <linux/ps2/dev.h>
+#include <linux/ps2/gs.h>
+
+#include <asm/pgtable.h>
+#include <asm/atomic.h>
+#include <asm/irq.h>
+
+#include <asm/mach-ps2/irq.h>
+#include <asm/mach-ps2/dma.h>
+#include <asm/mach-ps2/eedev.h>
+
+#include "ps2dev.h"
+
+/*
+ *  loadimage (EE->GS image data transfer)
+ */
+
+struct loadimage_request {
+    struct dma_dev_request r;
+    struct page_list *mem;
+    volatile int *done;
+    struct dma_tag tag[0] __attribute__((aligned(DMA_TRUNIT)));
+} __attribute__((aligned(DMA_TRUNIT)));
+
+static void loadimage_start(struct dma_request *req, struct dma_channel *ch)
+{
+    struct loadimage_request *lreq =
+        container_of(
+            container_of(req, struct dma_dev_request, r),
+            struct loadimage_request, r);
+
+    WRITEDMAREG(ch, PS2_Dn_TADR, virt_to_bus(lreq->tag));
+    WRITEDMAREG(ch, PS2_Dn_QWC, 0);
+    WRITEDMAREG(ch, PS2_Dn_CHCR, CHCR_SENDC);
+}
+
+static unsigned long loadimage_stop(struct dma_request *req, struct dma_channel *ch)
+{
+    DMABREAK(ch);
+    return 0;
+}
+
+static void loadimage_free(struct dma_request *req, struct dma_channel *ch)
+{
+    struct loadimage_request *lreq =
+        container_of(
+            container_of(req, struct dma_dev_request, r),
+            struct loadimage_request, r);
+
+    if (lreq->mem)
+	ps2pl_free(lreq->mem);
+    if (lreq->done)
+	*lreq->done = 1;
+    kfree(lreq);
+}
+
+static struct dma_ops loadimage_ops =
+{ loadimage_start, NULL, loadimage_stop, ps2dma_dev_end };
+
+int ps2gs_loadimage(struct ps2_image *img, struct dma_device *dev, int async)
+{
+    struct loadimage_request *lreq; 
+    struct dma_devch *devch = &dev->devch[DMA_SENDCH];
+    struct dma_channel *ch = devch->channel;
+    u64 *p;
+    struct dma_tag *tag, *dp;
+    struct page_list *mem = NULL;
+    int size, qsize;
+    volatile int done = 0;
+    int result;
+
+    switch (img->psm) {
+    case PS2_GS_PSMCT32:
+    case PS2_GS_PSMZ32:
+	size = (img->w * img->h) << 2;
+	break;
+    case PS2_GS_PSMCT24:
+    case PS2_GS_PSMZ24:
+	size = img->w * img->h * 3;
+	break;
+    case PS2_GS_PSMCT16:
+    case PS2_GS_PSMCT16S:
+    case PS2_GS_PSMZ16:
+    case PS2_GS_PSMZ16S:
+	size = (img->w * img->h) << 1;
+	break;
+    case PS2_GS_PSMT8:
+    case PS2_GS_PSMT8H:
+	if (img->x % 2 || img->w % 2)
+	    return -EINVAL;		/* invalid alignment */
+	size = img->w * img->h;
+	break;
+    case PS2_GS_PSMT4:
+    case PS2_GS_PSMT4HL:
+    case PS2_GS_PSMT4HH:
+	if (img->x % 4 || img->w % 4)
+	    return -EINVAL;		/* invalid alignment */
+	size = (img->w * img->h) >> 1;
+	break;
+    default:
+	return -EINVAL;
+    }
+    if (size == 0)
+	return -EINVAL;
+    size = DMA_ALIGN(size);
+
+    if (img->fbp & ~0x3fff) {
+	return -EINVAL;
+    }
+
+    if (img->fbw & ~0x3f) {
+	return -EINVAL;
+    }
+
+    switch (result = ps2dma_make_tag((unsigned long)img->ptr, size, &tag, NULL, &mem)) {
+    case BUFTYPE_MEM:
+    case BUFTYPE_SPR:
+	qsize = 0;
+	break;
+    case BUFTYPE_USER:
+	if ((result = ps2pl_copy_from_user(mem, img->ptr, size))) {
+	    ps2pl_free(mem);
+	    kfree(tag);
+	    return result;
+	}
+	qsize = size;
+	break;
+    default:
+	return result;
+    }
+
+    lreq = kmalloc(sizeof(struct loadimage_request) +
+			(6 + ((size >> PAGE_SHIFT) + 3) * 3) * DMA_TRUNIT,
+			GFP_KERNEL);
+    if ((lreq != NULL) && ((((unsigned long)&lreq->tag) & (DMA_TRUNIT - 1)) != 0)) {
+        kfree(lreq);
+        lreq = NULL;
+        printk(KERN_ERR "ps2gs_loadimage: lreq->tag is not DMA aligned.\n");
+    }
+    if (lreq == NULL) {
+	if (mem)
+	    ps2pl_free(mem);
+	kfree(tag);
+	return -ENOMEM;
+    }
+
+    init_dma_dev_request(&lreq->r, &loadimage_ops, devch, qsize, loadimage_free);
+    lreq->mem = mem;
+    lreq->done = NULL;
+
+    p = (u64 *)lreq->tag;
+    *p++ = DMATAG_SET(5, DMATAG_CNT, 0);
+    p++;
+
+    *p++ = PS2_GIFTAG_SET_TOPHALF(4, 0, 0, 0, PS2_GIFTAG_FLG_PACKED, 1);
+    *p++ = 0xe;		/* A+D */
+
+    *p++ = ((u64)(img->fbp & 0x3fff) << 32) |
+	((u64)(img->fbw & 0x3f) << 48) | ((u64)(img->psm & 0x3f) << 56);
+    *p++ = PS2_GS_BITBLTBUF;
+    *p++ = PACK64(0, PACK32(img->x & 0xfff, img->y & 0xfff));
+    *p++ = PS2_GS_TRXPOS;
+    *p++ = PACK64(img->w & 0xfff, img->h & 0xfff);
+    *p++ = PS2_GS_TRXREG;
+    *p++ = 0;
+    *p++ = PS2_GS_TRXDIR;
+
+    dp = tag;
+    while (dp->qwc != 0) {
+	*p++ = DMATAG_SET(1, DMATAG_CNT, 0);
+	p++;
+	*p++ = PS2_GIFTAG_SET_TOPHALF(dp->qwc, 0, 0, 0, PS2_GIFTAG_FLG_IMAGE, 0);
+	*p++ = 0;
+	*((struct dma_tag *)p) = *dp++;
+	p = (void *)(((struct dma_tag *)p) + 1);
+    }
+    *p++ = DMATAG_SET(1, DMATAG_END, 0);
+    p++;
+    *p++ = PS2_GIFTAG_SET_TOPHALF(0, 1, 0, 0, PS2_GIFTAG_FLG_IMAGE, 0);
+    *p++ = 0;
+    kfree(tag);
+    dp = NULL;
+    tag = NULL;
+
+    if (!async)
+	lreq->done = &done;
+
+    result = ps2dma_check_and_add_queue(&lreq->r, 0);
+    if (result < 0) {
+        loadimage_free(&lreq->r.r, ch);
+	return result;
+    }
+
+    if (!async && !done) {
+	DECLARE_WAITQUEUE(wait, current);
+
+	add_wait_queue(&devch->done, &wait);
+	while (1) {
+	    set_current_state(TASK_INTERRUPTIBLE);
+	    if (done || signal_pending(current))
+		break;
+	    schedule();
+	}
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&devch->done, &wait);
+
+	if (signal_pending(current))
+	    result = -ERESTARTNOHAND; /* already queued - don't restart */
+
+	spin_lock_irq(&devch->device->lock);
+	if (!done)
+	    lreq->done = NULL;
+	spin_unlock_irq(&devch->device->lock);
+    }
+    return result;
+}
+
+/*
+ *  storeimage (GS->EE image data transfer)
+ */
+
+struct storeimage_request {
+    struct dma_request r;
+    struct dma_channel *vifch, *gifch;
+    struct page_list *mem;
+    struct completion c;
+    struct timer_list timer;
+    int result;
+    atomic_t count;
+
+    void *hptr;
+    int hlen, hdummy;
+    void *tptr;
+    int tlen, tdummy;
+
+    /* VIFcode for image transfer */
+    u32 vifcode[4] __attribute__((aligned(DMA_TRUNIT)));
+    u64 gspacket[6 * 2] __attribute__((aligned(DMA_TRUNIT)));
+
+    /* DMA tag */
+    struct dma_tag tag[0] __attribute__((aligned(DMA_TRUNIT)));
+} __attribute__((aligned(DMA_TRUNIT)));
+
+struct storeimage_gif_request {
+    struct dma_request r;
+    struct storeimage_request *sreq;
+};
+
+static u32 mask_vifcode[] __attribute__((aligned(DMA_TRUNIT))) = {
+    0x00000000,		/* NOP */
+    0x06008000,		/* MSKPATH3(0x8000, 0) */
+    0x13000000,		/* FLUSHA */
+    0x50000006,		/* DIRECT(6, 0) */
+};
+static u32 unmask_vifcode[] __attribute__((aligned(DMA_TRUNIT))) = {
+    0x06000000,		/* MSKPATH3(0, 0) */
+    0x00000000,		/* NOP */
+    0x00000000,		/* NOP */
+    0x00000000,		/* NOP */
+};
+
+static struct storeimage_request *finish_sreq = NULL;
+
+extern struct dma_channel ps2dma_channels[];
+
+/* internal functions */
+static void storeimage_gif_start(struct dma_request *req, struct dma_channel *ch);
+static void storeimage_vif_start(struct dma_request *req, struct dma_channel *ch);
+static void storeimage_start(struct storeimage_request *sreq);
+
+int ps2gs_storeimage_finish(void);
+static int storeimage_vif_isdone(struct dma_request *req, struct dma_channel *ch);
+static void storeimage_vif_firstpio(struct storeimage_request *sreq);
+
+static int storeimage_vif_nextdma(struct dma_request *req, struct dma_channel *ch);
+
+static inline void storeimage_terminate(struct storeimage_request *sreq, int result);
+static void storeimage_timer_handler(unsigned long ptr);
+
+static void storeimage_vif_free(struct dma_request *req, struct dma_channel *ch);
+static void storeimage_gif_free(struct dma_request *req, struct dma_channel *ch);
+
+static inline int pio_transfer(unsigned char *ptr, int len, int dummy);
+
+/* storeimage operations */
+static struct dma_ops storeimage_gif_ops =
+{ storeimage_gif_start, NULL, NULL, storeimage_gif_free };
+static struct dma_ops storeimage_vif_ops =
+{ storeimage_vif_start, storeimage_vif_isdone, NULL, storeimage_vif_free };
+static struct dma_ops storeimage_vif_ops_dma =
+{ storeimage_vif_start, storeimage_vif_nextdma, NULL, storeimage_vif_free };
+static struct dma_ops storeimage_vif_ops_done =
+{ storeimage_vif_start, NULL, NULL, storeimage_vif_free };
+
+static void storeimage_gif_start(struct dma_request *req, struct dma_channel *ch)
+{
+    struct storeimage_gif_request *gifreq = container_of(req, struct storeimage_gif_request, r);
+
+    DSPRINT("storeimage_gif_start:\n");
+    storeimage_start(gifreq->sreq);
+}
+
+static void storeimage_vif_start(struct dma_request *req, struct dma_channel *ch)
+{
+    struct storeimage_request *sreq = container_of(req, struct storeimage_request, r);
+
+    DSPRINT("storeimage_vif_start:\n");
+    storeimage_start(sreq);
+}
+
+static void storeimage_start(struct storeimage_request *sreq)
+{
+    if (atomic_inc_return(&sreq->count) <= 1)
+	return;
+    DSPRINT("storeimage_start: %08X\n", sreq);
+
+    sreq->timer.expires = jiffies + DMA_TIMEOUT;
+    add_timer(&sreq->timer);
+    WRITEDMAREG(sreq->vifch, PS2_Dn_MADR, virt_to_bus(sreq->vifcode));
+    WRITEDMAREG(sreq->vifch, PS2_Dn_QWC, (sizeof(sreq->vifcode) + sizeof(sreq->gspacket))/ DMA_TRUNIT);
+    finish_sreq = sreq;
+    WRITEDMAREG(sreq->vifch, PS2_Dn_CHCR, CHCR_SENDN);
+}
+
+int ps2gs_storeimage_finish(void)
+{
+    struct storeimage_request *sreq = finish_sreq;
+    DSPRINT("storeimage_finish:\n");
+    if (finish_sreq == NULL)
+	return 0;
+    finish_sreq = NULL;
+    storeimage_vif_firstpio(sreq);
+    return 1;
+}
+
+static int storeimage_vif_isdone(struct dma_request *req, struct dma_channel *ch)
+{
+    struct storeimage_request *sreq = container_of(req, struct storeimage_request, r);
+
+    DSPRINT("storeimage_vif_isdone:\n");
+    sreq->r.ops = &storeimage_vif_ops_dma;
+    storeimage_vif_firstpio(sreq);
+    return 0;
+}
+
+static void storeimage_vif_firstpio(struct storeimage_request *sreq)
+{
+    if (atomic_dec_return(&sreq->count) > 0)
+	return;
+
+    del_timer(&sreq->timer);
+    DSPRINT("storeimage_vif_firstpio:\n");
+    /* switch bus direction (GS -> EE) */
+    SET_VIF1REG(PS2_VIFREG_STAT, 0x00800000);
+    outq(1ULL, GSSREG2(PS2_GSSREG_BUSDIR));
+    __asm__ __volatile__("sync.l":::"memory");
+
+    if (pio_transfer(sreq->hptr, sreq->hlen, sreq->hdummy) != 0) {
+	storeimage_terminate(sreq, -1);
+	return;
+    }
+
+    sreq->vifch->tagp = sreq->tag;
+    storeimage_vif_nextdma(&sreq->r, sreq->vifch);
+}
+
+static int storeimage_vif_nextdma(struct dma_request *req, struct dma_channel *ch)
+{
+    struct storeimage_request *sreq = container_of(req, struct storeimage_request, r);
+
+    del_timer(&sreq->timer);
+    DSPRINT("storeimage_vif_nextdma: %08X\n", ch->tagp);
+    if (ch->tagp != NULL && ch->tagp->qwc > 0) {
+	DSPRINT("storeimage_vif_nextdma: madr=%08X qwc=%d\n", ch->tagp->addr, ch->tagp->qwc);
+	sreq->timer.expires = jiffies + DMA_TIMEOUT;
+	add_timer(&sreq->timer);
+	WRITEDMAREG(ch, PS2_Dn_MADR, ch->tagp->addr);
+	WRITEDMAREG(ch, PS2_Dn_QWC, ch->tagp->qwc);
+	WRITEDMAREG(ch, PS2_Dn_CHCR, CHCR_RECVN);
+	ch->tagp++;
+	return 0;
+    }
+
+    if (pio_transfer(sreq->tptr, sreq->tlen, sreq->tdummy) != 0) {
+	storeimage_terminate(sreq, -1);
+	return 0;
+    }    
+
+    storeimage_terminate(sreq, 0);
+    return 0;
+}
+
+static inline void storeimage_terminate(struct storeimage_request *sreq, int result)
+{
+    struct dma_channel *ch = sreq->vifch;
+    DSPRINT("storeimage_terminate:\n");
+
+    if (result != 0) {
+	sreq->result = -EAGAIN;
+	/* GS,VIF1 FIFO reset */
+	outq(0x100ULL, GSSREG2(PS2_GSSREG_CSR));
+	SET_VIF1REG(PS2_VIFREG_FBRST, 1);
+    }
+
+    /* switch bus direction (EE -> GS) */
+    SET_VIF1REG(PS2_VIFREG_STAT, 0x00000000);
+    outq(0ULL, GSSREG2(PS2_GSSREG_BUSDIR));
+    __asm__ __volatile__("sync.l":::"memory");
+
+    /* send PATH3 unmask VIFcode */
+    sreq->r.ops = &storeimage_vif_ops_done;
+    WRITEDMAREG(ch, PS2_Dn_MADR, virt_to_bus(unmask_vifcode));
+    WRITEDMAREG(ch, PS2_Dn_QWC, sizeof(unmask_vifcode)/ DMA_TRUNIT);
+    WRITEDMAREG(ch, PS2_Dn_CHCR, CHCR_SENDN);
+
+    /* restart GIF DMA */
+    ps2dma_intr_handler(sreq->gifch->irq, sreq->gifch);
+
+    if (result != 0)
+	printk("ps2gs: storeimage timeout\n");
+}
+
+static void storeimage_timer_handler(unsigned long ptr)
+{
+    struct storeimage_request *sreq = (struct storeimage_request *)ptr;
+    struct dma_channel *ch = sreq->vifch;
+
+    finish_sreq = NULL;
+    DSPRINT("storeimage_timer_handler\n");
+
+    /* DMA force break */
+    DMABREAK(ch);
+
+    storeimage_terminate(sreq, -1);
+}
+
+static void storeimage_vif_free(struct dma_request *req, struct dma_channel *ch)
+{
+    struct storeimage_request *sreq = container_of(req, struct storeimage_request, r);
+
+    DSPRINT("storeimage_vif_free:\n");
+    if (sreq->mem)
+	ps2pl_free(sreq->mem);
+    DSPRINT("storeimage_vif_free: wake_up\n");
+    complete(&sreq->c);
+    DSPRINT("storeimage_vif_free: wake_up end\n");
+}
+
+static void storeimage_gif_free(struct dma_request *req, struct dma_channel *ch)
+{
+    DSPRINT("storeimage_gif_free:\n");
+    /* nothing to do */
+}
+
+
+#define VIF1FQC()	(VIF1REG(PS2_VIFREG_STAT) & 0x1f000000)
+#define PIO_TIMEOUT	100000
+
+extern void *ps2spr_vaddr;
+
+/* data transfer with PIO */
+static inline int pio_transfer(unsigned char *ptr, int len, int dummy)
+{
+    unsigned char buf0[128 + DMA_TRUNIT];
+    unsigned char *p, *buf;
+    int i, cnt;
+
+    buf = DMA_ALIGN(&buf0[0]);
+    p = buf;
+    i = len;
+
+    while (i > 0) {
+	cnt = 0;
+        /* wait for VIF1 FIFO fill */
+        while (VIF1FQC() == 0) {
+	    if (cnt++ > PIO_TIMEOUT) {
+		DSPRINT("storeimage_pio_transfer: data left = %d\n", i);
+		return -1;
+	    }
+        }
+        move_quad((unsigned long)p, KSEG1ADDR(VIF1_FIFO));
+	p += DMA_TRUNIT;
+	i -= DMA_TRUNIT;
+    }
+    while (dummy > 0) {
+	cnt = 0;
+        /* wait for VIF1 FIFO fill */
+        while (VIF1FQC() == 0) {
+	    if (cnt++ > PIO_TIMEOUT) {
+		DSPRINT("storeimage_pio_transfer: dummy left = %d\n", dummy);
+		return -1;
+	    }
+        }
+        dummy_read_quad(KSEG1ADDR(VIF1_FIFO));
+	dummy--;
+    }
+    if (len) {
+	if ((unsigned long)ptr >= 0x80000000 + SPR_SIZE) {
+	    memcpy(ptr, buf, len);
+	} else {		/* copy to scratchpad RAM */
+	    memcpy(ps2spr_vaddr + ((unsigned long)ptr & (SPR_SIZE - 1)),
+		   buf, len);
+	}
+    }
+    return 0;
+}
+
+int ps2gs_storeimage(struct ps2_image *img, struct dma_device *dev)
+{
+    struct storeimage_gif_request gifreq;
+    struct storeimage_request *sreq;
+    struct dma_channel *gifch = dev->devch[DMA_SENDCH].channel;
+    struct dma_channel *vifch = &ps2dma_channels[DMA_VIF1];
+
+    struct dma_tag *tag, *dp, *tp;
+    struct page_list *recv_mem = NULL;
+    int result;
+
+    int size;
+    int mask, a, tfrlen;
+    int bpl;		/* bytes per line */
+    int hlen;		/* PIO tfr size before DMA */
+    int hdummy;		/* dummy tfr size (qword) */
+    int dlen;		/* DMA tfr size (8qword aligned) */
+    int tlen;		/* PIO tfr size after DMA */
+    int tdummy;		/* dummy tfr size (qword) */
+    void *hptr, *tptr;
+    u64 *p;
+
+    /* get image size */
+    switch (img->psm) {
+    case PS2_GS_PSMCT32:
+    case PS2_GS_PSMZ32:
+	bpl = img->w << 2;
+	break;
+    case PS2_GS_PSMCT24:
+    case PS2_GS_PSMZ24:
+	bpl = img->w * 3;
+	break;
+    case PS2_GS_PSMCT16:
+    case PS2_GS_PSMCT16S:
+    case PS2_GS_PSMZ16:
+    case PS2_GS_PSMZ16S:
+	bpl = img->w << 1;
+	break;
+    case PS2_GS_PSMT8:
+    case PS2_GS_PSMT8H:
+	if (img->x % 2 || img->w % 2)
+	    return -EINVAL;		/* invalid alignment */
+	bpl = img->w;
+	break;
+    case PS2_GS_PSMT4:
+    case PS2_GS_PSMT4HL:
+    case PS2_GS_PSMT4HH:
+	if (img->x % 4 || img->w % 4)
+	    return -EINVAL;		/* invalid alignment */
+	bpl = img->w >> 1;
+	break;
+    default:
+	return -EINVAL;
+    }
+    size = bpl * img->h;
+    if (size == 0)
+	return -EINVAL;
+
+    DSPRINT("storeimage: %d x %d  %08X (%d,%d)\n", img->w, img->h, img->ptr, img->x, img->y);
+
+    if (img->fbp & ~0x3fff) {
+	return -EINVAL;
+    }
+
+    if (img->fbw & ~0x3f) {
+	return -EINVAL;
+    }
+
+    /* make DMA tags (including PIO transferred area) */
+    switch (result = ps2dma_make_tag((unsigned long)img->ptr, DMA_ALIGN(size), &tag, NULL, &recv_mem)) {
+    case BUFTYPE_MEM:
+    case BUFTYPE_SPR:
+    case BUFTYPE_USER:
+	hptr = bus_to_virt(tag[0].addr);
+	break;
+    default:
+	return result;
+    }
+    DSPRINT("storeimage: hptr = %08X\n", hptr);
+    if (recv_mem) { DSPRINT("storeimage: USER: %08X\n", recv_mem->page[0]); }
+
+    /* get the size of PIO transferred area before/after DMA */
+    hlen = DMA_ALIGN_IMG(hptr) - hptr;
+    hlen = size > hlen ? hlen : size;
+    tlen = (size - hlen) & (DMA_TRUNIT_IMG - 1);
+    dlen = (size - hlen) & ~(DMA_TRUNIT_IMG - 1);
+    hdummy = tdummy = 0;
+    if (tlen != 0 || dlen == 0) {
+	mask = 15;
+	for (a = bpl; (a % 2) == 0; a >>= 1)
+	    if ((mask >>= 1) == 0)
+		break;
+	img->h = (img->h + mask) & ~mask;
+	tfrlen = bpl * img->h;
+	if (tlen == 0)
+	    hdummy = (tfrlen - hlen) >> 4;
+	else
+	    tdummy = (tfrlen - dlen - hlen - tlen) >> 4;
+    }
+
+    DSPRINT("hlen=%d hdummy=%d dlen=%d tlen=%d tdummy=%d\n", hlen, hdummy, dlen, tlen, tdummy);
+    DSPRINT("%d x %d\n", img->w, img->h);
+
+    sreq = kmalloc(sizeof(struct storeimage_request) +
+			((size >> PAGE_SHIFT) + 3) * DMA_TRUNIT, GFP_KERNEL);
+    if ((sreq != NULL) && ((((unsigned long)&sreq->tag) & (DMA_TRUNIT - 1)) != 0)) {
+        kfree(sreq);
+        sreq = NULL;
+        printk(KERN_ERR "ps2gs_storeimage: sreq->tag is not DMA aligned.\n");
+    }
+    if (sreq == NULL) {
+	if (recv_mem)
+	    ps2pl_free(recv_mem);
+	kfree(tag);
+	return -ENOMEM;
+    }
+    memset(sreq, 0, sizeof(struct storeimage_request));
+
+    /* exclude PIO area from the tags */
+    dp = tag;
+    tp = sreq->tag;
+
+    dp->addr += hlen;		/* exclude PIO before DMA */
+    dp->qwc -= hlen >> 4;
+    if (dp->qwc == 0)
+	dp++;			/* all of the first tag is processed by PIO */
+
+    if (dp->qwc == 0) {
+	tptr = hptr + hlen;	/* no DMA transfer */
+    } else {
+	while (dp->qwc != 0)	/* copy tags */
+	    *tp++ = *dp++;
+	tp--;
+	tp->qwc -= (tlen + 15) >> 4;	/* exclude PIO after DMA */
+	tptr = bus_to_virt(tp->addr + (tp->qwc << 4));
+	if (tp->qwc)
+	    tp++;
+    }
+
+    tp->id = DMATAG_END;
+    tp->qwc = 0;		/* end of the tags */
+    tp++;
+    kfree(tag);
+    tag = NULL;
+    dp = NULL;
+
+    init_dma_request(&gifreq.r, &storeimage_gif_ops);
+    gifreq.sreq = sreq;
+
+    init_dma_request(&sreq->r, &storeimage_vif_ops);
+    init_completion(&sreq->c);
+    sreq->result = 0;
+    sreq->vifch = vifch;
+    sreq->gifch = gifch;
+    sreq->hptr = hptr;
+    sreq->hlen = hlen;
+    sreq->hdummy = hdummy;
+    sreq->tptr = tptr;
+    sreq->tlen = tlen;
+    sreq->tdummy = tdummy;
+    atomic_set(&sreq->count, 0);
+    
+    init_timer(&sreq->timer);
+    sreq->timer.function = storeimage_timer_handler;
+    sreq->timer.data = (unsigned long)sreq;
+
+    move_quad((unsigned long)sreq->vifcode, (unsigned long)mask_vifcode);
+    p = sreq->gspacket;
+    *p++ = PS2_GIFTAG_SET_TOPHALF(5, 1, 0, 0, PS2_GIFTAG_FLG_PACKED, 1);
+    *p++ = 0xe;		/* A+D */
+    
+    *p++ = ((u64)(img->fbp & 0x3fff) << 0) |
+	((u64)(img->fbw & 0x3f) << 16) | ((u64)(img->psm & 0x3f) << 24);
+    *p++ = PS2_GS_BITBLTBUF;
+    *p++ = PACK64(PACK32(img->x & 0xfff, img->y & 0xfff), 0);
+    *p++ = PS2_GS_TRXPOS;
+    *p++ = PACK64(img->w & 0xfff, img->h & 0xfff);
+    *p++ = PS2_GS_TRXREG;
+    *p++ = 0;
+    *p++ = PS2_GS_FINISH;
+    *p++ = 1;
+    *p++ = PS2_GS_TRXDIR;
+
+    ps2dma_add_queue(&gifreq.r, gifch, 1);
+    ps2dma_add_queue(&sreq->r, vifch, 1);
+    DSPRINT("storeimage: sleep_on\n");
+    wait_for_completion(&sreq->c);
+    DSPRINT("storeimage: sleep_on end\n");
+
+    result = sreq->result;
+    kfree(sreq);
+    if (recv_mem) {
+	if (result == 0)
+	    result = ps2pl_copy_to_user(img->ptr, recv_mem, size);
+	ps2pl_free(recv_mem);
+    }
+    return result;
+}
diff -purN linux-2.6.35.4-orig/arch/mips/ps2/ps2mem.c linux-2.6.35.4/arch/mips/ps2/ps2mem.c
--- linux-2.6.35.4-orig/arch/mips/ps2/ps2mem.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/ps2/ps2mem.c	2014-07-18 22:29:43.554367724 +0200
@@ -0,0 +1,156 @@
+/*
+ *  PlayStation 2 DMA buffer memory allocation interface (/dev/ps2mem)
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/mm.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/mman.h>
+#include <linux/fs.h>
+#include <linux/ps2/dev.h>
+
+#include <asm/uaccess.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <asm/io.h>
+#include <asm/addrspace.h>
+
+#include <asm/mach-ps2/dma.h>
+
+#include "ps2dev.h"
+
+struct vm_area_struct *ps2mem_vma_cache = NULL;
+
+static int ps2mem_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
+{
+    struct page_list *list, *newlist;
+    struct page *page;
+
+    ps2mem_vma_cache = NULL;
+    list = vma->vm_file->private_data;
+    if (list == NULL) {
+        return VM_FAULT_SIGBUS; /* no memory - SIGBUS */
+    }
+    if (list->pages <= vmf->pgoff) {
+	/* access to unallocated area - extend buffer */
+	if ((newlist = ps2pl_realloc(list, vmf->pgoff + 1)) == NULL)
+	    return VM_FAULT_SIGBUS; /* no memory - SIGBUS */
+	list = vma->vm_file->private_data = newlist;
+    }
+    page = list->page[vmf->pgoff];
+    get_page(page);	/* increment page count */
+    vmf->page = page;
+
+    return 0; /* success */
+}
+
+static struct vm_operations_struct ps2mem_vmops = {
+    fault:	ps2mem_fault,
+};
+
+static int ps2mem_open(struct inode *inode, struct file *file)
+{
+    ps2mem_vma_cache = NULL;
+    file->private_data = NULL;
+    return 0;
+}
+
+static int ps2mem_release(struct inode *inode, struct file *file)
+{
+    ps2mem_vma_cache = NULL;
+    if (file->private_data)
+	ps2pl_free((struct page_list *)file->private_data);
+    return 0;
+}
+
+static int ps2mem_mmap(struct file *file, struct vm_area_struct *vma)
+{
+    struct page_list *list, *newlist;
+    int pages;
+
+    if (file->f_flags & O_SYNC)
+	pgprot_val(vma->vm_page_prot) = (pgprot_val(vma->vm_page_prot) & ~_CACHE_MASK) | _CACHE_UNCACHED;
+
+    ps2mem_vma_cache = NULL;
+
+    pages = (vma->vm_end - vma->vm_start) >> PAGE_SHIFT;
+    pages += vma->vm_pgoff;
+    if (file->private_data == NULL) {
+	/* 1st mmap ... allocate buffer */
+	if ((list = ps2pl_alloc(pages)) == NULL)
+	    return -ENOMEM;
+	file->private_data = list;
+    } else {
+	list = (struct page_list *)file->private_data;
+	if (list->pages < pages) {		/* extend buffer */
+	    if ((newlist = ps2pl_realloc(list, pages)) == NULL)
+		return -ENOMEM;
+	    file->private_data = newlist;
+	}	
+    }
+
+    vma->vm_flags |= VM_CAN_NONLINEAR;
+    vma->vm_flags |= VM_IO;
+    vma->vm_ops = &ps2mem_vmops;
+    return 0;
+}
+
+static int ps2mem_ioctl(struct inode *inode, struct file *file,
+			unsigned int cmd, unsigned long arg)
+{
+    struct page_list *list = (struct page_list *)file->private_data;
+    unsigned long phys;
+    unsigned long *dest;
+    int i;
+
+    switch (cmd) {
+    case PS2IOC_PHYSADDR:
+	if (list == NULL)
+	    return 0;			/* buffer is not allocated */
+
+	dest = (unsigned long *)arg;
+	if (dest == NULL)		/* get the number of pages */
+	    return list->pages;
+
+	/* get a physical address table */
+	for (i = 0; i < list->pages; i++) {
+	    phys = page_to_phys(list->page[i]);
+	    if (copy_to_user(dest, &phys, sizeof(phys)) != 0)
+		return -EFAULT;
+	    dest++;
+	}
+	return 0;
+    default:
+	return -EINVAL;
+    }
+
+    return 0;
+}
+
+struct file_operations ps2mem_fops = {
+    llseek:	no_llseek,
+    ioctl:	ps2mem_ioctl,
+    mmap:	ps2mem_mmap,
+    open:	ps2mem_open,
+    release:	ps2mem_release,
+};
diff -purN linux-2.6.35.4-orig/arch/mips/ps2/rtc.c linux-2.6.35.4/arch/mips/ps2/rtc.c
--- linux-2.6.35.4-orig/arch/mips/ps2/rtc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/ps2/rtc.c	2014-07-18 22:29:43.554367724 +0200
@@ -0,0 +1,34 @@
+/*
+ *  PlayStation 2 time and rtc routines.
+ *
+ *  Copyright (C) 2011-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+
+int __init ps2rtc_init(void)
+{
+	struct platform_device *pdev;
+
+	/* Register PS2 RTC driver. */
+	pdev = platform_device_register_simple("rtc-ps2", -1, NULL, 0);
+	if (IS_ERR(pdev))
+		return PTR_ERR(pdev);
+
+	return 0;
+}
diff -purN linux-2.6.35.4-orig/arch/mips/ps2/sbcall.c linux-2.6.35.4/arch/mips/ps2/sbcall.c
--- linux-2.6.35.4-orig/arch/mips/ps2/sbcall.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/ps2/sbcall.c	2014-07-18 22:29:43.554367724 +0200
@@ -0,0 +1,435 @@
+/*
+ *  PlayStation 2 SBIOS support routines
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2011-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/module.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+
+#include <asm/io.h>
+
+#include <asm/mach-ps2/ps2.h>
+#include <asm/mach-ps2/irq.h>
+#include <asm/mach-ps2/sifdefs.h>
+#include <asm/mach-ps2/sbios.h>
+
+static wait_queue_head_t ps2sif_dma_waitq;
+static spinlock_t ps2sif_dma_lock = SPIN_LOCK_UNLOCKED;
+
+EXPORT_SYMBOL(sbios_rpc);
+EXPORT_SYMBOL(ps2sif_setdma);
+EXPORT_SYMBOL(ps2sif_dmastat);
+EXPORT_SYMBOL(__ps2sif_setdma_wait);
+EXPORT_SYMBOL(__ps2sif_dmastat_wait);
+EXPORT_SYMBOL(ps2sif_writebackdcache);
+
+EXPORT_SYMBOL(ps2sif_bindrpc);
+EXPORT_SYMBOL(ps2sif_callrpc);
+EXPORT_SYMBOL(ps2sif_checkstatrpc);
+EXPORT_SYMBOL(ps2sif_setrpcqueue);
+EXPORT_SYMBOL(ps2sif_getnextrequest);
+EXPORT_SYMBOL(ps2sif_execrequest);
+EXPORT_SYMBOL(ps2sif_registerrpc);
+EXPORT_SYMBOL(ps2sif_getotherdata);
+EXPORT_SYMBOL(ps2sif_removerpc);
+EXPORT_SYMBOL(ps2sif_removerpcqueue);
+
+typedef struct t_SifCmdHeader
+{
+	u32 size;
+	ps2_addr_t dest;
+	int cid;
+	u32 unknown;
+} SifCmdHeader_t;
+
+/*
+ *  SIF DMA functions
+ */
+
+unsigned int ps2sif_setdma(ps2sif_dmadata_t *sdd, int len)
+{
+    struct sb_sifsetdma_arg arg;
+    arg.sdd = sdd;
+    arg.len = len;
+    return sbios(SB_SIFSETDMA, &arg);
+}
+
+int ps2sif_dmastat(unsigned int id)
+{
+    struct sb_sifdmastat_arg arg;
+    arg.id = id;
+    return sbios(SB_SIFDMASTAT, &arg);
+}
+
+#define WAIT_DMA(cond, state)						\
+    do {								\
+	unsigned long flags;						\
+	wait_queue_t wait;						\
+									\
+	init_waitqueue_entry(&wait, current);				\
+									\
+	spin_lock_irqsave(&ps2sif_dma_lock, flags);			\
+	add_wait_queue(&ps2sif_dma_waitq, &wait);			\
+	while (cond) {							\
+	    set_current_state(state);					\
+	    spin_unlock_irq(&ps2sif_dma_lock);				\
+	    schedule();							\
+	    spin_lock_irq(&ps2sif_dma_lock);				\
+	    if(signal_pending(current) && state == TASK_INTERRUPTIBLE)	\
+		break;							\
+	}								\
+	remove_wait_queue(&ps2sif_dma_waitq, &wait);			\
+	spin_unlock_irqrestore(&ps2sif_dma_lock, flags);		\
+    } while (0)
+
+unsigned int __ps2sif_setdma_wait(ps2sif_dmadata_t *sdd, int len, long state)
+{
+    int res;
+    struct sb_sifsetdma_arg arg;
+
+    arg.sdd = sdd;
+    arg.len = len;
+
+    WAIT_DMA(((res = sbios(SB_SIFSETDMA, &arg)) == 0), state);
+
+    return (res);
+}
+
+int __ps2sif_dmastat_wait(unsigned int id, long state)
+{
+    int res;
+    struct sb_sifdmastat_arg arg;
+
+    arg.id = id;
+    WAIT_DMA((0 <= (res = sbios(SB_SIFDMASTAT, &arg))), state);
+
+    return (res);
+}
+
+void ps2sif_writebackdcache(void *addr, int size)
+{
+    dma_cache_wback_inv((unsigned long)addr, size);
+}
+
+
+/*
+ *  SIF RPC functions
+ */
+
+int ps2sif_getotherdata(ps2sif_receivedata_t *rd, void *src, void *dest, int size, unsigned int mode, ps2sif_endfunc_t func, void *para)
+{
+    struct sb_sifgetotherdata_arg arg;
+    arg.rd = rd;
+    arg.src = src;
+    arg.dest = dest;
+    arg.size = size;
+    arg.mode = mode;
+    arg.func = func;
+    arg.para = para;
+    return sbios(SB_SIFGETOTHERDATA, &arg);
+}
+
+int ps2sif_bindrpc(ps2sif_clientdata_t *bd, unsigned int command, unsigned int mode, ps2sif_endfunc_t func, void *para)
+{
+    struct sb_sifbindrpc_arg arg;
+    arg.bd = bd;
+    arg.command = command;
+    arg.mode = mode;
+    arg.func = func;
+    arg.para = para;
+    return sbios(SB_SIFBINDRPC, &arg);
+}
+
+int ps2sif_callrpc(ps2sif_clientdata_t *bd, unsigned int fno, unsigned int mode, void *send, int ssize, void *receive, int rsize, ps2sif_endfunc_t func, void *para)
+{
+    struct sb_sifcallrpc_arg arg;
+    arg.bd = bd;
+    arg.fno = fno;
+    arg.mode = mode;
+    arg.send = send;
+    arg.ssize = ssize;
+    arg.receive = receive;
+    arg.rsize = rsize;
+    arg.func = func;
+    arg.para = para;
+    return sbios(SB_SIFCALLRPC, &arg);
+}
+
+int ps2sif_checkstatrpc(ps2sif_rpcdata_t *cd)
+{
+    struct sb_sifcheckstatrpc_arg arg;
+    arg.cd = cd;
+    return sbios(SB_SIFCHECKSTATRPC, &arg);
+}
+
+void ps2sif_setrpcqueue(ps2sif_queuedata_t *pSrqd, void (*callback)(void*), void *aarg)
+{
+    struct sb_sifsetrpcqueue_arg arg;
+    arg.pSrqd = pSrqd;
+    arg.callback = callback;
+    arg.arg = aarg;
+    sbios(SB_SIFSETRPCQUEUE, &arg);
+}
+
+void ps2sif_registerrpc(ps2sif_servedata_t *pr, unsigned int command,
+			ps2sif_rpcfunc_t func, void *buff,
+			ps2sif_rpcfunc_t cfunc, void *cbuff,
+			ps2sif_queuedata_t *pq)
+{
+    struct sb_sifregisterrpc_arg arg;
+    arg.pr = pr;
+    arg.command = command;
+    arg.func = func;
+    arg.buff = buff;
+    arg.cfunc = cfunc;
+    arg.cbuff = cbuff;
+    arg.pq = pq;
+    sbios(SB_SIFREGISTERRPC, &arg);
+}
+
+ps2sif_servedata_t *ps2sif_removerpc(ps2sif_servedata_t *pr, ps2sif_queuedata_t *pq)
+{
+    struct sb_sifremoverpc_arg arg;
+    arg.pr = pr;
+    arg.pq = pq;
+    return (ps2sif_servedata_t *)sbios(SB_SIFREMOVERPC, &arg);
+}
+
+ps2sif_queuedata_t *ps2sif_removerpcqueue(ps2sif_queuedata_t *pSrqd)
+{
+    struct sb_sifremoverpcqueue_arg arg;
+    arg.pSrqd = pSrqd;
+    return (ps2sif_queuedata_t *)sbios(SB_SIFREMOVERPCQUEUE, &arg);
+}
+
+ps2sif_servedata_t *ps2sif_getnextrequest(ps2sif_queuedata_t *qd)
+{
+    struct sb_sifgetnextrequest_arg arg;
+    arg.qd = qd;
+    return (ps2sif_servedata_t *)sbios(SB_SIFGETNEXTREQUEST, &arg);
+}
+
+void ps2sif_execrequest(ps2sif_servedata_t *rdp)
+{
+    struct sb_sifexecrequest_arg arg;
+    arg.rdp = rdp;
+    sbios(SB_SIFEXECREQUEST, &arg);
+}
+
+
+/*
+ *  SBIOS blocking RPC function
+ */
+
+struct rpc_wait_queue {
+    wait_queue_head_t wq;
+    volatile int woken;
+    spinlock_t lock;
+};
+
+static void rpc_wakeup(void *p, int result)
+{
+    struct rpc_wait_queue *rwq = (struct rpc_wait_queue *)p;
+	unsigned long flags;
+
+    spin_lock_irqsave(&rwq->lock, flags);
+    rwq->woken = 1;
+    wake_up(&rwq->wq);
+    spin_unlock_irqrestore(&rwq->lock, flags);
+}
+
+int sbios_rpc(int func, void *arg, int *result)
+{
+    int ret;
+    unsigned long flags;
+    struct rpc_wait_queue rwq;
+    struct sbr_common_arg carg;
+    DECLARE_WAITQUEUE(wait, current);
+
+    carg.arg = arg;
+    carg.func = rpc_wakeup;
+    carg.para = &rwq;
+
+    init_waitqueue_head(&rwq.wq);
+    rwq.woken = 0;
+    spin_lock_init(&rwq.lock);
+
+    /*
+     * invoke RPC
+     */
+    do {
+	ret = sbios(func, &carg);
+	switch (ret) {
+	case 0:
+	    break;
+	case -SIF_RPCE_SENDP:
+	    /* resouce temporarily unavailable */
+	    break;
+	default:
+	    /* ret == -SIF_PRCE_GETP (=1) */
+	    *result = ret;
+	    printk("sbios_rpc: RPC failed, func=%d result=%d\n", func, ret);
+	    return ret;
+	}
+    } while (ret < 0);
+
+    /*
+     * wait for result
+     */
+    spin_lock_irqsave(&rwq.lock, flags);
+    add_wait_queue(&rwq.wq, &wait);
+    while (!rwq.woken) {
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	spin_unlock_irq(&rwq.lock);
+	schedule();
+	spin_lock_irq(&rwq.lock);
+    }
+    remove_wait_queue(&ps2sif_dma_waitq, &wait);
+    spin_unlock_irqrestore(&rwq.lock, flags);
+
+    *result = carg.result;
+
+    return 0;
+}
+
+
+/*
+ *  Miscellaneous functions
+ */
+
+void ps2_halt(int mode)
+{
+    struct sb_halt_arg arg;
+    arg.mode = mode;
+    sbios(SB_HALT, &arg);
+}
+
+
+/*
+ *  SIF interrupt handler
+ */
+static irqreturn_t sif0_dma_handler(int irq, void *dev_id)
+{
+    sbios(SB_SIFCMDINTRHDLR, 0);
+    return IRQ_HANDLED;
+}
+
+static irqreturn_t sif1_dma_handler(int irq, void *dev_id)
+{
+    spin_lock(&ps2sif_dma_lock);
+    wake_up(&ps2sif_dma_waitq);
+    spin_unlock(&ps2sif_dma_lock);
+    return IRQ_HANDLED;
+}
+
+static uint32_t usrCmdHandler[256];
+
+typedef struct {
+	struct t_SifCmdHeader    sifcmd;
+	u32 data[16];
+} iop_sifCmdBufferIrq_t;
+
+void handleRPCIRQ(iop_sifCmdBufferIrq_t *sifCmdBufferIrq, void *arg)
+{
+	do_IRQ(sifCmdBufferIrq->data[0]);
+}
+
+static void handleRPCPowerBtn(iop_sifCmdBufferIrq_t *sifCmdBufferIrq, void *arg)
+{
+	/* give a SIGPWR signal to init proc */
+	kill_cad_pid(SIGPWR, 0);
+}
+
+
+/*
+ *  Initialize
+ */
+
+int __init ps2sif_init(void)
+{
+    struct sb_sifsetcmdbuffer_arg setcmdhandlerbufferparam;
+
+    init_waitqueue_head(&ps2sif_dma_waitq);
+
+    setcmdhandlerbufferparam.db = usrCmdHandler;
+    setcmdhandlerbufferparam.size = sizeof(usrCmdHandler) / 8;
+
+    if (sbios(SB_SIFINIT, 0) < 0) {
+	printk(KERN_ERR "ps2sif: SIF init failed.\n");
+	return -1;
+    }
+    if (sbios(SB_SIFINITCMD, 0) < 0) {
+	printk(KERN_ERR "ps2sif: SIF CMD init failed.\n");
+	return -1;
+    }
+    if (request_irq(IRQ_DMAC_5, sif0_dma_handler, 0, "SIF0 DMA", NULL)) {
+	printk(KERN_ERR "ps2sif: Failed to setup SIF0 handler.\n");
+	return -1;
+    }
+    if (request_irq(IRQ_DMAC_6, sif1_dma_handler, 0, "SIF1 DMA", NULL)) {
+	printk(KERN_ERR "ps2sif: Failed to setup SIF1 handler.\n");
+	return -1;
+    }
+    if (sbios(SB_SIFSETCMDBUFFER, &setcmdhandlerbufferparam) < 0) {
+        printk("Failed to initialize EEDEBUG handler (1).\n");
+    } else {
+    	struct sb_sifaddcmdhandler_arg addcmdhandlerparam;
+
+    	addcmdhandlerparam.fid = 0x20;
+    	addcmdhandlerparam.func = handleRPCIRQ;
+    	addcmdhandlerparam.data = NULL;
+
+        if (sbios(SB_SIFADDCMDHANDLER, &addcmdhandlerparam) < 0) {
+            printk("Failed to initialize SIF IRQ handler.\n");
+        }
+
+    	addcmdhandlerparam.fid = 20;
+    	addcmdhandlerparam.func = handleRPCPowerBtn;
+    	addcmdhandlerparam.data = NULL;
+
+        if (sbios(SB_SIFADDCMDHANDLER, &addcmdhandlerparam) < 0) {
+            printk("Failed to initialize SIF power button handler.\n");
+        }
+    }
+    if (sbios(SB_SIFINITRPC, 0) < 0) {
+	printk(KERN_ERR "ps2sif: SIF init RPC failed.\n");
+	return -1;
+    }
+
+    if (ps2sif_initiopheap() < 0) {
+	printk(KERN_ERR "ps2sif: init IOP heap failed.\n");
+	return -1;
+    }
+    printk(KERN_INFO "ps2sif: SIF initialized.\n");
+
+    return 0;
+}
+
+void ps2sif_exit(void)
+{
+    sbios(SB_SIFEXITRPC, 0);
+    sbios(SB_SIFEXITCMD, 0);
+    free_irq(IRQ_DMAC_5, NULL);
+    sbios(SB_SIFEXIT, 0);
+    /* TBD: Test exit. */
+    free_irq(IRQ_DMAC_6, NULL);
+}
diff -purN linux-2.6.35.4-orig/arch/mips/ps2/sbios.c linux-2.6.35.4/arch/mips/ps2/sbios.c
--- linux-2.6.35.4-orig/arch/mips/ps2/sbios.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/ps2/sbios.c	2014-07-18 22:29:43.554367724 +0200
@@ -0,0 +1,37 @@
+/*
+ *  PlayStation 2 SBIOS call
+ *
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+
+#include <asm/mach-ps2/sbios.h>
+
+#define SBIOS_BASE  0x80001000
+
+typedef int (sbios_t) (int sbcall, void *arg);
+
+EXPORT_SYMBOL(sbios);
+
+int sbios(int sbcall, void *arg)
+{
+	sbios_t *ps2_sbios;
+
+	ps2_sbios = *((sbios_t **) SBIOS_BASE);
+
+	return ps2_sbios(sbcall, arg);
+}
diff -purN linux-2.6.35.4-orig/arch/mips/ps2/sbios-console.c linux-2.6.35.4/arch/mips/ps2/sbios-console.c
--- linux-2.6.35.4-orig/arch/mips/ps2/sbios-console.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/ps2/sbios-console.c	2014-07-18 22:29:43.554367724 +0200
@@ -0,0 +1,58 @@
+/*
+ *  PlayStation 2 SBIOS console
+ *
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/console.h>
+#include <linux/init.h>
+#include <linux/string.h>
+
+#include <asm/mach-ps2/ps2.h>
+#include <asm/mach-ps2/sbios.h>
+
+void prom_putchar(char c)
+{
+	struct sb_putchar_arg putc_arg;
+
+	putc_arg.c = c;
+	sbios(SB_PUTCHAR, &putc_arg);
+}
+
+int ps2_printf(const char *fmt, ...)
+{
+	char buffer[80];
+	va_list args;
+	int r;
+	int i;
+
+	va_start(args, fmt);
+	r = vsnprintf(buffer, sizeof(buffer), fmt, args);
+	va_end(args);
+	r = strnlen(buffer, sizeof(buffer));
+	for (i = 0; i < r; i++) {
+		prom_putchar(buffer[i]);
+	}
+	if (r >= (sizeof(buffer) - 1)) {
+		/* Add carriage return if buffer was too small. */
+		prom_putchar('.');
+		prom_putchar('.');
+		prom_putchar('.');
+		prom_putchar('\n');
+	}
+	return r;
+}
diff -purN linux-2.6.35.4-orig/arch/mips/ps2/setup.c linux-2.6.35.4/arch/mips/ps2/setup.c
--- linux-2.6.35.4-orig/arch/mips/ps2/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/ps2/setup.c	2014-07-18 22:29:43.554367724 +0200
@@ -0,0 +1,191 @@
+/*
+ *  PlayStation 2 system setup functions.
+ *
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/console.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/param.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/types.h>
+#include <linux/pm.h>
+#include <linux/platform_device.h>
+
+#include <asm/bootinfo.h>
+#include <asm/reboot.h>
+
+#include <asm/mach-ps2/ps2.h>
+#include <asm/mach-ps2/dma.h>
+#include <asm/mach-ps2/sifdefs.h>
+#include <asm/mach-ps2/sbios.h>
+
+void (*__wbflush)(void);
+
+EXPORT_SYMBOL(__wbflush);
+
+static struct resource usb_ohci_resources[] = {
+	[0] = {
+		.start	= 0xbf801600,
+		.end	= 0xbf801700,
+		/* OHCI needs IO memory. */
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_SBUS_USB,
+		.end	= IRQ_SBUS_USB,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static u64 usb_ohci_dma_mask = 0xffffffffUL;
+static struct platform_device usb_ohci_device = {
+	.name		= "ps2_ohci",
+	.id		= -1,
+	.dev = {
+		/* DMA memory is allocated from IOP heap. */
+		.dma_mask		= &usb_ohci_dma_mask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(usb_ohci_resources),
+	.resource	= usb_ohci_resources,
+};
+
+static struct platform_device smap_device = {
+	.name           = "ps2smap",
+};
+
+static struct platform_device smaprpc_device = {
+	.name           = "ps2smaprpc",
+};
+
+static struct platform_device gs_device = {
+	.name           = "ps2fb",
+};
+
+static unsigned int ps2_blink_frequency = 500;
+module_param_named(panicblink, ps2_blink_frequency, uint, 0600);
+MODULE_PARM_DESC(panicblink, "Frequency with which the PS2 HDD should blink when kernel panics");
+
+static void ps2_wbflush(void)
+{
+	__asm__ __volatile__("sync.l":::"memory");
+
+	/* flush write buffer to bus */
+	inl(ps2sif_bustophys(0));
+}
+
+static void ps2_machine_restart(char *command)
+{
+	ps2_halt(SB_HALT_MODE_RESTART);
+}
+
+static void ps2_machine_halt(void)
+{
+	ps2_halt(SB_HALT_MODE_HALT);
+}
+
+static void ps2_machine_off(void)
+{
+	ps2_halt(SB_HALT_MODE_PWROFF);
+}
+
+static long ps2_panic_blink(long count)
+{
+	static long last_blink;
+	static int powerbtn_enabled = 0;
+
+	if (!powerbtn_enabled) {
+		powerbtn_enabled = 1;
+
+		/* Enable power button, because init will not handle any signals. */
+		ps2_powerbutton_enable_auto_shutoff(-1);
+	}
+
+	/*
+	 * We expect frequency to be about 1/2s. KDB uses about 1s.
+	 * Make sure they are different.
+	 */
+	if (!ps2_blink_frequency)
+		return 0;
+	if (count - last_blink < ps2_blink_frequency)
+		return 0;
+
+	/* TBD: Blink HDD led of fat PS2. */
+	return 0;
+}
+
+void __init plat_mem_setup(void)
+{
+	_machine_restart = ps2_machine_restart;
+	_machine_halt = ps2_machine_halt;
+	pm_power_off = ps2_machine_off;
+	panic_blink = ps2_panic_blink;
+
+	__wbflush = ps2_wbflush;
+
+	/* IO port (out and in functions). */
+	ioport_resource.start = 0x10000000;
+	ioport_resource.end   = 0x1FFFFFFF;
+
+	/* IO memory. */
+	iomem_resource.start = 0x00000000;
+	iomem_resource.end   = KSEG2 - 1;
+
+	/* Memory for exception vectors. */
+	add_memory_region(0x00000000, 0x00001000, BOOT_MEM_RAM);
+	/* Reserved for SBIOS. */
+	add_memory_region(0x00001000, 0x0000F000, BOOT_MEM_RESERVED);
+	/* Free memory. */
+	add_memory_region(0x00010000, 0x01ff0000, BOOT_MEM_RAM);
+
+	/* Set base address of outb()/outw()/outl()/outq()/
+	 * inb()/inw()/inl()/inq().
+	 * This memory region is uncached.
+	 */
+	set_io_port_base(CKSEG1);
+
+#ifdef CONFIG_SERIAL_PS2_SBIOS_DEFAULT
+	/* Use PS2 SBIOS as default console. */
+	add_preferred_console(PS2_SBIOS_SERIAL_DEVICE_NAME, 0, NULL);
+#endif
+}
+
+void ps2_dev_init(void)
+{
+	ps2dma_init();
+	ps2sif_init();
+	ps2rtc_init();
+	ps2_powerbutton_init();
+	platform_device_register(&usb_ohci_device);
+
+	switch (ps2_pccard_present) {
+	case 0x0100:
+		platform_device_register(&smap_device);
+		break;
+	case 0x0200:
+		platform_device_register(&smaprpc_device);
+		break;
+	default:
+		printk("No SMAP network device found.");
+		break;
+	}
+	platform_device_register(&gs_device);
+}
diff -purN linux-2.6.35.4-orig/arch/mips/ps2/siflock.c linux-2.6.35.4/arch/mips/ps2/siflock.c
--- linux-2.6.35.4-orig/arch/mips/ps2/siflock.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/ps2/siflock.c	2014-07-18 22:29:43.554367724 +0200
@@ -0,0 +1,392 @@
+/*
+ *  PlayStation 2 SIF lock
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+
+#include <asm/mach-ps2/siflock.h>
+
+/*
+ * debug stuff
+ */
+#define PS2SIFLOCK_DEBUG
+#ifdef PS2SIFLOCK_DEBUG
+#define DBG_LOCK	(1<< 0)
+
+#define DBG_LOG_LEVEL	KERN_CRIT
+
+#define DPRINT(l, fmt, args...) \
+	if ((l)->flags & PS2LOCK_FLAG_DEBUG) \
+		printk(DBG_LOG_LEVEL "ps2siflock: " fmt, ## args)
+#define DPRINTK(l, fmt, args...) \
+	if ((l)->flags & PS2LOCK_FLAG_DEBUG) \
+		printk(fmt, ## args)
+#else
+#define DPRINT(mask, fmt, args...)	do {} while (0)
+#define DPRINTK(mask, fmt, args...)	do {} while (0)
+#endif
+
+EXPORT_SYMBOL(ps2sif_lockinit);
+EXPORT_SYMBOL(ps2sif_lockqueueinit);
+EXPORT_SYMBOL(__ps2sif_lock);
+EXPORT_SYMBOL(ps2sif_unlock);
+EXPORT_SYMBOL(ps2sif_unlock_interruptible);
+EXPORT_SYMBOL(ps2sif_lowlevel_lock);
+EXPORT_SYMBOL(ps2sif_lowlevel_unlock);
+EXPORT_SYMBOL(ps2sif_iswaiting);
+EXPORT_SYMBOL(ps2sif_getlock);
+EXPORT_SYMBOL(ps2sif_havelock);
+EXPORT_SYMBOL(ps2sif_setlockflags);
+EXPORT_SYMBOL(ps2sif_getlockflags);
+
+static ps2sif_lock_t lock_cdvd;
+static ps2sif_lock_t lock_sound;
+static ps2sif_lock_t lock_pad;
+static ps2sif_lock_t lock_mc;
+static ps2sif_lock_t lock_remocon;
+
+struct ps2siflock {
+	volatile int locked;
+	volatile pid_t owner;
+	volatile void *lowlevel_owner;
+	volatile int waiting;
+	char *ownername;
+	struct ps2siflock_queue low_level_waitq;
+	wait_queue_head_t waitq;
+	spinlock_t spinlock;
+	int flags;
+};
+
+static ps2sif_lock_t *locks[] = {
+  [PS2LOCK_CDVD]	= &lock_cdvd,
+  [PS2LOCK_SOUND]	= &lock_sound,
+  [PS2LOCK_PAD]		= &lock_pad,
+  [PS2LOCK_MC]		= &lock_mc,
+  [PS2LOCK_RTC]		= &lock_cdvd,
+  [PS2LOCK_POWER]	= &lock_cdvd,
+  [PS2LOCK_REMOCON]	= &lock_remocon,
+  [PS2LOCK_SYSCONF]	= &lock_cdvd,
+};
+
+/*
+ * utility functions
+ */
+static inline void
+qadd(ps2sif_lock_queue_t *q, ps2sif_lock_queue_t *i)
+{
+	if (q->prev)
+		q->prev->next = i;
+	i->prev = q->prev;
+	q->prev = i;
+	i->next = q;
+}
+
+static inline ps2sif_lock_queue_t *
+qpop(ps2sif_lock_queue_t *q)
+{
+	ps2sif_lock_queue_t *i;
+	if (q->next == q) {
+		return NULL;
+	}
+	i = q->next;
+	q->next = q->next->next;
+	q->next->prev = q;
+	i->next = NULL; /* failsafe */
+	i->prev = NULL; /* failsafe */
+
+	return (i);
+}
+
+/*
+ * functions
+ */
+ps2sif_lock_t *
+ps2sif_getlock(int lockid)
+{
+	int i;
+	static int initialized = 0;
+
+	if (!initialized) {
+		initialized = 1;
+		/* XXX, some items in locks will be initialized twice */
+		for (i = 0; i < sizeof(locks)/sizeof(*locks); i++)
+			ps2sif_lockinit(locks[i]);
+	}
+
+	if (lockid < 0 || sizeof(locks)/sizeof(*locks) <= lockid)
+		return (NULL);
+	else
+		return (locks[lockid]);
+}
+
+void
+ps2sif_lockinit(ps2sif_lock_t *l)
+{
+	l->locked = 0;
+	l->owner = 0;
+	l->lowlevel_owner = NULL;
+	init_waitqueue_head(&l->waitq);
+	l->waiting = 0;
+	l->ownername = NULL;
+	l->low_level_waitq.prev = &l->low_level_waitq;
+	l->low_level_waitq.next = &l->low_level_waitq;
+	spin_lock_init(&l->spinlock);
+}
+
+void
+ps2sif_lockqueueinit(ps2sif_lock_queue_t *q)
+{
+	q->prev = NULL;
+	q->next = NULL;
+	q->routine = NULL;
+}
+
+int
+__ps2sif_lock(ps2sif_lock_t *l, char *name, long state)
+{
+	int res;
+	unsigned long flags;
+	DECLARE_WAITQUEUE(wait, current);
+
+	spin_lock_irqsave(&l->spinlock, flags);
+	add_wait_queue(&l->waitq, &wait);
+	res = -ERESTARTSYS;
+	for ( ; ; ) {
+		if (!l->locked || l->owner == current->pid) {
+			if (l->locked++ == 0) {
+				DPRINT(l, "  LOCK: pid=%d\n",
+				       current->pid);
+				l->owner = current->pid;
+				l->ownername = name;
+			} else {
+				DPRINT(l, "  lock: pid=%d count=%d\n",
+				       current->pid, l->locked);
+			}
+			res = 0;
+			break;
+		}
+		l->waiting++;
+		DPRINT(l, "sleep: pid=%d\n", current->pid);
+		set_current_state(state);
+		spin_unlock_irq(&l->spinlock);
+		schedule();
+		spin_lock_irq(&l->spinlock);
+		DPRINT(l, "waken up: pid=%d\n", current->pid);
+		l->waiting--;
+		if(state == TASK_INTERRUPTIBLE && signal_pending(current)) {
+			res = -ERESTARTSYS;
+			break;
+		}
+	}
+	remove_wait_queue(&l->waitq, &wait);
+	spin_unlock_irqrestore(&l->spinlock, flags);
+
+	return (res);
+}
+
+int
+ps2sif_havelock(ps2sif_lock_t *l)
+{
+	int res;
+	unsigned long flags;
+
+	spin_lock_irqsave(&l->spinlock, flags);
+	res = (l->locked && l->owner == current->pid);
+	spin_unlock_irqrestore(&l->spinlock, flags);
+
+	return (res);
+}
+
+static inline void
+clear_lock(ps2sif_lock_t *l)
+{
+	l->locked = 0;
+	l->owner = 0;
+	l->ownername = NULL;
+	l->lowlevel_owner = NULL;
+}
+
+static inline void
+give_lowlevel_lock(ps2sif_lock_t *l, ps2sif_lock_queue_t *q, unsigned long flags)
+{
+	int t;
+
+	if (l->locked++ == 0) {
+		DPRINT(l, "  LOCK: qi=%p\n", q);
+	} else {
+		DPRINT(l, "  lock: qi=%p  count=%d\n", q, l->locked);
+	}
+	l->owner = -1;
+	l->lowlevel_owner = q;
+	l->ownername = q->name;
+	spin_unlock_irqrestore(&l->spinlock, flags);
+	t = (q->routine != NULL && q->routine(q->arg) == -1);
+	spin_lock_irqsave(&l->spinlock, flags);
+	if (t && --l->locked <= 0)
+		clear_lock(l);
+}
+
+void
+ps2sif_unlock(ps2sif_lock_t *l)
+{
+	unsigned long flags;
+	ps2sif_lock_queue_t *qi;
+
+	spin_lock_irqsave(&l->spinlock, flags);
+	if (l->owner != current->pid) {
+		spin_unlock_irqrestore(&l->spinlock, flags);
+		printk(KERN_CRIT "ps2cdvd: invalid unlock operation\n");
+		return;
+	}
+	if (--l->locked <= 0) {
+		clear_lock(l);
+		DPRINT(l, "UNLOCK: pid=%d\n", current->pid);
+		while (!l->locked && (qi = qpop(&l->low_level_waitq))) {
+			give_lowlevel_lock(l, qi, flags);
+		}
+		DPRINT(l, "        locked=%d  waiting=%d\n",
+		       l->locked, l->waiting);
+		if (!l->locked && l->waiting) {
+			wake_up(&l->waitq);
+			DPRINT(l, "        wake_up\n");
+		}
+	} else {
+		DPRINT(l, "unlock: pid=%d count=%d\n",
+		       current->pid, l->locked);
+	}
+	spin_unlock_irqrestore(&l->spinlock, flags);
+}
+
+void
+ps2sif_unlock_interruptible(ps2sif_lock_t *l)
+{
+	unsigned long flags;
+	int interrupt;
+
+	ps2sif_unlock(l);
+	spin_lock_irqsave(&l->spinlock, flags);
+	interrupt = (l->owner != current->pid && ps2sif_iswaiting(l));
+	spin_unlock_irqrestore(&l->spinlock, flags);
+	if (interrupt)
+		schedule();
+}
+
+int
+ps2sif_lowlevel_lock(ps2sif_lock_t *l, ps2sif_lock_queue_t *qi, int opt)
+{
+	int res;
+	unsigned long flags;
+
+	if (qi == NULL)
+		return (-1);
+
+	spin_lock_irqsave(&l->spinlock, flags);
+	if (!l->locked || l->lowlevel_owner == qi) {
+		give_lowlevel_lock(l, qi, flags);
+		res = 0;
+	} else {
+		if (opt & PS2SIF_LOCK_QUEUING) {
+			DPRINT(l, "enqueue: qi=%p\n", qi);
+			qadd(&l->low_level_waitq, qi);
+		}
+		res = -1;
+	}
+	spin_unlock_irqrestore(&l->spinlock, flags);
+
+	return res;
+}
+
+void
+ps2sif_lowlevel_unlock(ps2sif_lock_t *l, ps2sif_lock_queue_t *qi)
+{
+	unsigned long flags;
+
+	if (qi == NULL)
+		return;
+
+	spin_lock_irqsave(&l->spinlock, flags);
+	if (l->locked && l->lowlevel_owner == qi && l->owner == -1) {
+		if (--l->locked <= 0) {
+			clear_lock(l);
+			DPRINT(l, "UNLOCK: qi=%p\n", qi);
+			while (!l->locked &&
+			       (qi = qpop(&l->low_level_waitq))) {
+				give_lowlevel_lock(l, qi, flags);
+			}
+			if (!l->locked && l->waiting) {
+				DPRINT(l, "wakeup upper level\n");
+				wake_up(&l->waitq);
+			}
+		} else {
+			DPRINT(l, "unlock: qi=%p  count=%d\n",
+			       qi, l->locked);
+		}
+	} else {
+		printk(KERN_CRIT
+		       "ps2sif_lock: low level locking violation\n");
+	}
+	spin_unlock_irqrestore(&l->spinlock, flags);
+}
+
+int
+ps2sif_iswaiting(ps2sif_lock_t *l)
+{
+	return (l->waiting);
+}
+
+unsigned long
+ps2sif_setlockflags(ps2sif_lock_t *l, unsigned long flags)
+{
+	unsigned long irq, res;
+
+	spin_lock_irqsave(&l->spinlock, irq);
+	res = l->flags;
+	l->flags = flags;
+	spin_unlock_irqrestore(&l->spinlock, irq);
+
+	return (res);
+}
+
+unsigned long
+ps2sif_getlockflags(ps2sif_lock_t *l)
+{
+	return (l->flags);
+}
+
+int __init ps2sif_lock_init(void)
+{
+	return (0);
+}
+
+void
+ps2sif_lock_cleanup(void)
+{
+}
+
+module_init(ps2sif_lock_init);
+module_exit(ps2sif_lock_cleanup);
+
+MODULE_AUTHOR("Mega Man");
+MODULE_DESCRIPTION("SBIOS lock module");
+MODULE_LICENSE("GPL");
diff -purN linux-2.6.35.4-orig/arch/mips/ps2/time.c linux-2.6.35.4/arch/mips/ps2/time.c
--- linux-2.6.35.4-orig/arch/mips/ps2/time.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/arch/mips/ps2/time.c	2014-07-18 22:29:43.554367724 +0200
@@ -0,0 +1,128 @@
+/*
+ *  PlayStation 2 timer functions
+ *
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kernel_stat.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/param.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/timex.h>
+
+#include <asm/bootinfo.h>
+#include <asm/time.h>
+#include <asm/mipsregs.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/mach-ps2/irq.h>
+#include <asm/mach-ps2/ps2.h>
+
+#define CPU_FREQ  294912000		/* CPU clock frequency (Hz) */
+#define BUS_CLOCK (CPU_FREQ/2)		/* bus clock frequency (Hz) */
+#define TM_COMPARE_VALUE  (BUS_CLOCK/256/HZ)	/* to generate 100Hz */
+#define USECS_PER_JIFFY (1000000/HZ)
+
+#define T0_BASE  0x10000000
+#define T0_COUNT (T0_BASE + 0x00)
+#define T0_MODE  (T0_BASE + 0x10)
+#define T0_COMP  (T0_BASE + 0x20)
+
+/**
+ * 	ps2_timer_interrupt - Timer Interrupt Routine
+ *
+ * 	@regs:   registers as they appear on the stack
+ *	         during a syscall/exception.
+ * 	
+ * 	Timer interrupt routine, wraps the generic timer_interrupt() but
+ * 	sets the timer interrupt delay and clears interrupts first.
+ */
+static irqreturn_t ps2_timer_interrupt(int irq, void *dev_id)
+{
+	struct clock_event_device *cd = dev_id;
+
+	/* Clear the interrupt */
+	outl(inl(T0_MODE), T0_MODE);
+
+	cd->event_handler(cd);
+
+	return IRQ_HANDLED;
+}
+
+static void timer0_set_mode(enum clock_event_mode mode,
+                          struct clock_event_device *evt)
+{
+	switch (mode) {
+	case CLOCK_EVT_MODE_PERIODIC:
+		/* setup 100Hz interval timer */
+		outl(0, T0_COUNT);
+		outl(TM_COMPARE_VALUE, T0_COMP);
+
+		/* busclk / 256, zret, cue, cmpe, equf */
+		outl(2 | (1 << 6) | (1 << 7) | (1 << 8) | (1 << 10), T0_MODE);
+		break;
+	case CLOCK_EVT_MODE_ONESHOT:
+	case CLOCK_EVT_MODE_UNUSED:
+		break;
+	case CLOCK_EVT_MODE_SHUTDOWN:
+		/* Stop timer. */
+		outl(0, T0_MODE);
+		break;
+	case CLOCK_EVT_MODE_RESUME:
+		break;
+	}
+}
+
+static struct irqaction timer0_irqaction = {
+	.handler	= ps2_timer_interrupt,
+	.flags		= IRQF_DISABLED | IRQF_PERCPU | IRQF_TIMER,
+	.name		= "intc-timer0",
+};
+
+static struct clock_event_device timer0_clockevent_device = {
+	.name		= "timer0",
+	.features	= CLOCK_EVT_FEAT_PERIODIC, /* TBD: Timer is also able to provide CLOCK_EVT_FEAT_ONESHOT. */
+
+	/* .mult, .shift, .max_delta_ns and .min_delta_ns left uninitialized */
+
+	.rating		= 300, /* TBD: Check value. */
+	.irq		= IRQ_INTC_TIMER0,
+	.set_mode	= timer0_set_mode,
+};
+
+void __init plat_time_init(void)
+{
+	/* Setup interrupt */
+	struct clock_event_device *cd = &timer0_clockevent_device;
+	struct irqaction *action = &timer0_irqaction;
+	unsigned int cpu = smp_processor_id();
+
+	/* Add timer 0 as clock event source. */
+	cd->cpumask = cpumask_of(cpu);
+	clockevents_register_device(cd);
+	action->dev_id = cd;
+	setup_irq(IRQ_INTC_TIMER0, &timer0_irqaction);
+
+	/* Timer 1 is free and can also be configured as clock event source. */
+
+	/* Setup frequency for IP7 timer interrupt. */
+	mips_hpt_frequency = CPU_FREQ;
+}
diff -purN linux-2.6.35.4-orig/drivers/ide/Kconfig linux-2.6.35.4/drivers/ide/Kconfig
--- linux-2.6.35.4-orig/drivers/ide/Kconfig	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/drivers/ide/Kconfig	2014-07-18 22:29:43.554367724 +0200
@@ -888,4 +888,14 @@ config BLK_DEV_IDEDMA
 		 BLK_DEV_IDEDMA_ICS || BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
 	select IDE_XFER_MODE
 
+config BLK_DEV_PS2_IDE
+	tristate "Sony Playstation 2 IDE interface support"
+	depends on SONY_PS2
+	default y
+	help
+	  This is the IDE driver for the HDD/Ethernet adapter for the
+	  fat PS2.
+
+	  Say Y if you have a fat PS2.
+
 endif # IDE
diff -purN linux-2.6.35.4-orig/drivers/ide/Makefile linux-2.6.35.4/drivers/ide/Makefile
--- linux-2.6.35.4-orig/drivers/ide/Makefile	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/drivers/ide/Makefile	2014-07-18 22:29:43.554367724 +0200
@@ -117,3 +117,4 @@ obj-$(CONFIG_BLK_DEV_IDE_AU1XXX)	+= au1x
 obj-$(CONFIG_BLK_DEV_IDE_TX4938)	+= tx4938ide.o
 obj-$(CONFIG_BLK_DEV_IDE_TX4939)	+= tx4939ide.o
 obj-$(CONFIG_BLK_DEV_IDE_AT91)		+= at91_ide.o
+obj-$(CONFIG_BLK_DEV_PS2_IDE)		+= ps2ide.o
diff -purN linux-2.6.35.4-orig/drivers/ide/ps2ide.c linux-2.6.35.4/drivers/ide/ps2ide.c
--- linux-2.6.35.4-orig/drivers/ide/ps2ide.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ide/ps2ide.c	2014-07-18 22:29:43.554367724 +0200
@@ -0,0 +1,58 @@
+/*
+ *  Sony Playstation 2 IDE Driver
+ *
+ *     Copyright (C) 2011 by Mega Man
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License.  See the file COPYING in the main directory of this archive for
+ *  more details.
+ */
+
+#include <linux/types.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/blkdev.h>
+#include <linux/delay.h>
+#include <linux/ide.h>
+
+#define PS2_HDD_BASE 0xb4000040
+
+static void __init ps2ide_setup_ports(struct ide_hw *hw, unsigned long base,
+				      int irq)
+{
+	int i;
+
+	memset(hw, 0, sizeof(*hw));
+
+	for (i = 0; i < 8; i++)
+		hw->io_ports_array[i] = base + i * 2;
+
+	hw->io_ports.ctl_addr = base + 0x1c;
+
+	hw->irq = irq;
+}
+
+static const struct ide_port_info ps2ide_port_info = {
+	.host_flags		= IDE_HFLAG_MMIO | IDE_HFLAG_NO_DMA,
+	.irq_flags		= IRQF_SHARED,
+	.chipset		= ide_generic,
+};
+
+static int __init ps2ide_init(void)
+{
+	struct ide_hw hw, *hws[] = { &hw };
+	struct ide_port_info d = ps2ide_port_info;
+
+	if (ps2_pccard_present == 0x0100) {
+		printk(KERN_INFO "ide: Sony Playstation 2 IDE controller\n");
+		ps2ide_setup_ports(&hw, PS2_HDD_BASE, IRQ_SBUS_PCIC);
+		/* TBD: Add DMA support. */
+		return ide_host_add(&d, hws, 1, NULL);
+	} else {
+		return -ENODEV;
+	}
+}
+
+module_init(ps2ide_init);
+
+MODULE_LICENSE("GPL");
diff -purN linux-2.6.35.4-orig/drivers/Kconfig linux-2.6.35.4/drivers/Kconfig
--- linux-2.6.35.4-orig/drivers/Kconfig	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/drivers/Kconfig	2014-07-18 22:29:43.554367724 +0200
@@ -111,4 +111,6 @@ source "drivers/xen/Kconfig"
 source "drivers/staging/Kconfig"
 
 source "drivers/platform/Kconfig"
+
+source "drivers/ps2/Kconfig"
 endmenu
diff -purN linux-2.6.35.4-orig/drivers/Makefile linux-2.6.35.4/drivers/Makefile
--- linux-2.6.35.4-orig/drivers/Makefile	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/drivers/Makefile	2014-07-18 22:29:43.554367724 +0200
@@ -113,3 +113,4 @@ obj-$(CONFIG_VLYNQ)		+= vlynq/
 obj-$(CONFIG_STAGING)		+= staging/
 obj-y				+= platform/
 obj-y				+= ieee802154/
+obj-$(CONFIG_SONY_PS2)		+= ps2/
diff -purN linux-2.6.35.4-orig/drivers/ps2/cdvdaltdev.c linux-2.6.35.4/drivers/ps2/cdvdaltdev.c
--- linux-2.6.35.4-orig/drivers/ps2/cdvdaltdev.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/cdvdaltdev.c	2014-07-18 22:29:43.554367724 +0200
@@ -0,0 +1,77 @@
+/*
+ *  PlayStation 2 CD/DVD driver
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define __NO_VERSION__
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include <linux/fs.h>
+#include <linux/timer.h>
+#include "cdvd.h"
+
+static loff_t
+cdvd_file__llseek(struct file *file, loff_t offset, int origin)
+{
+	return -ESPIPE;
+}
+
+static ssize_t
+cdvd_file__read(struct file *filp, char *buffer, size_t count, loff_t *ppos)
+{
+	return -EINVAL;
+}
+
+static ssize_t
+cdvd_file__write(struct file *filp, const char *buffer, size_t count, loff_t *ppos)
+{
+	return -EINVAL;
+}
+
+static int
+cdvd_file__ioctl(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	return ps2cdvd_common_ioctl(cmd, arg);
+}
+
+static int
+cdvd_file__open(struct inode *inode, struct file *filp)
+{
+
+	return 0;
+}
+
+static int
+cdvd_file__release(struct inode *inode, struct file *filp)
+{
+
+	return 0;
+}
+
+struct file_operations ps2cdvd_altdev_fops = {
+	owner:	THIS_MODULE,
+	llseek:	cdvd_file__llseek,
+	read:	cdvd_file__read,
+	write:	cdvd_file__write,
+	ioctl:	cdvd_file__ioctl,
+	open:	cdvd_file__open,
+	release:cdvd_file__release,
+};
diff -purN linux-2.6.35.4-orig/drivers/ps2/cdvd.c linux-2.6.35.4/drivers/ps2/cdvd.c
--- linux-2.6.35.4-orig/drivers/ps2/cdvd.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/cdvd.c	2014-07-18 22:29:43.554367724 +0200
@@ -0,0 +1,1196 @@
+/*
+ *  PlayStation 2 CD/DVD driver
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/iso_fs.h>
+#include <linux/interrupt.h>
+#include <linux/major.h>
+
+#include "cdvd.h"
+
+/*
+ * macro defines
+ */
+#define MAJOR_NR	ps2cdvd_major
+#define DEVICE_NAME	"PS2 CD/DVD-ROM"
+/* #define DEVICE_INTR	do_ps2cdvd */
+
+#include <linux/blkdev.h>
+
+#define ENTER	1
+#define LEAVE	0
+#define INVALID_DISCTYPE	-1
+
+#define BUFFER_ALIGNMENT	64
+
+/* return values of checkdisc */
+#define DISC_ERROR	-1
+#define DISC_OK		0
+#define DISC_NODISC	1
+#define DISC_RETRY	2
+
+#define DVD_DATA_SECT_SIZE 2064
+#define DVD_DATA_OFFSET 12
+
+/*
+ * data types
+ */
+struct ps2cdvd_event {
+	int type;
+	void *arg;
+};
+
+static DEFINE_SPINLOCK(cdvd_lock);
+static DEFINE_SPINLOCK(cdvd_queue_lock);
+
+/*
+ * function prototypes
+ */
+static void ps2cdvd_request(struct request_queue *);
+static void ps2cdvd_timer(unsigned long);
+void ps2cdvd_cleanup(void);
+static int ps2cdvd_bdops_open(struct block_device *bdev, fmode_t mode);
+static int ps2cdvd_bdops_release(struct gendisk *disk, fmode_t mode);
+static int ps2cdvd_bdops_mediachanged(struct gendisk *disk);
+static int ps2cdvd_bdops_ioctl(struct block_device *bdev, fmode_t mode, unsigned cmd, unsigned long arg);
+static int checkdisc(void);
+static int spindown(void);
+
+/*
+ * variables
+ */
+int ps2cdvd_check_interval = 2;
+int ps2cdvd_databuf_size = 16;
+int ps2cdvd_debug = DBG_DEFAULT_FLAGS;
+int ps2cdvd_immediate_ioerr = 0;
+int ps2cdvd_major = PS2CDVD_MAJOR;
+int ps2cdvd_spindown = 0;
+int ps2cdvd_wrong_disc_retry = 0;
+
+module_param(ps2cdvd_check_interval, int, 0);
+MODULE_PARM_DESC(ps2cdvd_check_interval,
+	"CDVD check interval (1-30)");
+module_param(ps2cdvd_databuf_size, int, 0);
+MODULE_PARM_DESC(ps2cdvd_databuf_size,
+	"CDVD data buffer size (1-256)");
+module_param(ps2cdvd_debug, int, 0);
+MODULE_PARM_DESC(ps2cdvd_debug,
+	"Set debug level verbosity.");
+module_param(ps2cdvd_immediate_ioerr, int, 0);
+MODULE_PARM_DESC(ps2cdvd_immediate_ioerr,
+	"(0-1)");
+module_param(ps2cdvd_major, int, 0);
+MODULE_PARM_DESC(ps2cdvd_major,
+	"Major number for device (0-255)");
+module_param(ps2cdvd_spindown, int, 0);
+MODULE_PARM_DESC(ps2cdvd_spindown,
+	"CDVD spindown value (0-3600)");
+module_param(ps2cdvd_wrong_disc_retry, int, 0);
+MODULE_PARM_DESC(ps2cdvd_wrong_disc_retry,
+	"Enable wrong disc retry (0-1)");
+
+struct ps2cdvd_ctx ps2cdvd = {
+	disc_changed:	1,
+	disc_type:	INVALID_DISCTYPE,
+	databuf_nsects:	0,
+	label_mode: {
+		100,			/* try count			*/
+		0,			/* will be set			*/
+		SCECdSecS2048,		/* data size = 2048		*/
+		0xff			/* padding data			*/
+	},
+	data_mode: {
+		50,			/* try count			*/
+		SCECdSpinNom,		/* try with maximum speed	*/
+		SCECdSecS2048,		/* data size = 2048		*/
+		0xff			/* padding data			*/
+	},
+	cdda_mode: {
+		50,			/* try count			*/
+		SCECdSpinNom,		/* try with maximum speed	*/
+		SCECdSecS2352|0x80,	/* data size = 2352, CD-DA	*/
+		0x0f			/* padding data			*/
+	},
+};
+
+static LIST_HEAD(cdvd_deferred);
+static struct gendisk *disk;
+
+/*
+ * function bodies
+ */
+static void
+ps2cdvd_invalidate_discinfo(void)
+{
+	ps2cdvd.disc_type = INVALID_DISCTYPE;
+	if (ps2cdvd.label_valid)
+		DPRINT(DBG_DLOCK, "label gets invalid\n");
+	ps2cdvd.label_valid = 0;
+	if (ps2cdvd.toc_valid)
+		DPRINT(DBG_VERBOSE, "toc gets invalid\n");
+	ps2cdvd.toc_valid = 0;
+	ps2cdvd.databuf_nsects = 0;
+	ps2cdvd.disc_changed++;
+}
+
+static void
+ps2cdvd_request(struct request_queue *rq)
+{
+	unsigned long flags;
+	struct request *req;
+
+	while ((req = blk_fetch_request(rq)) != NULL) {
+		if (!blk_fs_request(req)) {
+			printk(KERN_DEBUG "ps2cdvd: Non-fs request ignored\n");
+			__blk_end_request_all(req, -EIO);
+			continue;
+		}
+		if (rq_data_dir(req) != READ) {
+			printk(KERN_NOTICE "ps2cdvd: Read only device -");
+			printk(" write request ignored\n");
+			__blk_end_request_all(req, -EIO);
+			continue;
+		}
+		spin_lock_irqsave(&cdvd_queue_lock, flags);
+		list_add_tail(&req->queuelist, &cdvd_deferred); // TBD: Protect with lock?
+		spin_unlock_irqrestore(&cdvd_queue_lock, flags);
+
+		spin_lock_irqsave(&ps2cdvd.ievent_lock, flags);
+		if (ps2cdvd.ievent == EV_NO_EVENT) {
+		    ps2cdvd.ievent = EV_START;
+		    up(&ps2cdvd.wait_sem);
+		}
+		spin_unlock_irqrestore(&ps2cdvd.ievent_lock, flags);
+	}
+}
+
+void
+ps2cdvd_lock(char *msg)
+{
+    DPRINT(DBG_LOCK, "lock '%s' pid=%d\n", msg, current->pid);
+    ps2sif_lock(ps2cdvd.lock, msg);
+    DPRINT(DBG_LOCK, "locked pid=%d\n", current->pid);
+}
+
+int
+ps2cdvd_lock_interruptible(char *msg)
+{
+    int res;
+
+    DPRINT(DBG_LOCK, "interruptible lock '%s' pid=%d\n", msg, current->pid);
+    res = ps2sif_lock_interruptible(ps2cdvd.lock, msg);
+    DPRINT(DBG_LOCK, "interruptible locked pid=%d res=%d\n",current->pid,res);
+
+    return (res);
+}
+
+void
+ps2cdvd_unlock()
+{
+
+    DPRINT(DBG_LOCK, "unlock pid=%d\n", current->pid);
+    ps2sif_unlock(ps2cdvd.lock);
+}
+
+static int
+ps2cdvd_command(int command)
+{
+    int res;
+
+    if ((res = down_interruptible(&ps2cdvd.command_sem)) != 0)
+	return (res);
+    ps2cdvd.event = command;
+    up(&ps2cdvd.wait_sem);
+
+    return (0);
+}
+
+static void
+ps2cdvd_sleep(long timeout)
+{
+    DECLARE_WAIT_QUEUE_HEAD(wq);
+
+    sleep_on_timeout(&wq, timeout);
+}
+
+int
+ps2cdvd_lock_ready(void)
+{
+    int res, state;
+    unsigned long flags;
+    DECLARE_WAITQUEUE(wait, current);
+
+    while (1) {
+	if ((res = ps2cdvd_lock_interruptible("ready")) != 0)
+	    return (res);
+	if ((state = ps2cdvd.state) == STAT_READY)
+	    return (0);
+	ps2cdvd_unlock();
+
+	switch (state) {
+	case STAT_WAIT_DISC:
+	    return (-ENOMEDIUM);
+	    break;
+
+	case STAT_IDLE:
+	    if ((res = ps2cdvd_command(EV_START)) != 0)
+		return (res);
+	    break;
+
+	case STAT_INVALID_DISC:
+	    if (!ps2cdvd_wrong_disc_retry)
+		return (-ENOMEDIUM);
+	    break;
+	}
+
+	spin_lock_irqsave(&ps2cdvd.state_lock, flags);
+	add_wait_queue(&ps2cdvd.statq, &wait);
+	while (ps2cdvd.state == state && !signal_pending(current)) {
+	    set_current_state(TASK_INTERRUPTIBLE);
+	    spin_unlock_irq(&ps2cdvd.state_lock);
+	    schedule();
+	    spin_lock_irq(&ps2cdvd.state_lock);
+	}
+	remove_wait_queue(&ps2cdvd.statq, &wait);
+	spin_unlock_irqrestore(&ps2cdvd.state_lock, flags);
+	if(signal_pending(current))
+	    return (-ERESTARTSYS);
+    }
+
+    /* not reached */
+}
+
+static void
+ps2cdvd_timer(unsigned long arg)
+{
+    unsigned long flags;
+
+    spin_lock_irqsave(&ps2cdvd.ievent_lock, flags);
+    if (ps2cdvd.ievent == EV_NO_EVENT) {
+	ps2cdvd.ievent = EV_TIMEOUT;
+	up(&ps2cdvd.wait_sem);
+    }
+    spin_unlock_irqrestore(&ps2cdvd.ievent_lock, flags);
+}
+
+static int
+ps2cdvd_getevent(int timeout)
+{
+    int ev, res;
+    unsigned long flags;
+    struct timer_list timer;
+
+    init_timer(&timer);
+    timer.function = (void(*)(u_long))ps2cdvd_timer;
+    timer.expires = jiffies + (timeout);
+    add_timer(&timer);
+    res = down_interruptible(&ps2cdvd.wait_sem);
+    del_timer(&timer);
+
+    if (res != 0)
+	return (EV_EXIT);
+
+    spin_lock_irqsave(&ps2cdvd.ievent_lock, flags);
+    ev = ps2cdvd.ievent;
+    ps2cdvd.ievent = EV_NO_EVENT;
+    spin_unlock_irqrestore(&ps2cdvd.ievent_lock, flags);
+    if (ev == EV_NO_EVENT) {
+	ev = ps2cdvd.event;
+	ps2cdvd.event = EV_NO_EVENT;
+	up(&ps2cdvd.command_sem);
+    }
+
+    return (ev);
+}
+
+static int
+ps2cdvd_check_cache(void)
+{
+    struct list_head *elem, *next;
+    unsigned long flags;
+    int rv;
+
+    spin_lock_irqsave(&cdvd_queue_lock, flags);
+    list_for_each_safe(elem, next, &cdvd_deferred) {
+        struct request *req;
+	unsigned int pos;
+	unsigned int sectors;
+	sector_t start;
+	sector_t end;
+	void *src;
+	void *dst;
+
+	req = list_entry(elem, struct request, queuelist);
+	start = blk_rq_pos(req);
+	end = start + blk_rq_sectors(req);
+
+	/* Check if data is in buffer. */
+	if (ps2cdvd.databuf_addr > start/4)
+		break;
+	if (end/4 > ps2cdvd.databuf_addr + ps2cdvd.databuf_nsects)
+		break;
+	DPRINT(DBG_READ, "REQ %p: sec=%lld  n=%d  buf=%p\n",
+	       req, start,
+	       blk_rq_sectors(req), req->buffer);
+	sectors = blk_rq_sectors(req) / 4;
+	src = ps2cdvd.databuf;
+	dst = req->buffer;
+	if (ps2cdvd.disc_type == SCECdDVDV) {
+		src += DVD_DATA_OFFSET + DVD_DATA_SECT_SIZE * (start/4 - ps2cdvd.databuf_addr);
+		/* Copy all sectors. */
+		for (pos = 0; pos < sectors; pos++) {
+			/* Copy one sector from cache to buffer of request. */
+			memcpy(dst, src, DATA_SECT_SIZE);
+			dst += DATA_SECT_SIZE;
+			src += DVD_DATA_SECT_SIZE;
+		}
+	} else {
+		/* Copy data from cache to buffer of request. */
+		src += DATA_SECT_SIZE * (start/4 - ps2cdvd.databuf_addr);
+		memcpy(dst, src, sectors * DATA_SECT_SIZE);
+	}
+	list_del_init(&req->queuelist);
+	__blk_end_request_all(req, 0);
+    }
+
+    rv = list_empty(&cdvd_deferred);
+    spin_unlock_irqrestore(&cdvd_queue_lock, flags);
+    return rv;
+}
+
+static int
+ps2cdvd_thread(void *arg)
+{
+    int res, new_state, disc_type;
+    int sum, traycount, ev;
+    unsigned long flags;
+    long sn;
+    int nsects;
+
+    /* get rid of all our resources related to user space */
+    daemonize("ps2cdvd thread");
+
+    ps2cdvd.state = STAT_INIT;
+    new_state = STAT_CHECK_DISC;
+    ev = EV_NO_EVENT;
+    ps2cdvd.sectoidle = ps2cdvd_spindown;
+    ps2cdvd_invalidate_discinfo();
+
+    /* notify we are running */
+    up(&ps2cdvd.ack_sem);
+
+#define NEW_STATE(s)	do { new_state = (s); goto set_state; } while (0)
+
+    if (ps2cdvd_lock_interruptible("cdvd thread") != 0)
+	goto out;
+
+ set_state:
+    spin_lock_irqsave(&ps2cdvd.state_lock, flags);
+    if (ps2cdvd.state != new_state) {
+	DPRINT(DBG_STATE, "event: %s  state: %s -> %s\n",
+	       ps2cdvd_geteventstr(ev),
+	       ps2cdvd_getstatestr(ps2cdvd.state),
+	       ps2cdvd_getstatestr(new_state));
+	ps2cdvd.state = new_state;
+	wake_up(&ps2cdvd.statq);
+    }
+    spin_unlock_irqrestore(&ps2cdvd.state_lock, flags);
+
+    switch (ps2cdvd.state) {
+    case STAT_WAIT_DISC:
+    case STAT_INVALID_DISC:
+	ps2cdvd_invalidate_discinfo();
+	if (!ps2cdvd.disc_locked ||
+	    (ps2cdvd.state == STAT_INVALID_DISC &&
+	     !ps2cdvd_wrong_disc_retry)) {
+	    unsigned long flags;
+
+	    spin_lock_irqsave(&cdvd_queue_lock, flags);
+	    if (!list_empty(&cdvd_deferred)) {
+    		struct list_head *elem, *next;
+		DPRINT(DBG_DIAG, "abort all pending request\n");
+
+    		list_for_each_safe(elem, next, &cdvd_deferred) {
+		        struct request *req;
+
+			req = list_entry(elem, struct request, queuelist);
+			list_del_init(&req->queuelist);
+			__blk_end_request_all(req, -EIO);
+		}
+	    }
+	    spin_unlock_irqrestore(&cdvd_queue_lock, flags);
+	}
+	ps2cdvd_unlock();
+	ev = ps2cdvd_getevent(ps2cdvd_check_interval * HZ);
+	if (ps2cdvd_lock_interruptible("cdvd thread") != 0)
+	    goto out;
+	switch (ev) {
+	case EV_START:
+	    NEW_STATE(STAT_CHECK_DISC);
+	    break;
+	case EV_TIMEOUT:
+	    if (ps2cdvdcall_gettype(&disc_type) != 0 ||
+		disc_type != SCECdNODISC)
+		NEW_STATE(STAT_CHECK_DISC);
+	    break;
+	case EV_EXIT:
+	    goto unlock_out;
+	}
+	break;
+
+    case STAT_CHECK_DISC:
+	ps2cdvd.sectoidle = ps2cdvd_spindown;
+	res = checkdisc();
+	sum = ps2cdvd_checksum((u_long*)ps2cdvd.labelbuf,
+			       2048/sizeof(u_long));
+	if (res != DISC_OK) {
+	    if (res == DISC_RETRY) {
+		ps2cdvd_sleep(HZ);
+		NEW_STATE(STAT_CHECK_DISC);
+	    }
+	    if (ps2cdvd.disc_locked)
+		NEW_STATE(STAT_INVALID_DISC);
+	    NEW_STATE(STAT_WAIT_DISC);
+	}
+	if (!ps2cdvd.disc_locked || ps2cdvd.disc_type == SCECdCDDA) {
+	    NEW_STATE(STAT_READY);
+	}
+	if (ps2cdvd.disc_lock_key_valid) {
+	    if (ps2cdvd.label_valid &&
+		ps2cdvd.disc_lock_key == sum) {
+		NEW_STATE(STAT_READY);
+	    }
+	    NEW_STATE(STAT_INVALID_DISC);
+	}
+	if (ps2cdvd.label_valid) {
+	    ps2cdvd.disc_lock_key = sum;
+	    NEW_STATE(STAT_READY);
+	}
+	NEW_STATE(STAT_INVALID_DISC);
+	break;
+
+    case STAT_READY: {
+	unsigned long flags;
+        struct request *req;
+	spin_lock_irqsave(&cdvd_queue_lock, flags);
+	if (list_empty(&cdvd_deferred)) {
+	    spin_unlock_irqrestore(&cdvd_queue_lock, flags);
+	    ps2cdvd_unlock();
+	    ev = ps2cdvd_getevent(ps2cdvd_check_interval * HZ);
+	    if (ps2cdvd_lock_interruptible("cdvd thread") != 0)
+		goto out;
+	    ps2cdvd.sectoidle -= ps2cdvd_check_interval;
+	    switch (ev) {
+	    case EV_START:
+		break;
+	    case EV_TIMEOUT:
+	        spin_lock_irqsave(&cdvd_queue_lock, flags);
+		if (ps2cdvd_spindown != 0 && ps2cdvd.sectoidle <= 0 && list_empty(&cdvd_deferred)
+		    && ps2cdvd.stream_start == 0) {
+	          spin_unlock_irqrestore(&cdvd_queue_lock, flags);
+		  NEW_STATE(STAT_IDLE);
+                } else {
+	          spin_unlock_irqrestore(&cdvd_queue_lock, flags);
+		}
+		if (ps2cdvdcall_trayreq(SCECdTrayCheck, &traycount) != 0 ||
+		    traycount != 0 ||
+		    ps2cdvd.traycount != 0) {
+		    ps2cdvd.traycount = 0;
+		    DPRINT(DBG_INFO, "tray was opened\n");
+		    NEW_STATE(STAT_CHECK_DISC);
+		}
+		break;
+	    case EV_EXIT:
+		goto unlock_out;
+	    }
+	    NEW_STATE(STAT_READY);
+	} else {
+	    spin_unlock_irqrestore(&cdvd_queue_lock, flags);
+	}
+
+	if (ps2cdvdcall_trayreq(SCECdTrayCheck, &traycount) != 0 ||
+	    traycount != 0 ||
+	    ps2cdvd.traycount != 0) {
+	    DPRINT(DBG_INFO, "tray was opened\n");
+	    ps2cdvd.traycount = 0;
+	    NEW_STATE(STAT_CHECK_DISC);
+	}
+
+	ps2cdvd.sectoidle = ps2cdvd_spindown;
+	if (ps2cdvd_check_cache())
+	    NEW_STATE(STAT_READY);
+
+	spin_lock_irqsave(&cdvd_queue_lock, flags);
+	req = list_first_entry(&cdvd_deferred, struct request, queuelist);
+	sn = blk_rq_pos(req)/4;
+	spin_unlock_irqrestore(&cdvd_queue_lock, flags);
+	nsects = ps2cdvd_databuf_size;
+
+    retry:
+	DPRINT(DBG_READ, "read: sec=%ld  n=%d  buf=%p %s\n",
+	       sn * 4, ps2cdvd_databuf_size, ps2cdvd.databuf,
+	       nsects != ps2cdvd_databuf_size ? "(retry)" : "");
+	ps2cdvd.databuf_nsects = 0;
+	if (ps2cdvd.disc_type == SCECdDVDV) {
+		if (ps2cdvdcall_read_dvd(sn, nsects, ps2cdvd.databuf,
+				     &ps2cdvd.data_mode) != 0) {
+		    NEW_STATE(STAT_CHECK_DISC);
+		}
+	} else {
+		if (ps2cdvdcall_read(sn, nsects, ps2cdvd.databuf,
+				     &ps2cdvd.data_mode) != 0) {
+		    NEW_STATE(STAT_CHECK_DISC);
+		}
+	}
+	res = ps2cdvdcall_geterror();
+	if (res == SCECdErNO) {
+	    ps2cdvd.databuf_addr = sn;
+	    ps2cdvd.databuf_nsects = nsects;
+	    ps2cdvd_check_cache();
+
+	    if (ps2sif_iswaiting(ps2cdvd.lock)) {
+		ps2cdvd_unlock();
+		schedule();
+		if (ps2cdvd_lock_interruptible("cdvd thread") != 0)
+		    goto out;
+	    }
+	    NEW_STATE(STAT_READY);
+	}
+	if ((res == SCECdErEOM ||
+	     res == SCECdErREAD ||
+	     res == SCECdErILI ||
+	     res == SCECdErIPI ||
+	     res == SCECdErABRT ||
+	     res == 0xfd /* XXX, should be defined in libcdvd.h */ ||
+	     res == 0x38 /* XXX, should be defined in libcdvd.h */) &&
+	    nsects != 1) {
+	    /* you got an error and you have not retried */
+	    DPRINT(DBG_DIAG, "error: %s, code=0x%02x (retry...)\n",
+		   ps2cdvd_geterrorstr(res), res);
+	    spin_lock_irqsave(&cdvd_queue_lock, flags);
+	    req = list_first_entry(&cdvd_deferred, struct request, queuelist);
+	    sn = blk_rq_pos(req)/4;
+	    spin_unlock_irqrestore(&cdvd_queue_lock, flags);
+	    nsects = 1;
+	    goto retry;
+	}
+	DPRINT(DBG_DIAG, "error: %s, code=0x%02x\n",
+	       ps2cdvd_geterrorstr(res), res);
+	spin_lock_irqsave(&cdvd_queue_lock, flags);
+	req = list_first_entry(&cdvd_deferred, struct request, queuelist);
+	list_del_init(&req->queuelist);
+	__blk_end_request_all(req, -EIO);
+	spin_unlock_irqrestore(&cdvd_queue_lock, flags);
+	NEW_STATE(STAT_CHECK_DISC);
+	break;
+    }
+
+    case STAT_IDLE: {
+	unsigned long flags;
+
+	if (ps2cdvd.disc_type != INVALID_DISCTYPE)
+		spindown();
+	ps2cdvd_unlock();
+	ev = ps2cdvd_getevent(ps2cdvd_check_interval * HZ);
+	if (ps2cdvd_lock_interruptible("cdvd thread") != 0)
+	    goto out;
+	switch (ev) {
+	case EV_START:
+	    NEW_STATE(STAT_CHECK_DISC);
+	    break;
+	case EV_EXIT:
+	    goto unlock_out;
+	}
+	/*
+	 * XXX, fail safe
+	 * EV_START might be lost
+	 */
+        spin_lock_irqsave(&cdvd_queue_lock, flags);
+	if (!list_empty(&cdvd_deferred)) {
+	    spin_unlock_irqrestore(&cdvd_queue_lock, flags);
+	    NEW_STATE(STAT_CHECK_DISC);
+	} else {
+	    spin_unlock_irqrestore(&cdvd_queue_lock, flags);
+	}
+	if (ps2cdvdcall_trayreq(SCECdTrayCheck, &traycount) != 0 ||
+	    traycount != 0 ||
+	    ps2cdvd.traycount != 0) {
+	    ps2cdvd.traycount = 0;
+	    DPRINT(DBG_INFO, "tray was opened\n");
+	    NEW_STATE(STAT_CHECK_DISC);
+	}
+	break;
+    }
+
+    case STAT_ERROR:
+	ps2cdvd_unlock();
+	ev = ps2cdvd_getevent(ps2cdvd_check_interval * HZ);
+	if (ps2cdvd_lock_interruptible("cdvd thread") != 0)
+	    goto out;
+	if (ev == EV_EXIT)
+	    goto unlock_out;
+	break;
+    }
+
+    goto set_state;
+
+ unlock_out:
+    ps2cdvd_unlock();
+
+ out: {
+    unsigned long flags;
+
+    DPRINT(DBG_INFO, "the thread is exiting...\n");
+
+    spin_lock_irqsave(&cdvd_queue_lock, flags);
+    if (!list_empty(&cdvd_deferred)) {
+	struct list_head *elem, *next;
+	DPRINT(DBG_DIAG, "abort all pending request\n");
+
+	list_for_each_safe(elem, next, &cdvd_deferred) {
+	        struct request *req;
+
+		req = list_entry(elem, struct request, queuelist);
+		list_del_init(&req->queuelist);
+		__blk_end_request_all(req, -EIO);
+	}
+    }
+    spin_unlock_irqrestore(&cdvd_queue_lock, flags);
+    }
+
+    /* notify we are exiting */
+    up(&ps2cdvd.ack_sem);
+
+    return (0);
+}
+
+static int
+checkdisc()
+{
+    int res;
+    int media, traycount, media_mode, disc_type;
+    int read_toc, read_label;
+
+    ps2cdvd_invalidate_discinfo();
+
+    /*
+     *  clear tray count
+     */
+    if (ps2cdvdcall_trayreq(SCECdTrayCheck, &traycount) != 0) {
+	DPRINT(DBG_DIAG, "trayreq() failed\n");
+	res = DISC_ERROR;
+	goto error_out;
+    }
+
+    /*
+     *  check disc type
+     */
+    if (ps2cdvdcall_gettype(&disc_type) != 0) {
+	/* error */
+	DPRINT(DBG_DIAG, "gettype() failed\n");
+	res = DISC_ERROR;
+	goto error_out;
+    }
+    ps2cdvd.disc_type = disc_type;
+    DPRINT(DBG_INFO, "ps2cdvdcall_gettype()='%s', %d\n",
+	   ps2cdvd_getdisctypestr(ps2cdvd.disc_type),
+	   ps2cdvd.disc_type);
+
+    read_toc = 1;
+    read_label = 1;
+    media_mode = SCECdCD;
+    ps2cdvd.label_mode.spindlctrl = SCECdSpinX4;
+    switch (ps2cdvd.disc_type) {
+    case SCECdPS2CDDA:		/* PS2 CD DA */
+    case SCECdPS2CD:		/* PS2 CD */
+	break;	/* go ahead */
+    case SCECdPSCDDA:		/* PS CD DA */
+    case SCECdPSCD:		/* PS CD */
+	ps2cdvd.label_mode.spindlctrl = SCECdSpinX1;
+	break;	/* go ahead */
+    case SCECdCDDA:		/* CD DA */
+	read_label = 0;
+	break;	/* go ahead */
+    case SCECdPS2DVD:		/* PS2 DVD */
+    case SCECdDVDV:		/* DVD video */
+	media_mode = SCECdDVD;
+	read_toc = 0;
+	break;	/* go ahead */
+    case SCECdDETCTDVDD:	/* DVD-dual detecting */
+    case SCECdDETCTDVDS:	/* DVD-single detecting */
+    case SCECdDETCTCD:		/* CD detecting */
+    case SCECdDETCT:		/* detecting */
+	res = DISC_RETRY;
+	goto error_out;
+    case SCECdNODISC:		/* no disc */
+	res = DISC_NODISC;
+	goto error_out;
+    case SCECdIllgalMedia:	/* illegal media */
+    case SCECdUNKNOWN:		/* unknown */
+	printk(KERN_CRIT "ps2cdvd: illegal media\n");
+	res = DISC_NODISC;
+	goto error_out;
+    default:
+	printk(KERN_CRIT "ps2cdvd: unknown disc type 0x%02x\n",
+	       ps2cdvd.disc_type);
+	res = DISC_NODISC;
+	goto error_out;
+    }
+
+    /*
+     *  get ready
+     */
+    DPRINT(DBG_INFO, "getting ready...\n");
+    if (ps2cdvdcall_ready(0 /* block */) != SCECdComplete) {
+	DPRINT(DBG_DIAG, "ready() failed\n");
+	res = DISC_ERROR;
+	goto error_out;
+    }
+
+    /*
+     *  set media mode
+     */
+    DPRINT(DBG_INFO, "media mode %s\n", media_mode == SCECdCD ? "CD" : "DVD");
+    if (ps2cdvdcall_mmode(media_mode) != 1) {
+	DPRINT(DBG_DIAG, "mmode() failed\n");
+	res = DISC_ERROR;
+	goto error_out;
+    }
+
+    /*
+     *  read TOC
+     */
+    if (read_toc) {
+	struct ps2cdvd_tocentry *toc;
+	int toclen = sizeof(ps2cdvd.tocbuf);
+	memset(ps2cdvd.tocbuf, 0, toclen);
+	if (ps2cdvdcall_gettoc(ps2cdvd.tocbuf, &toclen, &media) != 0) {
+	    DPRINT(DBG_DIAG, "gettoc() failed\n");
+	    res = DISC_ERROR;
+	    goto error_out;
+	}
+
+	ps2cdvd.toc_valid = 1;
+	DPRINT(DBG_DLOCK, "toc is valid\n");
+	toc = (struct ps2cdvd_tocentry *)ps2cdvd.tocbuf;
+	ps2cdvd.leadout_start = msftolba(decode_bcd(toc[2].abs_msf[0]),
+					 decode_bcd(toc[2].abs_msf[1]),
+					 decode_bcd(toc[2].abs_msf[2]));
+#ifdef PS2CDVD_DEBUG
+	if (ps2cdvd_debug & DBG_INFO) {
+	    if (media == 0) {
+		ps2cdvd_tocdump(DBG_LOG_LEVEL "ps2cdvd: ",
+				(struct ps2cdvd_tocentry *)ps2cdvd.tocbuf);
+	    } else {
+		/*
+		 * we have no interrest in DVD Physical format information
+		   ps2cdvd_hexdump(ps2cdvd.tocbuf, toclen);
+		 */
+	    }
+	}
+#endif
+    }
+
+    /*
+     *  read label
+     */
+    if (read_label) {
+	if (ps2cdvd.disc_type == SCECdDVDV) {
+		if (ps2cdvdcall_read_dvd(16, 1, ps2cdvd.labelbuf, &ps2cdvd.label_mode)!=0||
+		    ps2cdvdcall_geterror() != SCECdErNO) {
+		    DPRINT(DBG_DIAG, "read() failed\n");
+		    res = DISC_ERROR;
+		    goto error_out;
+		}
+	} else {
+		if (ps2cdvdcall_read(16, 1, ps2cdvd.labelbuf, &ps2cdvd.label_mode)!=0||
+		    ps2cdvdcall_geterror() != SCECdErNO) {
+		    DPRINT(DBG_DIAG, "read() failed\n");
+		    res = DISC_ERROR;
+		    goto error_out;
+		}
+	}
+	memcpy(ps2cdvd.labelbuf, ps2cdvd.labelbuf + DVD_DATA_OFFSET, DATA_SECT_SIZE);
+	ps2cdvd.label_valid = 1;
+	DPRINT(DBG_DLOCK, "label is valid\n");
+#ifdef PS2CDVD_DEBUG
+	{
+	    struct iso_primary_descriptor *label;
+	    label = (struct iso_primary_descriptor*)ps2cdvd.labelbuf;
+
+	    if (ps2cdvd_debug & DBG_INFO) {
+		printk(DBG_LOG_LEVEL "ps2cdvd: ");
+		ps2cdvd_print_isofsstr(label->system_id,
+				       sizeof(label->system_id));
+		ps2cdvd_print_isofsstr(label->volume_id,
+				       sizeof(label->volume_id));
+		ps2cdvd_print_isofsstr(label->volume_set_id,
+				       sizeof(label->volume_set_id));
+		ps2cdvd_print_isofsstr(label->publisher_id,
+				       sizeof(label->publisher_id));
+		ps2cdvd_print_isofsstr(label->application_id,
+				       sizeof(label->application_id));
+		printk("\n");
+
+		/* ps2cdvd_hexdump(DBG_LOG_LEVEL "ps2cdvd: ", ps2cdvd.labelbuf,
+		   2048);
+		 */
+	    }
+	}
+#endif
+    }
+
+    /*
+     *  check tray count
+     */
+    if (ps2cdvdcall_trayreq(SCECdTrayCheck, &traycount) != 0) {
+	DPRINT(DBG_DIAG, "trayreq() failed\n");
+	res = DISC_ERROR;
+	goto error_out;
+    }
+    if (traycount != 0) {
+	DPRINT(DBG_DIAG, "tray count != 0 (%d)\n", traycount);
+	res = DISC_RETRY;
+	goto error_out;
+    }
+
+    return (DISC_OK);
+
+ error_out:
+    ps2cdvd_invalidate_discinfo();
+
+    return (res);
+}
+
+static int
+spindown(void)
+{
+    struct sceCdRMode mode;
+
+    switch (ps2cdvd.disc_type) {
+    case SCECdPS2CDDA:		/* PS2 CD DA */
+    case SCECdPS2CD:		/* PS2 CD */
+    case SCECdPSCDDA:		/* PS CD DA */
+    case SCECdPSCD:		/* PS CD */
+    case SCECdPS2DVD:		/* PS2 DVD */
+    case SCECdIllgalMedia:	/* illegal media */
+    case SCECdUNKNOWN:		/* unknown */
+	DPRINT(DBG_INFO, "spindown: data\n");
+	mode = ps2cdvd.data_mode;
+	mode.spindlctrl = SCECdSpinX2;
+	if (ps2cdvdcall_read(16, 1, ps2cdvd.databuf, &mode) != 0)
+	    DPRINT(DBG_DIAG, "spindown: data failed\n");
+	ps2cdvd_invalidate_discinfo();
+	break;
+
+    case SCECdDVDV:		/* DVD video */
+	DPRINT(DBG_INFO, "spindown: data\n");
+	mode = ps2cdvd.data_mode;
+	mode.spindlctrl = SCECdSpinX2;
+	if (ps2cdvdcall_read_dvd(16, 1, ps2cdvd.databuf, &mode) != 0)
+	    DPRINT(DBG_DIAG, "spindown: data failed\n");
+	ps2cdvd_invalidate_discinfo();
+	break;
+
+    case SCECdCDDA:		/* CD DA */
+	DPRINT(DBG_INFO, "spindown: CD-DA\n");
+	mode = ps2cdvd.cdda_mode;
+	mode.spindlctrl = SCECdSpinX2;
+	if (ps2cdvdcall_read(16, 1, ps2cdvd.databuf, &mode))
+	    DPRINT(DBG_DIAG, "spindown: CD-DA failed\n");
+	ps2cdvd_invalidate_discinfo();
+	break;
+
+    case SCECdNODISC:		/* no disc */
+	ps2cdvd_invalidate_discinfo();
+	break;
+
+    case INVALID_DISCTYPE:
+    default:
+	/* nothing to do */
+	break;
+    }
+
+    return (0);
+}
+
+int
+ps2cdvd_reset(struct cdrom_device_info *cdi)
+{
+
+    DPRINT(DBG_INFO, "reset\n");
+
+    return (ps2cdvd_command(EV_RESET));
+}
+
+static struct block_device_operations ps2cdvd_bdops =
+{
+	owner:			THIS_MODULE,
+	open:			ps2cdvd_bdops_open,
+	release:		ps2cdvd_bdops_release,
+	media_changed:		ps2cdvd_bdops_mediachanged,
+	locked_ioctl:		ps2cdvd_bdops_ioctl,
+};
+
+static int
+ps2cdvd_bdops_open(struct block_device *bdev, fmode_t mode)
+{
+
+	switch (MINOR(bdev->bd_inode->i_rdev)) {
+#if 0
+	case 255:
+		filp->f_op = &ps2cdvd_altdev_fops; // TBD: check and test
+		break;
+#endif
+	default:
+		return cdrom_open(&ps2cdvd_info, bdev, mode);
+		break;
+	}
+#if 0 // TBD: Check and test
+	if (filp->f_op && filp->f_op->open)
+		return filp->f_op->open(inode,filp);
+#endif
+
+	return 0;
+}
+
+static int ps2cdvd_bdops_release(struct gendisk *disk, fmode_t mode)
+{
+	cdrom_release(&ps2cdvd_info, mode);
+	return 0;
+}
+
+static int ps2cdvd_bdops_mediachanged(struct gendisk *disk)
+{
+	return cdrom_media_changed(&ps2cdvd_info);
+}
+
+static int ps2cdvd_bdops_ioctl(struct block_device *bdev, fmode_t mode, unsigned cmd, unsigned long arg)
+{
+	/* TBD: Call ps2cdvd_dev_ioctl() also. */
+	return cdrom_ioctl(&ps2cdvd_info, bdev, mode, cmd, arg);
+}
+
+static int ps2cdvd_initialized;
+#define PS2CDVD_INIT_BLKDEV	0x0001
+#define PS2CDVD_INIT_CDROM	0x0002
+#define PS2CDVD_INIT_IOPSIDE	0x0004
+#define PS2CDVD_INIT_LABELBUF	0x0008
+#define PS2CDVD_INIT_DATABUF	0x0010
+#define PS2CDVD_INIT_THREAD	0x0020
+
+int __init ps2cdvd_init(void)
+{
+	int res;
+
+	/*
+	 * initialize variables
+	 */
+	init_waitqueue_head(&ps2cdvd.statq);
+	spin_lock_init(&ps2cdvd.state_lock);
+	init_MUTEX_LOCKED(&ps2cdvd.ack_sem);
+	init_MUTEX_LOCKED(&ps2cdvd.wait_sem);
+	init_MUTEX(&ps2cdvd.command_sem);
+	ps2cdvd.ievent = EV_NO_EVENT;
+	ps2cdvd.event = EV_NO_EVENT;
+	spin_lock_init(&ps2cdvd.ievent_lock);
+
+	/*
+	 * CD/DVD SBIOS lock
+	 */
+	DPRINT(DBG_VERBOSE, "init: get lock\n");
+	if ((ps2cdvd.lock = ps2sif_getlock(PS2LOCK_CDVD)) == NULL) {
+		printk(KERN_ERR "ps2cdvd: Can't get lock\n");
+		return (-1);
+	}
+
+	/*
+	 * allocate buffer
+	 */
+	DPRINT(DBG_VERBOSE, "init: allocate disklabel buffer\n");
+	ps2cdvd.labelbuf = kmalloc(DVD_DATA_SECT_SIZE, GFP_KERNEL);
+	if (ps2cdvd.labelbuf == NULL) {
+		printk(KERN_ERR "ps2cdvd: Can't allocate buffer\n");
+		ps2cdvd_cleanup();
+		return (-1);
+	}
+	ps2cdvd_initialized |= PS2CDVD_INIT_LABELBUF;
+
+	DPRINT(DBG_VERBOSE, "allocate buffer\n");
+	ps2cdvd.databufx = kmalloc(ps2cdvd_databuf_size * MAX_AUDIO_SECT_SIZE +
+				   BUFFER_ALIGNMENT, GFP_KERNEL);
+	if (ps2cdvd.databufx == NULL) {
+		printk(KERN_ERR "ps2cdvd: Can't allocate buffer\n");
+		ps2cdvd_cleanup();
+		return (-1);
+	}
+	ps2cdvd.databuf = (void *) ALIGN((unsigned long) ps2cdvd.databufx, BUFFER_ALIGNMENT);
+	ps2cdvd_initialized |= PS2CDVD_INIT_DATABUF;
+
+	/*
+	 * initialize CD/DVD SBIOS
+	 */
+	DPRINT(DBG_VERBOSE, "init: call sbios\n");
+
+	if (ps2cdvd_lock_interruptible("cdvd init") != 0)
+		return (-1);
+	res = ps2cdvdcall_init();
+	if (res) {
+		printk(KERN_ERR "ps2cdvd: Can't initialize CD/DVD-ROM subsystem\n");
+		ps2cdvd_unlock();
+		ps2cdvd_cleanup();
+		return (-1);
+	}
+#ifdef CONFIG_PS2_SBIOS_VER_CHECK
+	if (0x0201 <= sbios(SB_GETVER, NULL))
+		ps2cdvdcall_reset();
+#else
+	ps2cdvdcall_reset();
+#endif
+	ps2cdvd_unlock();
+	ps2cdvd_initialized |= PS2CDVD_INIT_IOPSIDE;
+
+	/*
+	 * start control thread
+	 */
+	ps2cdvd.thread_id = kernel_thread(ps2cdvd_thread, &ps2cdvd, CLONE_VM);
+	if (ps2cdvd.thread_id < 0) {
+		printk(KERN_ERR "ps2cdvd: can't start thread\n");
+		ps2cdvd_cleanup();
+		return (-1);
+	}
+	/* wait for the thread to start */
+	down(&ps2cdvd.ack_sem);
+	ps2cdvd_initialized |= PS2CDVD_INIT_THREAD;
+
+	/*
+	 * register block device
+	 */
+	DPRINT(DBG_VERBOSE, "init: register block device\n");
+	if ((res = register_blkdev(MAJOR_NR, "ps2cdvd")) < 0) {
+		printk(KERN_ERR "ps2cdvd: Unable to get major %d for PS2 CD/DVD-ROM\n",
+		       MAJOR_NR);
+		ps2cdvd_cleanup();
+		return (-1);
+	}
+
+	if (MAJOR_NR == 0) MAJOR_NR = res;
+	ps2cdvd_initialized |= PS2CDVD_INIT_BLKDEV;
+
+	disk = alloc_disk(1);
+	if (!disk) {
+		printk(KERN_ERR "ps2cdvd: Cannot alloc disk\n");
+		ps2cdvd_cleanup();
+		return (-1);
+	}
+	disk->major = MAJOR_NR;
+	disk->first_minor = 0;
+	disk->minors = 256;
+	strcpy(disk->disk_name, "ps2cdvd");
+
+	/*
+	 * register cdrom device
+	 */
+	DPRINT(DBG_VERBOSE, "init: register cdrom\n");
+	ps2cdvd.cdvd_queue = blk_init_queue(ps2cdvd_request, &cdvd_lock);
+       	if (register_cdrom(&ps2cdvd_info) != 0) {
+		printk(KERN_ERR "ps2cdvd: Cannot init queue\n");
+		ps2cdvd_cleanup();
+		return (-1);
+	}
+	disk->fops = &ps2cdvd_bdops;
+	blk_queue_logical_block_size(ps2cdvd.cdvd_queue, DATA_SECT_SIZE);
+	/* Maximum one segment. */
+	blk_queue_max_segments(ps2cdvd.cdvd_queue, 1);
+	blk_queue_max_segment_size(ps2cdvd.cdvd_queue, ps2cdvd_databuf_size * DATA_SECT_SIZE);
+	disk->queue = ps2cdvd.cdvd_queue;
+
+	ps2cdvd_initialized |= PS2CDVD_INIT_CDROM;
+
+	add_disk(disk);
+
+	printk(KERN_INFO "PlayStation 2 CD/DVD-ROM driver\n");
+
+	return (0);
+}
+
+void
+ps2cdvd_cleanup()
+{
+
+	DPRINT(DBG_VERBOSE, "cleanup\n");
+
+	if (ps2cdvd_initialized & PS2CDVD_INIT_THREAD) {
+		DPRINT(DBG_VERBOSE, "stop thread %d\n", ps2cdvd.thread_id);
+		kill_pid(find_get_pid(ps2cdvd.thread_id), SIGKILL, 1);
+		/* wait for the thread to exit */
+		down(&ps2cdvd.ack_sem);
+	}
+
+	ps2cdvd_lock("cdvd_cleanup");
+
+	if (ps2cdvd_initialized & PS2CDVD_INIT_LABELBUF) {
+		DPRINT(DBG_VERBOSE, "free labelbuf %p\n", ps2cdvd.labelbuf);
+		kfree(ps2cdvd.labelbuf);
+	}
+
+	if ((ps2cdvd_initialized & PS2CDVD_INIT_IOPSIDE) &&
+	    (ps2cdvd_initialized & PS2CDVD_INIT_DATABUF)) {
+		spindown();
+	}
+
+	if (ps2cdvd_initialized & PS2CDVD_INIT_DATABUF) {
+		DPRINT(DBG_VERBOSE, "free databuf %p\n", ps2cdvd.databufx);
+		kfree(ps2cdvd.databufx);
+	}
+
+	if (ps2cdvd_initialized & PS2CDVD_INIT_BLKDEV) {
+		DPRINT(DBG_VERBOSE, "unregister block device\n");
+		unregister_blkdev(MAJOR_NR, "ps2cdvd");
+	}
+
+	if (ps2cdvd_initialized & PS2CDVD_INIT_CDROM) {
+		DPRINT(DBG_VERBOSE, "unregister cdrom\n");
+		unregister_cdrom(&ps2cdvd_info);
+	}
+
+	ps2cdvd_initialized = 0;
+	ps2cdvd_unlock();
+
+	if (disk) {
+		del_gendisk(disk);
+		disk = NULL;
+	}
+
+	if (ps2cdvd.cdvd_queue) {
+		blk_cleanup_queue(ps2cdvd.cdvd_queue);
+		ps2cdvd.cdvd_queue = NULL;
+	}
+}
+
+module_init(ps2cdvd_init);
+module_exit(ps2cdvd_cleanup);
+
+MODULE_AUTHOR("Sony Computer Entertainment Inc.");
+MODULE_DESCRIPTION("PlayStation 2 CD/DVD driver");
+MODULE_LICENSE("GPL");
diff -purN linux-2.6.35.4-orig/drivers/ps2/cdvddev.c linux-2.6.35.4/drivers/ps2/cdvddev.c
--- linux-2.6.35.4-orig/drivers/ps2/cdvddev.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/cdvddev.c	2014-07-18 22:29:43.554367724 +0200
@@ -0,0 +1,624 @@
+/*
+ *  PlayStation 2 CD/DVD driver
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define __NO_VERSION__
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include <linux/fs.h>
+#include <linux/timer.h>
+
+#include <asm/uaccess.h>
+
+#include "cdvd.h"
+
+static int ps2cdvd_open(struct cdrom_device_info *, int);
+static void ps2cdvd_release(struct cdrom_device_info *);
+static int ps2cdvd_media_changed(struct cdrom_device_info *, int);
+static int ps2cdvd_tray_move(struct cdrom_device_info *, int);
+static int ps2cdvd_drive_status(struct cdrom_device_info *, int);
+static int ps2cdvd_lock_door(struct cdrom_device_info *, int);
+static int ps2cdvd_select_speed(struct cdrom_device_info *, int);
+static int ps2cdvd_audio_ioctl(struct cdrom_device_info *, unsigned int, void*);
+static int ps2cdvd_dev_ioctl(struct cdrom_device_info *, unsigned int, unsigned long);
+
+static inline int verify_area(int type, const void *addr, unsigned long size)
+{
+	return access_ok(type, addr, size) ? 0 : -EFAULT;
+}
+
+
+static int
+ps2cdvd_open(struct cdrom_device_info * cdi, int purpose)
+{
+
+	DPRINT(DBG_INFO, "open\n");
+
+	return 0;
+}
+
+static void
+ps2cdvd_release(struct cdrom_device_info * cdi)
+{
+	DPRINT(DBG_INFO, "release\n");
+	ps2cdvd_lock("cdvd_release");
+	if (ps2cdvd.stream_start) {
+	  ps2cdvdcall_dastream(PS2CDVD_STREAM_STOP, 0, 0, NULL,
+			       &ps2cdvd.cdda_mode);
+	  ps2cdvd.stream_start = 0;
+	}
+	ps2cdvd_unlock();
+}
+
+static int
+ps2cdvd_media_changed(struct cdrom_device_info * cdi, int disc_nr)
+{
+	int res;
+	ps2cdvd_lock("cdvd_release");
+	res = ps2cdvd.disc_changed ? 1 : 0;
+	ps2cdvd.disc_changed = 0;
+	ps2cdvd_unlock();
+	return res;
+}
+
+static int 
+ps2cdvd_tray_move(struct cdrom_device_info * cdi, int position)
+{
+	int res;
+
+	if ((res = ps2cdvd_lock_interruptible("tray_move")) != 0)
+		return (res);
+	ps2cdvd.traycount++;
+	if (position) {
+		/* open */
+		DPRINT(DBG_INFO, "tray open request\n");
+		res = ps2cdvdcall_trayreq(SCECdTrayOpen, NULL);
+	} else {
+		/* close */
+		DPRINT(DBG_INFO, "tray close request\n");
+		res = ps2cdvdcall_trayreq(SCECdTrayClose, NULL);
+	}
+	ps2cdvd_unlock();
+
+	return (res);
+}
+
+static int
+ps2cdvd_drive_status(struct cdrom_device_info *cdi, int arg)
+{
+	int res;
+
+	/* spinup and re-check disc if the state is in IDLE */
+	if (ps2cdvd_lock_ready() != 0)
+		return CDS_NO_INFO;
+
+	switch (ps2cdvd.state) {
+	case STAT_WAIT_DISC:
+	case STAT_INVALID_DISC:
+		DPRINT(DBG_INFO, "drive_status=NO_DISC\n");
+		res = CDS_NO_DISC;
+		break;
+
+	case STAT_READY:
+	case STAT_READ:
+	case STAT_READ_ERROR_CHECK:
+		DPRINT(DBG_INFO, "drive_status=DISC_OK\n");
+		res = CDS_DISC_OK;
+		break;
+
+	case STAT_ERROR:
+	default:
+		DPRINT(DBG_INFO, "drive_status=NO_INFO\n");
+		res = CDS_NO_INFO;
+		break;
+	}
+	ps2cdvd_unlock();
+
+	return res;
+}
+
+static int
+ps2cdvd_lock_door(struct cdrom_device_info *cdi, int lock)
+{
+	int res;
+
+	if ((res = ps2cdvd_lock_interruptible("tray_move")) != 0)
+		return (res);
+	if (lock) {
+		ps2cdvd.disc_locked = 1;
+		DPRINT(DBG_DLOCK, "disc is locked\n");
+		if (ps2cdvd.label_valid) {
+		  ps2cdvd.disc_lock_key =
+		  	ps2cdvd_checksum((u_long*)ps2cdvd.labelbuf,
+					 2048/sizeof(u_long));
+		  ps2cdvd.disc_lock_key_valid = 1;
+		  DPRINT(DBG_DLOCK, "disc lock key=%lX\n",
+			 ps2cdvd.disc_lock_key);
+		} else {
+		  ps2cdvd.disc_lock_key_valid = 0;
+		  DPRINT(DBG_DLOCK, "disc lock key=****\n");
+		}
+	} else {
+		/* unlock */
+		DPRINT(DBG_DLOCK, "disc is unlocked\n");
+		ps2cdvd.disc_locked = 0;
+	}
+	ps2cdvd_unlock();
+
+	return 0;
+}
+
+static int
+ps2cdvd_select_speed(struct cdrom_device_info *cdi, int speed)
+{
+	int ps2_speed;
+
+	if (speed == 0) {
+	  DPRINT(DBG_INFO, "select speed, Normal\n");
+	  ps2_speed = SCECdSpinNom;
+	} else if (speed == 1) {
+	  DPRINT(DBG_INFO, "select speed, x1\n");
+	  ps2_speed = SCECdSpinX1;
+	} else if (2 <= speed && speed < 4) {
+	  DPRINT(DBG_INFO, "select speed, x2\n");
+	  ps2_speed = SCECdSpinX2;
+	} else if (4 <= speed && speed < 8) {
+	  DPRINT(DBG_INFO, "select speed, x4\n");
+	  ps2_speed = SCECdSpinX4;
+	} else if (8 <= speed && speed <= 12) {
+	  DPRINT(DBG_INFO, "select speed, x12\n");
+	  ps2_speed = SCECdSpinX12;
+	} else if (12 < speed && speed) {
+	  DPRINT(DBG_INFO, "select speed, Max\n");
+	  ps2_speed = SCECdSpinMx;
+	} else {
+	  ps2_speed = SCECdSpinNom;
+	}
+
+	ps2cdvd.data_mode.spindlctrl = ps2_speed;
+	ps2cdvd.cdda_mode.spindlctrl = ps2_speed;
+
+	return 0;
+}
+
+static int
+ps2cdvd_audio_ioctl(struct cdrom_device_info *cdi, unsigned int cmd, void *arg)
+{
+   int res;
+
+   switch (cmd) {
+   case CDROMSTART:     /* Spin up the drive */
+   case CDROMSTOP:      /* Spin down the drive */
+   case CDROMPAUSE:     /* Pause the drive */
+     return 0;	/* just ignore it */
+     break;
+
+   case CDROMRESUME:    /* Start the drive after being paused */
+   case CDROMPLAYMSF:   /* Play starting at the given MSF address. */
+     return -EINVAL;
+     break;
+
+   case CDROMREADTOCHDR:        /* Read the table of contents header */
+      {
+         struct cdrom_tochdr *hdr;
+	 struct ps2cdvd_tocentry *toc = (struct ps2cdvd_tocentry *)ps2cdvd.tocbuf;
+         
+	 if ((res = ps2cdvd_lock_ready()) != 0)
+	   return (res);
+
+	 if (!ps2cdvd.toc_valid) {
+	   DPRINT(DBG_VERBOSE, "TOC is not valid\n");
+	   ps2cdvd_unlock();
+	   return -EIO;
+	 }
+         
+         hdr = (struct cdrom_tochdr *) arg;
+         hdr->cdth_trk0 = decode_bcd(toc[0].abs_msf[0]);
+         hdr->cdth_trk1 = decode_bcd(toc[1].abs_msf[0]);
+	 ps2cdvd_unlock();
+      }
+      return 0;
+
+   case CDROMREADTOCENTRY:      /* Read a given table of contents entry */
+      {
+	 struct ps2cdvd_tocentry *toc = (struct ps2cdvd_tocentry *)ps2cdvd.tocbuf;
+         struct cdrom_tocentry *entry;
+         int idx;
+         
+	 if ((res = ps2cdvd_lock_ready()) != 0)
+	   return (res);
+
+	 if (!ps2cdvd.toc_valid) {
+	   DPRINT(DBG_VERBOSE, "TOC is not valid\n");
+	   ps2cdvd_unlock();
+	   return -EIO;
+	 }
+         
+         entry = (struct cdrom_tocentry *) arg;
+         
+	 if (entry->cdte_track == CDROM_LEADOUT)
+	   entry->cdte_track = 102;
+	 for (idx = 0; idx <= 102; idx++) {
+	   if (decode_bcd(toc[idx].indexno) == entry->cdte_track) break;
+	 }
+	 if (102 < idx) {
+	   DPRINT(DBG_DIAG, "Can't find track %d(0x%02x)\n",
+		  entry->cdte_track, entry->cdte_track);
+	   ps2cdvd_unlock();
+	   return -EINVAL;
+	 }
+
+         entry->cdte_adr = toc[idx].addr;
+         entry->cdte_ctrl = toc[idx].ctrl;
+         
+         /* Logical buffer address or MSF format requested? */
+         if (entry->cdte_format == CDROM_LBA) {
+            entry->cdte_addr.lba = msftolba(toc[idx].abs_msf[0],
+					    toc[idx].abs_msf[1],
+					    toc[idx].abs_msf[2]);
+         } else
+	 if (entry->cdte_format == CDROM_MSF) {
+	   entry->cdte_addr.msf.minute = decode_bcd(toc[idx].abs_msf[0]);
+	   entry->cdte_addr.msf.second = decode_bcd(toc[idx].abs_msf[1]);
+	   entry->cdte_addr.msf.frame = decode_bcd(toc[idx].abs_msf[2]);
+         } else {
+	   ps2cdvd_unlock();
+	   return -EINVAL;
+	 }
+	 ps2cdvd_unlock();
+      }
+      return 0;
+      break;
+
+   case CDROMPLAYTRKIND:     /* Play a track.  This currently ignores index. */
+   case CDROMVOLCTRL:   /* Volume control.  What volume does this change, anyway? */
+   case CDROMSUBCHNL:   /* Get subchannel info */
+   default:
+      return -EINVAL;
+   }
+}
+
+static int
+ps2cdvd_dev_ioctl(struct cdrom_device_info *cdi,
+		    unsigned int  cmd,
+		    unsigned long arg)
+{
+#ifdef PS2CDVD_CDDA
+	int res;
+#endif
+
+	switch (cmd) {
+#ifdef PS2CDVD_CDDA
+	case CDROMREADAUDIO:      /* Read 2352 byte audio tracks and 2340 byte
+				     raw data tracks. */
+	  {
+	    struct cdrom_read_audio param;
+
+	    if ((res = ps2cdvd_lock_ready()) != 0)
+	      return (res);
+
+	    if (!ps2cdvd.toc_valid) {
+	      DPRINT(DBG_DIAG, "TOC is not valid\n");
+	      ps2cdvd_unlock();
+	      return -EIO;
+	    }
+	    ps2cdvd_unlock();
+
+	    if(copy_from_user(&param, (char *)arg, sizeof(param)))
+	      return -EFAULT;
+
+	    if (param.nframes == 0)
+	      return 0;
+
+	    res = verify_area(VERIFY_WRITE, param.buf,
+			      CD_FRAMESIZE_RAW * param.nframes);
+	    if(res < 0) return res;
+
+	    switch (param.addr_format) {
+	    case CDROM_LBA:
+	      break;
+	    case CDROM_MSF:
+	      if (60 <= param.addr.msf.second ||
+		  75 <= param.addr.msf.frame)
+		return -EINVAL;
+	      param.addr.lba = msftolba(param.addr.msf.minute * 4500,
+					param.addr.msf.second * 75,
+					param.addr.msf.frame);
+	      break;
+	    default:
+	      return -EINVAL;
+	    }
+
+
+            if (ps2cdvd.leadout_start <= param.addr.lba ||
+		ps2cdvd.leadout_start < param.addr.lba + param.nframes) {
+	      DPRINT(DBG_DIAG,
+		     "out of range: leadout_start=%ld lba=%d nframes=%d\n",
+		     ps2cdvd.leadout_start, param.addr.lba, param.nframes);
+	      return -EINVAL;
+	    }
+
+	    while (0 < param.nframes) {
+	      if ((res = ps2cdvd_lock_ready()) != 0)
+		return (res);
+	      ps2cdvd.sectoidle = ps2cdvd_spindown;
+	      if (ps2cdvd.databuf_addr <= param.addr.lba &&
+		  param.addr.lba < ps2cdvd.databuf_addr+ps2cdvd.databuf_nsects) {
+		/* we have at least one block in the cache */
+		int off = param.addr.lba - ps2cdvd.databuf_addr;
+		int n = MIN(ps2cdvd.databuf_nsects - off, param.nframes);
+		if (copy_to_user(param.buf, 
+				 ps2cdvd.databuf + AUDIO_SECT_SIZE * off,
+				 AUDIO_SECT_SIZE * n)) {
+		  ps2cdvd_unlock();
+		  return -EFAULT;
+		}
+		param.addr.lba += n;
+		param.nframes -= n;
+		param.buf += AUDIO_SECT_SIZE * n;
+	      } else {
+		/* fill cache */
+		int n;
+
+		/*
+		 * early firmware, before rev. 1.7.0, can't start
+		 * reading at a sector which doesn't have an address
+		 * in it's SUBQ channel. So, you must retry here.
+		 */
+		for (n = 0; n < ps2cdvd_databuf_size; n++) {
+		  ps2cdvd.databuf_nsects = 0;
+		  res = ps2cdvdcall_read(param.addr.lba - n,
+					 ps2cdvd_databuf_size,
+					 ps2cdvd.databuf, &ps2cdvd.cdda_mode);
+		  if (res < 0) {
+		    DPRINT(DBG_DIAG, "ps2cdvdcall_read() failed\n");
+		    res = -EIO;
+		    break;
+		  }
+		  if ((res = ps2cdvdcall_geterror()) == SCECdErNO) {
+		    ps2cdvd.databuf_addr = param.addr.lba - n;
+		    ps2cdvd.databuf_nsects = ps2cdvd_databuf_size;
+		    res = 0;
+		    break;
+		  }
+		  if (param.addr.lba - n == 0) {
+		    res = -EIO;
+		    break;
+		  }
+		  if (signal_pending(current)) {
+		    res = -ERESTART;
+		    break;
+		  }
+		  if (res != SCECdErEOM) {
+		    DPRINT(DBG_DIAG, "error=%d, retry on sector %d-%d\n",
+			   res, param.addr.lba, n + 1);
+		  }
+		  res = -EIO;
+		}
+		if (res != 0) {
+		  ps2cdvd_unlock();
+		  return (res);
+		}
+	      }
+	      ps2cdvd_unlock();
+	    }
+	    return 0;
+	  }
+	  break;
+	case PS2CDVDIO_DASTREAM: 
+	  {
+	    struct ps2cdvd_dastream_command param;
+	    int size, sectsize;
+
+	    if ((res = ps2cdvd_lock_ready()) != 0)
+	      return (res);
+
+	    if (!ps2cdvd.toc_valid) {
+	      DPRINT(DBG_DIAG, "TOC is not valid\n");
+	      ps2cdvd_unlock();
+	      return -EIO;
+	    }
+	    ps2cdvd_unlock();
+
+	    if(copy_from_user(&param, (char *)arg, sizeof(param)))
+	      return -EFAULT;
+
+	    switch(param.rmode.datapattern){
+	    case SCECdSecS2352:	sectsize = 2352; break;
+	    case SCECdSecS2368:	sectsize = 2368; break;
+	    case SCECdSecS2448: sectsize = 2448; break;
+	    default:		sectsize = 2352; break;
+	    }
+	    size = MIN(ps2cdvd_databuf_size,param.sectors) * sectsize;
+
+	    /*
+	     * get the lock and call SBIOS
+	     */
+	    ps2cdvd_lock("cdvd_dastream");
+	    ps2cdvd.databuf_nsects = 0;
+	    res = ps2cdvdcall_dastream(param.command, param.lbn, size,
+				       ps2cdvd.databuf, &param.rmode);
+	    if (param.command == PS2CDVD_STREAM_START ||
+		param.command == PS2CDVD_STREAM_SEEK)
+	      ps2cdvd.stream_start = 1;
+	    if (param.command == PS2CDVD_STREAM_STOP)
+	      ps2cdvd.stream_start = 0;
+	    ps2cdvd_unlock();
+	    if(res < 0) return -EIO;
+
+	    param.result = res;
+	    if (0 < res) {
+	      if (param.command == PS2CDVD_STREAM_READ) {
+		res = verify_area(VERIFY_WRITE, param.buf, param.result);
+		if(res < 0) return res;
+	      }
+	      copy_to_user(param.buf, ps2cdvd.databuf, param.result);
+	    }
+
+	    return (copy_to_user((char*)arg, &param, sizeof(param))?-EFAULT:0);
+	  }
+
+	  break;
+	case PS2CDVDIO_READSUBQ: 
+	  {
+	    struct ps2cdvd_subchannel param;
+
+	    if(copy_from_user(&param, (char*)arg, sizeof(param)))
+	      return -EFAULT;
+	    if ((res = ps2cdvd_lock_interruptible("cdvd_readsubq")) != 0)
+		return (res);
+	    res = ps2cdvdcall_readsubq(param.data, &param.stat);
+	    ps2cdvd_unlock();
+	    if (res < 0)
+	      return -EIO;
+
+	    return (copy_to_user((char*)arg, &param, sizeof(param))?-EFAULT:0);
+	  }
+	  break;
+#endif /* PS2CDVD_CDDA */
+
+	case PS2CDVDIO_READMODE1:
+	  {
+	    ps2cdvd_read cdvdread;
+	    int res;
+
+	    if(copy_from_user(&cdvdread, (char*)arg, sizeof(cdvdread)))
+	      return -EFAULT;
+
+	    if (ps2cdvd_databuf_size < cdvdread.sectors)
+	      return -EINVAL;
+
+    	    if ((res = ps2cdvd_lock_ready()) != 0) 
+    	      return (res); 
+	    ps2cdvd.databuf_nsects = 0;
+	    res = ps2cdvdcall_read(cdvdread.lbn, cdvdread.sectors,
+				   ps2cdvd.databuf, &ps2cdvd.data_mode);
+	    if (res < 0) {
+	      DPRINT(DBG_DIAG, "ps2cdvdcall_read() failed\n");
+	      res = -EIO;
+	      goto readmode1_out;
+	    }
+	    if (ps2cdvdcall_geterror() != SCECdErNO) {
+	      res = -EIO;
+	      goto readmode1_out;
+	    }
+	    if (copy_to_user((char *)cdvdread.buf, ps2cdvd.databuf,
+			     cdvdread.sectors * DATA_SECT_SIZE))
+	      res = -EFAULT;
+	    
+	  readmode1_out:
+	    ps2cdvd_unlock();
+	    return res;
+	  }
+	  break;
+	case PS2CDVDIO_CHANGETRYCNT:
+	  {
+	    if ((res = ps2cdvd_lock_interruptible("change_retrycount")) != 0)
+	      return (res);
+	    ps2cdvd.data_mode.trycount = arg;
+	    ps2cdvd.cdda_mode.trycount = arg;
+	    ps2cdvd_unlock();
+	    return 0;
+	  }
+	  break;
+	}
+
+	return ps2cdvd_common_ioctl(cmd, arg);
+}
+
+int
+ps2cdvd_common_ioctl(unsigned int  cmd, unsigned long arg)
+{
+	int res;
+
+	switch (cmd) {
+	case CDROM_SELECT_SPEED:
+	    if ((res = ps2cdvd_lock_interruptible("select_speed")) != 0)
+		return (res);
+	    res = ps2cdvd_select_speed(NULL, arg);
+	    ps2cdvd_unlock();
+	    return (res);
+
+	case PS2CDVDIO_GETDISCTYPE:
+	  {
+	    int type;
+
+	    if ((res = ps2cdvd_lock_interruptible("getdisctype")) != 0)
+		return (res);
+	    res = ps2cdvdcall_gettype(&type);
+	    ps2cdvd_unlock();
+	    if (res < 0)
+	      return -EIO;
+
+	    return (copy_to_user((char*)arg, &type, sizeof(type))?-EFAULT:0);
+	  }
+	  break;
+	case PS2CDVDIO_RCBYCTL:
+	  {
+	    struct ps2cdvd_rcbyctl rcbyctl;
+
+	    if (copy_from_user(&rcbyctl, (char *)arg, sizeof(rcbyctl)))
+		return -EFAULT;
+	    if ((res = ps2cdvd_lock_interruptible("rcbyctl")) != 0)
+		return (res);
+
+	    if (ps2cdvdcall_rcbyctl(rcbyctl.param, &rcbyctl.stat) != 1) {
+		printk(KERN_ERR "ps2cdvdstat: failed rcbyctl\n");
+		ps2cdvd_unlock();
+		return -EIO;
+	    }
+	    ps2cdvd_unlock();
+	    if (copy_to_user((char*)arg, &rcbyctl, sizeof(rcbyctl)))
+		return -EFAULT;
+	    return 0;
+	  }
+	  break;
+	}
+
+	return -EINVAL;
+}
+
+struct cdrom_device_ops ps2cdvd_dops = {
+	open:			ps2cdvd_open,
+	release:		ps2cdvd_release,
+	drive_status:		ps2cdvd_drive_status,
+	media_changed:		ps2cdvd_media_changed,
+	tray_move:		ps2cdvd_tray_move,
+	lock_door:		ps2cdvd_lock_door,
+	select_speed:		ps2cdvd_select_speed,
+	reset:			ps2cdvd_reset,
+	audio_ioctl:		ps2cdvd_audio_ioctl,
+#if 0 // TBD: Check
+	dev_ioctl:		ps2cdvd_dev_ioctl,
+#endif
+	capability:		CDC_OPEN_TRAY | CDC_LOCK | CDC_SELECT_SPEED |
+				CDC_MEDIA_CHANGED | CDC_RESET |
+				CDC_PLAY_AUDIO | CDC_DRIVE_STATUS,
+	n_minors:		1,
+};
+
+struct cdrom_device_info ps2cdvd_info = {
+	ops:			&ps2cdvd_dops,
+	speed:			2,
+	capacity:		1,
+	name:			"ps2cdvd",
+};
diff -purN linux-2.6.35.4-orig/drivers/ps2/cdvd.h linux-2.6.35.4/drivers/ps2/cdvd.h
--- linux-2.6.35.4-orig/drivers/ps2/cdvd.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/cdvd.h	2014-07-18 22:29:43.554367724 +0200
@@ -0,0 +1,212 @@
+/*
+ *  PlayStation 2 CD/DVD driver
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef PS2CDVD_H
+#define PS2CDVD_H
+
+#include <linux/cdrom.h>
+
+#include <asm/mach-ps2/sifdefs.h>
+#include <asm/mach-ps2/siflock.h>
+#include <asm/mach-ps2/cdrom.h>
+#include "libcdvd.h"
+#include <asm/mach-ps2/cdvdcall.h>
+
+/*
+ * macro defines
+ */
+#define PS2CDVD_DEBUG
+#ifdef PS2CDVD_DEBUG
+#define DBG_VERBOSE	(1<< 0)
+#define DBG_DIAG	(1<< 1)
+#define DBG_READ	(1<< 2)
+#define DBG_INFO	(1<< 3)
+#define DBG_STATE	(1<< 4)
+#define DBG_LOCK	(1<< 5)
+#define DBG_DLOCK	(1<< 6)
+#define DBG_IOPRPC	(1<< 7)
+
+#define DBG_LOG_LEVEL	KERN_CRIT
+#define DBG_DEFAULT_FLAGS DBG_DIAG
+
+#define DPRINT(mask, fmt, args...) \
+	if (ps2cdvd_debug & (mask)) printk(DBG_LOG_LEVEL "ps2cdvd: " fmt, ## args)
+#define DPRINTK(mask, fmt, args...) \
+	if (ps2cdvd_debug & (mask)) printk(fmt, ## args)
+#else
+#define DBG_DEFAULT_FLAGS 0
+#define DPRINT(mask, fmt, args...) do {} while(0)
+#define DPRINTK(mask, fmt, args...) do {} while(0)
+#endif
+
+#define ARRAYSIZEOF(a)	(sizeof(a)/sizeof(*(a)))
+#define MIN(a, b)	((a) < (b) ? (a) : (b))
+
+#define PS2CDVD_CDDA
+
+#define DATA_SECT_SIZE	2048
+#define AUDIO_SECT_SIZE	2352
+#define MAX_AUDIO_SECT_SIZE	2448
+
+#define SEND_BUSY	0
+#define SEND_NOWAIT	1
+#define SEND_BLOCK	2
+
+enum {
+	EV_NO_EVENT,
+	EV_START,
+	EV_TIMEOUT,
+	EV_EXIT,
+	EV_RESET,
+};
+
+enum {
+	STAT_INIT,
+	STAT_WAIT_DISC,
+	STAT_INVALID_DISC,
+	STAT_CHECK_DISC,
+	STAT_READY,
+	STAT_ERROR,
+	STAT_IDLE,
+
+	/* obsolete */
+	STAT_INIT_TRAYSTAT,
+	STAT_CHECK_DISCTYPE,
+	STAT_INIT_CHECK_READY,
+	STAT_SET_MMODE,
+	STAT_TOC_READ,
+	STAT_LABEL_READ,
+	STAT_LABEL_READ_ERROR_CHECK,
+	STAT_CHECK_TRAY,
+	STAT_READ,
+	STAT_READ_EOM_RETRY,
+	STAT_READ_ERROR_CHECK,
+	STAT_SPINDOWN,
+};
+
+/*
+ * types
+ */
+struct ps2cdvd_tocentry {
+	unsigned char addr:4;
+	unsigned char ctrl:4;
+	unsigned char trackno;
+	unsigned char indexno;
+	unsigned char rel_msf[3];
+	unsigned char zero;
+	unsigned char abs_msf[3];
+};
+
+struct ps2cdvd_ctx {
+	volatile int		state;
+	spinlock_t		state_lock;
+	wait_queue_head_t 	statq;
+	ps2sif_lock_t		*lock;
+	struct sceCdRMode	label_mode;
+	struct sceCdRMode	data_mode;
+	struct sceCdRMode	cdda_mode;
+
+	volatile int		traycount;
+
+	volatile int		disc_locked;
+	volatile int		disc_lock_key_valid;
+	volatile unsigned long	disc_lock_key;
+	volatile int		label_valid;
+	unsigned char		*labelbuf;
+	volatile int		toc_valid;
+	unsigned char		tocbuf[1024];
+
+	volatile int		disc_changed;
+	volatile int		disc_type;
+	long			leadout_start;
+	int			stream_start;
+	volatile int		sectoidle;
+
+	unsigned char		*databuf;
+	unsigned char		*databufx;
+	int			databuf_addr;
+	int			databuf_nsects;
+
+	struct semaphore	ack_sem;
+	struct semaphore	command_sem;
+	struct semaphore	wait_sem;
+	volatile int		ievent, event;
+	spinlock_t		ievent_lock;
+	int			thread_id;
+	struct request_queue	*cdvd_queue;
+};
+
+/*
+ * function prototypes
+ */
+char* ps2cdvd_geterrorstr(int);
+char* ps2cdvd_getdisctypestr(int);
+void ps2cdvd_tocdump(char*, struct ps2cdvd_tocentry *);
+void ps2cdvd_hexdump(char*, unsigned char *, int);
+unsigned long ps2cdvd_checksum(unsigned long *data, int len);
+void ps2cdvd_print_isofsstr(char *str, int len);
+char* ps2cdvd_geteventstr(int no);
+char* ps2cdvd_getstatestr(int no);
+
+void ps2cdvd_lock(char *);
+int ps2cdvd_lock_interruptible(char *);
+void ps2cdvd_unlock(void);
+int ps2cdvd_reset(struct cdrom_device_info *);
+int ps2cdvd_lock_ready(void);
+int ps2cdvd_common_ioctl(unsigned int, unsigned long);
+
+/*
+ * variables
+ */
+extern struct ps2cdvd_ctx ps2cdvd;
+extern struct file_operations ps2cdvd_altdev_fops;
+extern struct cdrom_device_ops ps2cdvd_dops;
+extern struct cdrom_device_info ps2cdvd_info;
+
+extern int ps2cdvd_check_interval;
+extern int ps2cdvd_databuf_size;
+extern int ps2cdvd_debug;
+extern int ps2cdvd_immediate_ioerr;
+extern int ps2cdvd_major;
+extern int ps2cdvd_read_ahead;
+extern int ps2cdvd_spindown;
+extern int ps2cdvd_wrong_disc_retry;
+
+/*
+ * utilities
+ */
+static inline int decode_bcd(int bcd) {
+	return ((bcd >> 4) & 0x0f) * 10 + (bcd & 0x0f);
+}
+
+static inline long msftolba(int m, int s, int f)
+{
+	return (m) * 4500 + (s) * 75 + (f) - 150;
+}
+
+static inline void lbatomsf(long lba, int *m, int *s, int *f)
+{
+	lba += 150;
+	*m = (lba / 4500);
+	*s = (lba % 4500) / 75;
+	*f = (lba % 75);
+}
+
+#endif /* PS2CDVD_H */
diff -purN linux-2.6.35.4-orig/drivers/ps2/cdvdutil.c linux-2.6.35.4/drivers/ps2/cdvdutil.c
--- linux-2.6.35.4-orig/drivers/ps2/cdvdutil.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/cdvdutil.c	2014-07-18 22:29:43.554367724 +0200
@@ -0,0 +1,236 @@
+/*
+ *  PlayStation 2 CD/DVD driver
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define __NO_VERSION__
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include <linux/fs.h>
+#include <linux/timer.h>
+
+#include "cdvd.h"
+
+/* error strings */
+char *ps2cdvd_errors[] = {
+	[SCECdErNO]	= "no error",
+	[SCECdErEOM]	= "end of media",
+	[SCECdErTRMOPN]	= "terminated by user",
+	[SCECdErREAD]	= "read error",
+	[SCECdErPRM]	= "parameter error",
+	[SCECdErILI]	= "invalid lendth",
+	[SCECdErIPI]	= "invalid address",
+	[SCECdErCUD]	= "inappropriate disc",
+	[SCECdErNORDY]	= "not ready",
+	[SCECdErNODISC]	= "no disc",
+	[SCECdErOPENS]	= "open tray",
+	[SCECdErCMD]	= "command not supported",
+	[SCECdErABRT]	= "aborted",
+};
+
+/* disc type names */
+char *ps2cdvd_disctypes[] = {
+	[SCECdIllgalMedia]	= "illegal media",
+	[SCECdDVDV]		= "DVD video",
+	[SCECdCDDA]		= "CD DA",
+	[SCECdPS2DVD]		= "PS2 DVD",
+	[SCECdPS2CDDA]		= "PS2 CD DA",
+	[SCECdPS2CD]		= "PS2 CD",
+	[SCECdPSCDDA]		= "PS CD DA",
+	[SCECdPSCD]		= "PS CD",
+	[SCECdUNKNOWN]		= "unknown",
+	[SCECdDETCTDVDD]	= "DVD-dual detecting",
+	[SCECdDETCTDVDS]	= "DVD-single detecting",
+	[SCECdDETCTCD]		= "CD detecting",
+	[SCECdDETCT]		= "detecting",
+	[SCECdNODISC]		= "no disc",
+};
+
+/* event names */
+char *ps2cdvd_events[] = {
+	[EV_NO_EVENT]		= "NONE",
+	[EV_START]		= "START",
+	[EV_TIMEOUT]		= "TIMEOUT",
+	[EV_EXIT]		= "EXIT",
+	[EV_RESET]		= "RESET",
+};
+
+/* state names */
+char *ps2cdvd_states[] = {
+	[STAT_INIT]			= "INIT",
+	[STAT_WAIT_DISC]		= "WAIT_DISC",
+	[STAT_INVALID_DISC]		= "INVALID_DISC",
+	[STAT_CHECK_DISC]		= "CHECK_DISC",
+	[STAT_READY]			= "READY",
+	[STAT_ERROR]			= "ERROR",
+	[STAT_IDLE]			= "IDLE",
+
+	/* obsolete */
+	[STAT_INIT_TRAYSTAT]		= "INIT_TRAYSTAT",
+	[STAT_CHECK_DISCTYPE]		= "CHECK_DISCTYPE",
+	[STAT_INIT_CHECK_READY]		= "INIT_CHECK_READY",
+	[STAT_SET_MMODE]		= "SET_MMODE",
+	[STAT_TOC_READ]			= "TOC_READ",
+	[STAT_LABEL_READ]		= "LABEL_READ",
+	[STAT_LABEL_READ_ERROR_CHECK]	= "LABEL_READ_ERROR_CHECK",
+	[STAT_CHECK_TRAY]		= "CHECK_TRAY",
+	[STAT_READ]			= "READ",
+	[STAT_READ_EOM_RETRY]		= "READ_EOM_RETRY",
+	[STAT_READ_ERROR_CHECK]		= "READ_ERROR_CHECK",
+	[STAT_SPINDOWN]			= "SPINDOWN",
+};
+
+unsigned long
+ps2cdvd_checksum(unsigned long *data, int len)
+{
+	unsigned long sum = 0;
+
+	while (len--) {
+		sum += *data++;
+		sum = ((sum << 24) | sum >> 8);
+		sum ^= (sum % (len + 1));
+	}
+
+	return sum;
+}
+
+void
+ps2cdvd_print_isofsstr(char *str, int len)
+{
+	int i;
+	int space = 0;
+	for (i = 0;i < len; i++) {
+	  if (*str == ' ') {
+	    if (!space) {
+	      space = 1;
+	      printk("%c", *str++);
+	    }
+	  } else {
+	    space = 0;
+	    printk("%c", *str++);
+	  }
+	}
+}
+
+char*
+ps2cdvd_geterrorstr(int no)
+{
+	static char buf[32];
+	if (0 <= no && no < ARRAYSIZEOF(ps2cdvd_errors) &&
+	    ps2cdvd_errors[no]) {
+		return ps2cdvd_errors[no];
+	} else {
+		sprintf(buf, "unknown error(0x%02x)", no);
+		return buf;
+	}
+}
+
+char*
+ps2cdvd_getdisctypestr(int no)
+{
+	static char buf[32];
+	if (0 <= no && no < ARRAYSIZEOF(ps2cdvd_disctypes) &&
+	    ps2cdvd_disctypes[no]) {
+		return ps2cdvd_disctypes[no];
+	} else {
+		sprintf(buf, "unknown type(0x%02x)", no);
+		return buf;
+	}
+}
+
+char*
+ps2cdvd_geteventstr(int no)
+{
+	static char buf[32];
+	if (0 <= no && no < ARRAYSIZEOF(ps2cdvd_events) &&
+	    ps2cdvd_events[no]) {
+		return ps2cdvd_events[no];
+	} else {
+		sprintf(buf, "unknown event(0x%02x)", no);
+		return buf;
+	}
+}
+
+char*
+ps2cdvd_getstatestr(int no)
+{
+	static char buf[32];
+	if (0 <= no && no < ARRAYSIZEOF(ps2cdvd_states) &&
+	    ps2cdvd_states[no]) {
+		return ps2cdvd_states[no];
+	} else {
+		sprintf(buf, "unknown state(0x%02x)", no);
+		return buf;
+	}
+}
+
+void
+ps2cdvd_hexdump(char *header, unsigned char *data, int len)
+{
+	int i;
+	char *hex = "0123456789abcdef";
+	char line[70];
+
+	for (i = 0; i < len; i++) {
+		int o = i % 16;
+		if (o == 0) {
+			memset(line, ' ', sizeof(line));
+			line[sizeof(line) - 1] = '\0';
+		}
+		line[o * 3 + 0] = hex[(data[i] & 0xf0) >> 4];
+		line[o * 3 + 1] = hex[(data[i] & 0x0f) >> 0];
+		if (0x20 <= data[i] && data[i] < 0x7f) {
+			line[o + 50] = data[i];
+		} else {
+			line[o + 50] = '.';
+		}
+		if (o == 15) {
+			printk("%s%s\n", header, line);
+		}
+	}
+}
+
+void
+ps2cdvd_tocdump(char *header, struct ps2cdvd_tocentry *tocents)
+{
+  int i, startno, endno;
+
+  startno = decode_bcd(tocents[0].abs_msf[0]);
+  endno = decode_bcd(tocents[1].abs_msf[0]);
+  printk("%strack: %d-%d  lead out: %02d:%02d:%02d\n",
+	 header, startno, endno, 
+	 decode_bcd(tocents[2].abs_msf[0]),
+	 decode_bcd(tocents[2].abs_msf[1]),
+	 decode_bcd(tocents[2].abs_msf[2]));
+  tocents += 2;
+  printk("%saddr/ctrl track index min/sec/frame\n", header);
+  for (i = startno; i <= endno; i++) {
+    printk("%s   %x/%x    %02d    %02d    %02d:%02d:%02d\n",
+	   header,
+	   tocents[i].addr,
+	   tocents[i].ctrl,
+	   decode_bcd(tocents[i].trackno),
+	   decode_bcd(tocents[i].indexno),
+	   decode_bcd(tocents[i].abs_msf[0]),
+	   decode_bcd(tocents[i].abs_msf[1]),
+	   decode_bcd(tocents[i].abs_msf[2]));
+  }
+}
diff -purN linux-2.6.35.4-orig/drivers/ps2/iopmem.c linux-2.6.35.4/drivers/ps2/iopmem.c
--- linux-2.6.35.4-orig/drivers/ps2/iopmem.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/iopmem.c	2014-07-18 22:29:43.554367724 +0200
@@ -0,0 +1,147 @@
+/*
+ *  PlayStation 2 IOP memory management utility
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <asm/mach-ps2/sbios.h>
+#include <asm/mach-ps2/sifdefs.h>
+
+#include "iopmem.h"
+
+#ifdef PS2IOPMEM_DEBUG
+#define DPRINT(fmt...) do { printk("ps2iopmem: " fmt); } while (0)
+#else
+#define DPRINT(fmt...) do {} while (0)
+#endif
+
+#define HANDLE(idx, off)	(((((idx)+1)&0xff)<<24)|((off)&0x00ffffff))
+#define INDEX(hdl)		((((hdl) >> 24) & 0xff)-1)
+#define OFFSET(hdl)		((hdl) & 0x00ffffff)
+
+void
+ps2iopmem_init(struct ps2iopmem_list *iml)
+{
+	int i;
+
+	init_MUTEX(&iml->lock);
+
+	/* cleanup */
+	for (i = 0; i < PS2IOPMEM_MAXMEMS; i++)
+		iml->mems[i].addr = 0;
+}
+
+void
+ps2iopmem_end(struct ps2iopmem_list *iml)
+{
+	int i;
+
+	down(&iml->lock);
+
+	/* free iopmem */
+	for (i = 0; i < PS2IOPMEM_MAXMEMS; i++) {
+		if (iml->mems[i].addr != 0) {
+			DPRINT("end: free %d bytes on IOP 0x%lx\n",
+			       iml->mems[i].size,
+			       iml->mems[i].addr);
+			ps2sif_freeiopheap(iml->mems[i].addr);
+			iml->mems[i].addr = 0; /* failsafe */
+		}
+	}
+
+	up(&iml->lock);
+}
+
+int
+ps2iopmem_alloc(struct ps2iopmem_list *iml, int size)
+{
+	int i;
+
+	down(&iml->lock);
+
+	/* search free entry */
+	for (i = 0; i < PS2IOPMEM_MAXMEMS; i++)
+		if (iml->mems[i].addr == 0)
+			break;
+	if (PS2IOPMEM_MAXMEMS <= i) {
+		up(&iml->lock);
+		DPRINT("alloc: list is full\n");
+		return (0);
+	}
+
+	iml->mems[i].addr = (int)ps2sif_allociopheap(size);
+	if(iml->mems[i].addr == 0) {
+		up(&iml->lock);
+		DPRINT("alloc: can't alloc iop heap\n");
+		return (0);
+	}
+	iml->mems[i].size = size;
+	up(&iml->lock);
+	DPRINT("alloc %d bytes on IOP 0x%lx, idx=%d\n",
+	       iml->mems[i].size, iml->mems[i].addr, i);
+
+	return (HANDLE(i, 0));
+}
+
+void
+ps2iopmem_free(struct ps2iopmem_list *iml, int hdl)
+{
+	int i;
+
+	down(&iml->lock);
+	i = INDEX(hdl);
+	if (i < 0 || PS2IOPMEM_MAXMEMS <= i || OFFSET(hdl) != 0 ||
+	    iml->mems[i].addr == 0) {
+		up(&iml->lock);
+		DPRINT("free: invalid handle 0x%08x\n", hdl);
+		return;
+	}
+	DPRINT("free %d bytes on IOP 0x%lx\n",
+	       iml->mems[i].size,
+	       iml->mems[i].addr);
+	ps2sif_freeiopheap(iml->mems[i].addr);
+	iml->mems[i].addr = 0; /* failsafe */
+	up(&iml->lock);
+}
+
+unsigned long
+ps2iopmem_getaddr(struct ps2iopmem_list *iml, int hdl, int size)
+{
+	int i;
+
+	down(&iml->lock);
+	i = INDEX(hdl);
+	if (i < 0 || PS2IOPMEM_MAXMEMS <= i || iml->mems[i].addr == 0) {
+		up(&iml->lock);
+		DPRINT("getaddr: invalid handle 0x%08x, idx=%d\n", hdl, i);
+		return (0);
+	}
+
+	if (iml->mems[i].size < OFFSET(hdl) + size) {
+		up(&iml->lock);
+		DPRINT("getaddr: offset+size is out of range,"
+		       "hdl=0x%08x size=%d\n", hdl, size);
+		return (0);
+	}
+	up(&iml->lock);
+
+	return (iml->mems[i].addr + OFFSET(hdl));
+}
diff -purN linux-2.6.35.4-orig/drivers/ps2/iopmem.h linux-2.6.35.4/drivers/ps2/iopmem.h
--- linux-2.6.35.4-orig/drivers/ps2/iopmem.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/iopmem.h	2014-07-18 22:29:43.554367724 +0200
@@ -0,0 +1,45 @@
+/*
+ *  PlayStation 2 IOP memory management utility
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __PS2_IOPMEM_H
+#define __PS2_IOPMEM_H
+
+#include <linux/kernel.h>
+#include <linux/semaphore.h>
+
+#define PS2IOPMEM_MAXMEMS	16
+
+struct ps2iopmem_entry {
+	dma_addr_t addr;
+	int size;
+};
+
+struct ps2iopmem_list {
+	struct semaphore	lock;
+	struct ps2iopmem_entry	mems[PS2IOPMEM_MAXMEMS];
+};
+
+void ps2iopmem_init(struct ps2iopmem_list *);
+void ps2iopmem_end(struct ps2iopmem_list *);
+int ps2iopmem_alloc(struct ps2iopmem_list *iml, int size);
+void ps2iopmem_free(struct ps2iopmem_list *iml, int hdl);
+unsigned long ps2iopmem_getaddr(struct ps2iopmem_list *, int hdl, int size);
+
+#endif /* __PS2_IOPMEM_H */
diff -purN linux-2.6.35.4-orig/drivers/ps2/joystick.c linux-2.6.35.4/drivers/ps2/joystick.c
--- linux-2.6.35.4-orig/drivers/ps2/joystick.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/joystick.c	2014-07-18 22:29:43.554367724 +0200
@@ -0,0 +1,243 @@
+/*
+ *  PlayStation 2 Game Controller driver
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <asm/io.h>
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/isapnp.h>
+#include <linux/stddef.h>
+#include <linux/delay.h>
+
+#include <linux/kernel.h>
+#include <linux/input.h>
+
+#include "pad.h"
+#include "padcall.h"
+
+
+#define PS2JS_REFRESH	HZ/50	/* Time between joystick polls [20 ms] */
+#define PS2JS_AXES 	2
+#define PS2JS_PADS 	10
+#define PS2JS_LENS 	18
+#define DIGITAL     	0
+#define ANALOG      	1
+
+char ps2name[PS2PAD_MAXNPADS][64];
+struct ps2js *ps2js_ptr[PS2PAD_MAXNPADS];
+
+static unsigned char ps2js_abs[] = { ABS_X, ABS_Y};
+static short ps2js_btn_pad[] = { BTN_TL2, BTN_TR2, BTN_TL, BTN_TR, 
+				 BTN_X, BTN_Y, BTN_B, BTN_A,  
+				 BTN_START, BTN_SELECT };
+
+struct ps2js {
+	struct timer_list timer;
+	struct input_dev *dev;
+	int reads;
+	int used;
+	unsigned char id;
+	unsigned char length;
+        int axes_X;
+        int axes_Y;
+        int analog_switch;
+        int port;
+        int slot;
+};
+
+
+static void ps2js_read(struct ps2js *ps2js)
+{
+	struct input_dev *dev = ps2js->dev;
+	int j, res;
+	u_char js_data[PS2PAD_DATASIZE];
+	int new_dig_X, new_dig_Y;
+
+
+	res = ps2padlib_GetState(ps2js->port,ps2js->slot);
+	if (res != PadStateFindCTP1 && res != PadStateStable) {
+		return;
+	}
+
+	res = ps2padlib_Read(ps2js->port, ps2js->slot, js_data);
+
+
+	/* input key */
+	for (j = 0; j < 8; j++)
+		input_report_key(dev, ps2js_btn_pad[j], (~js_data[3] & (1 << j)) ? 1:0);
+	input_report_key(dev, BTN_START,  (~js_data[2] & 0x08)?1:0);
+	input_report_key(dev, BTN_SELECT, (~js_data[2] & 0x01)?1:0);
+	
+
+	/* input abs */
+	new_dig_X = 128 + !(js_data[2] & 0x20) * 127 - !(js_data[2] & 0x80) * 128;
+	new_dig_Y = 128 + !(js_data[2] & 0x40) * 127 - !(js_data[2] & 0x10) * 128;
+
+	if ((js_data[1] & 0xf) <= 1) {     // digital input
+	  	if (ps2js->analog_switch == ANALOG) {    // analog --> digital 
+		  new_dig_X = 128;
+		  new_dig_Y = 128;
+		}
+		input_report_abs(dev, ABS_X, new_dig_X);
+		input_report_abs(dev, ABS_Y, new_dig_Y);
+	  
+		ps2js->axes_X = new_dig_X;
+		ps2js->axes_Y = new_dig_Y;
+		ps2js->analog_switch = DIGITAL;
+	}
+	else {                             // analog input
+	  	if ((new_dig_X != ps2js->axes_X) || (new_dig_Y != ps2js->axes_Y)) {
+			input_report_abs(dev, ABS_X, new_dig_X);
+			input_report_abs(dev, ABS_Y, new_dig_Y);
+		}
+		else {
+			input_report_abs(dev, ABS_X, js_data[6]);
+			input_report_abs(dev, ABS_Y, js_data[7]);
+		}
+
+		ps2js->axes_X = new_dig_X;
+		ps2js->axes_Y = new_dig_Y;
+		ps2js->analog_switch = ANALOG;
+	}
+}
+
+
+/*
+ * ps2js_timer() reads and analyzes joystick data.
+ */
+
+static void ps2js_timer(unsigned long private)
+{
+	struct ps2js *ps2js = (void *) private;
+
+	ps2js->reads++;
+	ps2js_read(ps2js);
+	mod_timer(&ps2js->timer, jiffies + PS2JS_REFRESH);
+}
+
+
+static int ps2js_open(struct input_dev *dev)
+{
+	struct ps2js *ps2js = input_get_drvdata(dev);
+	int i;
+
+	if (!ps2js->used++) {
+		mod_timer(&ps2js->timer, jiffies + PS2JS_REFRESH);	
+		for (i = 0; i < PS2JS_AXES; i++)
+			ps2js->dev->abs[ps2js_abs[i]] = 128;
+	}
+	/* TBD: MOD_INC_USE_COUNT; */
+
+	return 0;
+}
+
+
+static void ps2js_close(struct input_dev *dev)
+{
+	struct ps2js *ps2js = input_get_drvdata(dev);
+
+	/* TBD: MOD_DEC_USE_COUNT; */
+	if (!--ps2js->used)
+		del_timer(&ps2js->timer);
+}
+
+
+int __init ps2js_init(void)
+{
+	int i, npads;
+	struct ps2js *ps2js;
+	
+	for (npads = 0; npads < ps2pad_npads; npads++) {
+		if (!(ps2js_ptr[npads] = kmalloc(sizeof(struct ps2js), 
+						 GFP_KERNEL)))
+			return -ENOMEM;
+		ps2js = ps2js_ptr[npads];
+		memset(ps2js, 0, sizeof(struct ps2js));
+		
+		init_timer(&ps2js->timer);
+
+		ps2js->port = ps2pad_pads[npads].port;
+		ps2js->slot = ps2pad_pads[npads].slot;
+			
+		ps2js->timer.data = (long) ps2js;
+		ps2js->timer.function = ps2js_timer;
+		ps2js->length = PS2JS_LENS;
+		ps2js->dev = input_allocate_device();
+		if (ps2js->dev == NULL) {
+			printk(KERN_ERR "ps2js: Out of memory.\n");
+			for (i = 0; i < npads; i++) {
+				input_free_device(ps2js_ptr[i]->dev);
+				kfree(ps2js_ptr[i]);
+			}
+			kfree(ps2js);
+			return -ENOMEM;
+		}
+		input_set_drvdata(ps2js->dev, ps2js);
+		ps2js->dev->open = ps2js_open;
+		ps2js->dev->close = ps2js_close;
+		ps2js->dev->evbit[0] = BIT(EV_KEY) | BIT(EV_ABS);
+
+		sprintf(ps2name[npads], "PS2PAD JoyStick(controller %d)",
+			npads + 1);
+		ps2js->dev->name = ps2name[npads];
+
+		for (i = 0; i < BITS_TO_LONGS(KEY_MAX); i++)
+			ps2js->dev->key[i] = 0;
+
+		for (i = 0; i < PS2JS_AXES; i++)
+			set_bit(ps2js_abs[i], ps2js->dev->absbit);
+
+		for (i = 0; i < PS2JS_PADS; i++)
+			set_bit(ps2js_btn_pad[i], ps2js->dev->keybit);
+
+		for (i = 0; i < PS2JS_AXES; i++) {
+  			ps2js->dev->abs[ps2js_abs[i]] = 128;
+			ps2js->dev->absmax[ps2js_abs[i]] = 255;
+			ps2js->dev->absmin[ps2js_abs[i]] = 1;
+			ps2js->dev->absfuzz[ps2js_abs[i]] = 4;
+			ps2js->dev->absflat[ps2js_abs[i]] = 0;
+		}
+		
+		input_register_device(ps2js->dev);
+	}
+	return (0);
+}
+
+
+void
+ps2js_cleanup(void)
+{
+	int npads;
+
+	for (npads = 0; npads < ps2pad_npads; npads++) {
+		input_unregister_device(ps2js_ptr[npads]->dev);
+		input_free_device(ps2js_ptr[npads]->dev);
+		ps2js_ptr[npads]->dev = NULL;
+		kfree(ps2js_ptr[npads]);
+	}
+}
+
+module_init(ps2js_init);
+module_exit(ps2js_cleanup);
+
+MODULE_AUTHOR("Sony Computer Entertainment Inc.");
+MODULE_DESCRIPTION("PlayStation 2 Joystick driver");
+MODULE_LICENSE("GPL");
diff -purN linux-2.6.35.4-orig/drivers/ps2/Kconfig linux-2.6.35.4/drivers/ps2/Kconfig
--- linux-2.6.35.4-orig/drivers/ps2/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/Kconfig	2014-07-18 22:29:43.554367724 +0200
@@ -0,0 +1,55 @@
+#
+# Sony Playstation 2 configuration
+#
+
+menu "Sony Playstation 2 devices"
+
+config PS2_ETHER_SMAP
+	tristate "Ethernet driver for fat PS2"
+	default y
+	depends on SONY_PS2
+	depends on NET
+	help
+	   This enables the driver for the network adapter SCPH-10350 in the fat PS2.
+	   The network adapter SCPH-10281 should also work.
+
+	   If you don't know what to do here, say Y.
+
+config PS2_ETHER_SMAPRPC
+	tristate "Ethernet driver for slim PSTwo"
+	default y
+	depends on SONY_PS2
+	depends on NET
+	help
+	   This enables the driver for the builtin network adapter of the slim PSTwo.
+
+	   If you don't know what to do here, say Y.
+
+config PS2_PAD
+	tristate "Support for PS2 game pad device"
+	default y
+	depends on SONY_PS2
+
+config PS2_CDVD
+	tristate "Support for PS2 CD/DVD ROM drive"
+	default y
+	depends on SONY_PS2
+
+config PS2_MC
+	tristate "Support for PS2 Memory Card"
+	default y
+	depends on SONY_PS2
+
+config PS2_SD
+	tristate "Support for PS2 Sound device"
+	default y
+	depends on SONY_PS2 && SOUND_OSS_CORE
+
+config PS2_PAD_JS
+	tristate "Support for PS2 Joystick"
+	default y
+	depends on SONY_PS2 && PS2_PAD && INPUT
+
+source "drivers/ps2/mcfs/Kconfig"
+
+endmenu
diff -purN linux-2.6.35.4-orig/drivers/ps2/libcdvd.h linux-2.6.35.4/drivers/ps2/libcdvd.h
--- linux-2.6.35.4-orig/drivers/ps2/libcdvd.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/libcdvd.h	2014-07-18 22:29:43.554367724 +0200
@@ -0,0 +1,61 @@
+/*
+ *  PlayStation 2 CD/DVD driver
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef PS2LIBCDVD_H
+#define PS2LIBCDVD_H
+
+/*
+ * error code
+ */
+#define SCECdErFAIL		-1	/* can't get error code		*/
+#define SCECdErNO		0x00	/* No Error			*/
+#define SCECdErEOM		0x32	/* End of Media			*/
+#define SCECdErTRMOPN		0x31	/* tray was opened while reading */
+#define SCECdErREAD		0x30	/* read error			*/
+#define SCECdErPRM		0x22	/* invalid parameter		*/
+#define SCECdErILI		0x21	/* illegal length		*/
+#define SCECdErIPI		0x20	/* illegal address		*/
+#define SCECdErCUD		0x14	/* not appropreate for current disc */
+#define SCECdErNORDY		0x13    /* not ready			*/
+#define SCECdErNODISC		0x12	/* no disc			*/
+#define SCECdErOPENS		0x11	/* tray is open			*/
+#define SCECdErCMD		0x10	/* not supported command	*/
+#define SCECdErABRT		0x01	/* aborted			*/
+
+/*
+ * spinup result
+ */
+#define SCECdComplete	0x02	/* Command Complete 	  */
+#define SCECdNotReady	0x06	/* Drive Not Ready	  */
+
+/*
+ * media mode
+ */
+#define SCECdCD         1
+#define SCECdDVD        2
+
+/*
+ * tray request
+ */
+#define SCECdTrayOpen   0       /* Tray Open  */
+#define SCECdTrayClose  1       /* Tray Close */
+#define SCECdTrayCheck  2       /* Tray Check */
+
+#endif /* ! PS2LIBCDVD_H */
diff -purN linux-2.6.35.4-orig/drivers/ps2/Makefile linux-2.6.35.4/drivers/ps2/Makefile
--- linux-2.6.35.4-orig/drivers/ps2/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/Makefile	2014-07-18 22:29:43.554367724 +0200
@@ -0,0 +1,20 @@
+ps2smap-objs		:= smap.o
+ps2smaprpc-objs		:= smaprpc.o
+ps2pad-objs			:= pad.o
+ps2cdvd-objs		:= cdvd.o cdvdaltdev.o cdvddev.o cdvdutil.o
+ps2mc-objs			:= mc.o mcdir.o mcfile.o mcdev.o
+ps2sd-objs			:= sd.o sdmixer.o sdcnv.o iopmem.o
+ps2js-objs			:= joystick.o
+mcfs-objs			:= mcfs/ps2mcfs.o
+
+obj-$(CONFIG_PS2_ETHER_SMAP)	+= ps2smap.o
+obj-$(CONFIG_PS2_ETHER_SMAPRPC)	+= ps2smaprpc.o
+obj-$(CONFIG_SONY_PS2)			+= sysproc.o
+obj-$(CONFIG_PS2_PAD)			+= ps2pad.o
+obj-$(CONFIG_PS2_CDVD)			+= ps2cdvd.o
+obj-$(CONFIG_PS2_SD)			+= ps2sd.o
+obj-$(CONFIG_PS2_MC)			+= ps2mc.o
+obj-$(CONFIG_PS2_PAD_JS)		+= ps2js.o
+
+# Load module ps2mcfs after ps2mc. Don't change order in Makefile!
+obj-y							+= mcfs/
diff -purN linux-2.6.35.4-orig/drivers/ps2/mc.c linux-2.6.35.4/drivers/ps2/mc.c
--- linux-2.6.35.4-orig/drivers/ps2/mc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/mc.c	2014-07-18 22:29:43.558367724 +0200
@@ -0,0 +1,959 @@
+/*
+ *  PlayStation 2 Memory Card driver
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+
+#include <linux/rtc.h>
+#include <linux/moduleparam.h>
+#include <linux/sched.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/major.h>
+#include <linux/signal.h>
+#include <linux/ps2/mcio.h>
+#include <linux/smp_lock.h>
+#include <linux/kthread.h>
+
+#include <asm/time.h>
+#include <asm/mach-ps2/sbios.h>
+#include <asm/mach-ps2/sifdefs.h>
+#include <asm/mach-ps2/sifutil.h>
+#include <asm/mach-ps2/siflock.h>
+
+#include "mc.h"
+#include "mccall.h"
+
+//#define PS2MC_DEBUG
+#include "mcpriv.h"
+#include "mc_debug.h"
+
+/*
+ * macro defines
+ */
+#define ALIGN2(a, n)	((__typeof__(a))(((unsigned long)(a) + (n) - 1) / (n) * (n)))
+
+/*
+ * data types
+ */
+
+/*
+ * function prototypes
+ */
+/* mktime is defined in arch/mips/ps2/kernel/time.c */
+unsigned long mktime(unsigned int, unsigned int, unsigned int, unsigned int,
+		     unsigned int, unsigned int);
+
+/*
+ * variables
+ */
+int ps2mc_debug = 0;
+ps2sif_lock_t *ps2mc_lock;	/* the lock which is need to invoke RPC */
+static unsigned char *dmabuf = NULL;
+McDirEntry *dirbuf;
+char *ps2mc_rwbuf;
+int ps2mc_basedir_len;
+struct semaphore ps2mc_filesem;
+struct semaphore ps2mc_waitsem;
+
+/* card status wacthing thread stuff */
+static struct completion thread_comp;
+static struct task_struct *thread_task = NULL;
+static struct list_head listeners;
+static volatile int timer_flag = 0;
+atomic_t ps2mc_cardgens[PS2MC_NPORTS][PS2MC_NSLOTS];
+
+static char *ps2mc_type_names[] = {
+[PS2MC_TYPE_EMPTY]		= "empty",
+[PS2MC_TYPE_PS1]		= "PS1 memory card",
+[PS2MC_TYPE_PS2]		= "PS2 memory card",
+[PS2MC_TYPE_POCKETSTATION]	= "Pocket Station",
+};
+
+/*
+ * export symbols
+ */
+EXPORT_SYMBOL(ps2mc_add_listener);
+EXPORT_SYMBOL(ps2mc_del_listener);
+EXPORT_SYMBOL(ps2mc_getinfo);
+EXPORT_SYMBOL(ps2mc_readdir);
+EXPORT_SYMBOL(ps2mc_getdir);
+EXPORT_SYMBOL(ps2mc_setdir);
+EXPORT_SYMBOL(ps2mc_mkdir);
+EXPORT_SYMBOL(ps2mc_rename);
+EXPORT_SYMBOL(ps2mc_delete);
+EXPORT_SYMBOL(ps2mc_getdtablesize);
+EXPORT_SYMBOL(ps2mc_close);
+EXPORT_SYMBOL(ps2mc_lseek);
+EXPORT_SYMBOL(ps2mc_open);
+EXPORT_SYMBOL(ps2mc_read);
+EXPORT_SYMBOL(ps2mc_write);
+EXPORT_SYMBOL(ps2mc_checkdev);
+EXPORT_SYMBOL(ps2mc_blkrw_hook);
+EXPORT_SYMBOL(ps2mc_terminate_name);
+EXPORT_SYMBOL(ps2mc_add_disks);
+EXPORT_SYMBOL(ps2mc_del_disks);
+
+module_param(ps2mc_debug, int, 0);
+
+/*
+ * function bodies
+ */
+char*
+ps2mc_terminate_name(char buf[PS2MC_NAME_MAX+1], const char *name, int namelen)
+{
+
+	memcpy(buf, name, MIN(namelen, PS2MC_NAME_MAX));
+	buf[MIN(namelen, PS2MC_NAME_MAX)] = '\0';
+
+	return (buf);
+}
+
+/*
+ * format memory card
+ */
+int
+ps2mc_format(int portslot)
+{
+	int res, result;
+
+	if ((res = ps2sif_lock_interruptible(ps2mc_lock, "mc format")) < 0) {
+		return (res);
+	}
+
+	res = ps2mclib_Format(PS2MC_PORT(portslot), PS2MC_SLOT(portslot), &result);
+	if (res != 0 || result != 0) {
+		/* error */
+		printk("ps2mclib_Format() failed\n");
+		res = -EIO;
+		goto out;
+	}
+
+	DPRINT(DBG_INFO, "format(): card%d%d result=%d\n",
+	       PS2MC_PORT(portslot), PS2MC_SLOT(portslot), result);
+
+out:
+	ps2mc_dircache_invalidate(portslot);
+	ps2sif_unlock(ps2mc_lock);
+
+	ps2mc_set_state(portslot, PS2MC_TYPE_EMPTY);
+
+	return (res);
+}
+
+/*
+ * unformat memory card
+ */
+int
+ps2mc_unformat(int portslot)
+{
+	int res, result;
+
+	if ((res = ps2sif_lock_interruptible(ps2mc_lock, "mc format")) < 0) {
+		return (res);
+	}
+
+	res = ps2mclib_Unformat(PS2MC_PORT(portslot), PS2MC_SLOT(portslot), &result);
+	if (res != 0 || result != 0) {
+		/* error */
+		printk("ps2mclib_Unformat() failed\n");
+		res = -EIO;
+		goto out;
+	}
+
+	DPRINT(DBG_INFO, "unformat(): card%d%d result=%d\n",
+	       PS2MC_PORT(portslot), PS2MC_SLOT(portslot), result);
+
+out:
+	ps2mc_dircache_invalidate(portslot);
+	ps2sif_unlock(ps2mc_lock);
+
+	ps2mc_set_state(portslot, PS2MC_TYPE_EMPTY);
+
+	return (res);
+}
+
+/*
+ * get memory card info
+ */
+int
+ps2mc_getinfo(int portslot, struct ps2mc_cardinfo *info)
+{
+	int res;
+	int result, type, free, format;
+
+	int port = PS2MC_PORT(portslot);
+	int slot = PS2MC_SLOT(portslot);
+
+	if (port < 0 || PS2MC_NPORTS <= port ||
+	    slot < 0 || PS2MC_NSLOTS <= slot)
+		return (-ENODEV);
+
+	res = ps2mc_getinfo_sub(portslot, &result, &type, &free, &format);
+	if (res < 0)
+		return (res);
+
+	memset(info, 0, sizeof(struct ps2mc_cardinfo));
+	info->type = PS2MC_TYPE_EMPTY;
+
+	switch (result) {
+	case 0:
+	case -1:
+	case -2:
+		/* succeeded normaly */
+		break;
+	default:
+		return (0);
+	}
+
+	info->type = type;
+	info->freeblocks = free;
+	info->formatted = format;
+	info->generation = atomic_read(&ps2mc_cardgens[port][slot]);
+	if (type == PS2MC_TYPE_PS2) {
+		info->blocksize = 1024;		/* XXX, I donna */
+		info->totalblocks = 1024 * 8;	/* XXX, 8MB */
+	}
+	if (type == PS2MC_TYPE_PS1) {
+		info->blocksize = 1024 * 8;
+		info->totalblocks = 16;	     /* 16 blocks of 8KB (128 KB) */
+	}
+
+	return (0);
+}
+
+int
+ps2mc_checkdev(dev_t dev)
+{
+	int portslot = MINOR(dev);
+	int port = PS2MC_PORT(portslot);
+	int slot = PS2MC_SLOT(portslot);
+
+	if (MAJOR(dev) != PS2MC_MAJOR)
+		return (-ENODEV);
+
+	if (port < 0 || PS2MC_NPORTS <= port ||
+	    slot < 0 || PS2MC_NSLOTS <= slot)
+		return (-ENODEV);
+
+	return (0);
+}
+
+int
+ps2mc_getinfo_sub(int portslot, int *result, int *type, int *free, int *format)
+{
+	int res;
+	int port = PS2MC_PORT(portslot), slot = PS2MC_SLOT(portslot);
+
+	if ((res = ps2sif_lock_interruptible(ps2mc_lock, "mc get info")) < 0) {
+		return (res);
+	}
+
+	res = 0;
+	if (ps2mclib_GetInfo(port, slot, type, free, format, result) != 0) {
+		/* error */
+		printk("ps2mclib_GetInfo() failed\n");
+		res = -EIO;
+	}
+
+	DPRINT(DBG_POLLING,
+	       "getinfo(): card%d%d result=%d type=%d format=%d\n",
+	       port, slot,
+	       result != NULL ? *result : 0,
+	       type != NULL ? *type : 0,
+	       format != NULL ? *format : 0);
+
+	if (res == 0 && (*result == -1 || *result == -2)) {
+		/* card was replaced */
+		atomic_inc(&ps2mc_cardgens[port][slot]);
+	}
+
+	ps2sif_unlock(ps2mc_lock);
+
+	return (res);
+}
+
+/*
+ * make directory
+ */
+int
+ps2mc_mkdir(int portslot, const char *path)
+{
+	int res, result;
+
+	/*
+	 * XXX, recent PS2 Runtime library does not allow to
+	 * make a subdirectory.
+	 */
+	if (ps2mc_basedir_len != 0 && path[ps2mc_basedir_len + 1] != '\0')
+		return (-EPERM);
+
+	res = ps2sif_lock_interruptible(ps2mc_lock, "mc mkdir");
+	if (res < 0)
+		return (res);
+
+	/* invalidate directory cache */
+	ps2mc_dircache_invalidate(portslot);
+
+	res = 0;
+	if (ps2mclib_Mkdir(PS2MC_PORT(portslot), PS2MC_SLOT(portslot),
+			   (char*)path, &result) != 0) {
+		/* error */
+		printk("ps2mclib_Mkdir() failed\n");
+		res = -EIO;
+		goto out;
+	}
+
+	DPRINT(DBG_INFO, "mkdir(%s): card%d%d result=%d\n",
+	       path, PS2MC_PORT(portslot), PS2MC_SLOT(portslot), result);
+
+	switch (result) {
+	case 0:		res = 0;	break;
+	case -2:	res = -EINVAL;	break;	/* not formatted */
+	case -3:	res = -ENOSPC;	break;	/* no space left on device */
+	case -4:	res = -ENOENT;	break;	/* no such file or directory */
+	default:	res = -EIO;	break;
+	}
+
+ out:
+	ps2sif_unlock(ps2mc_lock);
+
+	return (res);
+}
+
+
+/*
+ * rename directory entry
+ */
+int
+ps2mc_rename(int portslot, const char *path, char *newname)
+{
+	int res, result;
+
+	res = ps2sif_lock_interruptible(ps2mc_lock, "mc rename");
+	if (res < 0)
+		return (res);
+
+	res = 0;
+	if (ps2mclib_Rename(PS2MC_PORT(portslot), PS2MC_SLOT(portslot), (char*)path, newname, &result) != 0) {
+		/* error */
+		printk("ps2mclib_Rename() failed\n");
+		res = -EIO;
+		goto out;
+	}
+
+	DPRINT(DBG_INFO, "rename(): result=%d\n", result);
+
+	switch (result) {
+	case 0: /* succeeded */
+		res = 0;
+		ps2mc_dircache_invalidate(portslot);
+		break;
+	case -4: /* File not found */
+		res = -ENOENT;
+		break;
+	default:
+		res = -EIO;
+		break;
+	}
+
+ out:
+	ps2sif_unlock(ps2mc_lock);
+
+	return (res);
+}
+
+/*
+ * delete directory or file
+ */
+int
+ps2mc_delete(int portslot, const char *path)
+{
+	int res, result;
+
+	res = ps2sif_lock_interruptible(ps2mc_lock, "mc delete");
+	if (res < 0)
+		return (res);
+
+	/* invalidate directory cache */
+	ps2mc_dircache_invalidate(portslot);
+
+	res = 0;
+	if (ps2mclib_Delete(PS2MC_PORT(portslot), PS2MC_SLOT(portslot),
+			    (char*)path, &result) != 0) {
+		/* error */
+		printk("ps2mclib_Delete() failed\n");
+		res = -EIO;
+		goto out;
+	}
+
+	DPRINT(DBG_INFO, "delete(%s): card%d%d result=%d\n",
+	       path, PS2MC_PORT(portslot), PS2MC_SLOT(portslot), result);
+
+	switch (result) {
+	case 0:		res = 0;	break;
+	case -2:	res = -EINVAL;	break;	/* not formatted */
+	case -4:	res = -ENOENT;	break;	/* no such file or directory */
+	case -5:	res = -EBUSY;	break;	/* device or resource busy */
+	case -6:	res = -ENOTEMPTY;break;	/* directory not empty */
+	default:	res = -EIO;	break;
+	}
+
+ out:
+	ps2sif_unlock(ps2mc_lock);
+
+	return (res);
+}
+
+/*
+ * delete directory and all files which belong to the directory
+ */
+int
+ps2mc_delete_all(int portslot, const char *path)
+{
+	struct ps2mc_dirent dirent;
+	int res;
+	char name[PS2MC_NAME_MAX+1];
+	char path2[PS2MC_PATH_MAX+1];
+
+	DPRINT(DBG_INFO, "delete all(): card%d%d %s\n",
+	       PS2MC_PORT(portslot), PS2MC_SLOT(portslot), path);
+
+	res = ps2mc_getdir_sub(portslot, path, 0, 1, &dirent);
+	if (res < 0)
+		return (res);
+	if (res == 0)
+		return (-ENOENT);
+
+	if (S_ISDIR(dirent.mode)) {
+		while (0 < ps2mc_readdir(portslot, path, 2, &dirent, 1)) {
+		    ps2mc_terminate_name(name, dirent.name, dirent.namelen);
+		    sprintf(path2, "%s/%s", path, name);
+		    if ((res = ps2mc_delete(portslot, path2)) != 0)
+			return (res);
+		}
+	}
+
+	return ps2mc_delete(portslot, path);
+}
+
+int
+ps2mc_getdir(int portslot, const char *path, struct ps2mc_dirent *buf)
+{
+	int count, res, entspace;
+
+	DPRINT(DBG_INFO, "getdir(): card%d%d %s\n",
+	       PS2MC_PORT(portslot), PS2MC_SLOT(portslot), path);
+
+	if (strcmp(path, "/") == 0) {
+		/*
+		 * PS2 memory card has no entry of root directry itself.
+		 */
+		buf->name[0] = '/';
+		buf->namelen = 1;
+		buf->mode = S_IFDIR | S_IRUGO | S_IXUGO | S_IWUGO; /* 0777 */
+		buf->mtime = get_seconds(); //CURRENT_TIME;
+		buf->ctime = get_seconds(); //CURRENT_TIME;
+	} else {
+		if ((res = ps2mc_getdir_sub(portslot, path, 0, 1, buf)) <= 0)
+			return (res);
+	}
+
+	if (S_ISDIR(buf->mode)) {
+		count = 0;
+		for ( ; ; ) {
+			struct ps2mc_dirent tmpbuf;
+			res = ps2mc_readdir(portslot, path, count, &tmpbuf, 1);
+			if (res < 0)
+				return (res); /* error */ 
+			if (res == 0)
+				break; /* no more entries */
+			/* read an entry successfully */
+			count++;
+		}
+		res = ps2sif_lock_interruptible(ps2mc_lock, "mc getentspace");
+		if (res < 0)
+			return (res);
+		res = ps2mclib_GetEntSpace(PS2MC_PORT(portslot),
+					   PS2MC_SLOT(portslot),
+					   (char*)path, &entspace);
+		ps2sif_unlock(ps2mc_lock);
+		if (res < 0)
+			return -EIO;
+		count += entspace;
+		buf->size = ALIGN2(count, 2) * 512;
+	}
+
+	return (1); /* succeeded */
+}
+
+/*
+ * get directory infomation
+ *
+ * return value:
+ *   < 0 error
+ *   0   no more entries
+ *   0 < succeeded
+ *       if return value equals maxent, there might be more entries.
+ */
+int
+ps2mc_getdir_sub(int portslot, const char *path, int mode, int maxent,
+		 struct ps2mc_dirent *buf)
+{
+	int i, res, result;
+
+	res = ps2sif_lock_interruptible(ps2mc_lock, "mc format");
+	if (res < 0)
+		return (res);
+
+	res = 0;
+	ps2mc_dircache_invalidate_next_pos(portslot);
+	if (ps2mclib_GetDir(PS2MC_PORT(portslot), PS2MC_SLOT(portslot),
+			    (char*)path, mode, maxent, dirbuf, &result) != 0) {
+		/* error */
+		printk("ps2mclib_GetDir() failed\n");
+		res = -EIO;
+		goto out;
+	}
+
+	DPRINT(DBG_DIRCACHE, "getdir_sub(): card%d%d %s result=%d\n",
+	       PS2MC_PORT(portslot), PS2MC_SLOT(portslot), path, result);
+	if (result < 0) {
+		res = -EIO;
+		goto out;
+	}
+	res = result;
+
+	/*
+	 * convert from ps2mclib_TblGetDir into ps2mc_dirent
+	 */
+	for (i = 0; i < res; i++) {
+		/* name */
+		memcpy(buf[i].name, dirbuf[i].EntryName, sizeof(buf[i].name));
+		buf[i].namelen = MIN(sizeof(buf[i].name),
+				     strlen(dirbuf[i].EntryName));
+
+		/* mode */
+		if (dirbuf[i].AttrFile & McFileAttrSubdir)
+			buf[i].mode = S_IFDIR;
+		else
+			buf[i].mode = S_IFREG;
+		if (dirbuf[i].AttrFile & McFileAttrReadable)
+			buf[i].mode |= S_IRUGO;
+		if (dirbuf[i].AttrFile & McFileAttrWriteable)
+			buf[i].mode |= S_IWUGO;
+		if (dirbuf[i].AttrFile & McFileAttrExecutable)
+			buf[i].mode |= S_IXUGO;
+
+		/* size */
+		buf[i].size = dirbuf[i].FileSizeByte;
+
+		/* create time */
+		buf[i].ctime = mktime(dirbuf[i]._Create.Year,
+				      dirbuf[i]._Create.Month,
+				      dirbuf[i]._Create.Day,
+				      dirbuf[i]._Create.Hour,
+				      dirbuf[i]._Create.Min,
+				      dirbuf[i]._Create.Sec) - McTZONE;
+
+		/* modify time */
+		buf[i].mtime = mktime(dirbuf[i]._Modify.Year,
+				      dirbuf[i]._Modify.Month,
+				      dirbuf[i]._Modify.Day,
+				      dirbuf[i]._Modify.Hour,
+				      dirbuf[i]._Modify.Min,
+				      dirbuf[i]._Modify.Sec) - McTZONE;
+	}
+
+#ifdef PS2MC_DEBUG
+	for (i = 0; i < res; i++) {
+	    char name[PS2MC_NAME_MAX+1];
+	    ps2mc_terminate_name(name, buf[i].name, buf[i].namelen);
+	    DPRINT(DBG_DIRCACHE, "%3d: %04x %ld %ld %ld %s\n", i,
+		   buf[i].mode,
+		   buf[i].ctime,
+		   buf[i].mtime,
+		   buf[i].size,
+		   name);
+	}
+#endif /* PS2MC_DEBUG */
+
+ out:
+	ps2sif_unlock(ps2mc_lock);
+
+	return (res);
+}
+
+int
+ps2mc_setdir(int portslot, const char *path, int flags,
+	     struct ps2mc_dirent *buf)
+{
+	int res, result;
+	unsigned valid = 0;
+
+	if (strcmp(path, "/") == 0) {
+		/*
+		 * PS2 memory card has no entry of root directry itself.
+		 * Just ignore.
+		 */
+		return (0);
+	}
+
+	res = ps2sif_lock_interruptible(ps2mc_lock, "mc format");
+	if (res < 0)
+		return (res);
+
+	if (flags & PS2MC_SETDIR_MODE) {
+		int rwx;
+
+		/*
+		 * first, you should retrieve current mode of the entry.
+		 */
+		res = ps2mclib_GetDir(PS2MC_PORT(portslot), PS2MC_SLOT(portslot),
+				  (char*)path, 0, 1, dirbuf, &result);
+		if (res != 0 || result < 0) {
+			/* error */
+			printk("setdir: ps2mclib_GetDir() failed\n");
+			res = -EIO;
+			goto out;
+		}
+
+		/* fix the mode bits in buf-> */
+		rwx = (buf->mode & 0700) >> 6;
+		buf->mode = (buf->mode & ~0777) |
+				(rwx << 6) | (rwx << 3) | (rwx << 0);
+		buf->mode &= (S_IFDIR | S_IFREG | S_IRUGO | S_IWUGO | S_IXUGO);
+
+		dirbuf[0].AttrFile &= ~(McFileAttrReadable |
+					McFileAttrWriteable |
+					McFileAttrExecutable);
+		if (buf->mode & S_IRUSR)
+			dirbuf->AttrFile |= McFileAttrReadable;
+		if (buf->mode & S_IWUSR)
+			dirbuf->AttrFile |= McFileAttrWriteable;
+		if (buf->mode & S_IXUSR)
+			dirbuf->AttrFile |= McFileAttrExecutable;
+		valid |= McFileInfoAttr;
+	}
+
+	if (flags & PS2MC_SETDIR_CTIME) { /* create time */
+		struct rtc_time date;
+
+		//to_tm(buf->ctime + McTZONE, &date);
+		rtc_time_to_tm(buf->ctime + McTZONE, &date);
+		dirbuf[0]._Create.Year = date.tm_year;
+		dirbuf[0]._Create.Month = date.tm_mon;
+		dirbuf[0]._Create.Day = date.tm_mday;
+		dirbuf[0]._Create.Hour = date.tm_hour;
+		dirbuf[0]._Create.Min = date.tm_min;
+		dirbuf[0]._Create.Sec = date.tm_sec;
+		valid |= McFileInfoCreate;
+	}
+
+	if (flags & PS2MC_SETDIR_MTIME) { /* modify time */
+		struct rtc_time date;
+
+		//to_tm(buf->mtime + McTZONE, &date);
+		rtc_time_to_tm(buf->mtime + McTZONE, &date);
+		dirbuf[0]._Modify.Year = date.tm_year;
+		dirbuf[0]._Modify.Month = date.tm_mon;
+		dirbuf[0]._Modify.Day = date.tm_mday;
+		dirbuf[0]._Modify.Hour = date.tm_hour;
+		dirbuf[0]._Modify.Min = date.tm_min;
+		dirbuf[0]._Modify.Sec = date.tm_sec;
+		valid |= McFileInfoModify;
+	}
+
+	res = ps2mclib_SetFileInfo(PS2MC_PORT(portslot), PS2MC_SLOT(portslot),
+			       (char*)path, (char*)dirbuf, valid, &result);
+	if (res != 0 || (result < 0 && result != -4)) {
+		/* error */
+		printk("ps2mclib_SetDir() failed\n");
+		res = -EIO;
+		goto out;
+	}
+
+	DPRINT(DBG_DIRCACHE, "setdir(): card%d%d %s result=%d\n",
+	       PS2MC_PORT(portslot), PS2MC_SLOT(portslot), path, result);
+
+ out:
+	ps2sif_unlock(ps2mc_lock);
+
+	return (res);
+}
+
+void
+ps2mc_add_listener(struct ps2mc_listener *listener)
+{
+	ps2sif_lock(ps2mc_lock, "ps2mc add listener");
+	list_add(&listener->link, &listeners);
+	ps2sif_unlock(ps2mc_lock);
+}
+
+void
+ps2mc_del_listener(struct ps2mc_listener *listener)
+{
+	ps2sif_lock(ps2mc_lock, "ps2mc del listener");
+	list_del(&listener->link);
+	ps2sif_unlock(ps2mc_lock);
+}
+
+void
+ps2mc_set_state(int portslot, int state)
+{
+	int port = PS2MC_PORT(portslot);
+	int slot = PS2MC_SLOT(portslot);
+	struct list_head *p;
+	static int cardstates[PS2MC_NPORTS][PS2MC_NSLOTS];
+
+	ps2sif_lock(ps2mc_lock, "ps2mc set state");
+	if (cardstates[port][slot] != state) {
+		DPRINT(DBG_INFO, "card%d%d: %s -> %s\n",
+		       port, slot,
+		       ps2mc_type_names[cardstates[port][slot]],
+		       ps2mc_type_names[state]);
+
+		ps2mc_dircache_invalidate(PS2MC_PORTSLOT(port, slot));
+
+		/*
+		 * notify all listeners
+		 */
+		for (p = listeners.next; p != &listeners; p = p->next) {
+			struct ps2mc_listener *listener;
+			listener = list_entry(p, struct ps2mc_listener,link);
+			if (listener->func != NULL)
+				(*listener->func)(listener->ctx,
+						  PS2MC_PORTSLOT(port, slot),
+						  cardstates[port][slot],
+						  state);
+		}
+		cardstates[port][slot] = state;
+	}
+	ps2sif_unlock(ps2mc_lock);
+}
+
+static void
+ps2mc_check(void)
+{
+	int res;
+	int port, slot;
+	int result, type, gen;
+	static int gens[PS2MC_NPORTS][PS2MC_NSLOTS];
+	struct block_device *bdev;
+
+	for (port = 0; port < PS2MC_NPORTS; port++) {
+	  for (slot = 0; slot < PS2MC_NSLOTS; slot++) {
+	    int portslot = PS2MC_PORTSLOT(port, slot);
+	    res = ps2mc_getinfo_sub(portslot, &result, &type, NULL, NULL);
+	    if (res < 0 || result < -2) {
+	      /* error */
+	      ps2mc_set_state(portslot, PS2MC_TYPE_EMPTY);
+	    } else {
+	      gen = atomic_read(&ps2mc_cardgens[port][slot]);
+	      if (gens[port][slot] != gen) {
+		ps2mc_set_state(portslot, PS2MC_TYPE_EMPTY);
+		gens[port][slot] = gen;
+		ps2mc_signal_change(port, slot);
+		
+		bdev = bdget(MKDEV(PS2MC_MAJOR, portslot));
+		if (bdev) {
+			invalidate_bdev(bdev);
+			bdput(bdev);
+		}
+	      }
+
+	      if (result == 0 || result == -1)
+		      ps2mc_set_state(portslot, type);
+	    }
+	  }
+	}
+}
+
+static void
+ps2mc_timer(unsigned long arg)
+{
+	timer_flag = 1;
+	up(&ps2mc_waitsem);
+}
+
+static int
+ps2mc_settimer(int timeout)
+{
+	int rv;
+	struct timer_list timer;
+
+	init_timer_on_stack(&timer);
+	timer.function = (void(*)(u_long))ps2mc_timer;
+	timer.expires = jiffies + timeout;
+	add_timer(&timer);
+	rv = down_interruptible(&ps2mc_waitsem);
+	del_timer(&timer);
+	return rv;
+}
+
+static int
+ps2mc_thread(void *arg)
+{
+	sigset_t blocked, oldset;
+
+	DPRINT(DBG_INFO, "start thread\n");
+
+	/* get rid of all our resources related to user space */
+	daemonize("ps2mc_thread");
+
+	siginitsetinv(&blocked, sigmask(SIGKILL)|sigmask(SIGINT)|sigmask(SIGTERM));
+	sigprocmask(SIG_SETMASK, &blocked, &oldset);
+
+	thread_task = current;
+	complete(&thread_comp); /* notify that we are ready */
+
+	/*
+	 * loop
+	 */
+	while(1) {
+		if (timer_flag) {
+			ps2mc_check();
+			timer_flag = 0;
+		}
+		if (ps2mc_settimer(PS2MC_CHECK_INTERVAL) != 0) {
+			/* Interrupted by signal. */
+			break;
+		}
+		ps2mc_process_request();
+
+		if (signal_pending(current) )
+			break;
+	}
+
+	printk("ps2mc_thread: exit thread\n");
+	DPRINT(DBG_INFO, "exit thread\n");
+
+	thread_task = NULL;
+	complete(&thread_comp); /* notify that we've exited */
+
+	return (0);
+}
+
+int __init
+ps2mc_init(void)
+{
+
+	ps2mc_basedir_len = strlen(PS2MC_BASEDIR);
+	init_MUTEX(&ps2mc_filesem);
+	sema_init(&ps2mc_filesem, ps2mc_getdtablesize());
+	init_completion(&thread_comp);
+	init_MUTEX(&ps2mc_waitsem);
+
+	printk("PlayStation 2 Memory Card driver\n");
+
+	/*
+	 * initialize lock
+	 */
+	if ((ps2mc_lock = ps2sif_getlock(PS2LOCK_MC)) == NULL) {
+		printk(KERN_ERR "ps2mc: Can't get lock\n");
+		return (-1);
+	}
+
+	if (ps2sif_lock_interruptible(ps2mc_lock, "mc init") < 0)
+		return (-1);
+
+	/*
+	 * allocate DMA buffers
+	 */
+	if ((dmabuf = kmalloc(1500 + PS2MC_RWBUFSIZE, GFP_KERNEL)) == NULL) {
+		ps2sif_unlock(ps2mc_lock);
+		return (-1);
+	}
+	PS2SIF_ALLOC_BEGIN(dmabuf, 1500 + PS2MC_RWBUFSIZE);
+	PS2SIF_ALLOC(dirbuf, sizeof(McDirEntry) * PS2MC_DIRCACHESIZE, 64);
+	PS2SIF_ALLOC(ps2mc_rwbuf, PS2MC_RWBUFSIZE, 64);
+	PS2SIF_ALLOC_END("memory card\n");
+
+	/*
+	 * initialize event lister list
+	 */
+	INIT_LIST_HEAD(&listeners);
+
+	/*
+	 * initialize IOP access library
+	 */
+	if (ps2mclib_Init() < 0) {
+		printk(KERN_CRIT "ps2mc: can't initialize memory card system\n");
+		ps2sif_unlock(ps2mc_lock);
+		kfree(dmabuf);
+		return -1;
+	}
+
+	/*
+	 * register block device entry
+	 */
+	if (ps2mc_devinit() < 0) {
+		printk(KERN_CRIT "ps2mc: can't register memory card system\n");
+		ps2sif_unlock(ps2mc_lock);
+		kfree(dmabuf);
+		return -1;
+	}
+
+	/*
+	 * create and start thread
+	 */
+	kernel_thread(ps2mc_thread, NULL, 0);
+ 	//kthread_run(ps2mc_thread, NULL, "ps2mc_thread");
+	wait_for_completion(&thread_comp);	/* wait the thread ready */
+	ps2sif_unlock(ps2mc_lock);
+	return 0;
+}
+
+void
+ps2mc_cleanup(void)
+{
+
+	/*
+	 * stop the thread
+	 */
+	if (thread_task != NULL) {
+            send_sig(SIGKILL, thread_task, 1);
+	    wait_for_completion(&thread_comp);	/* wait the thread exit */
+	}
+
+	/*
+	 * unregister block device entry
+	 */
+	ps2mc_devexit();
+
+//	ps2mclib_Exit();
+
+	/* free DMA buffer */
+	if (dmabuf != NULL) {
+		kfree(dmabuf);
+		dmabuf = NULL;
+	}
+}
+
+module_init(ps2mc_init);
+module_exit(ps2mc_cleanup);
+
+MODULE_AUTHOR("Sony Computer Entertainment Inc.");
+MODULE_DESCRIPTION("PlayStation 2 memory card driver");
+MODULE_LICENSE("GPL");
diff -purN linux-2.6.35.4-orig/drivers/ps2/mccall.h linux-2.6.35.4/drivers/ps2/mccall.h
--- linux-2.6.35.4-orig/drivers/ps2/mccall.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/mccall.h	2014-07-18 22:29:43.558367724 +0200
@@ -0,0 +1,197 @@
+/*
+ *  PlayStation 2 Memory Card driver
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <asm/mach-ps2/sbios.h>
+#include <asm/mach-ps2/sifdefs.h>
+
+static __inline__ int ps2mclib_Init(void)
+{
+	int res;
+
+#ifdef CONFIG_PS2_SBIOS_VER_CHECK
+	if (sbios(SB_GETVER, NULL) < 0x0200)
+		return -1;
+#endif
+
+	do {
+		if (sbios_rpc(SBR_MC_INIT, NULL, &res) < 0 || res < 0)
+			return -1;
+	} while (res == 0);
+	return 1;
+}
+
+static __inline__ int ps2mclib_Open(int port, int slot, const char *name, int mode, int *result)
+{
+	struct sbr_mc_open_arg arg;
+
+	arg.port = port;
+	arg.slot = slot;
+	arg.name = name;
+	arg.mode = mode;
+	return sbios_rpc(SBR_MC_OPEN, &arg, result);
+}
+
+static __inline__ int ps2mclib_Mkdir(int port, int slot, const char *name, int *result)
+{
+	struct sbr_mc_mkdir_arg arg;
+
+	arg.port = port;
+	arg.slot = slot;
+	arg.name = name;
+	return  sbios_rpc(SBR_MC_MKDIR, &arg, result);
+}
+
+static __inline__ int ps2mclib_Close(int fd, int *result)
+{
+	struct sbr_mc_close_arg arg;
+
+	arg.fd = fd;
+	return sbios_rpc(SBR_MC_CLOSE, &arg, result);
+}
+
+static __inline__ int ps2mclib_Seek(int fd, int offset, int mode, int *result)
+{
+	struct sbr_mc_seek_arg arg;
+
+	arg.fd = fd;
+	arg.offset = offset;
+	arg.mode = mode;
+	return sbios_rpc(SBR_MC_SEEK, &arg, result);
+}
+
+static __inline__ int ps2mclib_Read(int fd, void *buff, int size, int *result)
+{
+	struct sbr_mc_read_arg arg;
+
+	arg.fd = fd;
+	arg.buff = buff;
+	arg.size = size;
+	return sbios_rpc(SBR_MC_READ, &arg, result);
+}
+
+static __inline__ int ps2mclib_Write(int fd, void *buff, int size, int *result)
+{
+	struct sbr_mc_write_arg arg;
+
+	arg.fd = fd;
+	arg.buff = buff;
+	arg.size = size;
+	return sbios_rpc(SBR_MC_WRITE, &arg, result);
+}
+
+static __inline__ int ps2mclib_GetInfo(int port, int slot, int *type, int *free, int *format, int *result)
+{
+	struct sbr_mc_getinfo_arg arg;
+
+	arg.port = port;
+	arg.slot = slot;
+	arg.type = type;
+	arg.free = free;
+	arg.format = format;
+	return sbios_rpc(SBR_MC_GETINFO, &arg, result);
+}
+
+static __inline__ int ps2mclib_GetDir(int port, int slot, const char *name,
+				      unsigned int mode, int maxent,
+				      McDirEntry *table, int *result)
+{
+	struct sbr_mc_getdir_arg arg;
+
+	arg.port = port;
+	arg.slot = slot;
+	arg.name = name;
+	arg.mode = mode;
+	arg.maxent = maxent;
+	arg.table = table;
+	return sbios_rpc(SBR_MC_GETDIR, &arg, result);
+}
+
+static __inline__ int ps2mclib_Format(int port, int slot, int *result)
+{
+	struct sbr_mc_format_arg arg;
+
+	arg.port = port;
+	arg.slot = slot;
+	return sbios_rpc(SBR_MC_FORMAT, &arg, result);
+}
+
+static __inline__ int ps2mclib_Delete(int port, int slot, const char *name, int *result)
+{
+	struct sbr_mc_delete_arg arg;
+
+	arg.port = port;
+	arg.slot = slot;
+	arg.name = name;
+	return sbios_rpc(SBR_MC_DELETE, &arg, result);
+}
+
+static __inline__ int ps2mclib_Flush(int fd, int *result)
+{
+	struct sbr_mc_flush_arg arg;
+
+	arg.fd = fd;
+	return sbios_rpc(SBR_MC_FLUSH, &arg, result);
+}
+
+static __inline__ int ps2mclib_SetFileInfo(int port, int slot,
+					   const char *name, const char *info,
+					   unsigned int valid, int *result)
+{
+	struct sbr_mc_setfileinfo_arg arg;
+
+	arg.port = port;
+	arg.slot = slot;
+	arg.name = name;
+	arg.info = info;
+	arg.valid = valid;
+	return sbios_rpc(SBR_MC_SETFILEINFO, &arg, result);
+}
+
+static __inline__ int ps2mclib_Rename(int port, int slot,
+				      const char *orgname, const char *newname,
+				      int *result)
+{
+	struct sbr_mc_rename_arg arg;
+
+	arg.port = port;
+	arg.slot = slot;
+	arg.orgname = orgname;
+	arg.newname = newname;
+	return sbios_rpc(SBR_MC_RENAME, &arg, result);
+}
+
+static __inline__ int ps2mclib_Unformat(int port, int slot, int *result)
+{
+	struct sbr_mc_unformat_arg arg;
+
+	arg.port = port;
+	arg.slot = slot;
+	return sbios_rpc(SBR_MC_UNFORMAT, &arg, result);
+}
+
+static __inline__ int ps2mclib_GetEntSpace(int port, int slot, const char *path, int *result)
+{
+	struct sbr_mc_getentspace_arg arg;
+
+	arg.port = port;
+	arg.slot = slot;
+	arg.path = path;
+	return sbios_rpc(SBR_MC_GETENTSPACE, &arg, result);
+}
diff -purN linux-2.6.35.4-orig/drivers/ps2/mc_debug.h linux-2.6.35.4/drivers/ps2/mc_debug.h
--- linux-2.6.35.4-orig/drivers/ps2/mc_debug.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/mc_debug.h	2014-07-18 22:29:43.558367724 +0200
@@ -0,0 +1,49 @@
+/*
+ *  PlayStation 2 Memory Card driver
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef PS2MC_DEBUG_H
+#define PS2MC_DEBUG_H
+
+#ifdef PS2MC_DEBUG
+
+#define DBG_POLLING	(1<< 0)
+#define DBG_INFO	(1<< 1)
+#define DBG_DIRCACHE	(1<< 2)
+#define DBG_PATHCHECK	(1<< 3)
+#define DBG_DEV		(1<< 4)
+#define DBG_FILESEM	(1<< 5)
+#define DBG_LOG_LEVEL	KERN_CRIT
+
+#define DPRINT(mask, fmt, args...) \
+	do { \
+		if ((ps2mc_debug & (mask)) == (mask)) \
+			printk(DBG_LOG_LEVEL "ps2mc: " fmt, ## args); \
+	} while (0)
+#define DPRINTK(mask, fmt, args...) \
+	do { \
+		if ((ps2mc_debug & (mask)) == (mask)) \
+			printk(fmt, ## args); \
+	} while (0)
+#else
+#define DPRINT(mask, fmt, args...) do {} while (0)
+#define DPRINTK(mask, fmt, args...) do {} while (0)
+#endif
+
+#endif /* PS2MC_DEBUG_H */
diff -purN linux-2.6.35.4-orig/drivers/ps2/mcdev.c linux-2.6.35.4/drivers/ps2/mcdev.c
--- linux-2.6.35.4-orig/drivers/ps2/mcdev.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/mcdev.c	2014-07-18 22:29:43.558367724 +0200
@@ -0,0 +1,538 @@
+/*
+ *  PlayStation 2 Memory Card driver
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+
+#include <linux/genhd.h>
+#include <linux/module.h>
+#include <linux/poll.h>
+#include <linux/slab.h>
+#include <linux/ps2/mcio.h>
+#include <linux/major.h>
+#include <linux/vmalloc.h>
+
+#include <asm/mach-ps2/sbios.h>
+#include <asm/mach-ps2/sifdefs.h>
+#include <asm/mach-ps2/siflock.h>
+
+#include "mc.h"
+#include "mccall.h"
+
+#define PS2MC_DEBUG
+#include "mcpriv.h"
+#include "mc_debug.h"
+
+/*
+ * macro defines
+ */
+#define MIN(a, b)	((a) < (b) ? (a) : (b))
+
+/*
+ * block device stuffs
+ */
+#define MAJOR_NR PS2MC_MAJOR
+#define DEVICE_NAME "ps2mc"
+#define DEVICE_REQUEST do_ps2mc_request
+#define DEVICE_NR(device) (MINOR(device))
+#define DEVICE_ON(device)
+#define DEVICE_OFF(device)
+#define DEVICE_NO_RANDOM
+#define PS2MC_MINORS	4
+#define KERNEL_SECTOR_SIZE      512 
+#include <linux/blkdev.h>
+
+
+/*
+ * data types
+ */
+
+/*
+ * function prototypes
+ */
+static int ps2mc_devioctl(struct block_device *, fmode_t mode, unsigned cmd, unsigned long arg);
+static int ps2mc_devopen(struct block_device *, fmode_t mode);
+static int ps2mc_devrelease(struct gendisk *gd, fmode_t mode);
+static int ps2mc_devcheck(struct gendisk *gd);
+static void do_ps2mc_request(struct request_queue *);
+static int hardsect_size = 512;
+static int ps2mc_revalidate(struct gendisk *gd);
+
+struct request_queue *req_que_ex;
+
+struct ps2mc_dev {
+	int size;                       /* Device size in sectors */
+	u8 *data;                       /* The data array */
+	short media_change;             /* Flag a media change? */
+	spinlock_t spinlock;         	/* For mutual exclusion */
+	ps2sif_lock_t *ps2mc_lock;
+	struct request_queue *req_que;	/* The device request queue */
+	struct gendisk *gd;             /* The gendisk structure */
+	struct timer_list timer;        /* For simulated media changes */
+	atomic_t opened;
+};
+
+static struct ps2mc_dev *ps2mc_devices = NULL;
+
+struct block_device_operations ps2mc_bdops = {
+	.owner=			THIS_MODULE,
+	.open=			ps2mc_devopen,
+	.release=		ps2mc_devrelease,
+	.ioctl=			ps2mc_devioctl,
+	.media_changed=		ps2mc_devcheck,
+	.revalidate_disk=	ps2mc_revalidate,
+};
+
+int (*ps2mc_blkrw_hook)(int, int, void*, int);
+
+/*
+ * function bodies
+ */
+
+void ps2mc_signal_change(int port, int slot)
+{
+	ps2mc_devices[port * PS2MC_NSLOTS + slot].media_change = 1;
+}
+
+int setup_ps2mc_dev(struct ps2mc_dev *device_info, int minor_n, int i)
+{
+	memset (device_info, 0, sizeof (struct ps2mc_dev));
+	device_info->size = 8 * hardsect_size;
+	device_info->data = vmalloc(device_info->size);
+	if (device_info->data == NULL) {
+		printk (KERN_NOTICE "vmalloc failure.\n");
+		return -ENOMEM;
+	}
+	spin_lock_init(&device_info->spinlock);
+
+	device_info->gd = alloc_disk(1);
+	if (! device_info->gd) {
+		printk (KERN_ERR "alloc_disk failure\n");
+		vfree(device_info->data);
+		device_info->data = NULL;
+		return -ENOMEM;
+	}
+	device_info->gd->major = PS2MC_MAJOR;
+  	device_info->gd->first_minor = minor_n;
+  	device_info->gd->fops = &ps2mc_bdops;
+	device_info->gd->minors = PS2MC_MINORS; 
+	device_info->req_que = blk_init_queue(do_ps2mc_request, &device_info->spinlock);
+	if (device_info->req_que == NULL) {
+		printk (KERN_ERR "queue failure\n");
+		put_disk(device_info->gd);
+		device_info->gd = NULL;
+		vfree(device_info->data);
+		device_info->data = NULL;
+		return -ENOMEM;
+	}
+	device_info->req_que->queuedata = device_info;
+	blk_queue_logical_block_size(device_info->req_que, hardsect_size);
+  	device_info->gd->queue = device_info->req_que;
+  	device_info->gd->private_data = device_info;
+	sprintf(device_info->gd->disk_name, "ps2mc%d0", i);
+	device_info->gd->flags = GENHD_FL_REMOVABLE;
+	set_capacity(device_info->gd, (8 * (hardsect_size / KERNEL_SECTOR_SIZE)));
+	return 0;
+}
+
+int ps2mc_devinit(void)
+{
+	int i, port, slot, res;
+	/*
+	 * register block device entry
+	 */
+	if ((res = register_blkdev(PS2MC_MAJOR, "ps2mc")) < 0) {
+		printk(KERN_ERR "Unable to get major %d for PS2 Memory Card\n",
+		       PS2MC_MAJOR);
+		return -EINVAL;
+	}
+
+	ps2mc_devices = kzalloc(PS2MC_NPORTS * PS2MC_NSLOTS * sizeof(struct ps2mc_dev), GFP_KERNEL);
+	if (ps2mc_devices == NULL) {
+		ps2mc_devexit();
+		return -ENOMEM;
+	}
+	i = 0;
+	for (port = 0; port < PS2MC_NPORTS; port++) {
+	  	for (slot = 0; slot < PS2MC_NSLOTS; slot++) {
+			int portslot = PS2MC_PORTSLOT(port, slot);
+			int rv;
+
+			rv = setup_ps2mc_dev(ps2mc_devices + i, portslot, i);
+			if (rv != 0) {
+				printk(KERN_ERR "ps2mc: Failed to initialize port%d%d\n", port, slot);
+				return rv;
+			}
+			
+			i++;
+		}
+	}
+	return (0);
+}
+
+void ps2mc_add_disks(void)
+{
+	int i, port, slot;
+
+	i = 0;
+	for (port = 0; port < PS2MC_NPORTS; port++) {
+	  	for (slot = 0; slot < PS2MC_NSLOTS; slot++) {
+			/* Add disks, this will already call file operations. */
+			printk("ps2mc: Adding MC port %d slot %d.\n", port, slot);
+			add_disk(ps2mc_devices[i].gd);
+			i++;
+		}
+	}
+	printk("ps2mc: Finished adding MC ports.\n");
+}
+
+void ps2mc_del_disks(void)
+{
+	int i, port, slot;
+
+	i = 0;
+	for (port = 0; port < PS2MC_NPORTS; port++) {
+	  	for (slot = 0; slot < PS2MC_NSLOTS; slot++) {
+			/* Remove disks. */
+			del_gendisk(ps2mc_devices[i].gd);
+			i++;
+		}
+	}
+}
+
+int
+ps2mc_devexit(void)
+{
+	/*
+	 * unregister block device entry
+	 */
+	unregister_blkdev(PS2MC_MAJOR, "ps2mc");
+
+	return (0);
+}
+
+
+static int
+ps2mc_devioctl(struct block_device *bdev, fmode_t mode, unsigned cmd, unsigned long arg)
+{
+	dev_t devno = disk_devt(bdev->bd_disk);
+	int portslot = MINOR(devno);
+	int n, res, fd;
+	int port, slot;
+	struct ps2mc_cardinfo info;
+	struct ps2mc_arg cmdarg;
+	char path[PS2MC_NAME_MAX+1];
+
+	port = PS2MC_PORT(portslot);
+	slot = PS2MC_SLOT(portslot);
+	switch (cmd) {
+	case PS2MC_IOCGETINFO: {
+		struct ps2mc_dev *dev_i = bdev->bd_disk->private_data;
+
+		DPRINT(DBG_DEV, "device ioctl: card%x%x cmd=GETINFO\n",
+		       port, slot);
+		if ((res = ps2mc_getinfo(portslot, &info)) != 0)
+			return (res);
+		info.busy = atomic_read(&dev_i->opened);
+		return copy_to_user((void *)arg, &info, sizeof(info)) ? -EFAULT : 0;
+	}
+
+	case PS2MC_IOCFORMAT:
+		DPRINT(DBG_DEV, "device ioctl: card%x%x cmd=FORMAT\n",
+		       port, slot);
+		return ps2mc_format(portslot);
+
+	case PS2MC_IOCSOFTFORMAT:
+		DPRINT(DBG_DEV, "device ioctl: card%x%x cmd=SOFTFORMAT\n",
+		       port, slot);
+		if (ps2mc_basedir_len == 0)
+			return (0);
+
+		sprintf(path, "/%s", PS2MC_BASEDIR);
+		if ((res = ps2mc_delete_all(portslot, path)) != 0 &&
+		    res != -ENOENT) {
+			return (res);
+		}
+		if ((res = ps2mc_mkdir(portslot, path)) != 0)
+			return (res);
+		return (0);
+
+	case PS2MC_IOCUNFORMAT:
+		DPRINT(DBG_DEV, "device ioctl: card%x%x cmd=UNFORMAT\n",
+		       port, slot);
+		return ps2mc_unformat(portslot);
+
+	case PS2MC_IOCWRITE:
+	case PS2MC_IOCREAD:
+		/* get arguments */
+		if (copy_from_user(&cmdarg, (void *)arg, sizeof(cmdarg)))
+			return -EFAULT;
+		sprintf(path, "%s%s", ps2mc_basedir_len ? "/" : "",
+			PS2MC_BASEDIR);
+		n = strlen(path);
+		if (PS2MC_NAME_MAX < cmdarg.pathlen + n)
+			return -ENAMETOOLONG;
+		if (copy_from_user(&path[n], cmdarg.path, cmdarg.pathlen))
+			return -EFAULT;
+		path[cmdarg.pathlen + n] = '\0';
+
+		DPRINT(DBG_DEV,
+		       "device ioctl: card%x%x cmd=%s path=%s pos=%d\n",
+		       port, slot, cmd== PS2MC_IOCWRITE ? "WRITE" : "READ",
+		       path, cmdarg.pos);
+
+		res = ps2sif_lock_interruptible(ps2mc_lock, "mc call");
+		if (res < 0)
+			return (res);
+		fd = ps2mc_open(portslot, path, cmdarg.mode);
+		/*
+		 * Invalidate directory cache because 
+		 * the file might be created.
+		 */
+		ps2mc_dircache_invalidate(portslot);
+		ps2sif_unlock(ps2mc_lock);
+
+		if (fd < 0)
+			return (fd);
+
+		if ((res = ps2mc_lseek(fd, cmdarg.pos, 0 /* SEEK_SET */)) < 0)
+			goto rw_out;
+
+		res = 0;
+		while (0 < cmdarg.count) {
+			n = MIN(cmdarg.count, PS2MC_RWBUFSIZE);
+			if (cmd== PS2MC_IOCWRITE) {
+			    if (copy_from_user(ps2mc_rwbuf, cmdarg.data, n)) {
+				res = res ? res : -EFAULT;
+				goto rw_out;
+			    }
+			    if ((n = ps2mc_write(fd, ps2mc_rwbuf, n)) <= 0) {
+				res = res ? res : n;
+				goto rw_out;
+			    }
+			} else {
+			    if ((n = ps2mc_read(fd, ps2mc_rwbuf, n)) <= 0) {
+				res = res ? res : n;
+				goto rw_out;
+			    }
+			    if (copy_to_user(cmdarg.data, ps2mc_rwbuf, n)) {
+				res = res ? res : -EFAULT;
+				goto rw_out;
+			    }
+			}
+			cmdarg.data += n;
+			cmdarg.count -= n;
+			res += n;
+		}
+	rw_out:
+		ps2mc_close(fd);
+		return (res);
+
+	case PS2MC_IOCNOTIFY:
+		ps2mc_set_state(portslot, PS2MC_TYPE_EMPTY);
+		return (0);
+
+	case PS2MC_CALL:
+		res = ps2sif_lock_interruptible(ps2mc_lock, "mc call");
+		if (res < 0)
+			return (res);
+		res = sbios_rpc(SBR_MC_CALL, (void*)arg, &n);
+		ps2sif_unlock(ps2mc_lock);
+
+		return ((res < 0) ? -EBUSY : 0);
+
+	}
+
+	return -EINVAL;
+}
+
+static int
+ps2mc_devopen(struct block_device *bdev, fmode_t mode)
+{
+	struct ps2mc_dev *dev_i = bdev->bd_disk->private_data;
+	dev_t devno = disk_devt(bdev->bd_disk);
+	int portslot = MINOR(devno);
+	int port = PS2MC_PORT(portslot);
+	int slot = PS2MC_SLOT(portslot);
+
+	check_disk_change(bdev);
+	DPRINT(DBG_DEV, "device open: card%d%d\n", port, slot);
+
+	if (port < 0 || PS2MC_NPORTS <= port ||
+	    slot < 0 || PS2MC_NSLOTS <= slot) {
+		return (-ENODEV);
+	}
+	atomic_inc(&dev_i->opened);
+	return (0);
+}
+
+static int
+ps2mc_devrelease(struct gendisk *gd, fmode_t mode)
+{
+	struct ps2mc_dev *dev_i = gd->private_data;
+	dev_t devno = disk_devt(gd);
+	int portslot = MINOR(devno);
+	int port = PS2MC_PORT(portslot);
+	int slot = PS2MC_SLOT(portslot);
+	DPRINT(DBG_DEV, "device release: card%d%d\n", port, slot);
+	if (port < 0 || PS2MC_NPORTS <= port ||
+	    slot < 0 || PS2MC_NSLOTS <= slot)
+	{
+		printk(KERN_ERR "device LOST!!!%d%d\n", port, slot);
+		return (-ENODEV);
+	}
+	atomic_dec(&dev_i->opened);
+	return (0);
+}
+
+static void
+do_ps2mc_request(struct request_queue *req_que_ex)
+{
+	up(&ps2mc_waitsem);
+}
+
+int ps2mc_blk_request(struct request *req)
+{
+	int cmd_f;
+	dev_t dev;
+	struct gendisk *gd;
+	struct ps2mc_dev *device;
+	char *cmd = NULL;
+
+	if (!blk_fs_request(req)) {
+		return -EIO;
+	}
+
+	cmd_f = rq_data_dir(req);
+	switch(cmd_f)
+	{
+		case READ:
+			cmd = "read";
+			break;
+		case WRITE:
+			cmd = "write";
+			break;
+		default:
+			printk(KERN_ERR "ps2mc: unknown command: %u \n", cmd_f);
+			return -EIO;
+	}
+
+	gd = req->rq_disk;
+	device = gd->private_data;
+	dev = disk_devt(gd);
+	if (atomic_read(&device->opened) == 0) {
+		DPRINT(DBG_DEV, "%s sect=%llx, len=%u, addr=%p\n",
+	       cmd, blk_rq_pos(req),
+	       blk_rq_cur_sectors(req),
+	       req->buffer);
+		return -ENXIO;
+	}
+	if (ps2mc_blkrw_hook){
+		int res;
+
+		res = (*ps2mc_blkrw_hook)(req->cmd_flags == 0 ? 0 : 1,
+			blk_rq_pos(req),
+			req->buffer,
+			blk_rq_cur_sectors(req));
+		DPRINT(DBG_DEV, "ps2mc_blk_request: ps2mc_blkrw_hook res = %d\n", res);
+		return res;
+	} else {
+		printk(KERN_ERR "ps2mc: ps2mcfs is not initialized.\n");
+		return -EIO;
+	}
+}
+
+void ps2mc_process_request(void)
+{
+	struct request_queue *rq;
+	struct request *req;
+	int res, port, slot, i;
+
+	i = 0;
+	req = NULL;
+	for (port = 0; port < PS2MC_NPORTS; port++) {
+		for (slot = 0; slot < PS2MC_NSLOTS; slot++) {
+			/* Get queue for current MC port. */
+			rq = (ps2mc_devices + i)->req_que;
+
+			for (;;) {
+				if (req == NULL) {
+					spin_lock_irq(rq->queue_lock);
+					req = blk_fetch_request(rq);
+					spin_unlock_irq(rq->queue_lock);
+				}
+
+				if (req != NULL) {
+					/* Make block transfer. */
+					res = ps2mc_blk_request(req);
+	
+					spin_lock_irq(rq->queue_lock);
+					if (!__blk_end_request_cur(req, res)) {
+						req = NULL;
+					}
+					spin_unlock_irq(rq->queue_lock);
+					if (req != NULL) {
+						/* Failed to end request, try later again. */
+						set_current_state(TASK_INTERRUPTIBLE);
+						schedule();
+					}
+				} else {
+					/* All requests processed for current MC port. */
+					break;
+				}
+			}
+			i++;
+		}
+	} 
+}
+
+static int 
+ps2mc_devcheck(struct gendisk *gd)
+{
+	dev_t devno = disk_devt(gd);
+	int portslot = MINOR(devno);
+	int port = PS2MC_PORT(portslot);
+	int slot = PS2MC_SLOT(portslot);
+	int gen;
+	static int gens[PS2MC_NPORTS][PS2MC_NSLOTS];
+	if (port < 0 || PS2MC_NPORTS <= port ||
+	    slot < 0 || PS2MC_NSLOTS <= slot)
+	return (0);
+
+	gen = atomic_read(&ps2mc_cardgens[port][slot]);
+	if (gens[port][slot] != gen) {
+		DPRINT(DBG_DEV, "card%d%d was changed\n", port, slot);
+		gens[port][slot] = gen;
+		return (1);
+	}
+
+	return (0);
+}
+
+int ps2mc_revalidate(struct gendisk *gd)
+{
+    struct ps2mc_dev *dev = gd->private_data;
+    
+    if (dev->media_change) {
+        dev->media_change = 0;
+        memset(dev->data, 0, dev->size);
+    }
+    return 0;
+}
diff -purN linux-2.6.35.4-orig/drivers/ps2/mcdir.c linux-2.6.35.4/drivers/ps2/mcdir.c
--- linux-2.6.35.4-orig/drivers/ps2/mcdir.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/mcdir.c	2014-07-18 22:29:43.558367724 +0200
@@ -0,0 +1,224 @@
+/*
+ *  PlayStation 2 Memory Card driver
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+
+#include <linux/sched.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/signal.h>
+#include <linux/ps2/mcio.h>
+#include <linux/smp_lock.h>
+
+#include <asm/mach-ps2/sbios.h>
+#include <asm/mach-ps2/sifdefs.h>
+
+#include "mc.h"
+#include "mccall.h"
+
+//#define PS2MC_DEBUG
+#include "mcpriv.h"
+#include "mc_debug.h"
+
+/*
+ * macro defines
+ */
+
+/*
+ * variables
+ */
+/* directory info cache stuff */
+static char dircache_path[McMaxPathLen + 1];
+static int dircache_pos;
+static int dircache_next_pos;
+static int dircache_count = -1;
+static int dircache_portslot;
+static struct ps2mc_dirent dircache[PS2MC_DIRCACHESIZE];
+
+void
+ps2mc_dircache_invalidate(int portslot)
+{
+	ps2sif_assertlock(ps2mc_lock, "ps2mc_dircache_invalidate");
+	if (dircache_portslot == portslot)
+		dircache_count = -1;
+}
+
+void
+ps2mc_dircache_invalidate_next_pos(int portslot)
+{
+	ps2sif_assertlock(ps2mc_lock, "ps2mc_dircache_invalidate_next_pos");
+	if (dircache_portslot == portslot)
+		dircache_next_pos = 0;
+}
+
+#define cache_isvalid()	(dircache_count != -1)
+
+/*
+ * read single directory entry
+ *
+ * return value:
+ *   < 0 error
+ *   0   no more entries
+ *   0 < succeeded
+ *       if return value equals maxent, there might be more entries.
+ */
+static int
+ps2mc_readdir_sub(int portslot, const char *path, int pos,
+		  struct ps2mc_dirent *buf)
+{
+	int res;
+	int curpos;
+	char tmp_path[McMaxPathLen + 1];
+
+	/*
+	 * get the lock
+	 */
+	res = ps2sif_lock_interruptible(ps2mc_lock, "mc format");
+	if (res < 0) {
+		DPRINTK(DBG_DIRCACHE, " can't get the lock\n");
+		return (res);
+	}
+
+	DPRINT(DBG_DIRCACHE,
+	       "readdir card%02x %s pos=%d ",
+	       portslot, path, pos);
+	if (cache_isvalid())
+		DPRINTK(DBG_DIRCACHE, "(cache %s pos=%d count=%d)",
+			dircache_path, dircache_pos, dircache_count);
+	else
+		DPRINTK(DBG_DIRCACHE, "(cache invalid)");
+
+	/*
+	 * check the cache
+	 */
+	if (!cache_isvalid() ||
+	    dircache_portslot != portslot ||
+	    strcmp(dircache_path, path) != 0) {
+		ps2mc_dircache_invalidate(dircache_portslot);
+		dircache_portslot = portslot;
+		strcpy(dircache_path, path);
+	}
+
+	/*
+	 * Does the cache contains what we want?
+	 */
+	if (cache_isvalid() &&
+	    dircache_pos <= pos && pos < dircache_pos + dircache_count) {
+		DPRINTK(DBG_DIRCACHE, " cache hit\n");
+		goto out;
+	}
+
+	/*
+	 * are there more entries in the directory?
+	 */
+	if (cache_isvalid() &&
+	    dircache_pos + dircache_count <= pos) {
+		if (dircache_count < PS2MC_DIRCACHESIZE) {
+			DPRINTK(DBG_DIRCACHE, " no more entry(%d entries)\n",
+				dircache_pos + dircache_count);
+			ps2sif_unlock(ps2mc_lock);
+			return (0);	/* no more entries */
+		} else {
+			DPRINTK(DBG_DIRCACHE,
+				" read more entries continuously...\n");
+			curpos = dircache_next_pos;
+		}
+	} else {
+		DPRINTK(DBG_DIRCACHE, " read entries from start\n");
+		curpos = 0;
+	}
+
+	if (McMaxPathLen <= strlen(dircache_path) + 2) {
+		printk("ps2mc: path name is too long\n");
+		return (-ENOENT);
+	}
+	if (strcmp(dircache_path, "/") == 0)
+		strcpy(tmp_path, "/*");
+	else
+		sprintf(tmp_path, "%s/*", dircache_path);
+
+	for ( ; ; ) {
+		/*
+		 * read entries
+		 */
+		res = ps2mc_getdir_sub(dircache_portslot, tmp_path,
+				       curpos == 0 ? 0 : 1,
+				       PS2MC_DIRCACHESIZE, dircache);
+		if (res < 0) {
+			ps2mc_dircache_invalidate(dircache_portslot);
+			ps2sif_unlock(ps2mc_lock);
+			return (res);	/* error */
+		}
+		if (res == 0) {
+			/* save previous cache contents */
+			ps2sif_unlock(ps2mc_lock);
+			return (0);	/* no more directory entries */
+		}
+		dircache_pos = curpos;
+		dircache_count = res;	/* now the cache is valid */
+		curpos += res;
+		dircache_next_pos = curpos;
+		if (dircache_pos <= pos &&
+		    pos < dircache_pos + dircache_count)
+			break;		/* succeeded */
+		if (res < PS2MC_DIRCACHESIZE) {
+			ps2sif_unlock(ps2mc_lock);
+			return (0);	/* no more directory entries */
+		}
+	}
+
+ out:
+	memcpy(buf, &dircache[pos - dircache_pos],
+	       sizeof(struct ps2mc_dirent));
+	ps2sif_unlock(ps2mc_lock);
+
+	return (1);	/* succeeded */
+}
+
+/*
+ * read directory infomation
+ *
+ * return value:
+ *   < 0 error
+ *   0   no more entries
+ *   0 < succeeded
+ *       if return value equals maxent, there might be more entries.
+ */
+int
+ps2mc_readdir(int portslot, const char *path, int pos,
+	      struct ps2mc_dirent *buf, int maxent)
+{
+	int res, count;
+
+	count = 0;
+	while (count < maxent) {
+		res = ps2mc_readdir_sub(portslot, path, pos++, &buf[count]);
+		if (res <= 0)
+			return count ? count : res;
+		count++;
+	}
+
+	return (count);
+}
+
diff -purN linux-2.6.35.4-orig/drivers/ps2/mcfile.c linux-2.6.35.4/drivers/ps2/mcfile.c
--- linux-2.6.35.4-orig/drivers/ps2/mcfile.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/mcfile.c	2014-07-18 22:29:43.558367724 +0200
@@ -0,0 +1,306 @@
+/*
+ *  PlayStation 2 Memory Card driver
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/signal.h>
+#include <linux/ps2/mcio.h>
+#include <linux/smp_lock.h>
+
+#include <asm/mach-ps2/sbios.h>
+#include <asm/mach-ps2/sifdefs.h>
+#include <asm/mach-ps2/siflock.h>
+
+#include "mc.h"
+#include "mccall.h"
+
+//#define PS2MC_DEBUG
+#include "mcpriv.h"
+#include "mc_debug.h"
+
+#define MAXFILEDESC	32
+
+/*
+ * macro defines
+ */
+
+/*
+ * variables
+ */
+static int openedfd = 0;
+
+int
+ps2mc_getdtablesize()
+{
+	return (MIN(McMaxFileDiscr, 32));
+}
+
+int
+ps2mc_open(int portslot, const char *path, int mode)
+{
+	int res, result;
+	int iopflags;
+
+	switch (mode & O_ACCMODE) {
+	case O_RDONLY:
+		iopflags = McRDONLY;
+		break;
+	case O_WRONLY:
+		iopflags = McWRONLY;
+		break;
+	case O_RDWR:
+		iopflags = McRDWR;
+		break;
+	default:
+		return -EINVAL;
+	}
+	if (mode & O_CREAT)
+		iopflags |= McCREAT;
+
+	if ((res = down_interruptible(&ps2mc_filesem)) < 0)
+		return (res);
+	res = ps2sif_lock_interruptible(ps2mc_lock, "mc open");
+	if (res < 0) {
+		up(&ps2mc_filesem);
+		return (res);
+	}
+	if (mode & O_CREAT) {
+		/*
+		 * This might create a new entry, thereby,
+		 * invalidate directory cache.
+		 */
+		ps2mc_dircache_invalidate(portslot);
+	}
+
+	res = 0;
+	if (ps2mclib_Open(PS2MC_PORT(portslot), PS2MC_SLOT(portslot),
+		      (char *)path, iopflags, &result) != 0) {
+		/* error */
+		printk("ps2mclib_Open() failed\n");
+		res = -EIO;
+		goto out;
+	}
+
+	DPRINT(DBG_INFO, "open(): card%d%d %s result=%d\n",
+	       PS2MC_PORT(portslot), PS2MC_SLOT(portslot), path, result);
+
+	if (0 <= result) {
+		/* succeeded */
+		res = result;
+	} else {
+		switch (result) {
+		case -7: /* Too many open files */
+			res = -EMFILE;
+			break;
+		default:
+			res = -EIO;
+			break;
+		}
+	}
+
+ out:
+	if (res < 0) {
+		ps2sif_unlock(ps2mc_lock);
+		up(&ps2mc_filesem);
+	} else {
+		if (MAXFILEDESC <= res) {
+			printk(KERN_CRIT "ps2mc: ERROR: unexpected fd=%d\n",
+			       res);
+			ps2sif_unlock(ps2mc_lock);
+			up(&ps2mc_filesem);
+		} else {
+			openedfd |= (1 << res);
+			ps2sif_unlock(ps2mc_lock);
+		}
+	}
+	return (res);
+}
+
+int
+ps2mc_close(int fd)
+{
+	int res, result;
+
+	res = ps2sif_lock_interruptible(ps2mc_lock, "mc close");
+	if (res < 0)
+		return (res);
+
+	if (fd < 0 || MAXFILEDESC <= fd || !(openedfd & (1 << fd))) {
+		ps2sif_unlock(ps2mc_lock);
+		return -EBADF;
+	}
+
+	res = 0;
+	if (ps2mclib_Close(fd, &result) != 0) {
+		/* error */
+		printk("ps2mclib_Close() failed\n");
+		res = -EIO;
+		goto out;
+	}
+
+	DPRINT(DBG_INFO, "close(): result=%d\n", result);
+
+	switch (result) {
+	case 0: /* succeeded */
+		break;
+	case 4: /* Bad file number */
+		res = -EBADF;
+		break;
+	default:
+		res = -EIO;
+		break;
+	}
+
+ out:
+	openedfd &= ~(1 << fd);
+	ps2sif_unlock(ps2mc_lock);
+	up(&ps2mc_filesem);
+
+	return (res);
+}
+
+off_t
+ps2mc_lseek(int fd, off_t offset, int whence)
+{
+	int res, result;
+
+	res = ps2sif_lock_interruptible(ps2mc_lock, "mc lseek");
+	if (res < 0)
+		return (res);
+
+	res = 0;
+	if (ps2mclib_Seek(fd, offset, whence, &result) != 0) {
+		/* error */
+		printk("ps2mclib_Seek() failed\n");
+		res = -EIO;
+		goto out;
+	}
+
+	DPRINT(DBG_INFO, "lseek(): result=%d\n", result);
+
+	if (0 <= result) {
+		/* succeeded */
+		res = result;
+	} else {
+		switch (result) {
+		case 4: /* Bad file number */
+			res = -EBADF;
+			break;
+		default:
+			res = -EIO;
+			break;
+		}
+	}
+
+ out:
+	ps2sif_unlock(ps2mc_lock);
+
+	return (res);
+}
+
+ssize_t
+ps2mc_write(int fd, const void *buf, size_t size)
+{
+	int res, result;
+
+	res = ps2sif_lock_interruptible(ps2mc_lock, "mc write");
+	if (res < 0)
+		return (res);
+
+	res = 0;
+	if (ps2mclib_Write(fd, (char*)buf, size, &result) != 0) {
+		/* error */
+		printk("ps2mclib_Write() failed\n");
+		res = -EIO;
+		goto out;
+	}
+
+	DPRINT(DBG_INFO, "write(): result=%d\n", result);
+
+	if (0 <= result) {
+		/* succeeded */
+		res = result;
+	} else {
+		switch (result) {
+		case -4: /* Bad file number */
+			res = -EBADF;
+			break;
+		case -5: /* Operation not permitted */
+			res = -EPERM;
+			break;
+		default:
+			res = -EIO;
+			break;
+		}
+	}
+
+ out:
+	ps2sif_unlock(ps2mc_lock);
+
+	return (res);
+}
+
+ssize_t
+ps2mc_read(int fd, const void *buf, size_t size)
+{
+	int res, result;
+
+	res = ps2sif_lock_interruptible(ps2mc_lock, "mc read");
+	if (res < 0)
+		return (res);
+
+	res = 0;
+	if (ps2mclib_Read(fd, (char*)buf, size, &result) != 0) {
+		/* error */
+		printk("ps2mclib_Read() failed\n");
+		res = -EIO;
+		goto out;
+	}
+
+	DPRINT(DBG_INFO, "read(): result=%d\n", result);
+
+	if (0 <= result) {
+		/* succeeded */
+		res = result;
+	} else {
+		switch (result) {
+		case -4: /* Bad file number */
+			res = -EBADF;
+			break;
+		case -5: /* Operation not permitted */
+			res = -EPERM;
+			break;
+		default:
+			res = -EIO;
+			break;
+		}
+	}
+
+ out:
+	ps2sif_unlock(ps2mc_lock);
+
+	return (res);
+}
diff -purN linux-2.6.35.4-orig/drivers/ps2/mcfs/dir.c linux-2.6.35.4/drivers/ps2/mcfs/dir.c
--- linux-2.6.35.4-orig/drivers/ps2/mcfs/dir.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/mcfs/dir.c	2014-07-18 22:29:43.566367724 +0200
@@ -0,0 +1,471 @@
+/*
+ *  PlayStation 2 Memory Card File System driver
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+
+#include <asm/bitops.h>
+#include <asm/uaccess.h>
+
+#include "mcfs.h"
+#include "mcfs_debug.h"
+
+#define ARRAYSIZEOF(a)	(sizeof(a)/sizeof(*(a)))
+
+static int ps2mcfs_dir_readdir(struct file *, void *, filldir_t);
+static struct dentry *ps2mcfs_dir_lookup(struct inode *, struct dentry *, struct nameidata *);
+static int ps2mcfs_dir_mkdir(struct inode *, struct dentry *, int);
+static int ps2mcfs_dir_delete(struct inode *, struct dentry *);
+static int ps2mcfs_dir_create(struct inode *, struct dentry *, int, struct nameidata *);
+static int ps2mcfs_dir_rename(struct inode *, struct dentry *,
+			      struct inode *, struct dentry *);
+static int ps2mcfs_dentry_revalidate(struct dentry *, struct nameidata *);
+
+struct file_operations ps2mcfs_dir_operations = {
+	readdir:	ps2mcfs_dir_readdir,
+};
+
+struct inode_operations ps2mcfs_dir_inode_operations = {
+	create:			ps2mcfs_dir_create,
+	lookup:			ps2mcfs_dir_lookup,
+	unlink:			ps2mcfs_dir_delete,
+	mkdir:			ps2mcfs_dir_mkdir,
+	rmdir:			ps2mcfs_dir_delete,
+	rename:			ps2mcfs_dir_rename,
+	setattr:		ps2mcfs_setattr,
+};
+
+struct dentry_operations ps2mcfs_dentry_operations = {
+	d_revalidate:	ps2mcfs_dentry_revalidate,
+};
+
+static int
+ps2mcfs_fullpath(struct inode *dir, struct dentry *dentry, char *path)
+{
+	int res;
+	const char *parentpath;
+	struct ps2mcfs_dirent *parent = dir->i_private;
+	char buf[PS2MC_NAME_MAX + 1];
+
+	if (parent == NULL) {
+		printk("ps2mcfs_fullpath: dir->i_private is not initialized (dir %p).\n", dir);
+		return -EINVAL;
+	}
+
+	if (dentry->d_name.len > PS2MC_NAME_MAX)
+		return -ENAMETOOLONG;
+	parentpath = ps2mcfs_get_path(parent);
+	if (*parentpath == '\0') {
+		return (-ENAMETOOLONG); /* path name might be too long */
+	}
+	if (PS2MC_PATH_MAX <= strlen(parentpath) + dentry->d_name.len + 1) {
+		res = -ENOENT;
+		goto out;
+	}
+
+	ps2mc_terminate_name(buf, dentry->d_name.name, dentry->d_name.len);
+	sprintf(path, "%s%s%s", parentpath,
+		parentpath[1] != '\0' ? "/" : "", buf);
+	res = 0;
+
+ out:
+	ps2mcfs_put_path(parent, parentpath);
+
+	return (res);
+}
+
+int
+ps2mcfs_countdir(struct ps2mcfs_dirent *de)
+{
+	const char *path;
+	int count, res;
+	struct ps2mc_dirent buf;
+
+	path = ps2mcfs_get_path(de);
+	if (*path == '\0')
+		return -ENAMETOOLONG; /* path name might be too long */
+	count = 0;
+	res = 0;
+	for ( ; ; ) {
+		res = ps2mc_readdir(de->root->portslot, path, count, &buf, 1);
+		if (res <= 0)
+			break; /* error or no more entries */ 
+		/* read an entry successfully */
+		count++;
+	}
+
+	ps2mcfs_put_path(de, path);
+
+	return ((res == 0) ? count : res);
+}
+
+static int
+ps2mcfs_newentry(struct inode *dir, struct dentry *dentry, const char *path, struct inode **inodep, int force_alloc_dirent)
+{
+	int res;
+	struct ps2mcfs_dirent *parent = dir->i_private;
+	struct ps2mcfs_dirent *newent;
+	struct ps2mc_dirent buf;
+
+	ps2sif_assertlock(ps2mcfs_lock, "mcfs_init_dirent");
+	TRACE("ps2mcfs_newentry(dir=%p, dentry=%p): %s\n", dir, dentry, path);
+
+	*inodep = NULL;
+
+	res = ps2mc_getdir(parent->root->portslot, path, &buf);
+	if (res < 0)
+		return res;
+
+	if (res != 0 || force_alloc_dirent) {
+		/* there is real entry */
+		newent = ps2mcfs_alloc_dirent(parent, dentry->d_name.name,
+					      dentry->d_name.len);
+		if (newent == NULL)
+			return -ENOMEM;
+
+		/* Allocate inode for entry. */
+		*inodep = ps2mcfs_iget(dir->i_sb, newent->ino);
+		if (*inodep == NULL) {
+			ps2mcfs_free_dirent(newent);
+			return -ENOMEM;
+		}
+		return 0;
+	}
+
+	return -ENOENT;
+}
+
+static int
+ps2mcfs_dir_create(struct inode *dir, struct dentry *dentry, int mode, struct nameidata *name_i_data)
+{
+	int res;
+	char path[PS2MC_PATH_MAX + 1];
+	struct ps2mcfs_dirent *de = dir->i_private;
+	struct inode *inode;
+	struct ps2mc_dirent mcdirent;
+
+	res = ps2sif_lock_interruptible(ps2mcfs_lock, "mcfs_dir_create");
+	if (res < 0)
+		return (res);
+
+	if ((res = ps2mcfs_fullpath(dir, dentry, path)) < 0)
+		goto out;
+
+	TRACE("ps2mcfs_dir_create(%s)\n", path);
+
+	mcdirent.mode = mode;
+	res = ps2mc_setdir(de->root->portslot, path,
+			   PS2MC_SETDIR_MODE, &mcdirent);
+	if (res < 0)
+		goto out;
+
+	res = ps2mcfs_newentry(dir, dentry, path, &inode, 1);
+	if (res < 0)
+		goto out;
+
+	/* Fill inode->i_private */
+	ps2mcfs_read_inode(inode);
+
+	/*
+	 * XXX, You can't create real body of the file
+	 * without the struct ps2mc_dirent
+	 */
+	res = ps2mcfs_create(inode->i_private);
+	if (res < 0) {
+		inode->i_nlink = 0;
+		ps2mcfs_free_dirent(inode->i_private);
+		goto out;
+	}
+	ps2mcfs_update_inode(inode);
+
+	dir->i_nlink++;
+	d_instantiate(dentry, inode);
+
+	/* update directory size */
+	res = ps2mcfs_update_inode(dir);
+ out:
+	ps2sif_unlock_interruptible(ps2mcfs_lock);
+
+	return (res);
+}
+
+static int
+ps2mcfs_dir_rename(struct inode *old_dir, struct dentry *old_dentry,
+		   struct inode *new_dir, struct dentry *new_dentry)
+{
+	int res;
+	char path[PS2MC_PATH_MAX + 1];
+	char name[PS2MC_NAME_MAX + 1];
+	struct ps2mcfs_dirent *parent = old_dir->i_private;
+	struct ps2mcfs_dirent *dirent;
+
+	res = ps2sif_lock_interruptible(ps2mcfs_lock, "mcfs_dir_rename");
+	if (res < 0)
+		return (res);
+
+	if ((res = ps2mcfs_fullpath(old_dir, old_dentry, path)) < 0)
+		goto out;
+
+	ps2mc_terminate_name(name, new_dentry->d_name.name,
+			     new_dentry->d_name.len);
+#ifdef PS2MCFS_DEBUG
+	DPRINT(DBG_TRACE, "dir rename('%s'(%p)->'%s'(%p))\n",
+	       path, old_dentry->d_inode, name, new_dentry->d_inode);
+#endif
+
+	if (old_dir != new_dir) {
+		res = -EPERM;
+		goto out;
+	}
+	if (PS2MC_NAME_MAX < new_dentry->d_name.len) {
+		res = -ENAMETOOLONG;
+		goto out;
+	}
+
+	dirent = old_dentry->d_inode->i_private;
+	ps2mcfs_free_fd(dirent);
+	if ((res = ps2mc_rename(parent->root->portslot, path, name)) == 0) {
+		ps2mcfs_free_path(dirent);
+		memcpy(dirent->name, new_dentry->d_name.name, PS2MC_NAME_MAX);
+		dirent->namelen = new_dentry->d_name.len;
+	}
+
+ out:
+	ps2sif_unlock_interruptible(ps2mcfs_lock);
+
+	return (res);
+}
+
+static struct dentry *ps2mcfs_dir_lookup(struct inode *dir, struct dentry *dentry, struct nameidata *name_i_data)
+{
+	int res;
+	char path[PS2MC_PATH_MAX + 1];
+	struct inode *inode = NULL;
+
+	res = ps2sif_lock_interruptible(ps2mcfs_lock, "mcfs_dir_lookup");
+	if (res < 0)
+		return ERR_PTR(res);
+	ps2mc_terminate_name(path, dentry->d_name.name, dentry->d_name.len);
+	TRACE("ps2mcfs_dir_lookup(dir=%p, dent=%p): %s\n", dir, dentry, path);
+
+	/* Get string representation of path. */
+	res = ps2mcfs_fullpath(dir, dentry, path);
+	if (res < 0) {
+		ps2sif_unlock_interruptible(ps2mcfs_lock);
+		return ERR_PTR(res);
+	}
+
+	/* Check whether file exists. */
+	res = ps2mcfs_newentry(dir, dentry, path, &inode, 0);
+	if ((res < 0) && (res != -ENOENT)) {
+		ps2sif_unlock_interruptible(ps2mcfs_lock);
+		return ERR_PTR(res);
+	}
+
+	if (res == 0) {
+		/* File exists, update inode information. */
+		ps2mcfs_read_inode(inode);
+	}
+
+	dentry->d_op = &ps2mcfs_dentry_operations;
+	/* Add inode or NULL if not found. */
+	d_add(dentry, inode);
+	TRACE("ps2mcfs_dir_lookup(dir=%p, dent=%p, inode=%p): %s\n", dir, dentry, inode, path);
+	ps2sif_unlock_interruptible(ps2mcfs_lock);
+
+	return NULL;
+}
+
+static int
+ps2mcfs_dir_readdir(struct file * filp, void * dirent, filldir_t filldir)
+{
+	struct inode *inode = filp->f_dentry->d_inode;
+	int pos, res;
+	struct ps2mc_dirent buf;
+	struct ps2mcfs_dirent *de = inode->i_private;
+	const char *path;
+
+	TRACE("ps2mcfs_dir_readdir(filp=%p): inode=%p pos=%ld dirent=%p\n",
+	      filp, inode, (long)filp->f_pos, de);
+
+	if (!inode || !S_ISDIR(inode->i_mode))
+		return -ENOTDIR;
+
+	pos = filp->f_pos;
+	if (de->parent == NULL && *ps2mcfs_basedir == '\0') {
+		/* root directory of PS2 Memory Card doesn't
+		   have '.' and '..' */
+		if (filp->f_pos == 0) {
+			if (filldir(dirent, ".", 1, filp->f_pos,
+				    de->ino, DT_DIR) < 0)
+				return 0;
+			filp->f_pos++;
+		}
+		if (filp->f_pos == 1) {
+			if (filldir(dirent, "..", 2, filp->f_pos,
+				    ps2mcfs_pseudo_ino(), DT_DIR) < 0)
+				return 0;
+			filp->f_pos++;
+		}
+	}
+	for ( ; ; ) {
+#define S_SHIFT 12
+		static int types[S_IFMT >> S_SHIFT] = {
+			[S_IFREG >> S_SHIFT]	DT_REG,
+			[S_IFDIR >> S_SHIFT]	DT_DIR,
+		};
+		path = ps2mcfs_get_path(de);
+		if (*path == '\0')
+			return -ENAMETOOLONG; /* path name might be too long */
+		res = ps2mc_readdir(de->root->portslot, path, pos,
+				    &buf, 1);
+		ps2mcfs_put_path(de, path);
+		if (res < 0)
+			return 0; /* XXX, error, try again ??? */
+		if (res == 0)
+			return 1; /* no more entries */
+
+		/* read an entry successfully */
+		pos++;
+
+		/* copy directory information */
+		res = filldir(dirent, buf.name, buf.namelen,
+			      filp->f_pos, ps2mcfs_pseudo_ino(),
+			      types[(buf.mode & S_IFMT) >> S_SHIFT]);
+		if (res < 0)
+			return 0;
+		filp->f_pos++;
+	}
+
+	return 1;
+}
+
+static int
+ps2mcfs_dir_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+{
+	int res;
+	struct ps2mcfs_dirent *parent = dir->i_private;
+	char path[PS2MC_PATH_MAX + 1];
+	struct inode *inode;
+	struct ps2mc_dirent mcdirent;
+
+	res = ps2sif_lock_interruptible(ps2mcfs_lock, "mcfs_dir_create");
+	if (res < 0)
+		return (res);
+
+	ps2mc_terminate_name(path, dentry->d_name.name, dentry->d_name.len);
+	TRACE("ps2mcfs_dir_mkdir(%s)\n", path);
+
+	if ((res = ps2mcfs_fullpath(dir, dentry, path)) < 0)
+		goto out;
+
+	res = ps2mc_mkdir(parent->root->portslot, path);
+	if (res < 0)
+		goto out;
+
+	mcdirent.mode = mode;
+	res = ps2mc_setdir(parent->root->portslot, path,
+			   PS2MC_SETDIR_MODE, &mcdirent);
+	if (res < 0)
+		goto out;
+
+	res = ps2mcfs_newentry(dir, dentry, path, &inode, 0);
+	if (res < 0) {
+		ps2mc_delete(parent->root->portslot, path);
+		goto out;
+	}
+
+	dir->i_nlink++;
+	d_instantiate(dentry, inode);
+
+	/* update directory size */
+	res = ps2mcfs_update_inode(dir);
+ out:
+	ps2sif_unlock_interruptible(ps2mcfs_lock);
+
+	return (res);
+}
+
+static int
+ps2mcfs_dir_delete(struct inode *inode, struct dentry *dentry)
+{
+	int res;
+	char path[PS2MC_PATH_MAX + 1];
+	struct ps2mcfs_dirent *de = inode->i_private;
+
+	res = ps2sif_lock_interruptible(ps2mcfs_lock, "mcfs_dir_create");
+	if (res < 0)
+		return (res);
+
+	if ((res = ps2mcfs_fullpath(inode, dentry, path)) < 0)
+		goto out;
+
+	TRACE("ps2mcfs_dir_delete(%s): inode=%p dentry=%p\n",
+	      path, inode, dentry);
+
+	ps2mcfs_free_fd((struct ps2mcfs_dirent*)dentry->d_inode->i_private);
+	if ((res = ps2mc_delete(de->root->portslot, path)) < 0)
+		goto out;
+
+	/* decrement parent directory's link count */
+	inode->i_nlink--;
+
+	/* release inode */
+	dentry->d_inode->i_nlink = 0;
+
+	/* update directory size */
+	res = ps2mcfs_update_inode(inode);
+ out:
+	ps2sif_unlock_interruptible(ps2mcfs_lock);
+
+	return (res);
+}
+
+static int
+ps2mcfs_dentry_revalidate(struct dentry *dentry, struct nameidata *name_i_data) // int flags)
+{
+	struct inode *inode;
+	struct ps2mcfs_dirent *de;
+
+	if ((inode = dentry->d_inode) == NULL)
+		return (0);
+	if ((de = inode->i_private) == NULL)
+		return (0);
+#ifdef PS2MCFS_DEBUG
+	{
+		const char *path;
+		path = ps2mcfs_get_path(de);
+		TRACE("ps2mcfs_dentry_revalidate(%s): inode=%p dentry=%p %s\n",
+		      path, inode, dentry,
+		      (de->flags & PS2MCFS_DIRENT_INVALID) ? "<invalid>" : "");
+		ps2mcfs_put_path(de, path);
+	}
+#endif
+	if (de->flags & PS2MCFS_DIRENT_INVALID)
+		return (0);
+
+	return (1); /* this entry is valid */
+}
diff -purN linux-2.6.35.4-orig/drivers/ps2/mcfs/dirent.c linux-2.6.35.4/drivers/ps2/mcfs/dirent.c
--- linux-2.6.35.4-orig/drivers/ps2/mcfs/dirent.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/mcfs/dirent.c	2014-07-18 22:29:43.566367724 +0200
@@ -0,0 +1,300 @@
+/*
+ *  PlayStation 2 Memory Card File System driver
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+
+#include <asm/bitops.h>
+#include <asm/uaccess.h>
+
+#include "mcfs.h"
+#include "mcfs_debug.h"
+
+#define ARRAYSIZEOF(a)	(sizeof(a)/sizeof(*(a)))
+#define MIN(a, b)	((a) < (b) ? (a) : (b))
+#define HASH(a)		(0)
+
+static struct list_head free_dirents;
+static struct list_head active_dirents[1];
+static struct ps2mcfs_dirent *all_dirents[PS2MCFS_MAX_DIRENTS];
+static int nfreeents = 0;
+static int nents = 0;
+
+static void ps2mcfs_clean_dirent(struct ps2mcfs_dirent *de);
+
+static unsigned long get_next_ino(void)
+{
+	static unsigned long ino = 0;
+
+	return (++ino & ~(1<<31));
+}
+
+unsigned long ps2mcfs_pseudo_ino(void)
+{
+	static unsigned long pino = 0;
+
+	return (++pino | (1<<31));
+}
+
+int ps2mcfs_is_pseudo_ino(unsigned long ino)
+{
+	return (ino & (1<<31));
+}
+
+static int ps2mcfs_compare_name(struct ps2mcfs_dirent *de, const char *name,
+			      int namelen)
+{
+	if (de->namelen != namelen)
+		return (1);	/* XXX, fix me !*/
+	return (strncmp(de->name, name, namelen));
+}
+
+int ps2mcfs_init_dirent(void)
+{
+	int i;
+
+	ps2sif_assertlock(ps2mcfs_lock, "mcfs_init_dirent");
+	INIT_LIST_HEAD(&free_dirents);
+	for (i = 0; i < ARRAYSIZEOF(active_dirents); i++)
+		INIT_LIST_HEAD(&active_dirents[i]);
+
+	return (0);
+}
+
+struct ps2mcfs_dirent* ps2mcfs_alloc_dirent(struct ps2mcfs_dirent *parent,
+					    const char *name, int namelen)
+{
+	struct ps2mcfs_dirent *newent = NULL;
+	char buf[PS2MC_NAME_MAX + 1];
+
+	ps2mc_terminate_name(buf, name, namelen);
+	TRACE("ps2mcfs_alloc_dirent(%s)\n", buf);
+	ps2sif_assertlock(ps2mcfs_lock, "mcfs_alloc_dirent");
+	if (list_empty(&free_dirents)) {
+		if (PS2MCFS_MAX_DIRENTS <= nents) {
+			printk(KERN_CRIT "ps2mcfs: too many directory entries\n");
+			newent = NULL;
+			goto out;
+		}
+		newent = kmalloc(sizeof(struct ps2mcfs_dirent), GFP_KERNEL);
+		if (!newent)
+			goto out;
+		all_dirents[nents] = newent;
+		memset(newent, 0, sizeof(struct ps2mcfs_dirent));
+		newent->no = nents;
+		newent->ino = get_next_ino();
+		nents++;
+	} else {
+		newent = list_entry(free_dirents.next, struct ps2mcfs_dirent, 
+				    next);
+		list_del(&newent->next);
+		nfreeents--;
+	}
+	ps2mcfs_clean_dirent(newent);
+	if ((newent->parent = parent) != NULL) {
+		ps2mcfs_ref_dirent(parent);
+		list_add(&newent->next, &parent->sub);
+		newent->root = parent->root;
+	}
+	newent->namelen = MIN(namelen, PS2MC_NAME_MAX);
+	memcpy(newent->name, name, newent->namelen);
+
+	list_add(&newent->hashlink, &active_dirents[HASH(newent->ino)]);
+ out:
+
+	return (newent);
+}
+
+struct ps2mcfs_dirent* ps2mcfs_find_dirent(struct ps2mcfs_dirent *parent,
+					   const char *name, int namelen)
+{
+	struct list_head *tmp;
+	char buf[PS2MC_NAME_MAX + 1];
+
+	ps2mc_terminate_name(buf, name, namelen);
+	TRACE("ps2mcfs_find_dirent(%s)\n", buf);
+	ps2sif_assertlock(ps2mcfs_lock, "mcfs_find_dirent");
+
+	for (tmp = parent->sub.next; tmp != &parent->sub; tmp = tmp->next) {
+		struct ps2mcfs_dirent *de;
+		de = list_entry(tmp, struct ps2mcfs_dirent, next);
+		if (ps2mcfs_compare_name(de, name, namelen) == 0)
+			return (de);
+	}
+
+	return (NULL);
+}
+
+struct ps2mcfs_dirent* ps2mcfs_find_dirent_ino(unsigned long ino)
+{
+	struct list_head *tmp;
+
+	TRACE("ps2mcfs_find_dirent_ino(%ld)\n", ino);
+	ps2sif_assertlock(ps2mcfs_lock, "mcfs_find_dirent_ino");
+
+	for (tmp = active_dirents[HASH(newent->ino)].next;
+	     tmp != &active_dirents[HASH(newent->ino)]; tmp = tmp->next) {
+		struct ps2mcfs_dirent *de;
+		de = list_entry(tmp, struct ps2mcfs_dirent, hashlink);
+		if (de->ino == ino)
+			return de;
+	}
+
+	return (NULL);
+}
+
+struct ps2mcfs_dirent* ps2mcfs_find_dirent_no(int no)
+{
+	TRACE("ps2mcfs_find_dirent_no(%d)\n", no);
+	ps2sif_assertlock(ps2mcfs_lock, "mcfs_find_dirent_no");
+	if (no < 0 || nents <= no)
+		return (NULL);
+
+	return (all_dirents[no]);
+}
+
+static void ps2mcfs_clean_dirent(struct ps2mcfs_dirent *de)
+{
+	de->parent = NULL;
+	INIT_LIST_HEAD(&de->next);
+	INIT_LIST_HEAD(&de->sub);
+	INIT_LIST_HEAD(&de->hashlink);
+	de->flags = 0;
+	de->inode = NULL;
+	de->root = NULL;
+	de->refcount = 0;
+}
+
+void ps2mcfs_ref_dirent(struct ps2mcfs_dirent *de)
+{
+	char buf[PS2MC_NAME_MAX + 1];
+
+	ps2mc_terminate_name(buf, de->name, de->namelen);
+	TRACE("ps2mcfs_ref_dirent(%s): refcount=%d++\n", buf, de->refcount);
+	ps2sif_assertlock(ps2mcfs_lock, "mcfs_ref_dirent");
+	de->refcount++;
+}
+
+void ps2mcfs_unref_dirent(struct ps2mcfs_dirent *de)
+{
+	char buf[PS2MC_NAME_MAX + 1];
+
+	ps2mc_terminate_name(buf, de->name, de->namelen);
+	TRACE("ps2mcfs_unref_dirent(%s): refcount=%d--\n", buf, de->refcount);
+	ps2sif_assertlock(ps2mcfs_lock, "mcfs_unref_dirent");
+	if (--de->refcount == 0)
+		ps2mcfs_free_dirent(de);
+}
+
+void ps2mcfs_free_dirent(struct ps2mcfs_dirent *de)
+{
+	char buf[PS2MC_NAME_MAX + 1];
+
+	ps2mc_terminate_name(buf, de->name, de->namelen);
+	TRACE("ps2mcfs_free_dirent(%s) entries=%d(%d)\n",
+	      buf, nents, nfreeents + 1);
+	ps2sif_assertlock(ps2mcfs_lock, "mcfs_free_dirent");
+
+	list_del(&de->next);
+	list_del(&de->hashlink);
+
+	if (de->flags & PS2MCFS_DIRENT_BMAPPED)
+		invalidate_bdev(de->inode->i_bdev);
+
+	/*
+	 * free file descriptor cache entry
+	 */
+	ps2mcfs_free_fd(de);
+
+	/*
+	 * free path name cache entry
+	 */
+	ps2mcfs_free_path(de);
+
+	/*
+	 * decrement parent's reference count
+	 * (it might free the parent entry)
+	 */
+	if (de->parent)
+		ps2mcfs_unref_dirent(de->parent);
+
+	/*
+	 * link with free list
+	 */
+	list_add(&de->next, &free_dirents);
+	nfreeents++;
+}
+
+void
+ps2mcfs_invalidate_dirents(struct ps2mcfs_root *root)
+{
+	int i;
+	struct list_head *p;
+	struct ps2mcfs_dirent *de;
+	struct inode *inode;
+	const char *path;
+
+	TRACE("ps2mcfs_invalidate_dirents(card%02x)\n", root->portslot);
+
+	if (ps2sif_lock_interruptible(ps2mcfs_lock, "mcfs_invalidate_dirents") < 0)
+		return;
+	for (i = 0; i < ARRAYSIZEOF(active_dirents); i++) {
+		for (p = active_dirents[i].next;
+		     p != &active_dirents[i]; p = p->next) {
+
+			de = list_entry(p, struct ps2mcfs_dirent, hashlink);
+			if (de->root != root)
+				continue;
+
+			path = ps2mcfs_get_path(de);
+			DPRINT(DBG_INFO, "  invalidate: %s\n", path);
+			ps2mcfs_put_path(de, path);
+
+			de->flags |= PS2MCFS_DIRENT_INVALID;
+			if (de->flags & PS2MCFS_DIRENT_BMAPPED) {
+				de->flags &= ~PS2MCFS_DIRENT_BMAPPED;
+
+				/*
+				 * XXX,
+				 * You can't call ps2mcfs_unref_dirent(de)
+				 * because it possibly free the node.
+				 * But I think it might not happen...
+				 */
+				de->refcount--;
+				if (de->refcount == 0)
+					printk("ps2mcfs: dirent refcount=0\n");
+			}
+
+			if ((inode = de->inode) != NULL) {
+				/*inode->i_op = &ps2mcfs_null_inode_operations;
+				 */
+				inode->i_nlink = 0;
+			}
+		}
+	}
+	ps2sif_unlock(ps2mcfs_lock);
+}
diff -purN linux-2.6.35.4-orig/drivers/ps2/mcfs/file.c linux-2.6.35.4/drivers/ps2/mcfs/file.c
--- linux-2.6.35.4-orig/drivers/ps2/mcfs/file.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/mcfs/file.c	2014-07-18 22:29:43.566367724 +0200
@@ -0,0 +1,471 @@
+/*
+ *  PlayStation 2 Memory Card File System driver
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/stat.h>
+#include <linux/list.h>
+#include <linux/init.h>
+#include <linux/unistd.h>
+#include <linux/slab.h>
+#include <linux/pagemap.h>
+#include <linux/fs.h>
+#include <linux/buffer_head.h>
+
+#include <asm/bitops.h>
+#include <asm/uaccess.h>
+
+#include "mcfs.h"
+#include "mcfs_debug.h"
+
+#define PS2MCFS_FILEBUFSIZE	1024
+#define ALIGN2(a, n)	((__typeof__(a))(((unsigned long)(a) + (n) - 1) / (n) * (n)))
+#define MIN(a, b)	((a) < (b) ? (a) : (b))
+
+char *ps2mcfs_filebuf;
+void *dmabuf;
+
+static ssize_t ps2mcfs_read(struct file *, char *, size_t, loff_t *);
+static ssize_t ps2mcfs_write(struct file *, const char *, size_t, loff_t *);
+static void ps2mcfs_truncate(struct inode *);
+static int ps2mcfs_open(struct inode *, struct file *);
+static int ps2mcfs_release(struct inode *, struct file *);
+static int ps2mcfs_readpage(struct file *, struct page *);
+static int ps2mcfs_writepage(struct page *page, struct writeback_control *wbc);
+static int ps2mcfs_get_block(struct inode *inode, sector_t iblock,
+			struct buffer_head *bh_result, int create);
+static sector_t ps2mcfs_bmap(struct address_space *address_space, sector_t sectort);
+
+struct file_operations ps2mcfs_file_operations = {
+	read:		ps2mcfs_read,
+	write:		ps2mcfs_write,
+	mmap:		generic_file_mmap,
+	open:		ps2mcfs_open,
+	release:	ps2mcfs_release,
+};
+
+struct inode_operations ps2mcfs_file_inode_operations = {
+	truncate:		ps2mcfs_truncate,
+	setattr:		ps2mcfs_setattr,
+};
+
+struct address_space_operations ps2mcfs_addrspace_operations = {
+	readpage:		ps2mcfs_readpage,
+	writepage:		ps2mcfs_writepage,
+	sync_page:		block_sync_page,
+	bmap:			ps2mcfs_bmap,
+};
+
+int
+ps2mcfs_init_filebuf()
+{
+	int dtabsz = ps2mc_getdtablesize();
+
+	TRACE("ps2mcfs_init_filebuf()\n");
+	ps2sif_assertlock(ps2mcfs_lock, "mcfs_init_filebuf");
+
+	dmabuf = kmalloc(PS2MCFS_FILEBUFSIZE * dtabsz + 64, GFP_KERNEL);
+	if (dmabuf == NULL)
+		return -ENOMEM;
+	ps2mcfs_filebuf = ALIGN2(dmabuf, 64);
+
+	return (0);
+}
+
+int
+ps2mcfs_exit_filebuf()
+{
+
+	TRACE("ps2mcfs_exit_filebuf()\n");
+	ps2sif_assertlock(ps2mcfs_lock, "mcfs_exit_filebuf");
+	if (dmabuf != NULL)
+		kfree(dmabuf);
+	dmabuf = NULL;
+
+	return (0);
+}
+
+#define READ_MODE	0
+#define WRITE_MODE	1
+#define USER_COPY	2
+
+static ssize_t
+ps2mcfs_rw(struct inode *inode, char *buf, size_t nbytes, loff_t *ppos, int mode)
+{
+	struct ps2mcfs_dirent *de;
+	int fd = -1;
+	int res, nreads, pos;
+	char *filebuf;
+
+	de = inode->i_private;
+	if (de->flags & PS2MCFS_DIRENT_INVALID)
+		return -EIO;
+
+	/*
+	 * get full-path-name and open file
+	 */
+	res = ps2mcfs_get_fd(de, (mode & WRITE_MODE) ? O_WRONLY : O_RDONLY);
+	if (res < 0)
+		goto out;
+	fd = res;
+
+	/*
+	 * XXX, It asummes that (0 <= fd) and (fd < descriptor table size)
+	 */
+	filebuf = &ps2mcfs_filebuf[PS2MCFS_FILEBUFSIZE * fd];
+
+	/*
+	 * seek
+	 */
+	if (mode & WRITE_MODE) {
+		if (inode->i_size < *ppos)
+			pos = inode->i_size;
+		else
+			pos = *ppos;
+	} else {
+			pos = *ppos;
+	}
+	if ((res = ps2mc_lseek(fd, pos, 0 /* SEEK_SET */)) < 0)
+		goto out;
+	if (res != pos) {
+		res = -EIO;
+		goto out;
+	}
+	if ((mode & WRITE_MODE) && inode->i_size < *ppos) {
+		int pad = *ppos - inode->i_size;
+		memset(filebuf, 0, MIN(pad, PS2MCFS_FILEBUFSIZE));
+		while (0 < pad) {
+			int n = MIN(pad, PS2MCFS_FILEBUFSIZE);
+			res = ps2mc_write(fd, filebuf, n);
+			if (res <= 0) /* error or EOF */
+				goto out;
+			pad -= res;
+			inode->i_size += res;
+		}
+	}
+
+	/*
+	 * read/write
+	 */
+	nreads = 0;
+	res = 0;
+	while (0 < nbytes) {
+		int n = MIN(nbytes, PS2MCFS_FILEBUFSIZE);
+		if (mode & WRITE_MODE) {
+			/* write */
+			if (mode & USER_COPY) {
+				if (copy_from_user(filebuf, buf, n)) {
+					res = -EFAULT;
+					goto out;
+				}
+			} else {
+				memcpy(filebuf, buf, n);
+			}
+			res = ps2mc_write(fd, filebuf, n);
+			if (res <= 0) /* error or EOF */
+				break;
+		} else {
+			/* read */
+			res = ps2mc_read(fd, filebuf, n);
+			if (res <= 0) /* error or EOF */
+				break;
+			if (mode & USER_COPY) {
+				if (copy_to_user(buf, filebuf, res)) {
+					res = -EFAULT;
+					goto out;
+				}
+			} else {
+				memcpy(buf, filebuf, res);
+			}
+		}
+		nreads += res;
+		buf += res;
+		nbytes -= res;
+		*ppos += res;
+	}
+	res = (nreads == 0) ? res : nreads;
+
+ out:
+	TRACE("ps2mcfs_rw(): res=%d\n", res);
+
+	return (res);
+}
+
+int
+ps2mcfs_create(struct ps2mcfs_dirent *de)
+{
+	int res;
+	const char *path;
+
+	/* need the lock to call get_fd() */
+	res = ps2sif_lock_interruptible(ps2mcfs_lock, "mcfs_read");
+	if (res < 0)
+		return (res);
+
+	path = ps2mcfs_get_path(de);
+	TRACE("ps2mcfs_create(%s)\n", path);
+	ps2mcfs_put_path(de, path);
+
+	if (0 <= (res = ps2mcfs_get_fd(de, O_RDWR | O_CREAT))) {
+		res = 0; /* succeeded */
+	}
+	ps2sif_unlock(ps2mcfs_lock);
+
+	return (res);
+}
+
+static ssize_t
+ps2mcfs_read(struct file *filp, char * buf, size_t count, loff_t *ppos)
+{
+	int res;
+	TRACE("ps2mcfs_read(filp=%p, pos=%ld)\n", filp, (long)*ppos);
+
+	res = ps2sif_lock_interruptible(ps2mcfs_lock, "mcfs_read");
+	if (res < 0)
+		return (res);
+
+	res = ps2mcfs_rw(filp->f_dentry->d_inode, buf,
+			 count, ppos, READ_MODE|USER_COPY);
+	ps2sif_unlock_interruptible(ps2mcfs_lock);
+
+	return (res);
+}
+
+static ssize_t
+ps2mcfs_write(struct file *filp, const char * buf, size_t count, loff_t *ppos)
+{
+	int res;
+	struct inode *inode = filp->f_dentry->d_inode;
+
+	TRACE("ps2mcfs_write(filp=%p, pos=%ld)\n", filp, (long)*ppos);
+	res = ps2sif_lock_interruptible(ps2mcfs_lock, "mcfs_write");
+	if (res < 0)
+		return (res);
+
+	res = ps2mcfs_rw(filp->f_dentry->d_inode, (char*)buf,
+			 count, ppos, WRITE_MODE|USER_COPY);
+	if (res < 0)
+		goto out;
+
+	if (inode->i_size < *ppos)
+		inode->i_size = *ppos; /* file size was extended */
+	inode->i_mtime = CURRENT_TIME;
+ out:
+	ps2sif_unlock_interruptible(ps2mcfs_lock);
+
+	return (res);
+}
+
+static int
+ps2mcfs_open(struct inode *inode, struct file *filp)
+{
+	int res;
+	struct ps2mcfs_dirent *de = inode->i_private;
+	const char *path;
+
+	path = ps2mcfs_get_path(de);
+	TRACE("ps2mcfs_open(%s)\n", path);
+	if (*path == '\0')
+		return -ENAMETOOLONG; /* path name might be too long */
+	ps2mcfs_put_path(de, path);
+
+	res = ps2sif_lock_interruptible(ps2mcfs_lock, "mcfs_read");
+	if (res < 0)
+		return (res);
+	ps2mcfs_ref_dirent(de);
+	ps2sif_unlock_interruptible(ps2mcfs_lock);
+
+	return (0);
+}
+
+static int
+ps2mcfs_release(struct inode *inode, struct file *filp)
+{
+	int res;
+	struct ps2mcfs_dirent *de = inode->i_private;
+	const char *path;
+
+	path = ps2mcfs_get_path(de);
+	TRACE("ps2mcfs_release(%s)\n", path);
+	ps2mcfs_put_path(de, path);
+
+	res = ps2sif_lock_interruptible(ps2mcfs_lock, "mcfs_read");
+	if (res < 0)
+		return (res);
+	ps2mcfs_free_fd(de);
+	ps2mcfs_unref_dirent(de);
+	ps2sif_unlock_interruptible(ps2mcfs_lock);
+
+	return (0);
+}
+
+static int
+ps2mcfs_readpage(struct file *filp, struct page *page)
+{
+	return block_read_full_page(page, ps2mcfs_get_block);
+}
+
+static sector_t ps2mcfs_bmap(struct address_space *address_space, sector_t sectort)
+{
+	return generic_block_bmap(address_space, sectort, ps2mcfs_get_block);
+}
+
+static int ps2mcfs_get_block(struct inode *inode, sector_t block,
+			struct buffer_head *bh, int create)
+{
+	struct ps2mcfs_dirent *de;
+	int block_shift;
+	long sector;
+
+	ps2sif_lock(ps2mcfs_lock, "mcfs_bmap");
+	de = inode->i_private;
+	block_shift = de->root->block_shift;
+	if ((1 << PS2MCFS_SECTOR_BITS) <= (block << block_shift)) {
+		printk("ps2mcfs_bmap(): block number is too big\n");
+		ps2sif_unlock(ps2mcfs_lock);
+		return -EINVAL;
+	}
+
+	if (de->flags & PS2MCFS_DIRENT_INVALID) {
+		ps2sif_unlock(ps2mcfs_lock);
+		return -EINVAL;
+	}
+
+	sector = ((de->no << PS2MCFS_SECTOR_BITS) >> block_shift) | block;
+	de->flags |= PS2MCFS_DIRENT_BMAPPED;
+
+#ifdef PS2MCFS_DEBUG
+	{
+	const char *path;
+	path = ps2mcfs_get_path(de);
+	DPRINT(DBG_BLOCKRW, "ps2mcfs_bmap(%s): block=%llx -> %lx\n",
+	       path, block, sector);
+	ps2mcfs_put_path(de, path);
+	}
+#endif
+	ps2sif_unlock(ps2mcfs_lock);
+
+	bh->b_bdev = inode->i_bdev;
+	bh->b_blocknr = sector;
+	bh->b_state |= (1 << BH_Mapped);
+
+	return (0);
+}
+
+static int
+ps2mcfs_writepage(struct page *page, struct writeback_control *wbc)
+{
+	return block_write_full_page(page, ps2mcfs_get_block, wbc);
+}
+
+int
+ps2mcfs_blkrw(int rw, int sector, void *buffer, int nsectors)
+{
+	struct ps2mcfs_dirent *de;
+	int dno, res;
+	loff_t pos;
+
+	dno = ((sector >> PS2MCFS_DIRENT_SHIFT) & PS2MCFS_DIRENT_MASK);
+	sector = ((sector >> PS2MCFS_SECTOR_SHIFT) & PS2MCFS_SECTOR_MASK);
+        DPRINT(DBG_BLOCKRW, "ps2mcfs: %s dirent=%d sect=%x, len=%d, addr=%p\n",
+	       rw ? "write" : "read", dno, sector, nsectors, buffer);
+
+	ps2sif_lock(ps2mcfs_lock, "mcfs_bmap");
+	if ((de = ps2mcfs_find_dirent_no(dno)) == NULL ||
+	    de->inode == NULL) {
+		res = -ENOENT;
+		goto out;
+	}
+
+	if (de->inode->i_size < (sector + nsectors) * 512) {
+		res = -EIO;
+		goto out;
+	}
+
+	pos = sector * 512;
+	res = ps2mcfs_rw(de->inode, buffer, nsectors * 512, &pos,
+			 rw ? WRITE_MODE : READ_MODE);
+
+	res = (res == nsectors * 512 ? 0 : -EIO);
+ out:
+	ps2sif_unlock(ps2mcfs_lock);
+
+	return (res);
+}
+
+static void
+ps2mcfs_truncate(struct inode *inode)
+{
+	struct ps2mcfs_dirent *de;
+	const char *path;
+	struct ps2mc_dirent mcdirent;
+
+	ps2sif_lock(ps2mcfs_lock, "truncate");
+	de = inode->i_private;
+	path = ps2mcfs_get_path(de);
+	if (*path == '\0')
+		return; /* path name might be too long */
+
+	TRACE("ps2mcfs_truncate(%s): size=%lld\n", path, inode->i_size);
+
+	if (de->flags & PS2MCFS_DIRENT_INVALID)
+		goto out;
+
+	/*
+	 * the size must be zero.
+	 * please see ps2mcfs_notify_change() in inode.c.
+	 */
+	if (inode->i_size != 0)
+		goto out;
+
+	/*
+	 * save mode and time of creation 
+	 */
+	if (ps2mc_getdir(de->root->portslot, path, &mcdirent) < 0)
+		goto out;
+
+	/*
+	 * remove the entry
+	 */
+	if (ps2mc_delete(de->root->portslot, path) < 0)
+		goto out;
+
+	/*
+	 * create new one
+	 */
+	if (ps2mcfs_create(de) < 0)
+		goto out;
+
+	/*
+	 * restore mode and time of creation 
+	 */
+	if (ps2mc_setdir(de->root->portslot, path,
+			   PS2MC_SETDIR_CTIME, &mcdirent) < 0)
+		goto out;
+
+ out:
+	ps2mcfs_put_path(de, path);
+	ps2sif_unlock(ps2mcfs_lock);
+
+	return;
+}
diff -purN linux-2.6.35.4-orig/drivers/ps2/mcfs/filedesc.c linux-2.6.35.4/drivers/ps2/mcfs/filedesc.c
--- linux-2.6.35.4-orig/drivers/ps2/mcfs/filedesc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/mcfs/filedesc.c	2014-07-18 22:29:43.566367724 +0200
@@ -0,0 +1,253 @@
+/*
+ *  PlayStation 2 Memory Card File System driver
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/stat.h>
+#include <linux/list.h>
+#include <linux/init.h>
+#include <linux/unistd.h>
+#include <linux/slab.h>
+
+#include <asm/bitops.h>
+#include <asm/uaccess.h>
+
+#include "mcfs.h"
+#include "mcfs_debug.h"
+
+static struct ps2mcfs_filedesc {
+	struct ps2mcfs_dirent *dirent;
+	struct list_head link;
+	int fd;
+	int rwmode;
+	int expire_time;
+} *items;
+
+static struct list_head lru;
+
+static void __free_fd(struct ps2mcfs_dirent *);
+
+/*
+ * Insert a new entry at tail of the specified list
+ */
+static __inline__ void list_addtail(struct list_head *new, struct list_head *head)
+{
+	__list_add(new, head->prev, head);
+}
+
+int
+ps2mcfs_init_fdcache()
+{
+	int i;
+	int dtabsz = ps2mc_getdtablesize();
+
+	ps2sif_assertlock(ps2mcfs_lock, "mcfs_init_fdcache");
+#if defined(PS2MCFS_DEBUG) && defined(CONFIG_T10000_DEBUG_HOOK)
+	if (ps2mcfs_debug & DBG_DEBUGHOOK) {
+		static void dump(void);
+		extern void (*ps2_debug_hook[0x80])(int c);
+		ps2_debug_hook['D'] = (void(*)(int))dump;
+	}
+#endif
+
+	items = kmalloc(sizeof(struct ps2mcfs_filedesc) * dtabsz, GFP_KERNEL);
+	if (items == NULL)
+		return -ENOMEM;
+
+	INIT_LIST_HEAD(&lru);
+	for (i = 0; i < dtabsz; i++) {
+		items[i].dirent = NULL;
+		items[i].fd = -1;
+		list_add(&items[i].link, &lru);
+	}
+
+	return (0);
+}
+
+int
+ps2mcfs_exit_fdcache()
+{
+	static struct list_head *p;
+
+	ps2sif_assertlock(ps2mcfs_lock, "mcfs_exit_fdcache");
+	if (items != NULL)
+		kfree(items);
+	items = NULL;
+
+#if defined(PS2MCFS_DEBUG) && defined(CONFIG_T10000_DEBUG_HOOK)
+	if (ps2mcfs_debug & DBG_DEBUGHOOK) {
+		static void dump(void);
+		extern void (*ps2_debug_hook[0x80])(int c);
+		ps2_debug_hook['D'] = (void(*)(int))NULL;
+	}
+#endif
+	for (p = lru.next; p != &lru; p = p->next) {
+		struct ps2mcfs_filedesc *ent;
+
+		ent = list_entry(p, struct ps2mcfs_filedesc, link);
+		if (ent->dirent)
+			__free_fd(ent->dirent);
+	}
+
+	return (0);
+}
+
+
+#if defined(PS2MCFS_DEBUG) && defined(CONFIG_T10000_DEBUG_HOOK)
+static void dump(void)
+{
+	struct list_head *p;
+	const char *path;
+
+	for (p = lru.next; p != &lru; p = p->next) {
+		struct ps2mcfs_filedesc *ent;
+
+		ent = list_entry(p, struct ps2mcfs_filedesc, link);
+		if (ent->dirent)
+			path = ps2mcfs_get_path(ent->dirent);
+		else
+			path = "-";
+		printk(" %d: '%s' fd=%d\n", ent - items, path, ent->fd);
+		if (ent->dirent)
+			ps2mcfs_put_path(ent->dirent, path);
+	}
+}
+#endif
+
+int
+ps2mcfs_get_fd(struct ps2mcfs_dirent *dirent, int rwmode)
+{
+	int res;
+	struct ps2mcfs_filedesc *ent;
+#ifdef PS2MCFS_DEBUG
+	const char *path;
+
+	ps2sif_assertlock(ps2mcfs_lock, "mcfs_get_fd");
+	path = ps2mcfs_get_path(dirent);
+	if (*path == '\0')
+		return -ENAMETOOLONG; /* path name might be too long */
+#endif
+
+	ent = dirent->fd;
+	if (ent != NULL) {
+		if (ent->rwmode == rwmode) {
+			list_del(&ent->link);
+			list_add(&ent->link, &lru);
+			ent->expire_time = PS2MCFS_FD_EXPIRE_TIME;
+			DPRINT(DBG_FILECACHE, "get_fd: %s\n", path);
+			res = ent->fd;
+			goto out;
+		}
+		__free_fd(dirent);
+	}
+
+	ent = list_entry(lru.prev, struct ps2mcfs_filedesc, link);
+	if (ent->dirent != NULL)
+		__free_fd(ent->dirent);
+	list_del(&ent->link);
+	list_add(&ent->link, &lru);
+	ent->expire_time = PS2MCFS_FD_EXPIRE_TIME;
+	dirent->fd = ent;
+	ent->dirent = dirent;
+	ent->rwmode = rwmode;
+	DPRINT(DBG_FILECACHE, "get_fd: ps2mc_open(%s)\n", path);
+	ent->fd = ps2mc_open(dirent->root->portslot, path, rwmode);
+	res = ent->fd;
+	if (ent->fd < 0)
+		__free_fd(dirent);
+ out:
+	DPRINT(DBG_FILECACHE, "get_fd: fd=%d %s\n", ent->fd, path);
+	ps2mcfs_put_path(dirent, path);
+
+	return (res);
+}
+
+void
+ps2mcfs_free_fd(struct ps2mcfs_dirent *dirent)
+{
+	ps2sif_lock(ps2mcfs_lock, "mcfs_free_fd");
+	__free_fd(dirent);
+	ps2sif_unlock(ps2mcfs_lock);
+}
+
+static void
+__free_fd(struct ps2mcfs_dirent *dirent)
+{
+	struct ps2mcfs_filedesc *ent;
+
+	if (dirent->fd == NULL) {
+		return;
+	}
+	ent = dirent->fd;
+	dirent->fd = NULL;
+#ifdef PS2MCFS_DEBUG
+	{
+		const char *path;
+		
+		path = ps2mcfs_get_path(dirent);
+		DPRINT(DBG_FILECACHE, "ps2mcfs_free_fd: %s(fd=%d)\n",
+		       path, ent->fd);
+		if (0 <= ent->fd)
+			DPRINT(DBG_FILECACHE,
+			       "free_fd: ps2mc_close(%s)\n", path);
+		ps2mcfs_put_path(dirent, path);
+	}
+#endif
+	if (0 <= ent->fd)
+		ps2mc_close(ent->fd);
+	ent->dirent = NULL;
+	ent->fd = -1;
+	list_del(&ent->link);
+	list_addtail(&ent->link, &lru);
+}
+
+/*
+ * ps2mcfs_check_fd() is called from daemon thread (ps2mcfs_thread)
+ * periodically.
+ */
+void
+ps2mcfs_check_fd()
+{
+	struct list_head *p;
+
+	ps2sif_assertlock(ps2mcfs_lock, "mcfs_check_fd");
+	for (p = lru.next; p != &lru; p = p->next) {
+		struct ps2mcfs_filedesc *ent;
+
+		ent = list_entry(p, struct ps2mcfs_filedesc, link);
+		if (ent->dirent) {
+			ent->expire_time -= PS2MCFS_CHECK_INTERVAL;
+			if (ent->expire_time < 0) {
+#ifdef PS2MCFS_DEBUG
+				const char *path = NULL;
+				path = ps2mcfs_get_path(ent->dirent);
+				DPRINT(DBG_FILECACHE,
+				       "check_fd: expire '%s'\n", path);
+				ps2mcfs_put_path(ent->dirent, path);
+#endif
+				__free_fd(ent->dirent);
+			}
+
+		}
+	}
+}
diff -purN linux-2.6.35.4-orig/drivers/ps2/mcfs/inode.c linux-2.6.35.4/drivers/ps2/mcfs/inode.c
--- linux-2.6.35.4-orig/drivers/ps2/mcfs/inode.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/mcfs/inode.c	2014-07-18 22:29:43.566367724 +0200
@@ -0,0 +1,429 @@
+/*
+ *  PlayStation 2 Memory Card File System driver
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/stat.h>
+#include <linux/file.h>
+#include <linux/limits.h>
+#include <linux/time.h>
+#include <linux/rtc.h>
+#include <linux/fs.h>
+#include <linux/pagemap.h>
+#include <linux/statfs.h>
+
+#include <asm/time.h>
+#include <asm/system.h>
+#include <asm/uaccess.h>
+
+#include "mcfs.h"
+#include "mcfs_debug.h"
+
+extern void free_ps2mcfs_entry(struct ps2mcfs_dirent *);
+int ps2mcfs_write_inode(struct inode *, struct writeback_control *);
+int ps2mcfs_statfs(struct dentry *, struct kstatfs *);
+void ps2mcfs_umount_begin(struct super_block *);
+
+/*
+* The Linux kernel has changed, so I had to make changes in order to compile
+* this code. i_blksize is no longer a member of struct inode. However,
+* i_blkbits remains, and i_blksize = (1 << i_blkbits).
+* i_blkbits is computed by the function blksize_bits(), which I copied
+* from linux/include/linux/blkdev.h.
+* u.generic_ip is no longer part of struct inode; we use i_private instead.
+* Finally, lfs_get_super was modified to reflect current declarations.
+* -- Chris Brannon, 02/08/2009 - (the followin lines are from his patch)
+*/
+
+static inline unsigned int blksize_bits(unsigned int size)
+{
+ 	unsigned int bits = 8;
+	do {
+ 		bits++;
+ 		size >>= 1;
+	} while (size > 256);
+return bits;
+}
+
+struct inode *ps2mcfs_iget(struct super_block *sb, unsigned long ino)
+{
+            struct inode *inode;
+          
+            inode = iget_locked(sb, ino);
+            if(!inode)
+                         return ERR_PTR(-ENOMEM);
+            if(!(inode->i_state & I_NEW))
+                          return inode;
+
+            /* TBD: Your implementation specific code like initializeing atime,
+	     * ctime, mtime, address_space mapping etc. ( depends on what you
+	     * wanna do with a new inode )
+	     */
+       
+            unlock_new_inode(inode);
+            return inode;  
+           
+}
+
+/*
+ * Decrement the use count of the ps2mcfs_dirent.
+ */
+static void ps2mcfs_delete_inode(struct inode *inode)
+{
+	struct ps2mcfs_dirent *de;
+
+	ps2sif_lock(ps2mcfs_lock, "mcfs_delete_inode");
+	de = inode->i_private;
+	if (de) {
+		char buf[PS2MC_NAME_MAX + 1];
+
+		ps2mc_terminate_name(buf, de->name, de->namelen);
+		TRACE("ps2mcfs_delete_inode(%p): %s\n", inode, buf);
+		de->inode = NULL;		/* failsafe */
+		inode->i_private = NULL;	/* failsafe */
+		ps2mcfs_unref_dirent(de);
+	}
+	clear_inode(inode);
+	ps2sif_unlock(ps2mcfs_lock);
+}
+
+#ifdef PS2MCFS_DEBUG
+static char *
+ps2mcfs_ctime(time_t t)
+{
+	static char tmpbuf[32];
+	struct rtc_time date;
+
+	rtc_time_to_tm(t, &date);
+	sprintf(tmpbuf, "%04d.%02d.%02d %02d:%02d:%02d",
+		date.tm_year, date.tm_mon, date.tm_mday,
+		date.tm_hour, date.tm_min, date.tm_sec);
+	return (tmpbuf);
+}
+#endif
+
+int
+ps2mcfs_setattr(struct dentry *dentry, struct iattr *attr)
+{
+	int res, flags;
+	struct inode *inode = dentry->d_inode;
+	struct ps2mcfs_dirent *de = inode->i_private;
+	const char *path;
+	struct ps2mc_dirent mcdirent;
+
+	path = ps2mcfs_get_path(de);
+	TRACE("ps2mcfs_setattr(%s)\n", path);
+	ps2mcfs_put_path(de, path);
+
+	/*
+	 * inode_change_ok and inode_setattr are defined in linux/fs/attr.c
+	 */
+	if ((res = inode_change_ok(inode, attr)) < 0)
+		return (res);
+
+#ifdef PS2MCFS_DEBUG
+	DPRINT(DBG_INFO, "ps2mcfs_setattr():");
+	if (attr->ia_valid & ATTR_UID)
+		DPRINTK(DBG_INFO, " uid %d->%d", inode->i_uid, attr->ia_uid);
+	if (attr->ia_valid & ATTR_GID)
+		DPRINTK(DBG_INFO, " gid %d->%d", inode->i_gid, attr->ia_gid);
+	if (attr->ia_valid & ATTR_SIZE)
+		DPRINTK(DBG_INFO, " size %lld->%lld", inode->i_size, attr->ia_size);
+	if (attr->ia_valid & ATTR_ATIME)
+		DPRINTK(DBG_INFO, " atime %ld->%ld", inode->i_atime.tv_sec, attr->ia_atime.tv_sec);
+	if (attr->ia_valid & ATTR_MTIME)
+		DPRINTK(DBG_INFO, " mtime %ld->%ld(%s)", inode->i_mtime.tv_sec, attr->ia_mtime.tv_sec, ps2mcfs_ctime(attr->ia_mtime.tv_sec));
+	if (attr->ia_valid & ATTR_CTIME)
+		DPRINTK(DBG_INFO, " ctime %ld->%ld", inode->i_ctime.tv_sec, attr->ia_ctime.tv_sec);
+	if (attr->ia_valid & ATTR_MODE)
+		DPRINTK(DBG_INFO, " mode %x->%x", inode->i_mode, attr->ia_mode);
+	DPRINTK(DBG_INFO, "\n");
+#endif
+
+	/*
+	 * currently, we can't truncate file size unless the size is zero.
+	 */
+	if ((attr->ia_valid & ATTR_SIZE) && attr->ia_size != 0)
+		return -EPERM;
+
+	/* just ignore these changes */
+	attr->ia_valid &= ~(ATTR_UID | ATTR_GID | ATTR_ATIME | ATTR_CTIME);
+
+	flags = 0;
+	if (attr->ia_valid & ATTR_MODE) {
+		mcdirent.mode = attr->ia_mode;
+		flags |= PS2MC_SETDIR_MODE;
+	}
+	if (attr->ia_valid & ATTR_MTIME) {
+		mcdirent.mtime = attr->ia_mtime.tv_sec;
+		flags |= PS2MC_SETDIR_MTIME;
+	}
+
+	/*
+	 * Update real directory now intead of write inode operaion.
+	 */
+	path = ps2mcfs_get_path(de);
+	if (*path == '\0')
+		return -ENAMETOOLONG; /* path name might be too long */
+	res = ps2mc_setdir(de->root->portslot, path, flags, &mcdirent);
+	ps2mcfs_put_path(de, path);
+	if (res < 0)
+		return res;
+	
+	/* ps2mc_setdir might fix the mcdirent */
+	if (attr->ia_valid & ATTR_MODE)
+		inode->i_mode = (mcdirent.mode & ~((mode_t)de->root->opts.umask));
+	if (attr->ia_valid & ATTR_MTIME)
+		inode->i_mtime.tv_sec = mcdirent.mtime;
+	if (attr->ia_valid & ATTR_SIZE)
+		inode->i_size = attr->ia_size;
+
+	return res;
+}
+
+void ps2mcfs_put_super(struct super_block *sb)
+{
+	char dbuf[BDEVNAME_SIZE];
+	TRACE("ps2mcfs_put_super(dev=%s)\n", __bdevname(sb->s_dev, dbuf));
+	ps2mcfs_put_root(MINOR(sb->s_dev));
+}
+
+static struct super_operations ps2mcfs_sops = { 
+	write_inode:	ps2mcfs_write_inode,
+	delete_inode:	ps2mcfs_delete_inode,
+	put_super:	ps2mcfs_put_super,
+	statfs:		ps2mcfs_statfs,
+	umount_begin:	ps2mcfs_umount_begin,
+};
+
+static int parse_options(char *options, struct ps2mcfs_options *opts)
+{
+	char *this_char,*value;
+
+	TRACE("parse_options(%s)\n", options);
+	if (!options) return 1;
+
+	opts->uid = current->cred->uid;
+	opts->gid = current->cred->gid;
+	opts->umask = 077;
+
+	for (this_char = strsep(&options, ",");
+	     this_char;
+	     this_char = strsep(&options,",")) {
+		if ((value = strchr(this_char, '=')) != NULL)
+			*value++ = 0;
+		if (!strcmp(this_char, "uid")) {
+			if (!value || !*value) return (0);
+			opts->uid = simple_strtoul(value, &value, 0);
+			if (*value) return (0);
+		}
+		else if (!strcmp(this_char, "gid")) {
+			if (!value || !*value) return (0);
+			opts->gid = simple_strtoul(value, &value, 0);
+			if (*value) return (0);
+		}
+		else if (!strcmp(this_char, "umask")) {
+			if (!value || !*value) return (0);
+			opts->umask = simple_strtoul(value, &value, 8);
+			if (*value) return (0);
+		}
+		else return (0);
+	}
+
+	return (1);
+}
+
+extern int ps2mcfs_read_super(struct super_block *sb, void *data, 
+				    int silent)
+{
+	char dbuf[BDEVNAME_SIZE];
+	struct inode *root_inode = NULL;
+	struct ps2mcfs_root *root;
+
+	TRACE("ps2mcfs_read_super(dev=%s)\n", __bdevname(sb->s_dev, dbuf));
+	if (ps2mcfs_get_root(sb->s_dev, &root) < 0) {
+		printk("ps2mcfs: memory card%d%d doesn't exist\n",
+		       PS2MC_PORT(MINOR(sb->s_dev)),
+		       PS2MC_SLOT(MINOR(sb->s_dev)));
+		return -EINVAL;
+	}
+
+	sb->s_blocksize_bits = 10;
+	sb->s_blocksize = (1 << sb->s_blocksize_bits);
+	sb->s_magic = PS2MCFS_SUPER_MAGIC;
+	sb->s_op = &ps2mcfs_sops;
+	if (!parse_options(data, &root->opts))
+		goto errout;
+	if ((root_inode = ps2mcfs_iget(sb, root->dirent->ino)) == NULL)
+		goto errout;
+	ps2mcfs_read_inode(root_inode);
+	sb->s_root = d_alloc_root(root_inode);
+	if (!sb->s_root)
+		goto errout;
+
+	return(0);
+
+errout:
+	if (root_inode) iput(root_inode);
+	sb->s_dev = 0;
+
+	return -EINVAL;
+}
+
+int ps2mcfs_statfs(struct dentry *dentry, struct kstatfs *k_statfs)
+{
+	int res;
+	struct ps2mc_cardinfo info;
+
+	TRACE("ps2mcfs_statfs(card%02x)\n", MINOR(dentry->d_sb->s_dev));
+
+	if ((res = ps2mc_getinfo(MINOR(dentry->d_sb->s_dev), &info)) < 0)
+		return res;
+
+	memset(k_statfs, 0, sizeof(struct kstatfs));
+	k_statfs->f_type = PS2MCFS_SUPER_MAGIC;
+	k_statfs->f_namelen = PS2MC_NAME_MAX;
+
+	if ((info.type == PS2MC_TYPE_PS2) || (info.type == PS2MC_TYPE_PS1)) {
+		k_statfs->f_bsize = info.blocksize;
+		k_statfs->f_blocks = info.totalblocks;
+		k_statfs->f_bfree = info.freeblocks;
+		k_statfs->f_bavail = info.freeblocks;
+	}
+
+	return (0);
+}
+
+void ps2mcfs_umount_begin(struct super_block *sb)
+{
+	TRACE("ps2mcfs_umount_begin(dev=%d)\n", sb->s_dev);
+}
+
+void ps2mcfs_read_inode(struct inode *inode)
+{
+	struct ps2mcfs_dirent *de;
+	
+	TRACE("ps2mcfs_read_inode(inode=%p): ino=%ld\n", inode, inode->i_ino);
+
+	/*
+	 * TBD: Why this function doesn't return some value?
+	 */
+	inode->i_nlink = 0;
+	inode->i_op = NULL;
+	inode->i_mode = 0;
+	inode->i_size = 0;
+	inode->i_mtime.tv_sec = inode->i_atime.tv_sec = inode->i_ctime.tv_sec = 0;
+	inode->i_blkbits = blksize_bits(0);
+	inode->i_blocks = 0;
+	inode->i_uid = 0;
+	inode->i_gid = 0;
+
+	ps2sif_lock(ps2mcfs_lock, "mcfs_read_inode");
+	if ((de = ps2mcfs_find_dirent_ino(inode->i_ino)) == NULL) {
+		printk(KERN_CRIT "ps2mcfs: can't find dirent!\n");
+		goto out;
+	}
+#ifdef PS2MCFS_DEBUG
+	if (inode->i_private != NULL) {
+		printk(KERN_CRIT "ps2mcfs: inode isn't clean!\n");
+		goto out;
+	}
+#endif
+	inode->i_private = de;
+	de->inode = inode;
+	ps2mcfs_ref_dirent(de);
+
+	if (ps2mcfs_update_inode(inode) < 0) {
+		if (de->parent == NULL)
+			ps2mcfs_setup_fake_root(de->root);
+	}
+ out:
+	ps2sif_unlock(ps2mcfs_lock);
+
+	return;
+}
+
+int ps2mcfs_update_inode(struct inode *inode)
+{
+	int res;
+	struct ps2mc_dirent buf;
+	struct ps2mcfs_dirent *de;
+	const char *path;
+
+	ps2sif_lock(ps2mcfs_lock, "mcfs_update_inode");
+	de = inode->i_private;
+
+	path = ps2mcfs_get_path(de);
+	if (*path == '\0') {
+		res = -ENAMETOOLONG;
+		goto out;
+	}
+	TRACE("ps2mcfs_update_inode(%s)\n", path);
+
+	res = ps2mc_getdir(de->root->portslot, path, &buf);
+	ps2mcfs_put_path(de, path);
+	if (res <= 0) {
+		if (de->parent == NULL)
+			res = ps2mcfs_setup_fake_root(de->root);
+		goto out;
+	}
+
+	if (buf.mode & S_IFDIR) {
+		/* count up how many entries in it */
+		if ((res = ps2mcfs_countdir(de)) < 0)
+			goto out;
+		/* root directory doesn't contains '.' and '..' entries */
+		if (de->parent == NULL)
+			res += 2;
+		inode->i_nlink = res;
+		inode->i_op = &ps2mcfs_dir_inode_operations;
+		inode->i_fop = &ps2mcfs_dir_operations;
+	} else {
+		inode->i_nlink = 1;
+		inode->i_op = &ps2mcfs_file_inode_operations;
+		inode->i_fop = &ps2mcfs_file_operations;
+		inode->i_mapping->a_ops = &ps2mcfs_addrspace_operations;
+	}
+
+	inode->i_mtime.tv_sec = buf.mtime;
+	inode->i_mode = buf.mode & ~((mode_t)de->root->opts.umask);
+	inode->i_size = buf.size;
+
+	inode->i_atime = inode->i_ctime = CURRENT_TIME;	/* TBD */
+	inode->i_blkbits = blksize_bits(inode->i_sb->s_blocksize);
+	inode->i_blocks = (buf.size + inode->i_sb->s_blocksize - 1) / inode->i_sb->s_blocksize;
+	inode->i_uid = de->root->opts.uid;
+	inode->i_gid = de->root->opts.gid;
+	res = 0;
+ out:
+	ps2sif_unlock(ps2mcfs_lock);
+
+	return (res);
+}
+
+int ps2mcfs_write_inode(struct inode *inode, struct writeback_control * wbc) 
+{
+	TRACE("ps2mcfs_write_inode(inode=%p): ino=%ld\n", inode, inode->i_ino);
+	return 0;
+}
diff -purN linux-2.6.35.4-orig/drivers/ps2/mcfs/Kconfig linux-2.6.35.4/drivers/ps2/mcfs/Kconfig
--- linux-2.6.35.4-orig/drivers/ps2/mcfs/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/mcfs/Kconfig	2014-07-18 22:29:43.566367724 +0200
@@ -0,0 +1,12 @@
+#
+# Sony Playstation 2 configuration
+#
+
+menu "Sony Playstation 2 Memory Card"
+
+config PS2_MCFS
+	tristate "Support for PS2MCFS"
+	default y
+	depends on SONY_PS2 && PS2_MC
+
+endmenu
diff -purN linux-2.6.35.4-orig/drivers/ps2/mcfs/Makefile linux-2.6.35.4/drivers/ps2/mcfs/Makefile
--- linux-2.6.35.4-orig/drivers/ps2/mcfs/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/mcfs/Makefile	2014-07-18 22:29:43.566367724 +0200
@@ -0,0 +1,8 @@
+#
+# Makefile for the ps2 mcfs.
+#
+
+ps2mcfs-objs	:= mcfs.o inode.o root.o dir.o file.o \
+	null.o dirent.o path.o filedesc.o
+
+obj-$(CONFIG_PS2_MCFS)		+= ps2mcfs.o
diff -purN linux-2.6.35.4-orig/drivers/ps2/mcfs/mcfs.c linux-2.6.35.4/drivers/ps2/mcfs/mcfs.c
--- linux-2.6.35.4-orig/drivers/ps2/mcfs/mcfs.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/mcfs/mcfs.c	2014-07-18 22:29:43.566367724 +0200
@@ -0,0 +1,211 @@
+/*
+ *  PlayStation 2 Memory Card File System driver
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/soundcard.h>
+#include <linux/smp_lock.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/signal.h>
+
+#include "mcfs.h"
+#include "mcfs_debug.h"
+
+unsigned long ps2mcfs_debug = 0;
+static unsigned long oldflags;
+extern int (*ps2mc_blkrw_hook)(int, int, void*, int);
+
+char *ps2mcfs_basedir = PS2MC_BASEDIR;
+ps2sif_lock_t *ps2mcfs_lock;
+
+static int ps2mcfs_get_sb(struct file_system_type *fs_type, int flags, const char *dev_name, void *data, struct vfsmount *mnt)
+{
+	return get_sb_bdev(fs_type, flags, dev_name, data,
+		ps2mcfs_read_super, mnt);
+}
+
+struct file_system_type ps2mcfs_fs_type = {
+	.name	= 	"ps2mcfs",
+	.fs_flags=	FS_REQUIRES_DEV,
+	.get_sb	= 	ps2mcfs_get_sb,
+	.kill_sb= 	kill_block_super,
+	.owner	=	THIS_MODULE,
+};
+
+
+/* wacthing thread stuff */
+static struct completion thread_comp;
+static struct task_struct *thread_task = NULL;
+static DECLARE_WAIT_QUEUE_HEAD(thread_wq);
+
+static int ps2mcfs_init(void);
+void ps2mcfs_cleanup(void);
+static int ps2mcfs_thread(void *);
+
+static int __init ps2mcfs_init()
+{
+	TRACE("ps2mcfs_init()\n");
+	printk("PlayStation 2 Memory Card file system\n");
+	init_completion(&thread_comp);
+
+	if ((ps2mcfs_lock = ps2sif_getlock(PS2LOCK_MC)) == NULL) {
+		printk(KERN_ERR "ps2mcfs: Can't get lock\n");
+		return (-1);
+	}
+#ifdef PS2MCFS_DEBUG
+	if (ps2mcfs_debug & DBG_LOCK) {
+		oldflags = ps2sif_getlockflags(ps2mcfs_lock);
+		ps2sif_setlockflags(ps2mcfs_lock,
+				    (oldflags | PS2LOCK_FLAG_DEBUG));
+	}
+#endif
+
+	if (ps2sif_lock_interruptible(ps2mcfs_lock, "mcfs init") < 0)
+		return (-1);
+
+	if (ps2mcfs_init_filebuf() < 0 ||
+	    ps2mcfs_init_pathcache() < 0 ||
+	    ps2mcfs_init_fdcache() < 0 ||
+	    ps2mcfs_init_dirent() < 0 ||
+	    ps2mcfs_init_root() < 0)
+		goto error;
+
+	/*
+	 * hook block device read/write routine
+	 */
+	if (ps2mc_blkrw_hook == NULL)
+		ps2mc_blkrw_hook = ps2mcfs_blkrw;
+
+	/*
+	 * create and start thread
+	 */
+	kernel_thread(ps2mcfs_thread, NULL, 0);
+	wait_for_completion(&thread_comp);	/* wait the thread ready */
+                
+	if (register_filesystem(&ps2mcfs_fs_type) < 0)
+		goto error;
+
+	ps2sif_unlock(ps2mcfs_lock);
+
+	/* Add disks, this will already use file operations.
+	 * This should have been done in ps2mc, but this leads
+	 * to a deadlock, because block transfer is only working if
+	 * the callback was registered by ps2mcfs.
+	 */
+	ps2mc_add_disks();
+
+	return (0);
+
+ error:
+	ps2mcfs_cleanup();
+	ps2sif_unlock(ps2mcfs_lock);
+
+	return (-1);
+}
+
+void
+ps2mcfs_cleanup()
+{
+	TRACE("ps2mcfs_cleanup()\n");
+
+	/* Remove disks. */
+	ps2mc_del_disks();
+
+	ps2sif_lock(ps2mcfs_lock, "mcfs cleanup");
+#ifdef PS2MCFS_DEBUG
+	if (ps2mcfs_debug & DBG_LOCK)
+		ps2sif_setlockflags(ps2mcfs_lock, oldflags);
+#endif
+
+	/*
+	 * un-hook block device read/write routine
+	 */
+	if (ps2mc_blkrw_hook == ps2mcfs_blkrw)
+		ps2mc_blkrw_hook = NULL;
+
+	/*
+	 * stop the thread
+	 */
+	if (thread_task != NULL) {
+            send_sig(SIGKILL, thread_task, 1);
+	    wait_for_completion(&thread_comp);	/* wait the thread exit */
+	}
+
+	unregister_filesystem(&ps2mcfs_fs_type);
+	ps2mcfs_exit_root();
+	ps2mcfs_exit_pathcache();
+	ps2mcfs_exit_fdcache();
+	ps2mcfs_exit_filebuf();
+	ps2sif_unlock(ps2mcfs_lock);
+}
+
+module_init(ps2mcfs_init);
+module_exit(ps2mcfs_cleanup);
+
+MODULE_AUTHOR("Sony Computer Entertainment Inc.");
+MODULE_DESCRIPTION("PlayStation 2 memory card filesystem");
+MODULE_LICENSE("GPL");
+
+static int
+ps2mcfs_thread(void *arg)
+{
+
+	DPRINT(DBG_INFO, "start thread\n");
+
+	lock_kernel();
+	/* get rid of all our resources related to user space */
+	daemonize("ps2mcfs");
+	siginitsetinv(&current->blocked,
+		      sigmask(SIGKILL)|sigmask(SIGINT)|sigmask(SIGTERM));
+	/* Set the name of this process. */
+	sprintf(current->comm, "ps2mcfs");
+	unlock_kernel();
+
+	thread_task = current;
+	complete(&thread_comp); /* notify that we are ready */
+
+	/*
+	 * loop
+	 */
+	while(1) {
+		if (ps2sif_lock_interruptible(ps2mcfs_lock, "mcfs_thread")==0){
+			ps2mcfs_check_fd();
+			ps2sif_unlock(ps2mcfs_lock);
+		}
+
+		interruptible_sleep_on_timeout(&thread_wq,
+					       PS2MCFS_CHECK_INTERVAL);
+
+		if (signal_pending(current) )
+			break;
+	}
+
+	DPRINT(DBG_INFO, "exit thread\n");
+
+	thread_task = NULL;
+	complete(&thread_comp); /* notify that we've exited */
+
+	return (0);
+}
diff -purN linux-2.6.35.4-orig/drivers/ps2/mcfs/mcfs_debug.h linux-2.6.35.4/drivers/ps2/mcfs/mcfs_debug.h
--- linux-2.6.35.4-orig/drivers/ps2/mcfs/mcfs_debug.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/mcfs/mcfs_debug.h	2014-07-18 22:29:43.566367724 +0200
@@ -0,0 +1,63 @@
+/*
+ *  PlayStation 2 Memory Card File System driver
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define PS2MCFS_DEBUG
+#ifdef PS2MCFS_DEBUG
+
+extern unsigned long ps2mcfs_debug;
+
+#define DBG_INFO	(1<< 0)
+#define DBG_TRACE	(1<< 1)
+#define DBG_PATHCACHE	(1<< 2)
+#define DBG_FILECACHE	(1<< 3)
+#define DBG_DEBUGHOOK	(1<< 4)
+#define DBG_READPAGE	(1<< 5)
+#define DBG_BLOCKRW	(1<< 6)
+#define DBG_LOCK	(1<< 7)
+#define DBG_LOG		(1<<31)
+#define DBG_LOG_LEVEL	KERN_CRIT
+/*
+#define DEBUGLOG(fmt, args...)		debuglog(NULL, fmt, ## args)
+*/
+#define DEBUGLOG(fmt, args...)		do {} while (0)
+#define DPRINT(mask, fmt, args...) \
+	do { \
+		if ((ps2mcfs_debug & (mask)) == (mask)) { \
+			if (ps2mcfs_debug & DBG_LOG) \
+				DEBUGLOG(fmt, ## args); \
+			else \
+				printk(DBG_LOG_LEVEL "ps2mcfs: " fmt, ## args); \
+		} \
+	} while (0)
+#define DPRINTK(mask, fmt, args...) \
+	do { \
+		if ((ps2mcfs_debug & (mask)) == (mask)) { \
+			if (ps2mcfs_debug & DBG_LOG) \
+				DEBUGLOG(fmt, ## args); \
+			else \
+				printk(fmt, ## args); \
+		} \
+	} while (0)
+#else
+#define DPRINT(mask, fmt, args...) do {} while (0)
+#define DPRINTK(mask, fmt, args...) do {} while (0)
+#endif
+
+#define TRACE(fmt, args...) DPRINT(DBG_TRACE, fmt, ## args)
diff -purN linux-2.6.35.4-orig/drivers/ps2/mcfs/mcfs.h linux-2.6.35.4/drivers/ps2/mcfs/mcfs.h
--- linux-2.6.35.4-orig/drivers/ps2/mcfs/mcfs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/mcfs/mcfs.h	2014-07-18 22:29:43.566367724 +0200
@@ -0,0 +1,129 @@
+/*
+ *  PlayStation 2 Memory Card File System driver
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _PS2MCFS_H_
+#define _PS2MCFS_H_
+
+#include <linux/fs.h>
+
+#include <linux/ps2/mcio.h>
+
+#include <asm/mach-ps2/sbios.h>
+#include <asm/mach-ps2/sifdefs.h>
+#include <asm/mach-ps2/siflock.h>
+
+#define PS2MCFS_FD_EXPIRE_TIME	(HZ * 5)
+#define PS2MCFS_CHECK_INTERVAL	(PS2MCFS_FD_EXPIRE_TIME/3)
+#define PS2MCFS_SUPER_MAGIC	0xaaaa
+#define PS2MCFS_NAME_CACHESIZE	30
+
+#define PS2MCFS_DIRENT_INVALID	(1<<0)
+#define PS2MCFS_DIRENT_BMAPPED	(1<<1)
+
+#define PS2MCFS_DIRENT_BITS	8
+#define PS2MCFS_SECTOR_BITS	24
+#define PS2MCFS_DIRENT_SHIFT	PS2MCFS_SECTOR_BITS
+#define PS2MCFS_SECTOR_SHIFT	0
+
+#define PS2MCFS_MAX_DIRENTS	(1 << PS2MCFS_DIRENT_BITS)
+#define PS2MCFS_DIRENT_MASK	((1<<PS2MCFS_DIRENT_BITS)-1)
+#define PS2MCFS_SECTOR_MASK	((1<<PS2MCFS_SECTOR_BITS)-1)
+
+struct ps2mcfs_options {
+	uid_t uid;
+	gid_t gid;
+	unsigned short umask;
+};
+
+struct ps2mcfs_root {
+	int portslot;
+	int refcount;
+	struct ps2mcfs_dirent *dirent;
+	struct ps2mcfs_options opts;
+	int block_shift;
+	dev_t dev;
+};
+
+struct ps2mcfs_dirent {
+	int no;
+	unsigned long ino;
+	struct ps2mcfs_root *root;
+	char name[PS2MC_NAME_MAX];
+	struct ps2mcfs_pathent *path;
+	struct ps2mcfs_filedesc *fd;
+	unsigned short namelen;
+	unsigned long size;
+	struct inode *inode;
+	struct ps2mcfs_dirent *parent;
+	struct list_head next, sub, hashlink;
+	int refcount;
+	int flags;
+};
+extern struct inode_operations ps2mcfs_dir_inode_operations;
+extern struct inode_operations ps2mcfs_file_inode_operations;
+extern struct inode_operations ps2mcfs_null_inode_operations;
+extern struct file_operations ps2mcfs_dir_operations;
+extern struct file_operations ps2mcfs_file_operations;
+extern struct file_operations ps2mcfs_null_operations;
+extern struct address_space_operations ps2mcfs_addrspace_operations;
+extern char *ps2mcfs_basedir;
+extern ps2sif_lock_t *ps2mcfs_lock;
+
+int ps2mcfs_init_dirent(void);
+int ps2mcfs_init_root(void);
+int ps2mcfs_exit_root(void);
+int ps2mcfs_init_pathcache(void);
+int ps2mcfs_exit_pathcache(void);
+int ps2mcfs_init_fdcache(void);
+int ps2mcfs_exit_fdcache(void);
+const char *ps2mcfs_get_path(struct ps2mcfs_dirent *);
+void ps2mcfs_put_path(struct ps2mcfs_dirent *, const char *path);
+void ps2mcfs_free_path(struct ps2mcfs_dirent *);
+int ps2mcfs_get_fd(struct ps2mcfs_dirent *, int);
+void ps2mcfs_free_fd(struct ps2mcfs_dirent *);
+void ps2mcfs_check_fd(void);
+int ps2mcfs_init_filebuf(void);
+int ps2mcfs_exit_filebuf(void);
+int ps2mcfs_blkrw(int, int, void*, int);
+
+int ps2mcfs_get_root(dev_t, struct ps2mcfs_root **);
+int ps2mcfs_put_root(int);
+unsigned long ps2mcfs_pseudo_ino(void);
+int ps2mcfs_is_pseudo_ino(unsigned long);
+int ps2mcfs_countdir(struct ps2mcfs_dirent *);
+int ps2mcfs_update_inode(struct inode * inode);
+int ps2mcfs_setup_fake_root(struct ps2mcfs_root*);
+void ps2mcfs_invalidate_dirents(struct ps2mcfs_root *);
+
+struct ps2mcfs_dirent* ps2mcfs_alloc_dirent(struct ps2mcfs_dirent *, const char *, int);
+struct ps2mcfs_dirent* ps2mcfs_find_dirent(struct ps2mcfs_dirent *, const char *, int);
+struct ps2mcfs_dirent* ps2mcfs_find_dirent_ino(unsigned long);
+struct ps2mcfs_dirent* ps2mcfs_find_dirent_no(int no);
+void ps2mcfs_ref_dirent(struct ps2mcfs_dirent *);
+void ps2mcfs_unref_dirent(struct ps2mcfs_dirent *);
+void ps2mcfs_free_dirent(struct ps2mcfs_dirent *);
+
+int ps2mcfs_setattr(struct dentry *, struct iattr *);
+extern int ps2mcfs_read_super(struct super_block *, void *, int);
+int ps2mcfs_create(struct ps2mcfs_dirent *);
+struct inode *ps2mcfs_iget(struct super_block *, unsigned long);
+void ps2mcfs_read_inode(struct inode *);
+
+#endif /* _PS2MCFS_H_ */
diff -purN linux-2.6.35.4-orig/drivers/ps2/mcfs/null.c linux-2.6.35.4/drivers/ps2/mcfs/null.c
--- linux-2.6.35.4-orig/drivers/ps2/mcfs/null.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/mcfs/null.c	2014-07-18 22:29:43.566367724 +0200
@@ -0,0 +1,47 @@
+/*
+ *  PlayStation 2 Memory Card File System driver
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+
+#include "mcfs.h"
+#include "mcfs_debug.h"
+
+static struct dentry *ps2mcfs_null_lookup(struct inode *, struct dentry *, struct nameidata *);
+
+struct file_operations ps2mcfs_null_operations = {
+	/* NULL */
+};
+
+struct inode_operations ps2mcfs_null_inode_operations = {
+	lookup:			ps2mcfs_null_lookup,
+};
+
+static struct dentry *
+ps2mcfs_null_lookup(struct inode *dir, struct dentry *dentry, struct nameidata *name_i_data)
+{
+	return ERR_PTR(-ENOENT);
+}
diff -purN linux-2.6.35.4-orig/drivers/ps2/mcfs/path.c linux-2.6.35.4/drivers/ps2/mcfs/path.c
--- linux-2.6.35.4-orig/drivers/ps2/mcfs/path.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/mcfs/path.c	2014-07-18 22:29:43.566367724 +0200
@@ -0,0 +1,192 @@
+/*
+ *  PlayStation 2 Memory Card File System driver
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+
+#include <linux/sched.h>
+#include <linux/stat.h>
+#include <linux/list.h>
+#include <linux/string.h>	/* for memmove */
+#include <linux/fs.h>
+
+#include "mcfs.h"
+#include "mcfs_debug.h"
+
+#define ARRAYSIZEOF(a)	(sizeof(a)/sizeof(*(a)))
+
+static struct ps2mcfs_pathent {
+	char pathname[PS2MC_PATH_MAX + 1]; /* null terminated full path name */
+	struct ps2mcfs_dirent *dirent;
+	struct list_head link;
+	int inuse;
+} items[PS2MCFS_NAME_CACHESIZE];
+
+static struct list_head lru;
+
+/*
+ * Insert a new entry at tail of the specified list
+ */
+static __inline__ void list_addtail(struct list_head *new, struct list_head *head)
+{
+	__list_add(new, head->prev, head);
+}
+
+int
+ps2mcfs_init_pathcache()
+{
+	int i;
+
+	ps2sif_assertlock(ps2mcfs_lock, "mcfs_init_pathcache");
+	INIT_LIST_HEAD(&lru);
+	for (i = 0; i < ARRAYSIZEOF(items); i++) {
+		list_add(&items[i].link, &lru);
+	}
+	return (0);
+}
+
+int
+ps2mcfs_exit_pathcache()
+{
+	ps2sif_assertlock(ps2mcfs_lock, "mcfs_exit_pathcache");
+	return (0);
+}
+
+#ifdef PS2MCFS_DEBUG
+static void dump(void)
+{
+	struct list_head *p;
+
+	ps2sif_assertlock(ps2mcfs_lock, "mcfs_init_pathcache");
+	for (p = lru.prev; p != &lru; p = p->prev) {
+		struct ps2mcfs_pathent *ent;
+		ent = list_entry(p, struct ps2mcfs_pathent, link);
+		printk(" %3d: %d %s\n", ent - items, ent->inuse, ent->pathname);
+	}
+}
+#endif
+
+const char *
+ps2mcfs_get_path(struct ps2mcfs_dirent *dirent)
+{
+	struct ps2mcfs_pathent *ent;
+	struct ps2mcfs_dirent *p;
+	int i;
+
+	ps2sif_lock(ps2mcfs_lock, "mcfs_get_path");
+	ent = dirent->path;
+	if (ent != NULL) {
+		list_del(&ent->link);
+		list_add(&ent->link, &lru);
+		ent->inuse++;
+		DPRINT(DBG_PATHCACHE, "get_path: %s(count=%d)\n",
+		       ent->pathname, ent->inuse);
+		ps2sif_unlock(ps2mcfs_lock);
+
+		return (ent->pathname);
+	}
+
+	ent = list_entry(lru.prev, struct ps2mcfs_pathent, link);
+	if (0 < ent->inuse) {
+		printk(KERN_CRIT "ps2mcfs_get_path(): resource not available\n");
+#ifdef PS2MCFS_DEBUG
+		dump();
+#else
+		ps2sif_unlock(ps2mcfs_lock);
+
+		return (NULL); /* This will make oops */
+#endif
+	}
+	ent->inuse = 1;
+
+	if (ent->dirent != NULL)
+		ent->dirent->path = NULL;
+	list_del(&ent->link);
+	list_add(&ent->link, &lru);
+	ent->dirent = dirent;
+	dirent->path = ent;
+
+	i = ARRAYSIZEOF(ent->pathname) - 1;
+	ent->pathname[i] = '\0'; /* terminator */
+	for (p = dirent; p != NULL; p = p->parent) {
+		i -= p->namelen;
+		if (i < 1) {
+			printk("ps2mcfs: path name is too long\n");
+			printk("...%s\n", &ent->pathname[i]);
+			ent->pathname[0] = '\0';
+			/* TBD: caller shouldn't call put_path() */
+			ent->inuse = 0;
+			break;
+		}
+		memcpy(&ent->pathname[i], p->name, p->namelen);
+		if (p->namelen != 0)
+			ent->pathname[--i] = '/';
+	}
+	if (ent->pathname[i] != '/')
+		ent->pathname[--i] = '/';
+	memmove(&ent->pathname[0], &ent->pathname[i],
+		ARRAYSIZEOF(ent->pathname) - i);
+
+	DPRINT(DBG_PATHCACHE, "get_path: %s\n", ent->pathname);
+	ps2sif_unlock(ps2mcfs_lock);
+
+	return (ent->pathname);
+}
+
+void
+ps2mcfs_put_path(struct ps2mcfs_dirent *dirent, const char *path)
+{
+
+	ps2sif_lock(ps2mcfs_lock, "mcfs_put_path");
+	if (dirent->path != NULL) {
+#ifdef PS2MCFS_DEBUG
+		if (dirent->path->pathname != path)
+			DPRINT(DBG_PATHCACHE,
+			       "ps2mcfs_put_path: something wrong...\n");
+#endif
+		dirent->path->inuse--;
+		DPRINT(DBG_PATHCACHE, "put_path: %s(count=%d)\n",
+		       dirent->path->pathname, dirent->path->inuse);
+	}
+	ps2sif_unlock(ps2mcfs_lock);
+}
+
+void
+ps2mcfs_free_path(struct ps2mcfs_dirent *dirent)
+{
+	struct ps2mcfs_pathent *ent;
+
+	ps2sif_lock(ps2mcfs_lock, "mcfs_free_path");
+	if (dirent->path != NULL) {
+		ent = dirent->path;
+#ifdef PS2MCFS_DEBUG
+		DPRINT(DBG_PATHCACHE, "ps2mcfs_free_path: %s(count=%d)\n",
+		       ent->pathname, ent->inuse);
+		if (ent->inuse)
+			printk(KERN_CRIT "ps2mcfs: path name '%s' refcount != 0\n",
+			       ent->pathname);
+#endif
+		ent->dirent = NULL;
+		dirent->path = NULL;
+		list_del(&ent->link);
+		list_addtail(&ent->link, &lru);
+	}
+	ps2sif_unlock(ps2mcfs_lock);
+}
diff -purN linux-2.6.35.4-orig/drivers/ps2/mcfs/root.c linux-2.6.35.4/drivers/ps2/mcfs/root.c
--- linux-2.6.35.4-orig/drivers/ps2/mcfs/root.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/mcfs/root.c	2014-07-18 22:29:43.566367724 +0200
@@ -0,0 +1,229 @@
+/*
+ *  PlayStation 2 Memory Card File System driver
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/dcache.h>
+#include <linux/kdev_t.h>
+#include <linux/fs.h>
+#include <linux/blkdev.h>
+
+#include <asm/bitops.h>
+#include <asm/uaccess.h>
+
+#include "mcfs.h"
+#include "mcfs_debug.h"
+
+#define ARRAYSIZEOF(a)	(sizeof(a)/sizeof(*(a)))
+
+static struct ps2mc_listener listener;
+static struct ps2mcfs_root roots[16];
+
+static void ps2mcfs_listener(void *ctxx, int portslot, int oldstate, int newstate)
+{
+	struct ps2mcfs_root *root;
+
+	DPRINT(DBG_INFO, "card%02x state=%d->%d\n",
+	       portslot, oldstate, newstate);
+
+	ps2sif_lock(ps2mcfs_lock, "mcfs_listener");
+	if (ps2mcfs_get_root(portslot, &root) < 0) {
+		ps2sif_unlock(ps2mcfs_lock);
+		return;
+	}
+
+	if (root->dirent->inode != NULL) {
+		/* the card is currently mounted */
+		/*
+		 * release dcache which are not used
+		 */
+		shrink_dcache_sb(root->dirent->inode->i_sb);
+
+		if (newstate != PS2MC_TYPE_PS2) {
+			ps2mcfs_setup_fake_root(root);
+			/*
+			 * invalidate all dirent and inode entries which belong
+			 * to this card.
+			 */
+			ps2mcfs_invalidate_dirents(root);
+		} else {
+			ps2mcfs_update_inode(root->dirent->inode);
+		}
+	}
+
+	ps2mcfs_put_root(portslot);
+	ps2sif_unlock(ps2mcfs_lock);
+}
+
+int ps2mcfs_init_root()
+{
+	int i;
+
+	ps2sif_assertlock(ps2mcfs_lock, "mcfs_init_root");
+	for (i = 0; i < ARRAYSIZEOF(roots); i++)
+		roots[i].portslot = PS2MC_INVALIDPORTSLOT;
+
+	listener.func = ps2mcfs_listener;
+	listener.ctx = NULL;
+	ps2mc_add_listener(&listener);
+	return (0);
+}
+
+int ps2mcfs_exit_root()
+{
+	ps2sif_assertlock(ps2mcfs_lock, "mcfs_exit_root");
+	ps2mc_del_listener(&listener);
+	return (0);
+}
+
+static int
+ps2mcfs_alloc_root(struct ps2mcfs_root *root, dev_t dev)
+{
+	int res;
+	struct ps2mcfs_dirent *rootent;
+	struct ps2mc_cardinfo info;
+	int portslot = MINOR(dev);
+
+	TRACE("ps2mcfs_alloc_root(port/slot=%02x)\n", portslot);
+	ps2sif_assertlock(ps2mcfs_lock, "mcfs_alloc_root");
+	if ((res = ps2mc_getinfo(portslot, &info)) < 0)
+		return res;
+
+	rootent = ps2mcfs_alloc_dirent(NULL, ps2mcfs_basedir,
+				       strlen(ps2mcfs_basedir));
+	if (rootent == NULL)
+		return -ENOMEM;
+
+	root->portslot = portslot;
+	root->dev = dev;
+	root->refcount = 0;
+	rootent->root = root;
+	root->dirent = rootent;
+
+	/* add reference count so that the root can't disappear */
+	ps2mcfs_ref_dirent(rootent);
+
+	return (0);
+}
+
+int
+ps2mcfs_setup_fake_root(struct ps2mcfs_root *root)
+{
+	struct ps2mcfs_dirent *de = root->dirent;
+	struct inode *inode = de->inode;
+
+	TRACE("ps2mcfs_setup_fake_root(card%02x)\n", de->root->portslot);
+	ps2sif_assertlock(ps2mcfs_lock, "mcfs_setup_fake_root");
+	if (inode) {
+		inode->i_mode = S_IFDIR; /* d--------- */
+		inode->i_mode &= ~((mode_t)root->opts.umask);
+		inode->i_size = 1024; /* 2 entries */
+		inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
+		inode->i_blkbits = blksize_bits(inode->i_sb->s_blocksize);
+		inode->i_blocks = (inode->i_size + inode->i_sb->s_blocksize - 1) / inode->i_sb->s_blocksize;
+		inode->i_uid = root->opts.uid;
+		inode->i_gid = root->opts.gid;
+		inode->i_op = &ps2mcfs_null_inode_operations;
+		inode->i_fop = &ps2mcfs_null_operations;
+	}
+
+	return (0);
+}
+
+int ps2mcfs_get_root(dev_t dev, struct ps2mcfs_root **rootp)
+{
+	int i;
+	int res;
+	int portslot;
+	int blocksize;
+	struct ps2mcfs_root *ent = NULL;
+
+	ps2sif_lock(ps2mcfs_lock, "mcfs_get_root");
+	if (ps2mc_checkdev(dev) < 0) {
+		res = -EINVAL;
+		goto out;
+	}
+
+	portslot = MINOR(dev);
+	TRACE("ps2mcfs_get_root(port/slot=%02x)\n", portslot);
+	for (i = 0; i < ARRAYSIZEOF(roots); i++) {
+		if (roots[i].portslot == PS2MC_INVALIDPORTSLOT) {
+			if (ent == NULL)
+				ent = &roots[i];
+		} else {
+			if (roots[i].portslot == portslot) {
+				roots[i].refcount++;
+				*rootp = &roots[i];
+				res = 0;
+				goto out;
+			}
+		}
+	}
+
+	if (ent == NULL) {
+		res = -EBUSY;	/* no entry available. might not occur. */
+		goto out;
+	}
+
+	*rootp = ent;
+	if ((res = ps2mcfs_alloc_root(ent, dev)) < 0) {
+		res = res;
+		goto out;
+	}
+	ent->refcount++;
+
+	blocksize = BLOCK_SIZE;
+
+	/* '512' is hardware sector size */
+	ent->block_shift = 0;
+	while ((1 << ent->block_shift) < blocksize / 512)
+	     ent->block_shift++;
+	res = 0;
+ out:
+	ps2sif_unlock(ps2mcfs_lock);
+
+	return (res);
+}
+
+int ps2mcfs_put_root(int portslot)
+{
+	int i, res;
+
+	ps2sif_lock(ps2mcfs_lock, "mcfs_get_root");
+	res = 0;
+	for (i = 0; i < ARRAYSIZEOF(roots); i++) {
+		if (roots[i].portslot == portslot) {
+			if (--roots[i].refcount <= 0) {
+				ps2mcfs_unref_dirent(roots[i].dirent);
+				roots[i].portslot = PS2MC_INVALIDPORTSLOT;
+				res = 1;
+			}
+			break;
+		}
+	}
+	ps2sif_unlock(ps2mcfs_lock);
+
+	return (res);
+}
diff -purN linux-2.6.35.4-orig/drivers/ps2/mc.h linux-2.6.35.4/drivers/ps2/mc.h
--- linux-2.6.35.4-orig/drivers/ps2/mc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/mc.h	2014-07-18 22:29:43.558367724 +0200
@@ -0,0 +1,61 @@
+/*
+ *  PlayStation 2 Memory Card driver
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef PS2MC_H
+#define PS2MC_H
+
+typedef struct {
+	struct {
+		unsigned char Resv2,Sec,Min,Hour;
+		unsigned char Day,Month;
+		unsigned short Year;
+	} _Create;
+	struct {
+		unsigned char Resv2,Sec,Min,Hour;
+		unsigned char Day,Month;
+		unsigned short Year;
+	} _Modify;
+	unsigned FileSizeByte;
+	unsigned short AttrFile;
+	unsigned short Reserve1;
+	unsigned Reserve2[2];
+	unsigned char EntryName[32];
+} McDirEntry __attribute__((aligned (64)));
+
+#define McMaxFileDiscr		3
+#define McMaxPathLen		1023
+
+#define McRDONLY		0x0001
+#define McWRONLY		0x0002
+#define McRDWR			0x0003
+#define McCREAT			0x0200
+
+#define McFileInfoCreate	0x01
+#define McFileInfoModify	0x02
+#define McFileInfoAttr		0x04
+
+#define McFileAttrReadable	0x0001
+#define McFileAttrWriteable	0x0002
+#define McFileAttrExecutable	0x0004
+#define McFileAttrSubdir	0x0020
+
+#define McTZONE			(9 * 60 * 60)
+
+#endif /* PS2MC_H */
diff -purN linux-2.6.35.4-orig/drivers/ps2/mcpriv.h linux-2.6.35.4/drivers/ps2/mcpriv.h
--- linux-2.6.35.4-orig/drivers/ps2/mcpriv.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/mcpriv.h	2014-07-18 22:29:43.558367724 +0200
@@ -0,0 +1,61 @@
+/*
+ *  PlayStation 2 Memory Card driver
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef PS2MCPRIV_H
+#define PS2MCPRIV_H
+
+#include <asm/mach-ps2/siflock.h>
+
+#define PS2MC_DIRCACHESIZE	7
+#define PS2MC_CHECK_INTERVAL	(HZ/2)
+#define PS2MC_RWBUFSIZE		1024
+
+#define PS2MC_NPORTS	2
+#define PS2MC_NSLOTS	1
+
+#define ARRAYSIZEOF(a)	(sizeof(a)/sizeof(*(a)))
+#define MIN(a, b)	((a) < (b) ? (a) : (b))
+
+extern int ps2mc_debug;
+extern ps2sif_lock_t *ps2mc_lock;
+extern struct file_operations ps2mc_fops;
+extern atomic_t ps2mc_cardgens[PS2MC_NPORTS][PS2MC_NSLOTS];
+extern int ps2mc_basedir_len;
+extern atomic_t ps2mc_opened[PS2MC_NPORTS][PS2MC_NSLOTS];
+extern struct semaphore ps2mc_filesem;
+extern char *ps2mc_rwbuf;
+extern int (*ps2mc_blkrw_hook)(int, int, void*, int);
+extern struct semaphore ps2mc_waitsem;
+extern void ps2mc_process_request(void);
+void ps2mc_signal_change(int port, int slot);
+int ps2mc_devinit(void);
+int ps2mc_devexit(void);
+void ps2mc_dircache_invalidate(int);
+void ps2mc_dircache_invalidate_next_pos(int);
+char* ps2mc_terminate_name(char *, const char *, int);
+int ps2mc_getdir_sub(int, const char*, int, int, struct ps2mc_dirent *);
+int ps2mc_getinfo_sub(int, int *, int *, int *, int *);
+int ps2mc_check_path(const char *);
+int ps2mc_format(int portslot);
+int ps2mc_unformat(int portslot);
+void ps2mc_set_state(int portslot, int state);
+int ps2mc_delete_all(int portslot, const char *path);
+
+#endif /* PS2MCPRIV_H */
diff -purN linux-2.6.35.4-orig/drivers/ps2/pad.c linux-2.6.35.4/drivers/ps2/pad.c
--- linux-2.6.35.4-orig/drivers/ps2/pad.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/pad.c	2014-07-18 22:29:43.558367724 +0200
@@ -0,0 +1,898 @@
+/*
+ *  PlayStation 2 Game Controller driver
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <linux/slab.h>
+#include <linux/major.h>
+#include <linux/wait.h>
+#include <linux/sched.h>
+#include <asm/addrspace.h>
+#include <asm/uaccess.h>
+#ifdef CONFIG_PROC_FS
+#include <linux/proc_fs.h>
+#endif
+
+#include "pad.h"
+#include "padcall.h"
+
+#define PS2PAD_NOPORTCLOSE
+
+#define PORT(n)		(((n) & 0x10) >> 4)
+#define SLOT(n)		(((n) & 0x0f) >> 0)
+#define NPORTS		PS2PAD_NPORTS
+#define NSLOTS		PS2PAD_NSLOTS
+#define MAXNPADS	PS2PAD_MAXNPADS
+#define DMABUFSIZE	(16 * 16)
+#define INTERVAL_TIME  	HZ/10	/* 100ms */
+
+struct ps2pad_dev {
+	struct ps2pad_libctx *pad;
+};
+
+struct ps2pad_ctl_dev {
+	int stat_is_valid;
+	struct ps2pad_stat stat[MAXNPADS];
+};
+
+static void ps2pad_start_timer(void);
+static inline void ps2pad_stop_timer(void);
+static inline void ps2pad_update_status(void);
+static int lock(void);
+static void unlock(void);
+
+static int ps2pad_read_proc(char *, char **, off_t, int, int *, void *);
+static ssize_t ps2pad_read(struct file *, char *, size_t, loff_t *);
+static unsigned int ps2pad_poll(struct file *file, poll_table * wait);
+static int ps2pad_ioctl(struct inode *, struct file *, u_int, u_long);
+static int ps2pad_open(struct inode *, struct file *);
+static int ps2pad_release(struct inode *, struct file *);
+
+static ssize_t ps2pad_ctl_read(struct file *, char *, size_t, loff_t *);
+static unsigned int ps2pad_ctl_poll(struct file *file, poll_table * wait);
+static int ps2pad_ctl_ioctl(struct inode *, struct file *, u_int, u_long);
+static int ps2pad_ctl_release(struct inode *, struct file *);
+
+static int ps2pad_major = PS2PAD_MAJOR;
+static spinlock_t spinlock;
+
+module_param(ps2pad_major, int, 0);
+MODULE_PARM_DESC(ps2pad_major,
+		"Major device node number for PS2 pad driver.");
+
+//#define PS2PAD_DEBUG
+#ifdef PS2PAD_DEBUG
+int ps2pad_debug = 0;
+#define DPRINT(fmt, args...) \
+	if (ps2pad_debug) printk(KERN_CRIT "ps2pad: " fmt, ## args)
+module_param(ps2pad_debug, int, 0);
+MODULE_PARM_DESC(ps2pad_debug,
+		"Set debug output level of verbosity (0 = off, other value means on).");
+#else
+#define DPRINT(fmt, args...) do {} while (0)
+#endif
+
+#define ARRAYSIZEOF(a)	(sizeof(a)/sizeof(*(a)))
+
+struct ps2pad_libctx ps2pad_pads[MAXNPADS];
+int ps2pad_npads = 0;
+EXPORT_SYMBOL(ps2pad_pads);
+EXPORT_SYMBOL(ps2pad_npads);
+
+static DECLARE_WAIT_QUEUE_HEAD(lockq);
+static int locked = 0;
+static DECLARE_WAIT_QUEUE_HEAD(watchq);
+static struct timer_list ps2pad_timer;
+static struct ps2pad_stat cur_stat[MAXNPADS];
+static struct ps2pad_stat new_stat[MAXNPADS];
+static int open_devices = 0;
+static int run_timer = 0;
+
+static struct file_operations ps2pad_fops = {
+	owner:		THIS_MODULE,
+	read:		ps2pad_read,
+	poll:		ps2pad_poll,
+	ioctl:		ps2pad_ioctl,
+	open:		ps2pad_open,
+	release:	ps2pad_release,
+};
+
+static struct file_operations ps2pad_ctlops = {
+	owner:		THIS_MODULE,
+	read:		ps2pad_ctl_read,
+	poll:		ps2pad_ctl_poll,
+	ioctl:		ps2pad_ctl_ioctl,
+	release:	ps2pad_ctl_release,
+};
+
+char *pad_type_names[16] = {
+	"type 0",
+	"type 1",
+	"NEJICON",	/* PS2PAD_TYPE_NEJICON	*/
+	"type 3",
+	"DIGITAL",	/* PS2PAD_TYPE_DIGITAL	*/
+	"ANALOG",	/* PS2PAD_TYPE_ANALOG	*/
+	"type 6",
+	"DUALSHOCK",	/* PS2PAD_TYPE_DUALSHOCK*/
+	"type 8",
+	"type 9",
+	"type A",
+	"type B",
+	"type C",
+	"type D",
+	"type E",
+	"type F",
+};
+
+static unsigned char stat_conv_table[] = {
+	[PadStateDiscon]	= PS2PAD_STAT_NOTCON,
+	[PadStateFindPad]	= PS2PAD_STAT_BUSY,
+	[PadStateFindCTP1]	= PS2PAD_STAT_READY,
+	[PadStateExecCmd]	= PS2PAD_STAT_BUSY,
+	[PadStateStable]	= PS2PAD_STAT_READY,
+	[PadStateError]		= PS2PAD_STAT_ERROR,
+};
+
+static unsigned char rstat_conv_table[] = {
+	[PadReqStateComplete]		= PS2PAD_RSTAT_COMPLETE,
+	[PadReqStateFailed]		= PS2PAD_RSTAT_FAILED,
+	[PadReqStateBusy]		= PS2PAD_RSTAT_BUSY,
+};
+
+int
+ps2pad_stat_conv(int stat)
+{
+	if (stat < 0 || ARRAYSIZEOF(stat_conv_table) <= stat) {
+		return PS2PAD_STAT_ERROR;
+	} else {
+		return stat_conv_table[stat];
+	}
+}
+
+static inline int
+ps2pad_comp_stat(struct ps2pad_stat *a, struct ps2pad_stat *b)
+{
+	return memcmp(a, b, sizeof(struct ps2pad_stat) * ps2pad_npads);
+}
+
+static inline void
+ps2pad_copy_stat(struct ps2pad_stat *a, struct ps2pad_stat *b)
+{
+	memcpy(a, b, sizeof(struct ps2pad_stat) * ps2pad_npads);
+}
+
+static void
+ps2pad_read_stat(struct ps2pad_stat *stat)
+{
+	int i, res;
+	u_char data[PS2PAD_DATASIZE];
+
+	for (i = 0; i < ps2pad_npads; i++) {
+		/* port and slot */
+		stat[i].portslot = ((ps2pad_pads[i].port << 4) |
+				    ps2pad_pads[i].slot);
+
+		/* request status */
+		res = ps2padlib_GetReqState(ps2pad_pads[i].port,
+					ps2pad_pads[i].slot);
+		if (res < 0 || ARRAYSIZEOF(rstat_conv_table) <= res) {
+			stat[i].rstat = PS2PAD_RSTAT_FAILED;
+		} else {
+			stat[i].rstat = rstat_conv_table[res];
+		}
+
+		/* connection status */
+		res = ps2padlib_GetState(ps2pad_pads[i].port, ps2pad_pads[i].slot);
+		stat[i].type = 0;
+		if (res < 0 || ARRAYSIZEOF(stat_conv_table) <= res) {
+			stat[i].stat = PS2PAD_STAT_ERROR;
+		} else {
+			stat[i].stat = stat_conv_table[res];
+			if (stat[i].stat == PS2PAD_STAT_READY) {
+				res = ps2padlib_Read(ps2pad_pads[i].port,
+						 ps2pad_pads[i].slot,
+						 data);
+				if (res != 0 && data[0] == 0) {
+					/* pad data is valid */
+					stat[i].type = data[1];
+				} else {
+					stat[i].stat = PS2PAD_STAT_ERROR;
+				}
+			}
+		}
+	}
+}
+
+static void
+ps2pad_do_timer(unsigned long data)
+{
+
+	ps2pad_read_stat(new_stat);
+	if (ps2pad_comp_stat(new_stat, cur_stat)) {
+		ps2pad_copy_stat(cur_stat, new_stat);
+#ifdef PS2PAD_DEBUG
+			DPRINT("timer: new status: ");
+			if (ps2pad_debug) {
+				int i;
+				u_char *p = (u_char*)new_stat;
+				for (i = 0; i < sizeof(*new_stat) * 2; i++)
+					printk("%02X", *p++);
+				printk("\n");
+			}
+#endif
+		wake_up_interruptible(&watchq);
+	}
+
+	ps2pad_timer.expires = jiffies + INTERVAL_TIME;
+	add_timer(&ps2pad_timer);
+}
+
+static void
+ps2pad_start_timer()
+{
+	unsigned long flags;
+
+	DPRINT("start timer\n");
+	ps2pad_read_stat(cur_stat);
+	spin_lock_irqsave(&spinlock, flags);
+	run_timer = 1;
+	ps2pad_do_timer(ps2pad_timer.data);
+	spin_unlock_irqrestore(&spinlock, flags);
+}
+
+static inline void
+ps2pad_stop_timer()
+{
+	unsigned long flags;
+
+	DPRINT("stop timer\n");
+	spin_lock_irqsave(&spinlock, flags);
+	run_timer = 0;
+	del_timer(&ps2pad_timer);
+	spin_unlock_irqrestore(&spinlock, flags);
+}
+
+static inline void
+ps2pad_update_status()
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&spinlock, flags);
+	if (run_timer) {
+		del_timer(&ps2pad_timer);
+		ps2pad_do_timer(ps2pad_timer.data);
+	}
+	spin_unlock_irqrestore(&spinlock, flags);
+}
+
+static int
+lock()
+{
+	for ( ; ; ) {
+		unsigned long flags;
+
+		spin_lock_irqsave(&spinlock, flags);
+		if (!locked) {
+			locked = 1;
+			spin_unlock_irqrestore(&spinlock, flags);
+			return 0;
+		}
+		interruptible_sleep_on(&lockq);
+		spin_unlock_irqrestore(&spinlock, flags);
+		if(signal_pending(current)) {
+			return -ERESTARTSYS;
+		}
+	}
+}
+
+static void
+unlock()
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&spinlock, flags);
+	locked = 0;
+	wake_up_interruptible(&lockq);
+	spin_unlock_irqrestore(&spinlock, flags);
+}
+
+static ssize_t
+ps2pad_read(struct file *filp, char *buf, size_t size, loff_t *off)
+{
+	int res;
+	struct ps2pad_dev *dev = filp->private_data;
+	u_char data[PS2PAD_DATASIZE];
+
+	/* ps2padlib_Read() does not involve any RPC to IOP.
+	  if (lock() < 0) return -ERESTARTSYS;
+	 */
+	res = ps2padlib_Read(dev->pad->port, dev->pad->slot, data);
+	/*
+	  unlock();
+	 */
+	if (res == 0 || data[0] != 0) {
+		/* pad data is invalid */
+		return -EIO;	/* XXX */
+	}
+
+	/*
+	 * XXX, ignore offset
+	 */
+	res = (data[1] & 0x0f) * 2 + 2;
+	if (res < size) {
+		size = res;
+	}
+	//memcpy_tofs(buf, data, size);
+	copy_to_user(buf, data, size);
+	return size;
+}
+
+static int
+ps2pad_wait_req_stat(struct ps2pad_dev *dev)
+{
+	int res;
+
+	for ( ; ; ) {
+		unsigned long flags;
+
+		spin_lock_irqsave(&spinlock, flags);
+		res = ps2padlib_GetReqState(dev->pad->port, dev->pad->slot);
+		DPRINT("port%d slot%d: req stat %d\n",
+		       dev->pad->port, dev->pad->slot, res);
+		if (res != PadReqStateBusy) {
+			spin_unlock_irqrestore(&spinlock, flags);
+			return res;
+		}
+		interruptible_sleep_on(&watchq);
+		spin_unlock_irqrestore(&spinlock, flags);
+		if(signal_pending(current)) {
+			return -ERESTARTSYS;
+		}
+	}
+}
+
+static int
+ps2pad_check_req_stat(struct ps2pad_dev *dev)
+{
+	int res;
+
+	if ((res = ps2pad_wait_req_stat(dev)) < 0)
+		return res;
+	return (res == PadReqStateComplete) ? 0 : -EIO;
+}
+
+static int
+ps2pad_ioctl(struct inode *inode, struct file *filp, u_int cmd, u_long arg)
+{
+	int i, res;
+	struct ps2pad_dev *dev = filp->private_data;
+	int port = dev->pad->port;
+	int slot = dev->pad->slot;
+
+	switch (cmd) {
+	case PS2PAD_IOCPRESSMODEINFO:
+		if (lock() < 0) return -ERESTARTSYS;
+		res = ps2padlib_InfoPressMode(port, slot);
+		unlock();
+		return put_user(res, (int *)arg);
+		break;
+	case PS2PAD_IOCENTERPRESSMODE:
+		if (lock() < 0) return -ERESTARTSYS;
+		res = ps2padlib_EnterPressMode(port, slot);
+		unlock();
+		ps2pad_update_status();
+		if (res != 1)
+			return -EIO;
+		return (filp->f_flags & O_NONBLOCK) ? 0 : ps2pad_check_req_stat(dev);
+		break;
+	case PS2PAD_IOCEXITPRESSMODE:
+		if (lock() < 0) return -ERESTARTSYS;
+		res = ps2padlib_ExitPressMode(port, slot);
+		unlock();
+		ps2pad_update_status();
+		if (res != 1)
+			return -EIO;
+		return (filp->f_flags & O_NONBLOCK) ? 0 : ps2pad_check_req_stat(dev);
+		break;
+	case PS2PAD_IOCGETREQSTAT:
+		if (filp->f_flags & O_NONBLOCK) {
+			res = ps2padlib_GetReqState(port, slot);
+		} else {
+			if ((res = ps2pad_wait_req_stat(dev)) < 0)
+				return res;
+		}
+		if (res < 0 || ARRAYSIZEOF(rstat_conv_table) <= res) {
+			return -EIO;
+		} else {
+			return put_user(rstat_conv_table[res], (int *)arg);
+		}
+		break;
+	case PS2PAD_IOCGETSTAT:
+		if (lock() < 0) return -ERESTARTSYS;
+		res = ps2padlib_GetState(port, slot);
+		unlock();
+		if (res < 0 || ARRAYSIZEOF(stat_conv_table) <= res) {
+			return -EIO;
+		} else {
+			return put_user(stat_conv_table[res], (int *)arg);
+		}
+		break;
+	case PS2PAD_IOCACTINFO: {
+		struct ps2pad_actinfo info;
+		if (copy_from_user(&info, (char *)arg, sizeof(info)))
+		    return (-EFAULT);
+		if (lock() < 0) return -ERESTARTSYS;
+		res = ps2padlib_InfoAct(port, slot, info.actno, info.term);
+		unlock();
+		if (res < 0) return -EIO;
+		info.result = res;
+		res = copy_to_user((char *)arg, &info, sizeof(info));
+		return (res ? -EFAULT : 0);
+		}
+		break;
+	case PS2PAD_IOCCOMBINFO: {
+		struct ps2pad_combinfo info;
+		if (copy_from_user(&info, (char *)arg, sizeof(info)))
+		    return (-EFAULT);
+		if (lock() < 0) return -ERESTARTSYS;
+		res = ps2padlib_InfoComb(port, slot, info.listno, info.offs);
+		unlock();
+		if (res < 0) return -EIO;
+		info.result = res;
+		res = copy_to_user((char *)arg, &info, sizeof(info));
+		return (res ? -EFAULT : 0);
+		}
+		break;
+	case PS2PAD_IOCMODEINFO: {
+		struct ps2pad_modeinfo info;
+		if (copy_from_user(&info, (char *)arg, sizeof(info)))
+		    return (-EFAULT);
+		if (lock() < 0) return -ERESTARTSYS;
+		res = ps2padlib_InfoMode(port, slot, info.term, info.offs);
+		unlock();
+		if (res < 0) return -EIO;
+		info.result = res;
+		res = copy_to_user((char *)arg, &info, sizeof(info));
+		return (res ? -EFAULT : 0);
+		}
+		break;
+	case PS2PAD_IOCSETMODE: {
+		struct ps2pad_mode mode;
+		if (copy_from_user(&mode, (char *)arg, sizeof(mode)))
+		    return (-EFAULT);
+		if (lock() < 0) return -ERESTARTSYS;
+		res = ps2padlib_SetMainMode(port, slot, mode.offs, mode.lock);
+		unlock();
+		ps2pad_update_status();
+		if (res != 1) {
+			DPRINT("%d %d: ps2padlib_SetMainMode() failed\n",
+			       dev->pad->port, dev->pad->slot);
+			return -EIO;
+		}
+		if (filp->f_flags & O_NONBLOCK) {
+			DPRINT("port%d slot%d: PS2PAD_IOCSETMODE: non-block\n",
+			       dev->pad->port, dev->pad->slot);
+			return 0;
+		} else {
+			return ps2pad_check_req_stat(dev);
+		}
+		}
+		break;
+	case PS2PAD_IOCSETACTALIGN: {
+		struct ps2pad_act act;
+		if (copy_from_user(&act, (char *)arg, sizeof(act)))
+		    return (-EFAULT);
+		if (6 < act.len) {
+			return EINVAL;
+		}
+		for (i = act.len; i < 6; i++) {
+			act.data[i] = 0xff;
+		}
+		if (lock() < 0) return -ERESTARTSYS;
+		res = ps2padlib_SetActAlign(port, slot, act.data);
+		unlock();
+		ps2pad_update_status();
+		if (res != 1) return -EIO;
+		return (filp->f_flags & O_NONBLOCK) ? 0 : ps2pad_check_req_stat(dev);
+		}
+		break;
+	case PS2PAD_IOCSETACT: {
+		struct ps2pad_act act;
+		if (copy_from_user(&act, (char *)arg, sizeof(act)))
+		    return (-EFAULT);
+		if (6 < act.len) {
+			return EINVAL;
+		}
+		if (lock() < 0) return -ERESTARTSYS;
+		res = ps2padlib_SetActDirect(port, slot, act.data);
+		unlock();
+		if (res != 1) return -EIO;
+		return 0;
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int
+ps2pad_open(struct inode *inode, struct file *filp)
+{
+	dev_t devno = inode->i_rdev;
+
+	/* diagnosis */
+	if (MAJOR(devno) != ps2pad_major) {
+		printk(KERN_ERR "ps2pad: incorrect major no\n");
+		return -ENODEV;
+	}
+
+	DPRINT("open, devno=%04x\n", devno);
+
+	if (MINOR(devno)== 255) {
+		/*
+		 * control device
+		 */
+		struct ps2pad_ctl_dev *dev;
+
+		dev = kmalloc(sizeof(struct ps2pad_ctl_dev), GFP_KERNEL);
+		if (dev == NULL) {
+			return -ENOMEM;
+		}
+		filp->private_data = dev;
+
+		filp->f_op = &ps2pad_ctlops;
+
+		dev->stat_is_valid = 0;
+	} else {
+		/*
+		 * control device
+		 */
+		struct ps2pad_dev *dev;
+		int i;
+		int port, slot;
+
+		port = PORT(devno);
+		slot = SLOT(devno);
+
+		for (i = 0; i < ps2pad_npads; i++) {
+			if (ps2pad_pads[i].port == port &&
+			    ps2pad_pads[i].slot == slot) {
+				break;
+			}
+		}
+
+		if (ps2pad_npads <= i) {
+			/* pad device not found */
+			DPRINT("pad(%d,%d) not found\n", port, slot);
+			return -ENODEV;
+		}
+
+		dev = kmalloc(sizeof(struct ps2pad_dev), GFP_KERNEL);
+		if (dev == NULL) {
+			return -ENOMEM;
+		}
+		filp->private_data = dev;
+
+		dev->pad = &ps2pad_pads[i];
+	}
+
+	if (open_devices++ == 0)
+		ps2pad_start_timer();
+
+	return 0;
+}
+
+static ssize_t
+ps2pad_ctl_read(struct file *filp, char *buf, size_t size, loff_t *off)
+{
+	struct ps2pad_ctl_dev *dev = filp->private_data;
+	unsigned long flags;
+
+	if (sizeof(struct ps2pad_stat) * ps2pad_npads < size)
+		size = sizeof(struct ps2pad_stat) * ps2pad_npads;
+	spin_lock_irqsave(&spinlock, flags);
+	for ( ; ; ) {
+		if ((filp->f_flags & O_NONBLOCK) ||
+		    !dev->stat_is_valid ||
+		    ps2pad_comp_stat(dev->stat, cur_stat)) {
+			ps2pad_copy_stat(dev->stat, cur_stat);
+			dev->stat_is_valid = 1;
+#ifdef PS2PAD_DEBUG
+			DPRINT("new status: ");
+			if (ps2pad_debug) {
+				int i;
+				u_char *p = (u_char*)dev->stat;
+				for (i = 0; i < size; i++)
+					printk("%02X", *p++);
+				printk("\n");
+			}
+#endif
+			copy_to_user(buf, dev->stat, size);
+			spin_unlock_irqrestore(&spinlock, flags);
+			return size;
+		}
+		interruptible_sleep_on(&watchq);
+		spin_unlock_irqrestore(&spinlock, flags);
+		if(signal_pending(current)) {
+			return -ERESTARTSYS;
+		}
+	}
+}
+
+static int
+ps2pad_ctl_ioctl(struct inode *inode, struct file *filp, u_int cmd, u_long arg)
+{
+	/*
+	int res;
+	struct ps2pad_ctl_dev *dev = filp->private_data;
+	*/
+
+	switch (cmd) {
+	case PS2PAD_IOCGETNPADS:
+		return put_user(ps2pad_npads, (int *)arg);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static unsigned int
+ps2pad_poll(struct file *file, poll_table * wait)
+{
+	return POLLIN | POLLRDNORM;
+}
+
+static unsigned int
+ps2pad_ctl_poll(struct file *filp, poll_table * wait)
+{
+	unsigned int mask = 0;
+	struct ps2pad_ctl_dev *dev = filp->private_data;
+	unsigned long flags;
+
+	poll_wait(filp, &watchq, wait);
+	spin_lock_irqsave(&spinlock, flags);
+	if (!dev->stat_is_valid || ps2pad_comp_stat(dev->stat, cur_stat))
+		mask |= POLLIN | POLLRDNORM;
+	spin_unlock_irqrestore(&spinlock, flags);
+
+	return mask;
+}
+
+static int
+ps2pad_release(struct inode *inode, struct file *filp)
+{
+	struct ps2pad_dev *dev = filp->private_data;
+
+	DPRINT("close, dev=%lx\n", (unsigned long)dev);
+
+       	kfree(dev);
+
+	if (--open_devices == 0)
+		ps2pad_stop_timer();
+
+	return 0;
+}
+
+static int
+ps2pad_ctl_release(struct inode *inode, struct file *filp)
+{
+	struct ps2pad_ctl_dev *dev = filp->private_data;
+
+	DPRINT("ctl close, dev=%lx\n", (u_long)dev);
+
+	kfree(dev);
+
+	if (--open_devices == 0)
+		ps2pad_stop_timer();
+
+	return 0;
+}
+
+#ifdef CONFIG_PROC_FS
+static char* PadStateStr[] =
+{"DISCONNECT", "", "FINDCTP1", "", "", "EXECCMD", "STABLE", "ERROR" };
+
+static int
+ps2pad_read_proc(char *page, char **start, off_t offset, int len, int *eof, void *data)
+{
+	int res;
+	int n, i, j;
+	char *p = page;
+	u_char buf[PS2PAD_DATASIZE];
+	char *tmp;
+	unsigned long flags;
+
+	p += sprintf(p, "port slot status     type      button\n");
+	*eof = 1;
+
+	spin_lock_irqsave(&spinlock, flags);
+	for (i = 0; i < ps2pad_npads; i++) {
+		res = ps2padlib_GetState(ps2pad_pads[i].port, ps2pad_pads[i].slot);
+		tmp = (res >= 0 && res <= 7) ? PadStateStr[res] : "";
+		p += sprintf(p, "%4d %4d %-10s",
+			     ps2pad_pads[i].port, ps2pad_pads[i].slot, tmp);
+
+		res = ps2padlib_Read(ps2pad_pads[i].port, ps2pad_pads[i].slot,
+				 buf);
+		if (res != 0 && buf[0] == 0) {
+			/* pad data is valid */
+			p += sprintf(p, " %-9s",
+				     pad_type_names[(buf[1] & 0xf0) >> 4]);
+			p += sprintf(p, " %02X%02X ", buf[2], buf[3]);
+			n = (buf[1] & 0x0f) * 2 + 2;
+			for (j = 4; j < n; j++) {
+				p += sprintf(p, "%02X", buf[j]);
+			}
+		}
+		p += sprintf(p, "\n");
+	}
+	spin_unlock_irqrestore(&spinlock, flags);
+
+	return (p - page);
+}
+#endif
+
+static unsigned char *dmabuf;
+static int init_flags;
+#define INIT_LIB	(1<< 0)
+#define INIT_BUF	(1<< 1)
+#define INIT_DEV	(1<< 2)
+#define INIT_PROC	(1<< 3)
+
+int __init ps2pad_init(void)
+{
+	int res, i;
+	int port, slot;
+
+	DPRINT("PlayStation 2 game pad: initialize...\n");
+
+	spin_lock_init(&spinlock);
+
+	/*
+	 * initialize library
+	 */
+	if (ps2padlib_Init(0) != 1) {
+		printk(KERN_ERR "ps2pad: failed to initialize\n");
+		return -EIO;
+	}
+	init_flags |= INIT_LIB;
+
+	/*
+	 * allocate memory space
+	 */
+	dmabuf = kmalloc(DMABUFSIZE * MAXNPADS, GFP_KERNEL);
+	if (dmabuf == NULL) {
+		printk(KERN_ERR "ps2pad: can't allocate memory\n");
+		return -ENOMEM;
+	}
+	init_flags |= INIT_BUF;
+
+	for (i = 0; i < MAXNPADS; i++) {
+		/* 
+		 * We must access asynchronous DMA buffer via 
+		 * non-cached segment(KSEG1).
+		 */
+		ps2pad_pads[i].dmabuf = (void *)KSEG1ADDR(&dmabuf[DMABUFSIZE * i]);
+	}
+
+	/*
+	 * scan all pads and start DMA
+	 */
+	if (lock() < 0) return -ERESTARTSYS;
+	for (port = 0; port < NPORTS; port++) {
+	    for (slot = 0; slot < NSLOTS; slot++) {
+		res = ps2padlib_PortOpen(port, slot,
+				     (void *)ps2pad_pads[ps2pad_npads].dmabuf);
+		if (res == 1) {
+			if (MAXNPADS <= ps2pad_npads) {
+				printk(KERN_WARNING "ps2pad: too many pads\n");
+				break;
+			}
+			DPRINT("port%d  slot%d\n", port, slot);
+			ps2pad_pads[ps2pad_npads].port = port;
+			ps2pad_pads[ps2pad_npads].slot = slot;
+			ps2pad_npads++;
+		}
+	    }
+	}
+	unlock();
+
+	/*
+	 * initialize timer
+	 */
+	init_timer(&ps2pad_timer);
+	ps2pad_timer.function = ps2pad_do_timer;
+	ps2pad_timer.data = 0;
+
+	/*
+	 * register device entry
+	 */
+	if ((res = register_chrdev(ps2pad_major, "ps2pad", &ps2pad_fops)) < 0) {
+		printk(KERN_ERR "ps2pad: can't get major %d\n", ps2pad_major);
+		return res;
+	}
+	if (ps2pad_major == 0)
+		ps2pad_major = res;
+	init_flags |= INIT_DEV;
+
+#ifdef CONFIG_PROC_FS
+	create_proc_read_entry("ps2pad", 0, 0, ps2pad_read_proc, NULL);
+	init_flags |= INIT_PROC;
+#endif
+
+	return( 0 );
+}
+
+void
+ps2pad_cleanup(void)
+{
+#ifndef PS2PAD_NOPORTCLOSE
+	int res, i;
+#endif
+
+	DPRINT("unload\n");
+
+#ifndef PS2PAD_NOPORTCLOSE
+	if (init_flags & INIT_LIB) {
+		for (i = 0; i < ps2pad_npads; i++) {
+			res = ps2padlib_PortClose(ps2pad_pads[i].port,
+					      ps2pad_pads[i].slot);
+			if (res != 1) {
+				printk(KERN_WARNING "ps2pad: failed to close\n");
+			}
+		}
+	}
+#endif
+
+	if (init_flags & INIT_DEV) {
+		unregister_chrdev(ps2pad_major, "ps2pad");
+	} else {
+		printk(KERN_WARNING "ps2pad: unregister_chrdev() error\n");
+	}
+	init_flags &= ~INIT_DEV;
+
+#ifdef CONFIG_PROC_FS
+	if (init_flags & INIT_PROC)
+		remove_proc_entry("ps2pad", NULL);
+	init_flags &= ~INIT_PROC;
+#endif
+
+	if ((init_flags & INIT_LIB) && ps2padlib_End() != 1) {
+		printk(KERN_WARNING "ps2pad: failed to finalize\n");
+	}
+	init_flags &= ~INIT_LIB;
+
+	if (init_flags & INIT_BUF)
+		kfree(dmabuf);
+	init_flags &= ~INIT_BUF;
+}
+
+module_init(ps2pad_init);
+module_exit(ps2pad_cleanup);
+
+MODULE_AUTHOR("Sony Computer Entertainment Inc.");
+MODULE_DESCRIPTION("PlayStation 2 game controller driver");
+MODULE_LICENSE("GPL");
diff -purN linux-2.6.35.4-orig/drivers/ps2/padcall.h linux-2.6.35.4/drivers/ps2/padcall.h
--- linux-2.6.35.4-orig/drivers/ps2/padcall.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/padcall.h	2014-07-18 22:29:43.558367724 +0200
@@ -0,0 +1,210 @@
+/*
+ *  PlayStation 2 Game Controller driver
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <asm/mach-ps2/sifdefs.h>
+#include <asm/mach-ps2/sbios.h>
+
+static __inline__ int ps2padlib_Init(int mode)
+{
+	struct sbr_pad_init_arg arg;
+	int res;
+
+#ifdef CONFIG_PS2_SBIOS_VER_CHECK
+	if (sbios(SB_GETVER, NULL) < 0x0200)
+		return -1;
+#endif
+
+	arg.mode = mode;
+	do {
+		if (sbios_rpc(SBR_PAD_INIT, &arg, &res) < 0 || res < 0)
+			return -1;
+	} while (res == 0);
+	return 1;
+}
+
+static __inline__ int ps2padlib_End(void)
+{
+	int res;
+	if (sbios_rpc(SBR_PAD_END, NULL, &res) < 0)
+		return -1;
+	return res;
+}
+
+static __inline__ int ps2padlib_PortOpen(int port, int slot, void *addr)
+{
+	struct sbr_pad_portopen_arg po_arg;
+	int res;
+
+	po_arg.port = port;
+	po_arg.slot = slot;
+	po_arg.addr = (void *)addr;
+	if (sbios_rpc(SBR_PAD_PORTOPEN, &po_arg, &res) < 0)
+		return -1;
+	return res;
+}
+
+static __inline__ int ps2padlib_PortClose(int port, int slot)
+{
+	struct sbr_pad_portclose_arg pc_arg;
+	int res;
+
+	pc_arg.port = port;
+	pc_arg.slot = slot;
+	if (sbios_rpc(SBR_PAD_PORTCLOSE, &pc_arg, &res) < 0)
+		return -1;
+	return res;
+}
+
+static __inline__ int ps2padlib_SetMainMode(int port, int slot, int offs, int lock)
+{
+	struct sbr_pad_setmainmode_arg sm_arg;
+	int res;
+
+	sm_arg.port = port;
+	sm_arg.slot = slot;
+	sm_arg.offs = offs;
+	sm_arg.lock = lock;
+	if (sbios_rpc(SBR_PAD_SETMAINMODE, &sm_arg, &res) < 0)
+		return -1;
+	return res;
+}
+
+static __inline__ int ps2padlib_SetActDirect(int port, int slot, const unsigned char *data)
+{
+	struct sbr_pad_setactdirect_arg sd_arg;
+	int res;
+
+	sd_arg.port = port;
+	sd_arg.slot = slot;
+	sd_arg.data = data;
+	if (sbios_rpc(SBR_PAD_SETACTDIRECT, &sd_arg, &res) < 0)
+		return -1;
+	return res;
+}
+
+static __inline__ int ps2padlib_SetActAlign(int port, int slot, const unsigned char *data)
+{
+	struct sbr_pad_setactalign_arg sa_arg;
+	int res;
+
+	sa_arg.port = port;
+	sa_arg.slot = slot;
+	sa_arg.data = data;
+	if (sbios_rpc(SBR_PAD_SETACTALIGN, &sa_arg, &res) < 0)
+		return -1;
+	return res;
+}
+
+static __inline__ int ps2padlib_InfoPressMode(int port, int slot)
+{
+	struct sbr_pad_pressmode_arg pr_arg;
+	int res;
+
+	pr_arg.port = port;
+	pr_arg.slot = slot;
+	if (sbios_rpc(SBR_PAD_INFOPRESSMODE, &pr_arg, &res) < 0)
+		return -1;
+	return res;
+}
+
+static __inline__ int ps2padlib_EnterPressMode(int port, int slot)
+{
+	struct sbr_pad_pressmode_arg pr_arg;
+	int res;
+
+	pr_arg.port = port;
+	pr_arg.slot = slot;
+	if (sbios_rpc(SBR_PAD_ENTERPRESSMODE, &pr_arg, &res) < 0)
+		return -1;
+	return res;
+}
+
+static __inline__ int ps2padlib_ExitPressMode(int port, int slot)
+{
+	struct sbr_pad_pressmode_arg pr_arg;
+	int res;
+
+	pr_arg.port = port;
+	pr_arg.slot = slot;
+	if (sbios_rpc(SBR_PAD_EXITPRESSMODE, &pr_arg, &res) < 0)
+		return -1;
+	return res;
+}
+
+static __inline__ int ps2padlib_Read(int port, int slot, unsigned char *rdata)
+{
+	struct sb_pad_read_arg rd_arg;
+
+	rd_arg.port = port;
+	rd_arg.slot = slot;
+	rd_arg.rdata = rdata;
+	return sbios(SB_PAD_READ, &rd_arg);
+}
+
+static __inline__ int ps2padlib_GetState(int port, int slot)
+{
+	struct sb_pad_getstate_arg gs_arg;
+
+	gs_arg.port = port;
+	gs_arg.slot = slot;
+	return sbios(SB_PAD_GETSTATE, &gs_arg);
+}
+
+static __inline__ int ps2padlib_GetReqState(int port, int slot)
+{	
+	struct sb_pad_getreqstate_arg gr_arg;
+
+	gr_arg.port = port;
+	gr_arg.slot = slot;
+	return sbios(SB_PAD_GETREQSTATE, &gr_arg);
+}
+
+static __inline__ int ps2padlib_InfoAct(int port, int slot, int actno, int term)
+{	
+	struct sb_pad_infoact_arg ia_arg;
+
+	ia_arg.port = port;
+	ia_arg.slot = slot;
+	ia_arg.actno = actno;
+	ia_arg.term = term;
+	return sbios(SB_PAD_INFOACT, &ia_arg);
+}
+
+static __inline__ int ps2padlib_InfoComb(int port, int slot, int listno, int offs)
+{	
+	struct sb_pad_infocomb_arg ic_arg;
+
+	ic_arg.port = port;
+	ic_arg.slot = slot;
+	ic_arg.listno = listno;
+	ic_arg.offs = offs;
+	return sbios(SB_PAD_INFOCOMB, &ic_arg);
+}
+
+static __inline__ int ps2padlib_InfoMode(int port, int slot, int term, int offs)
+{	
+	struct sb_pad_infomode_arg im_arg;
+
+	im_arg.port = port;
+	im_arg.slot = slot;
+	im_arg.term = term;
+	im_arg.offs = offs;
+	return sbios(SB_PAD_INFOMODE, &im_arg);
+}
diff -purN linux-2.6.35.4-orig/drivers/ps2/pad.h linux-2.6.35.4/drivers/ps2/pad.h
--- linux-2.6.35.4-orig/drivers/ps2/pad.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/pad.h	2014-07-18 22:29:43.558367724 +0200
@@ -0,0 +1,52 @@
+/*
+ *  PlayStation 2 Game Controller driver
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <asm/mach-ps2/sbios.h>
+#include <asm/mach-ps2/sifdefs.h>
+#include <linux/ps2/pad.h>
+
+#define PadStateDiscon		(0)
+#define PadStateFindPad		(1)
+#define PadStateFindCTP1	(2)
+#define PadStateExecCmd		(5)
+#define PadStateStable		(6)
+#define PadStateError		(7)
+
+#define PadReqStateComplete	(0)
+#define PadReqStateFaild	(1)
+#define PadReqStateFailed	(1)
+#define PadReqStateBusy		(2)
+
+#define PS2PAD_NPORTS            2
+#define PS2PAD_NSLOTS            1 /* currently, we doesn't support multitap */
+#define PS2PAD_MAXNPADS          8
+
+struct ps2pad_libctx {
+	int port, slot;
+	void *dmabuf;
+};
+
+extern struct ps2pad_libctx ps2pad_pads[];
+extern int ps2pad_npads;
+
+void ps2pad_js_init(void);
+void ps2pad_js_quit(void);
+
+int ps2pad_stat_conv(int stat);
diff -purN linux-2.6.35.4-orig/drivers/ps2/sd.c linux-2.6.35.4/drivers/ps2/sd.c
--- linux-2.6.35.4-orig/drivers/ps2/sd.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/sd.c	2014-07-18 22:29:43.558367724 +0200
@@ -0,0 +1,2780 @@
+/*
+ *  PlayStation 2 Sound driver
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/soundcard.h>
+#include <asm/io.h>
+#include <asm/addrspace.h>
+#include <asm/uaccess.h>
+
+#include <asm/mach-ps2/sbios.h>
+#include <asm/mach-ps2/sifdefs.h>
+#include <asm/mach-ps2/sifutil.h>
+#include <asm/mach-ps2/siflock.h>
+#include <asm/mach-ps2/sound.h>
+#include <asm/mach-ps2/bootinfo.h>
+
+#include "../../sound/oss/sound_config.h"
+#include "iopmem.h"
+
+#define PS2SD_DMA_ADDR_CHECK
+#define PS2SD_USE_THREAD
+
+#include "sd.h"
+#include "sdmacro.h"
+#include "sdcall.h"
+
+/*
+ * macro defines
+ */
+#define PS2SD_INIT_REGDEV	(1 <<  0)
+#define PS2SD_INIT_UNIT		(1 <<  1)
+#define PS2SD_INIT_IOP		(1 <<  3)
+#define PS2SD_INIT_DMACALLBACK  (1 <<  4)
+#define PS2SD_INIT_IOPZERO    	(1 <<  5)
+#define PS2SD_INIT_REGMIXERDEV	(1 <<  6)
+#define PS2SD_INIT_TIMER	(1 <<  7)
+#define PS2SD_INIT_BUFFERALLOC	(1 <<  8)
+#define PS2SD_INIT_THREAD	(1 <<  9)
+
+#define DEVICE_NAME	"PS2 Sound"
+
+#define BUFUNIT	1024		/* don't change this */
+#define INTRSIZE 512		/* don't change this */
+#define CNVBUFSIZE (BUFUNIT*2)
+#define INTBUFSIZE BUFUNIT	/* don't change this */
+#define SPU2SPEED 48000		/* 48KHz */
+#define SPU2FMT AFMT_S16_LE
+#define SUPPORTEDFMT	(AFMT_S16_LE)
+
+#define UNIT0_FLAGS	0
+#ifdef CONFIG_PS2_SD_ALTPCM
+#define UNIT1_FLAGS	0
+#else
+#define UNIT1_FLAGS	(PS2SD_UNIT_NOPCM)
+#endif
+#define UNIT2_FLAGS	(PS2SD_UNIT_EXCLUSIVE)
+
+#define MIN(a, b)	((a) < (b) ? (a) : (b))
+#define PS2SD_MINIMUM_BUFSIZE		(BUFUNIT * 2)	/* 2KB */
+#define PS2SD_DEFAULT_DMA_BUFSIZE	16	/*  16KB	*/
+#define PS2SD_DEFAULT_IOP_BUFSIZE	8	/*   8KB	*/
+#define PS2SD_MAX_DMA_BUFSIZE		128	/* 128KB	*/
+#define PS2SD_MAX_IOP_BUFSIZE		64	/*  64KB	*/
+
+#define PS2SD_SPU2PCMBUFSIZE	1024
+
+#define PS2SD_FADEINOUT
+
+#define CHECKPOINT(s)	devc->debug_check_point = (s)
+
+#define UNIT(dev)	((MINOR(dev) & 0x00f0) >> 4)
+
+#define SWAP(a, b)	\
+    do { \
+	__typeof__(a) tmp; \
+	tmp = (a); \
+	(a) = (b); \
+	(b) = tmp; \
+    } while (0)
+
+#define CHECKBUFRANGE
+#ifdef CHECKBUFRANGE
+#define CHECK_BUF_RANGE(startaddr, bufsize, tailaddr, size, count) \
+    do { \
+	if ((startaddr + bufsize) < (tailaddr + size)) { \
+		printk("Out of range: end of buf = 0x%p (start 0x%p + bufsize 0x%x), \
+but writing at 0x%p (tail 0x%p + size 0x%x), bufcount = %d\n", \
+		       startaddr + bufsize, startaddr ,bufsize, tailaddr + size, \
+		       tailaddr, size, count); \
+	} \
+    } while (0)
+#else
+#define CHECK_BUF_RANGE(startaddr, bufsize, tailaddr, size) do {} while (0)
+#endif
+
+/*
+ * data types
+ */
+enum dmastat {
+	DMASTAT_STOP,
+	DMASTAT_START,
+	DMASTAT_RUNNING,
+	DMASTAT_STOPREQ,
+	DMASTAT_STOPPING,
+	DMASTAT_CANCEL,
+	DMASTAT_CLEAR,
+	DMASTAT_ERROR,
+	DMASTAT_RESET,
+};
+
+char *dmastatnames[] = {
+	[DMASTAT_STOP]		= "STOP",
+	[DMASTAT_START]		= "START",
+	[DMASTAT_RUNNING]	= "RUNNING",
+	[DMASTAT_STOPREQ]	= "STOPREQ",
+	[DMASTAT_STOPPING]	= "STOPPING",
+	[DMASTAT_CANCEL]	= "CANCEL",
+	[DMASTAT_CLEAR]		= "CLEAR",
+	[DMASTAT_ERROR]		= "ERROR",
+	[DMASTAT_RESET]		= "RESET",
+};
+
+/*
+ * function prototypes
+ */
+void ps2sd_cleanup(void);
+static int ps2sd_init(void);
+
+static loff_t ps2sd_llseek(struct file *, loff_t, int);
+static ssize_t ps2sd_read(struct file *, char *, size_t, loff_t *);
+static ssize_t ps2sd_write(struct file *, const char *, size_t, loff_t *);
+static unsigned int ps2sd_poll(struct file *, struct poll_table_struct *);
+static int ps2sd_mmap(struct file *, struct vm_area_struct *);
+static int ps2sd_ioctl(struct inode *, struct file *, unsigned int, unsigned long);
+static int ps2sd_open(struct inode *, struct file *);
+static int ps2sd_release(struct inode *, struct file *);
+static void ps2sd_setup(void);
+static int ps2sd_command_end(struct ps2sd_unit_context *devc);
+static void ps2sd_mute(struct ps2sd_unit_context *);
+static void ps2sd_unmute(struct ps2sd_unit_context *);
+
+#ifdef PS2SD_USE_THREAD
+static int ps2sd_thread(void *);
+static int ps2sd_intr(void *, int);
+#else
+#define ps2sd_intr ps2sd_dmaintr
+#endif
+static int ps2sd_dmaintr(void* argx, int dmach);
+
+static int adjust_bufsize(int size);
+static int alloc_buffer(struct ps2sd_unit_context *devc);
+static int free_buffer(struct ps2sd_unit_context *devc);
+static int reset_buffer(struct ps2sd_unit_context *devc);
+static int start(struct ps2sd_unit_context *devc);
+static int stop(struct ps2sd_unit_context *devc);
+static int wait_dma_stop(struct ps2sd_unit_context *devc);
+static int reset_error(struct ps2sd_unit_context *devc);
+static int stop_sequence0(void*);
+static void stop_sequence(void*);
+static int set_format(struct ps2sd_unit_context *, int, int, int, int);
+
+/*
+ * variables
+ */
+unsigned long ps2sd_debug = 0;
+struct ps2sd_module_context ps2sd_mc;
+struct ps2iopmem_list ps2sd_unit2_iopmemlist;
+struct ps2sd_unit_context ps2sd_units[3];
+int ps2sd_nunits = ARRAYSIZEOF(ps2sd_units);
+struct ps2sd_mixer_context ps2sd_mixers[1];
+int ps2sd_nmixers = ARRAYSIZEOF(ps2sd_mixers);
+struct ps2sd_mixer_channel mixer_dummy_channel;
+int ps2sd_dmabufsize = PS2SD_DEFAULT_DMA_BUFSIZE;
+int ps2sd_iopbufsize = PS2SD_DEFAULT_IOP_BUFSIZE;
+int ps2sd_max_dmabufsize = PS2SD_MAX_DMA_BUFSIZE;
+int ps2sd_max_iopbufsize = PS2SD_MAX_IOP_BUFSIZE;
+int ps2sd_normal_debug;
+#ifdef CONFIG_T10000_DEBUG_HOOK
+int ps2sd_debug_hook = 0;
+#endif
+
+module_param(ps2sd_debug, ulong, 0);
+module_param(ps2sd_dmabufsize, int, 0);
+module_param(ps2sd_iopbufsize, int, 0);
+module_param(ps2sd_max_dmabufsize, int, 0);
+module_param(ps2sd_max_iopbufsize, int, 0);
+#ifdef CONFIG_T10000_DEBUG_HOOK
+module_param(ps2sd_debug_hook, bool, 0);
+#endif
+
+static struct file_operations ps2sd_dsp_fops = {
+	owner:		THIS_MODULE,
+	llseek:		ps2sd_llseek,
+	read:		ps2sd_read,
+	write:		ps2sd_write,
+	poll:		ps2sd_poll,
+	ioctl:		ps2sd_ioctl,
+	mmap:		ps2sd_mmap,
+	open:		ps2sd_open,
+	release:	ps2sd_release,
+};
+
+/*
+ * function bodies
+ */
+/*
+ * retrieve a value of counter register,
+ * which is counting CPU clock.
+ *
+ * PS2 CPU clock is 294.912MHz.
+ * 294.912MHz = 294912000
+ *  = 2048 * 3 * 48000
+ *  = 2^15 * 9 * 1000
+ */
+static inline __u32
+getcounter(void)
+{
+        __u32 r;
+        asm volatile (
+                "mfc0   %0,$9;"
+                : "=r" (r) /* output */
+                :
+           );
+	return (r);
+}
+
+static inline __u32
+convertusec(int32_t c)
+{
+	/* usec = counter * 1000000 / 294912000 */
+	return (c / 128 * 1000 / 2304);
+}
+
+static inline int
+getudelay(struct ps2sd_unit_context *devc)
+{
+	return (convertusec(getcounter() - devc->prevdmaintr));
+}
+
+static inline int
+dest_to_src_bytes(struct ps2sd_unit_context *devc, int dest_bytes)
+{
+	if (devc->noconversion)
+	  return (dest_bytes);
+	else
+	  return (dest_bytes / 4 * devc->samplesize *
+		  devc->cnvsrcrate / devc->cnvdstrate);
+}
+
+static inline int
+src_to_dest_bytes(struct ps2sd_unit_context *devc, int src_bytes)
+{
+	if (devc->noconversion)
+	  return (src_bytes);
+	else
+	  return (src_bytes / devc->samplesize * 4 *
+		  devc->cnvdstrate / devc->cnvsrcrate);
+}
+
+static int
+setdmastate(struct ps2sd_unit_context *devc, int curstat, int newstat, char *cause)
+{
+	int res;
+	unsigned long flags;
+
+	spin_lock_irqsave(&devc->spinlock, flags);
+	if (devc->dmastat == curstat) {
+		DPRINT(DBG_DMASTAT,
+		       "core%d %s->%s, '%s'\n", devc->core,
+		       dmastatnames[curstat], dmastatnames[newstat], cause);
+		devc->dmastat = newstat;
+		res = 0;
+	} else {
+		DPRINT(DBG_DMASTAT,
+		       "core%d %s->%s denied, current stat=%s, '%s'\n",
+		       devc->core,
+		       dmastatnames[curstat], dmastatnames[newstat],
+		       dmastatnames[devc->dmastat], cause);
+		res = -1;
+	}
+	wake_up(&devc->dmastat_wq);
+	spin_unlock_irqrestore(&devc->spinlock, flags);
+
+	return res;
+}
+
+static void
+ps2sd_timer(unsigned long data)
+{
+	struct ps2sd_unit_context *devc = (struct ps2sd_unit_context *)data;
+
+	if (devc->intr_count == 0) {
+		DPRINT(DBG_INFO, "DMA%d seems to be hunging up\n",
+		       devc->dmach);
+		if (setdmastate(devc, DMASTAT_RUNNING, DMASTAT_STOPPING,
+				"DMA seems to be hunging up") == 0 ||
+		    setdmastate(devc, DMASTAT_STOPREQ, DMASTAT_STOPPING,
+				"DMA seems to be hunging up") == 0){
+			/* mute */
+			ps2sd_mute(devc);
+			devc->lockq.routine = stop_sequence0;
+			devc->lockq.arg = devc;
+			devc->lockq.name = "stop by timer";
+			ps2sif_lowlevel_lock(ps2sd_mc.lock, &devc->lockq,
+					     PS2SIF_LOCK_QUEUING);
+		}
+	} else {
+		devc->intr_count = 0;
+		devc->timer.expires = jiffies + devc->timeout;
+		add_timer(&devc->timer);
+	}
+}
+
+static inline void
+ps2sd_iopdma(ps2sif_dmadata_t *sdd, int len)
+{
+	unsigned int dmaid;
+
+	dmaid = ps2sif_setdma_wait(sdd, len);
+	ps2sif_dmastat_wait(dmaid);
+}
+
+static inline int
+ps2sd_iopdma_interruptible(ps2sif_dmadata_t *sdd, int len)
+{
+	unsigned int dmaid;
+
+	if ((dmaid = ps2sif_setdma_wait_interruptible(sdd, len)) == 0 ||
+	    0 <= ps2sif_dmastat_wait_interruptible(dmaid))
+		return (-ERESTART);
+
+	return (0);
+}
+
+/*
+ * audio_driver interface functions
+ */
+static loff_t
+ps2sd_llseek(struct file *file, loff_t offset, int origin)
+{
+	return -ESPIPE;
+}
+
+static ssize_t
+ps2sd_read(struct file *filp, char *buffer, size_t count, loff_t *ppos)
+{
+	return -EINVAL;
+}
+
+static int
+flush_intbuf(struct ps2sd_unit_context *devc, int nonblock)
+{
+	int res, i, buftail, bufcount;
+	unsigned long flags;
+	DECLARE_WAITQUEUE(wait, current);
+
+	TRACE("flush_intbuf\n");
+	spin_lock_irqsave(&devc->spinlock, flags);
+	add_wait_queue(&devc->write_wq, &wait);
+	res = -EINVAL; /* failsafe */
+	for ( ; ; ) {
+		/* is dma buffer space available? */
+		buftail = devc->dmabuftail;
+		bufcount = devc->dmabufcount;
+
+		if (bufcount < devc->dmabufsize) {
+			res = 0;
+			break;
+		}
+
+		/* no space */
+		if (nonblock) {
+			res = -EBUSY;
+			break;
+		}
+		if ((res = start(devc)) < 0)
+			break;
+		set_current_state(TASK_INTERRUPTIBLE);
+		spin_unlock_irq(&devc->spinlock);
+		schedule();
+		spin_lock_irq(&devc->spinlock);
+		if (signal_pending(current)) {
+			DPRINT(DBG_INFO, "flush_intbuf(): interrupted\n");
+			res = -ERESTARTSYS;
+			break;
+		}
+		TRACE2("flush_intbuf loop\n");
+		continue;
+	}
+	remove_wait_queue(&devc->write_wq, &wait);
+	spin_unlock_irqrestore(&devc->spinlock, flags);
+	if (res != 0)
+		return (res);
+
+	/* now, we have at least BUFUNIT space in dma buffer */
+	/* convert into 512 bytes interleaved format */
+	if (devc->flags & PS2SD_UNIT_INT512) {
+		memcpy(&devc->dmabuf[buftail], devc->intbuf, BUFUNIT);
+	} else {
+		unsigned short *src, *dst;
+		src = (unsigned short*)devc->intbuf;
+		dst = (unsigned short*)&devc->dmabuf[buftail];
+		for (i = 0; i < BUFUNIT/sizeof(u_short)/2; i++) {
+			dst[0] = *src++;
+			dst[BUFUNIT/sizeof(u_short)/2] = *src++;
+			dst++;
+		}
+	}
+	ps2sif_writebackdcache(&devc->dmabuf[buftail], BUFUNIT);
+
+	buftail += BUFUNIT;
+	buftail %= devc->dmabufsize;
+	bufcount += BUFUNIT;
+	devc->intbufcount = 0;
+	spin_lock_irqsave(&devc->spinlock, flags);
+	devc->dmabuftail = buftail;
+	devc->dmabufcount += BUFUNIT;
+	spin_unlock_irqrestore(&devc->spinlock, flags);
+
+	return (0);
+}
+
+static void
+flush_cnvbuf(struct ps2sd_unit_context *devc)
+{
+	int n;
+
+	preempt_disable();
+	if (devc->noconversion) {
+		TRACE("flush_cnvbuf no conversion\n");
+		n = MIN(INTBUFSIZE - devc->intbufcount, 
+			devc->cnvbufcount);
+		if (CNVBUFSIZE - devc->cnvbufhead < n)
+			n = CNVBUFSIZE - devc->cnvbufhead;
+		memcpy(&devc->intbuf[devc->intbufcount],
+		       &devc->cnvbuf[devc->cnvbufhead], n);
+		devc->intbufcount += n;
+		devc->cnvbufcount -= n;
+		devc->cnvbufhead += n;
+		devc->cnvbufhead %= CNVBUFSIZE;
+	} else {
+		struct ps2sd_sample s0, s1, *d;
+		int scount = 0, dcount = 0;
+
+#define CUR_ADDR &devc->cnvbuf[devc->cnvbufhead]
+#define NEXT_ADDR &devc->cnvbuf[(devc->cnvbufhead + devc->samplesize) % CNVBUFSIZE]
+		(*devc->fetch)(&s0, CUR_ADDR);
+		(*devc->fetch)(&s1, NEXT_ADDR);
+		d = (void*)&devc->intbuf[devc->intbufcount];
+		while (devc->intbufcount < INTBUFSIZE &&
+		       devc->samplesize * 2 <= devc->cnvbufcount) {
+			d->l = (s0.l * devc->cnvd + s1.l * (devc->cnvdstrate - devc->cnvd))/devc->cnvdstrate;
+			d->r = (s0.r * devc->cnvd + s1.r * (devc->cnvdstrate - devc->cnvd))/devc->cnvdstrate;
+			d++;
+			devc->intbufcount += sizeof(struct ps2sd_sample);
+			dcount += sizeof(struct ps2sd_sample);
+			if ((devc->cnvd -= devc->cnvsrcrate) < 0) {
+				s0 = s1;
+				devc->cnvbufhead += devc->samplesize;
+				devc->cnvbufhead %= CNVBUFSIZE;
+				devc->cnvbufcount -= devc->samplesize;
+				(*devc->fetch)(&s1, NEXT_ADDR);
+				devc->cnvd += devc->cnvdstrate;
+				scount += devc->samplesize;
+			}
+		}
+		DPRINT(DBG_VERBOSE, "dma%d: flush_cnvbuf convert %d -> %d bytes cnvbufcount=%d intbufcount=%d\n",
+		       devc->dmach, scount, dcount, devc->cnvbufcount, devc->intbufcount);
+	}
+	preempt_enable();
+}
+
+static int
+post_buffer(struct ps2sd_unit_context *devc)
+{
+	int res;
+	unsigned long flags;
+
+
+	/* just falesafe, this sould not occur */
+	if (devc->samplesize == 0) {
+		printk(KERN_CRIT "ps2sd: internal error, sampelsize = 0");
+		devc->samplesize = 1;
+	}
+
+	/* make sure that conversion buffer is empty */
+	while (devc->samplesize * 2 <= devc->cnvbufcount) {
+		flush_cnvbuf(devc);
+		if (devc->intbufcount == INTBUFSIZE) {
+			if ((res = flush_intbuf(devc, 0 /* block */)) < 0)
+				return res;
+		}
+	}
+
+	/* flush interleave buffer */
+	if (devc->intbufcount != 0) {
+		/* pad interleave buffer if necessary */
+		if (devc->intbufcount < INTBUFSIZE) {
+			DPRINT(DBG_INFO, "pad interleave buf %d bytes\n", 
+			       INTBUFSIZE - devc->intbufcount);
+			memset(&devc->intbuf[devc->intbufcount], 0,
+			       INTBUFSIZE - devc->intbufcount);
+		}
+		/* flush the buffer */
+		if ((res = flush_intbuf(devc, 0 /* block */)) < 0)
+			return res;
+	}
+
+	spin_lock_irqsave(&devc->spinlock, flags);
+	if (devc->dmastat == DMASTAT_STOP &&
+	    devc->dmabufcount != 0) {
+		spin_unlock_irqrestore(&devc->spinlock, flags);
+		memset(devc->intbuf, 0, INTBUFSIZE);
+		DPRINT(DBG_INFO, "pad dma buf %d bytes\n", 
+		       devc->iopbufsize/2 - devc->dmabufcount);
+		while (devc->dmabufcount < devc->iopbufsize/2) {
+			res = flush_intbuf(devc, 0 /* block */);
+			if (res < 0)
+				return res;
+		}
+		start(devc);
+	} else {
+		spin_unlock_irqrestore(&devc->spinlock, flags);
+	}
+
+	return 0;
+}
+
+static int
+sync_buffer(struct ps2sd_unit_context *devc)
+{
+	int res;
+
+	if ((res = post_buffer(devc)) < 0)
+		return res;
+	return wait_dma_stop(devc);
+}
+
+static ssize_t
+ps2sd_write(struct file *filp, const char *buffer, size_t count, loff_t *ppos)
+{
+	int ret, res;
+	struct ps2sd_unit_context *devc;
+
+	devc = PS2SD_DEVC(filp);
+
+	if (!access_ok(VERIFY_WRITE, buffer, count))
+		return -EFAULT;
+
+	DPRINT(DBG_WRITE, "write %dbytes head=%p cnt=0x%x\n",
+	       count, &devc->dmabuf[devc->dmabuftail], devc->dmabufcount);
+
+	if (devc->cnvbuf == NULL)
+		return -EINVAL; /* no PCM buffers allocated */
+
+	ret = 0;
+	while (0 < count) {
+		int n;
+
+		/* check errors and reset it */
+		if ((res = reset_error(devc)) < 0)
+			return ret ? ret : res;
+
+		/*
+		 * copy into format conversion buffer
+		 * user space -> cnvbuf
+		 */
+		preempt_disable();
+		if (0 < (n = CNVBUFSIZE - devc->cnvbufcount)) {
+			if (devc->cnvbufhead <= devc->cnvbuftail)
+				n = CNVBUFSIZE - devc->cnvbuftail;
+			if (count < n) {
+				n = count;
+			}
+
+			CHECK_BUF_RANGE(&devc->cnvbuf[0], CNVBUFSIZE, &devc->cnvbuf[devc->cnvbuftail], n,
+					devc->cnvbufcount);
+			if (copy_from_user(&devc->cnvbuf[devc->cnvbuftail],
+					   buffer, n)) {
+				preempt_enable();
+				return ret ? ret : -EFAULT;
+			}
+			DPRINT(DBG_VERBOSE, "dma%d: copy_from_user %d bytes\n", devc->dmach, n);
+			devc->cnvbuftail += n;
+			devc->cnvbuftail %= CNVBUFSIZE;
+			devc->cnvbufcount += n;
+			count -= n;
+			buffer += n;
+			ret += n;
+		}
+		preempt_enable();
+
+		/* 
+		 * format conversion
+		 * cnvbuf -> intbuf
+		 */
+		flush_cnvbuf(devc);
+
+		/*
+		 * flush interleave buffer if it gets full
+		 * intbuf -> dmabuf
+		 */
+		if (devc->intbufcount == INTBUFSIZE) {
+			res = flush_intbuf(devc, filp->f_flags & O_NONBLOCK);
+			if (res < 0) {
+				return ret ? ret : res;
+			}
+		}
+
+		/* kick DMA */
+		if (devc->iopbufsize <= devc->dmabufcount)
+			if ((res = start(devc)) < 0)
+				return ret ? ret : res;
+	}
+
+	return ret;
+}
+
+static unsigned int 
+ps2sd_poll(struct file *filp, struct poll_table_struct *wait)
+{
+	struct ps2sd_unit_context *devc;
+	unsigned long flags;
+	int space;
+	unsigned int mask = 0;
+
+	devc = PS2SD_DEVC(filp);
+	poll_wait(filp, &devc->write_wq, wait);
+
+	spin_lock_irqsave(&devc->spinlock, flags);
+	space = devc->dmabufsize - devc->dmabufcount;
+	spin_unlock_irqrestore(&devc->spinlock, flags);
+
+	if (devc->iopbufsize/2 <= space)
+	  mask |= POLLOUT | POLLWRNORM;
+
+	return mask;
+}
+
+static int
+ps2sd_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+       	return -EINVAL;
+}
+
+static int
+ps2sd_ioctl(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	int i, val, res, dmabytes;
+	unsigned long flags;
+	struct ps2sd_unit_context *devc;
+        audio_buf_info abinfo;
+        count_info cinfo;
+
+	devc = PS2SD_DEVC(filp);
+
+	switch (cmd) {
+	case OSS_GETVERSION:
+		DPRINT(DBG_IOCTL, "ioctl(OSS_GETVERSION)\n");
+		return put_user(SOUND_VERSION, (int *)arg);
+
+	case SNDCTL_DSP_SYNC:
+		DPRINT(DBG_IOCTL, "ioctl(SNDCTL_DSP_SYNC)\n");
+		return sync_buffer(devc);
+		break;
+
+	case SNDCTL_DSP_SETDUPLEX:
+		DPRINT(DBG_IOCTL, "ioctl(SNDCTL_DSP_SETDUPLEX)\n");
+		return -EINVAL;
+
+	case SNDCTL_DSP_GETCAPS:
+		DPRINT(DBG_IOCTL, "ioctl(SNDCTL_DSP_GETCAPS)\n");
+		return put_user(DSP_CAP_BATCH, (int *)arg);
+
+	case SNDCTL_DSP_RESET:
+		DPRINT(DBG_IOCTL, "ioctl(SNDCTL_DSP_RESET)\n");
+		/* stop DMA */
+		res = stop(devc);
+		reset_error(devc);
+		reset_buffer(devc); /* clear write buffer */
+		return res;
+
+	case SNDCTL_DSP_SPEED:
+		if (get_user(val, (int *)arg))
+			return (-EFAULT);
+		DPRINT(DBG_IOCTL, "ioctl(SNDCTL_DSP_SPEED): %d\n", val);
+		if (0 <= val) {
+			if ((res = set_format(devc, devc->format,
+					      val, devc->stereo, 0)) < 0)
+				return res;
+		}
+		return put_user(devc->speed, (int *)arg);
+
+	case SNDCTL_DSP_STEREO:
+		if (get_user(val, (int *)arg))
+			return (-EFAULT);
+		DPRINT(DBG_IOCTL, "ioctl(SNDCTL_DSP_STEREO): %s\n",
+		       val ? "stereo" : "monaural");
+		return set_format(devc, devc->format, devc->speed, val, 0);
+
+	case SNDCTL_DSP_CHANNELS:
+		if (get_user(val, (int *)arg))
+			return (-EFAULT);
+		DPRINT(DBG_IOCTL, "ioctl(SNDCTL_DSP_CHANNELS): %d\n", val);
+		if (val == 1) /* momaural */
+			return set_format(devc, devc->format, devc->speed,0,0);
+		if (val == 2) /* stereo */
+			return set_format(devc, devc->format, devc->speed,1,0);
+		return -EINVAL;
+
+	case SNDCTL_DSP_GETFMTS: /* Returns a mask */
+		DPRINT(DBG_IOCTL, "ioctl(SNDCTL_DSP_GETFMTS)\n");
+		/*
+		 * SPU2 supports only one format,
+		 * little endian signed 16 bit natively.
+		 */
+		return put_user(SUPPORTEDFMT, (int *)arg);
+		break;
+
+	case SNDCTL_DSP_SETFMT: /* Selects ONE fmt*/
+		if (get_user(val, (int *)arg))
+			return (-EFAULT);
+		DPRINT(DBG_IOCTL, "ioctl(SNDCTL_DSP_SETFMT): %x\n", val);
+		if (val != AFMT_QUERY) {
+			if ((res = set_format(devc, val, devc->speed,
+					      devc->stereo, 0)) < 0)
+				return res;
+		}
+		return put_user(devc->format, (int *)arg);
+
+	case SNDCTL_DSP_POST:
+		DPRINT(DBG_IOCTL, "ioctl(SNDCTL_DSP_POST)\n");
+		return post_buffer(devc);
+
+	case SNDCTL_DSP_GETTRIGGER:
+		DPRINT(DBG_IOCTL, "ioctl(SNDCTL_DSP_GETTRIGGER)\n");
+		/* trigger function is not supported */
+		return -EINVAL;
+
+	case SNDCTL_DSP_SETTRIGGER:
+		DPRINT(DBG_IOCTL, "ioctl(SNDCTL_DSP_SETTRIGGER)\n");
+		/* trigger function is not supported */
+		return -EINVAL;
+
+	case SNDCTL_DSP_GETOSPACE:
+		/*DPRINT(DBG_IOCTL, "ioctl(SNDCTL_DSP_GETOSPACE)\n");
+		 */
+		spin_lock_irqsave(&devc->spinlock, flags);
+		abinfo.fragsize = dest_to_src_bytes(devc, devc->iopbufsize/2);
+		abinfo.bytes = dest_to_src_bytes(devc, 
+						 devc->dmabufsize -
+						 devc->dmabufcount);
+		abinfo.fragstotal = devc->dmabufsize / (devc->iopbufsize/2);
+		abinfo.fragments = (devc->dmabufsize - devc->dmabufcount) /
+					(devc->iopbufsize/2);
+		spin_unlock_irqrestore(&devc->spinlock, flags);
+		return copy_to_user((void *)arg, &abinfo, sizeof(abinfo)) ? -EFAULT : 0;
+
+	case SNDCTL_DSP_GETISPACE:
+		DPRINT(DBG_IOCTL, "ioctl(SNDCTL_DSP_GETISPACE)\n");
+		/* SPU2 has no input device */
+		return -EINVAL;
+
+	case SNDCTL_DSP_NONBLOCK:
+		/* This command seems to be undocumented!? */
+		DPRINT(DBG_IOCTL, "ioctl(SNDCTL_DSP_NONBLOCK)\n");
+                filp->f_flags |= O_NONBLOCK;
+		return (0);
+
+	case SNDCTL_DSP_GETODELAY:
+		DPRINT(DBG_IOCTL, "ioctl(SNDCTL_DSP_GETODELAY)\n");
+		/* How many bytes are there in the buffer? */
+		if (!(filp->f_mode & FMODE_WRITE))
+			return -EINVAL;
+		spin_lock_irqsave(&devc->spinlock, flags);
+		if (devc->dmastat == DMASTAT_RUNNING) {
+		    dmabytes = devc->iopbufsize/2;
+		    if (devc->prevdmaintrvalid) {
+			dmabytes -= (192*getudelay(devc)/1000);
+		    } else {
+			dmabytes -= (192*(getudelay(devc) - 1000)/1000);
+		    }
+		} else {
+		    dmabytes = 0;
+		}
+		val = dest_to_src_bytes(devc,
+					devc->dmabufcount +
+					devc->intbufcount +
+					dmabytes);
+		val += devc->cnvbufcount;
+		DPRINT(DBG_INTR, "%s%s val=%d dma=%d int=%d iop=%d cnv=%d\n",
+		       devc->dmastat == DMASTAT_RUNNING ? "run" : "stop",
+		       devc->prevdmaintrvalid ? " " : "?",
+		       val,
+		       devc->dmabufcount,
+		       devc->intbufcount,
+		       dmabytes,
+		       devc->cnvbufcount);
+		spin_unlock_irqrestore(&devc->spinlock, flags);
+		return put_user(val, (int *)arg);
+
+	case SNDCTL_DSP_GETIPTR:
+		DPRINT(DBG_IOCTL, "ioctl(SNDCTL_DSP_GETIPTR)\n");
+		/* SPU2 has no input device */
+		return -EINVAL;
+
+	case SNDCTL_DSP_GETOPTR:
+		DPRINT(DBG_IOCTL, "ioctl(SNDCTL_DSP_GETOPTR)\n");
+		spin_lock_irqsave(&devc->spinlock, flags);
+                cinfo.bytes = dest_to_src_bytes(devc,devc->total_output_bytes);
+                cinfo.blocks = devc->total_output_bytes / (devc->iopbufsize/2);
+                cinfo.ptr = 0;
+		spin_unlock_irqrestore(&devc->spinlock, flags);
+                return copy_to_user((void *)arg, &cinfo, sizeof(cinfo)) ? -EFAULT : 0;
+
+	case SNDCTL_DSP_GETBLKSIZE:
+		DPRINT(DBG_IOCTL, "ioctl(SNDCTL_DSP_GETBLKSIZE)\n");
+		return put_user(dest_to_src_bytes(devc, devc->iopbufsize/2),
+				(int *)arg);
+
+	case SNDCTL_DSP_SETFRAGMENT:
+                if (get_user(val, (int *)arg))
+			return (-EFAULT);
+		DPRINT(DBG_IOCTL,
+		       "ioctl(SNDCTL_DSP_SETFRAGMENT) size=2^%d, max=%d\n",
+		       (val & 0xffff), ((val >> 16) & 0xffff));
+		devc->requested_fragsize = 2 << ((val & 0xffff) - 1);
+		devc->requested_maxfrags = (val >> 16) & 0xffff;
+		set_format(devc, devc->format, devc->speed, devc->stereo, 1);
+		return (0);
+
+	/*
+	 * I couldn't found these commands in OSS programers...
+	 */
+	case SNDCTL_DSP_SUBDIVIDE:
+	case SOUND_PCM_WRITE_FILTER:
+	case SNDCTL_DSP_SETSYNCRO:
+	case SOUND_PCM_READ_RATE:
+	case SOUND_PCM_READ_CHANNELS:
+	case SOUND_PCM_READ_BITS:
+	case SOUND_PCM_READ_FILTER:
+		return -EINVAL;
+
+	case PS2SDCTL_SET_INTMODE:
+	    if (get_user(val, (int *)arg))
+		return (-EFAULT);
+	    switch (val) {
+	    case PS2SD_INTMODE_NORMAL:
+		DPRINT(DBG_IOCTL, "ioctl(PS2SDCTL_SET_INTMODE): normal\n");
+		devc->flags &= ~PS2SD_UNIT_INT512;
+		break;
+	    case PS2SD_INTMODE_512:
+		DPRINT(DBG_IOCTL, "ioctl(PS2SDCTL_SET_INTMODE): 512\n");
+		devc->flags |= PS2SD_UNIT_INT512;
+		break;
+	    default:
+		return (-EINVAL);
+	    }
+	    return (0);
+
+	case PS2SDCTL_SET_SPDIFMODE:
+	    if (get_user(val, (int *)arg))
+		return (-EFAULT);
+	    if (ps2sdcall_set_coreattr(SB_SOUND_CA_SPDIF_MODE, val) < 0)
+	      return (-EIO);
+	    return (0);
+
+	case PS2SDCTL_IOP_ALLOC:
+	    {
+		ps2sd_voice_data data;
+
+		if (devc->iopmemlist == NULL)
+		    return (-EINVAL);
+		if (copy_from_user(&data, (char *)arg, sizeof(data)))
+		    return (-EFAULT);
+
+		DPRINT(DBG_COMMAND,
+		       "ioctl(PS2SDCTL_IOP_ALLOC): %d bytes...\n",
+		       data.len);
+		data.addr = ps2iopmem_alloc(devc->iopmemlist, data.len);
+		DPRINT(DBG_COMMAND,
+		       "ioctl(PS2SDCTL_IOP_ALLOC): 0x%x\n",
+		       data.addr);
+		if (data.addr == 0)
+		    return (-ENOMEM);
+		return copy_to_user((void *)arg, &data, sizeof(data)) ? -EFAULT : 0;
+	    }
+
+	case PS2SDCTL_IOP_FREE:
+	    if (devc->iopmemlist == NULL)
+		return (-EINVAL);
+	    DPRINT(DBG_COMMAND, "ioctl(PS2SDCTL_IOP_FREE): 0x%lx...\n", arg);
+	    ps2iopmem_free(devc->iopmemlist, arg);
+	    return (0);
+
+#if 0 /* This function isn't implemented yet */
+	case PS2SDCTL_IOP_GET:
+	    break;
+#endif
+	case PS2SDCTL_IOP_PUT:
+	    {
+		ps2sd_voice_data data;
+		int count;
+	    
+		if (!(devc->flags & PS2SD_UNIT_COMMANDMODE) ||
+		    devc->iopmemlist == NULL)
+		    return (-EINVAL);
+		if (copy_from_user(&data, (char *)arg, sizeof(data)) ||
+		    !access_ok(VERIFY_READ, data.data, data.len))
+		    return (-EFAULT);
+
+		data.addr = ps2iopmem_getaddr(devc->iopmemlist,
+					      data.addr, data.len);
+
+		DPRINT(DBG_COMMAND,
+		       "ioctl(PS2SDCTL_IOP_PUT): %d bytes to 0x%08x\n",
+		       data.len, data.addr);
+		if (data.addr == 0)
+			return (-EFAULT);
+
+		res = ps2sif_lock_interruptible(ps2sd_mc.lock, "iop put");
+		if (res < 0)
+		    return (res);
+		count = 0;
+		data.len = ALIGN(data.len, 64);
+		while (count < data.len) {
+		    int n;
+		    ps2sif_dmadata_t dmacmd;
+
+		    /* copy from user space to kernel space */
+		    n = MIN(data.len - count, devc->dmabufsize);
+		    if (copy_from_user(devc->dmabuf, &data.data[count], n)) {
+			ps2sif_unlock(ps2sd_mc.lock);
+			return (count ? count : -EFAULT);
+		    }
+		    ps2sif_writebackdcache(devc->dmabuf, n);
+
+		    /* copy from kernel space to IOP */
+		    dmacmd.data = (u_int)devc->dmabuf;
+		    dmacmd.addr = (u_int)(data.addr + count);
+		    dmacmd.size = n;
+		    dmacmd.mode = 0;
+		    if ((res = ps2sd_iopdma_interruptible(&dmacmd, 1)) != 0)
+			return (count ? count : res);
+		    count += n;
+		}
+		ps2sif_unlock(ps2sd_mc.lock);
+		return (count);
+	    }
+
+	case PS2SDCTL_COMMAND_INIT:
+	    DPRINT(DBG_COMMAND, "ioctl(PS2SDCTL_COMMAND_INIT): ");
+	    if (!(devc->flags & PS2SD_UNIT_EXCLUSIVE) ||
+		(devc->flags & PS2SD_UNIT_COMMANDMODE)) {
+		DPRINTK(DBG_COMMAND, "error\n");
+		return (-EINVAL);
+	    }
+	    DPRINTK(DBG_COMMAND, "ok\n");
+	    /* enter command mode */
+	    for (i = 0; i < ps2sd_nunits; i++)
+		ps2sd_units[i].flags |= PS2SD_UNIT_COMMANDMODE;
+	    return (0);
+
+	case PS2SDCTL_COMMAND_KERNEL22:
+	case PS2SDCTL_COMMAND:
+	    {
+#define CHECKIOPADDR(a, h, s)do {     \
+    if (((a) = ps2iopmem_getaddr(devc->iopmemlist, (h), (s))) == 0) \
+return (-EFAULT);    \
+} while (0)
+#define CHECKIOPADDR_ALLOWNULL(a, h, s)do {    \
+    if ((h) != 0 &&    \
+((a) = ps2iopmem_getaddr(devc->iopmemlist, (h), (s))) == 0) \
+return (-EFAULT);    \
+} while (0)
+		ps2sd_command cmd;
+
+		if (!(devc->flags & PS2SD_UNIT_COMMANDMODE))
+		    return (-EINVAL);
+		if(copy_from_user(&cmd, (char *)arg, sizeof(cmd)))
+		    return (-EFAULT);
+
+		switch (cmd.command) {
+		case PS2SDCTL_COMMAND_WRITE:
+		case PS2SDCTL_COMMAND_WRITE2:		    
+		case PS2SDCTL_COMMAND_WRITE3:
+		case PS2SDCTL_COMMAND_READ:
+		case PS2SDCTL_COMMAND_OPEN1:
+		case PS2SDCTL_COMMAND_OPEN2:
+		case PS2SDCTL_COMMAND_OPEN3:
+		case PS2SDCTL_COMMAND_OPEN4:
+		    if (devc->iopmemlist == NULL)
+			return (-EINVAL);
+		}
+
+		switch (cmd.command) {
+		case PS2SDCTL_COMMAND_OPEN1:
+		    CHECKIOPADDR(cmd.args[0], cmd.args[0], 0);
+		    CHECKIOPADDR(cmd.args[1], cmd.args[1], 0);
+		    break;
+		case PS2SDCTL_COMMAND_WRITE:
+		case PS2SDCTL_COMMAND_WRITE3:
+		case PS2SDCTL_COMMAND_OPEN2:
+		    CHECKIOPADDR(cmd.args[0], cmd.args[0], 0);
+		    break;
+		case PS2SDCTL_COMMAND_READ:
+		case PS2SDCTL_COMMAND_OPEN3:
+		    CHECKIOPADDR(cmd.args[1], cmd.args[1], 0);
+		    break;
+		case PS2SDCTL_COMMAND_WRITE2:
+		case PS2SDCTL_COMMAND_OPEN4:
+		    CHECKIOPADDR_ALLOWNULL(cmd.args[1], cmd.args[1], 0);
+		    CHECKIOPADDR_ALLOWNULL(cmd.args[2], cmd.args[2], 0);
+		    break;
+		}
+		DPRINT(DBG_COMMAND, "command: %x %x %x %x %x\n", cmd.command,
+		       cmd.args[0], cmd.args[1], cmd.args[2], cmd.args[3]);
+		res = ps2sif_lock_interruptible(ps2sd_mc.lock, "command");
+		if (res < 0)
+		    return (res);
+		res = ps2sdcall_remote(&cmd.command, &cmd.result);
+		ps2sif_unlock(ps2sd_mc.lock);
+		DPRINT(DBG_COMMAND, "command: %x res=%d, 0x%x\n", cmd.command,
+		       res, cmd.result);
+	        if (res < 0)
+		    return (-EIO);
+                return copy_to_user((void *)arg, &cmd, sizeof(cmd)) ? -EFAULT : 0;
+	    }
+
+	case PS2SDCTL_COMMAND_END:
+	    DPRINT(DBG_COMMAND, "ioctl(PS2SDCTL_COMMAND_END)\n");
+	    return ps2sd_command_end(devc);
+
+	case PS2SDCTL_CHANGE_THPRI:
+	{
+		struct task_struct *tsk;
+		int priority = (int)arg;
+		struct sched_param param = { .sched_priority = priority };
+
+		DPRINT(DBG_COMMAND, "ioctl(PS2SDCTL_CHANGE_THPRI)\n");
+		/* TBD: Check if virtual pid is correct thing to search in Linux 2.6. */
+		if ((tsk = find_task_by_vpid(ps2sd_mc.thread_id)) == NULL) {
+			printk("ps2sd: sound thread doesn't exist.\n");
+			return -1;
+		}
+		if (priority == 0) {
+			sched_setscheduler(tsk, SCHED_NORMAL, &param);
+		} else if (priority > 0) {
+			sched_setscheduler(tsk, SCHED_FIFO, &param);
+		} else {
+			return -EINVAL;
+		}
+		return (0);
+	}
+	}
+
+	return ps2sdmixer_do_ioctl(&ps2sd_mixers[0], cmd, arg);
+}
+
+static int
+ps2sd_open(struct inode *inode, struct file *filp)
+{
+	int i, minor = MINOR(inode->i_rdev);
+	struct ps2sd_unit_context *devc;
+
+	/*
+	 * we have no input device
+	 */
+	if (filp->f_mode & FMODE_READ)
+		return -ENODEV;
+
+	devc = ps2sd_lookup_by_dsp(minor);
+	if (devc == NULL) return -ENODEV;
+
+	DPRINT(DBG_INFO, "open: core%d, dmastat=%s\n",
+	       devc->core, dmastatnames[devc->dmastat]);
+
+	spin_lock_irq(&ps2sd_mc.spinlock);
+	if (devc->flags & PS2SD_UNIT_EXCLUSIVE) {
+		for (i = 0; i < ps2sd_nunits; i++) {
+			if (ps2sd_units[i].flags & PS2SD_UNIT_OPENED) {
+				spin_unlock_irq(&ps2sd_mc.spinlock);
+				return -EBUSY;
+			}
+		}
+	} else {
+		if (devc->flags & PS2SD_UNIT_OPENED) {
+			spin_unlock_irq(&ps2sd_mc.spinlock);
+			return -EBUSY;
+		}
+		for (i = 0; i < ps2sd_nunits; i++) {
+			if ((ps2sd_units[i].flags & PS2SD_UNIT_EXCLUSIVE) &&
+			    (ps2sd_units[i].flags & PS2SD_UNIT_OPENED)) {
+				spin_unlock_irq(&ps2sd_mc.spinlock);
+				return -EBUSY;
+			}
+		}
+	}
+	devc->flags = (devc->init_flags | PS2SD_UNIT_OPENED);
+	spin_unlock_irq(&ps2sd_mc.spinlock);
+
+	devc->total_output_bytes = 0;
+	filp->private_data = devc;
+
+	/*
+	 * set defaut format and fragment size
+	 */
+	devc->requested_fragsize = 0; /* no request */
+	devc->dmabufsize = ps2sd_dmabufsize;
+	devc->iopbufsize = ps2sd_iopbufsize;
+	set_format(devc, AFMT_MU_LAW, 8000, 0 /* monaural */, 1);
+	reset_buffer(devc);
+
+	/* initialize iopmem list (if any) */
+	if (devc->iopmemlist != NULL)
+		ps2iopmem_init(devc->iopmemlist);
+
+	return 0;
+}
+
+static int
+ps2sd_release(struct inode *inode, struct file *filp)
+{
+	struct ps2sd_unit_context *devc;
+
+	devc = PS2SD_DEVC(filp);
+	DPRINT(DBG_INFO, "close: core%d, dmastat=%s\n",
+	       devc->core, dmastatnames[devc->dmastat]);
+	sync_buffer(devc);
+
+	if (devc->flags & PS2SD_UNIT_COMMANDMODE)
+		ps2sd_command_end(devc);
+
+	/* free iopmem (if any) */
+	if (devc->iopmemlist != NULL)
+		ps2iopmem_end(devc->iopmemlist);
+
+	spin_lock_irq(&ps2sd_mc.spinlock);
+	devc->flags &= ~PS2SD_UNIT_OPENED;
+	spin_unlock_irq(&ps2sd_mc.spinlock);
+
+	return 0;
+}
+
+struct ps2sd_unit_context *
+ps2sd_lookup_by_dsp(int dsp)
+{
+	int i;
+	for (i = 0; i < ps2sd_nunits; i++) {
+		if (ps2sd_units[i].dsp == dsp)
+			return &ps2sd_units[i];
+	}
+	return NULL;
+}
+
+struct ps2sd_unit_context *
+ps2sd_lookup_by_dmach(int dmach)
+{
+	int i;
+	for (i = 0; i < ps2sd_nunits; i++) {
+		if (ps2sd_units[i].dmach == dmach &&
+		    (ps2sd_units[i].flags & PS2SD_UNIT_OPENED))
+			return &ps2sd_units[i];
+	}
+	for (i = 0; i < ps2sd_nunits; i++) {
+		if (ps2sd_units[i].dmach == dmach)
+			return &ps2sd_units[i];
+	}
+	return NULL;
+}
+
+struct ps2sd_mixer_context *
+ps2sd_lookup_mixer(int mixer)
+{
+	int i;
+	for (i = 0; i < ps2sd_nmixers; i++) {
+		if (ps2sd_mixers[i].mixer == mixer)
+			return &ps2sd_mixers[i];
+	}
+	return NULL;
+}
+
+#ifdef PS2SD_USE_THREAD
+static int
+ps2sd_thread(void *arg)
+{
+	int status, i;
+
+	/* get rid of all our resources related to user space */
+	daemonize("ps2sd thread");
+
+	/* notify we are running */
+	complete(&ps2sd_mc.ack_comp);
+
+	while (1) {
+		if (down_interruptible(&ps2sd_mc.intr_sem))
+			goto out;
+		DPRINT(DBG_INTR, "DMA interrupt service thread\n");
+	  
+		spin_lock_irq(&ps2sd_mc.spinlock);
+		status = ps2sd_mc.intr_status;
+		ps2sd_mc.intr_status = 0;
+		spin_unlock_irq(&ps2sd_mc.spinlock);
+
+		for (i = 0; i < 32; i++)
+			if (status & (1 << i)) {
+				struct ps2sd_unit_context *devc;
+				unsigned long flags;
+
+				devc = ps2sd_lookup_by_dmach(i);
+
+				if (devc != NULL) {
+					spin_lock_irqsave(&devc->spinlock, flags);
+					ps2sd_dmaintr(NULL, i);
+					spin_unlock_irqrestore(&devc->spinlock, flags);
+				} else {
+					DPRINT(DBG_DIAG, "ignore DMA interrupt %d\n", dmach);
+				}
+			}
+		DPRINT(DBG_INTR, "DMA interrupt service thread...sleep\n");
+	}
+
+ out:
+	DPRINT(DBG_INFO, "the thread is exiting...\n");
+
+	/* notify we are exiting */
+	complete(&ps2sd_mc.ack_comp);
+
+	return (0);
+}
+
+static int
+ps2sd_intr(void* argx, int dmach)
+{
+
+	spin_lock(&ps2sd_mc.spinlock);
+	ps2sd_mc.intr_status |= (1 << dmach);
+	spin_unlock(&ps2sd_mc.spinlock);
+	DPRINT(DBG_INTR, "DMA interrupt %d\n", dmach);
+#ifdef PS2SD_USE_THREAD
+	up(&ps2sd_mc.intr_sem);
+#endif
+
+	return (0);
+}
+#endif /* PS2SD_USE_THREAD */
+
+static int
+ps2sd_dmaintr(void* argx, int dmach)
+{
+	int i;
+	struct ps2sd_unit_context *devc;
+	ps2sif_dmadata_t dmacmd;
+#ifdef PS2SD_DMA_ADDR_CHECK
+	unsigned int dmamode, maddr;
+#endif
+
+	if ((devc = ps2sd_lookup_by_dmach(dmach)) == NULL) {
+		DPRINT(DBG_DIAG, "ignore DMA interrupt %d\n", dmach);
+		return (0);
+	}
+	devc->total_output_bytes += devc->fg->size;
+	devc->intr_count++;
+
+#ifdef PS2SD_DEBUG
+	if (ps2sd_debug & DBG_INTR) {
+	    int delay;
+	    delay = getudelay(devc);
+	    devc->prevdmaintr = getcounter();
+	    DPRINT(DBG_INTR, "DMA interrupt %d (+%d usec)\n",
+		   dmach, delay);
+	} else
+#endif
+	devc->prevdmaintr = getcounter();
+	devc->prevdmaintrvalid = 1;
+	if (devc->dmastat == DMASTAT_STOP) {
+		if (devc->flags & PS2SD_UNIT_COMMANDMODE)
+			DPRINT(DBG_DIAG, "ignore DMA interrupt %d\n", dmach);
+			return (0);
+		/*
+		 * stray interrupt
+		 * try to stop the DMA again
+		 */
+		printk(KERN_CRIT "ps2sd: core%d stray interrupt\n",
+		       devc->core);
+		setdmastate(devc, DMASTAT_STOP, DMASTAT_STOPPING,
+			    "stray interrupt");
+		goto stopdma;
+	}
+
+	if (devc->dmastat == DMASTAT_STOPREQ) {
+		/*
+		 * setdmastate() must always succeed because we are in
+		 * interrupt and no one interrupt us.
+		 */
+#if 0
+		setdmastate(devc, DMASTAT_STOPREQ, DMASTAT_STOPPING,
+			    "stop by request");
+		goto stopdma;
+#else
+		/*
+		 * force it to be underflow instead of stopping DMA
+		 * immediately so that it will clear page0 on IOP for
+		 * next session.
+		 */
+		setdmastate(devc, DMASTAT_STOPREQ, DMASTAT_RUNNING,
+			    "stop by request, dmabufcount -> 0");
+		devc->dmabufcount = 0;
+#endif
+	}
+
+	if (devc->dmastat != DMASTAT_RUNNING) {
+		/*
+		 * stop sequence might be in progress...
+		 */
+		return (0);
+	}
+
+	if (devc->bg->dmaid != 0) {
+		if (0 <= ps2sif_dmastat(devc->bg->dmaid)) {
+			/* previous DMA operation does not finish */
+			DPRINT(DBG_DIAG, "DMA %d does not finish\n",
+			       devc->bg->dmaid);
+			/*
+			 * setdmastate() must always succeed because we are in
+			 * interrupt and no one interrupt us.
+			 */
+			setdmastate(devc, DMASTAT_RUNNING, DMASTAT_STOPPING,
+				    "previous DMA session is not completed");
+			goto stopdma;
+		} else {
+			/* previous DMA operation completed */
+			unsigned long flags;
+
+			spin_lock_irqsave(&devc->spinlock, flags);
+			devc->dmabufhead += devc->bg->size;
+			devc->dmabufhead %= devc->dmabufsize;
+			DPRINT(DBG_INTR | DBG_VERBOSE, "dmabufcount = %d-%d\n",
+			       devc->dmabufcount, devc->bg->size);
+			devc->dmabufcount -= devc->bg->size;
+			wake_up(&devc->write_wq);
+			spin_unlock_irqrestore(&devc->spinlock, flags);
+		}
+	}
+
+#ifdef PS2SD_DMA_ADDR_CHECK
+	/*
+	 * check DMA address register on IOP
+	 * if it has the same value as the address expected,
+	 * that's ok.
+	 */
+	if (ps2sdcall_get_reg(SB_SOUND_REG_DMAMOD(devc->core), &dmamode) < 0 ||
+	    ps2sdcall_get_reg(SB_SOUND_REG_MADR(devc->core), &maddr) < 0) {
+		/* SBIOS failed */
+		SWAP(devc->fg, devc->bg);
+	} else {
+		if (dmamode) {
+			DPRINT(DBG_INTR | DBG_VERBOSE,
+			       "dma%d reg=%x devc->bg->iopaddr=%lx\n",
+			       devc->dmach, maddr, devc->bg->iopaddr);
+			if (devc->bg->iopaddr <= maddr &&
+			    maddr < devc->bg->iopaddr + devc->iopbufsize / 2) {
+				/* ok */
+				SWAP(devc->fg, devc->bg);
+			} else {
+		 		DPRINT(DBG_INTR, "phase error\n");
+				devc->phaseerr++;
+			}
+		}
+	}
+#else
+	SWAP(devc->fg, devc->bg);
+#endif
+
+	if ((devc->dmabufunderflow == 0 && devc->dmabufcount < devc->bg->size)
+	    || devc->dmabufunderflow != 0) {
+		unsigned char *head = 0;
+		int n;
+
+		if (devc->dmabufunderflow == 0 &&
+		    devc->dmabufcount < 0)
+			devc->dmabufunderflow = 1;
+
+		switch (devc->dmabufunderflow) {
+		case 0:
+			/*
+			 * buffer underflow
+			 */
+			head = &devc->dmabuf[devc->dmabufhead + 
+					     devc->dmabufcount];
+			n = devc->bg->size - devc->dmabufcount;
+			DPRINT(DBG_INFO, "dma%d buffer underflow %d+%dbytes\n",
+			       devc->dmach, devc->dmabufcount, n);
+			memset(head, 0, n);
+			ps2sif_writebackdcache(head, n);
+#ifdef PS2SD_FADEINOUT
+			if (BUFUNIT <= devc->dmabufcount) {
+			    int i, j;
+			    short *p;
+			    p = (short*)&devc->dmabuf[devc->dmabufhead +
+						      devc->dmabufcount -
+						      BUFUNIT];
+			    DPRINT(DBG_INFO, "dma%d: fade out %p~",
+				   devc->dmach, p);
+			    for (i = 0; i < 2; i++) {
+				for (j = INTRSIZE/sizeof(*p)-1; 0 <= j; j--) {
+				    int r = 0x10000 * j/(INTRSIZE/sizeof(*p));
+				    *p = (((*p * r) >> 16) & 0xffff);
+				    p++;
+				}
+			    }
+			    DPRINTK(DBG_INFO, "%p\n", p);
+			    ps2sif_writebackdcache(p - BUFUNIT/sizeof(*p),
+						   BUFUNIT);
+			}
+#endif
+			devc->dmabufunderflow = 1;
+			devc->dmabufcount = devc->bg->size;
+			break;
+		case 1:
+		case 2:
+			/*
+			 * buffer underflow have been detected but we have
+			 * the last fragment to output on IOP.
+			 */
+			head = &devc->dmabuf[devc->dmabufhead];
+			n = devc->bg->size;
+			devc->dmabufunderflow++;
+			memset(head, 0, n);
+			ps2sif_writebackdcache(head, n);
+			devc->dmabufcount = n;
+			break;
+		case 3:
+			setdmastate(devc, DMASTAT_RUNNING, DMASTAT_STOPPING,
+				    "underflow 3");
+			goto stopdma;
+		default: /* XXX, This should not occur. */
+			setdmastate(devc, DMASTAT_RUNNING, DMASTAT_STOPPING,
+				    "underflow sequence error");
+			goto stopdma;
+		}
+	}
+
+	dmacmd.data = (u_int)&devc->dmabuf[devc->dmabufhead];
+	dmacmd.addr = (u_int)devc->bg->iopaddr;
+	dmacmd.size = devc->bg->size;
+	dmacmd.mode = 0;
+
+#ifdef PS2SD_DEBUG
+	if (devc->dmabufunderflow)
+		DPRINT(DBG_INFO, "ps2sif_setdma(%x->%x  %d bytes)\n",
+		       dmacmd.data, dmacmd.addr, dmacmd.size);
+#endif
+	DPRINT(DBG_INTR | DBG_VERBOSE, "ps2sif_setdma(%x->%x  %d bytes) ",
+	       dmacmd.data, dmacmd.addr, dmacmd.size);
+
+	for (i = 0; i < 20; i++) {
+		if ((devc->bg->dmaid = ps2sif_setdma(&dmacmd, 1)) != 0)
+			break;
+		udelay(50);
+	}
+#ifdef PS2SD_DEBUG
+	if (i)
+		DPRINT(DBG_DIAG, "dmaintr: setdma() retry %d times\n", i);
+#endif
+	if (devc->bg->dmaid == 0) {
+		printk("dmaintr: ps2sif_setdma() failed\n");
+		setdmastate(devc, DMASTAT_RUNNING, DMASTAT_STOPPING,
+			    "setdma failed. (DMA queue might be full)");
+		goto stopdma;
+	}
+	DPRINTK(DBG_INTR | DBG_VERBOSE, "= %d\n", devc->bg->dmaid);
+	
+	return 0;
+
+ stopdma:
+	/* mute */
+	ps2sd_mute(devc);
+
+	/*
+	 * get the lock and invoke stop sequence
+	 */
+	del_timer(&devc->timer);
+	devc->lockq.routine = stop_sequence0;
+	devc->lockq.arg = devc;
+	devc->lockq.name = "stop sequence";
+	if (ps2sif_lowlevel_lock(ps2sd_mc.lock, &devc->lockq,
+				 PS2SIF_LOCK_QUEUING) == 0) {
+		DPRINT(DBG_DMASTAT, "core%d lock succeeded\n", devc->core);
+	} else {
+		DPRINT(DBG_DMASTAT, "core%d lock deferred\n", devc->core);
+	}
+
+	return 0;
+}
+
+static int
+ps2sd_attach_unit(struct ps2sd_unit_context *devc, int core, int dmach,
+		  struct ps2sd_mixer_context *mixer, int init_flags)
+{
+	int res, resiop;
+	ps2sif_dmadata_t dmacmd;
+
+	devc->init = 0;
+
+	devc->flags = devc->init_flags = init_flags;
+	devc->core = core;
+	devc->dmach = dmach;
+	devc->dmabuf = NULL;
+	devc->cnvbuf = NULL;
+	devc->intbuf = NULL;
+	devc->iopbuf = 0;
+	init_waitqueue_head(&devc->write_wq);
+	init_waitqueue_head(&devc->dmastat_wq);
+	spin_lock_init(&devc->spinlock);
+	devc->dmastat = DMASTAT_STOP;
+	ps2sif_lockqueueinit(&devc->lockq);
+#ifdef PS2SD_DEBUG_DMA
+	if (devc->dmabufsize < PS2SD_DEBUG_DMA_BUFSIZE)
+		devc->dmabufsize = PS2SD_DEBUG_DMA_BUFSIZE;
+	if (devc->iopbufsize < PS2SD_DEBUG_IOP_BUFSIZE)
+		devc->iopbufsize = PS2SD_DEBUG_IOP_BUFSIZE;
+#endif
+
+	/* initialize timer */
+	init_timer(&devc->timer);
+	devc->timer.function = ps2sd_timer;
+	devc->timer.data = (long)devc;
+	devc->init |= PS2SD_INIT_TIMER;
+
+	/* set format, sampling rate and stereo  */
+	set_format(devc, SPU2FMT, SPU2SPEED, 1, 1);
+
+	/* never fail to get the lock */
+	ps2sif_lock(ps2sd_mc.lock, "attach unit");
+
+	if(init_flags & PS2SD_UNIT_NOPCM)
+		goto allocated;
+
+	/*
+	 * allocate DMA buffer
+	 */
+	if(init_flags & PS2SD_UNIT_EXCLUSIVE) {
+		/*
+		 * XXX, You can use another unit's buffer.
+		 */
+		devc->iopbuf = ps2sd_units[0].iopbuf;
+		devc->dmabuf = ps2sd_units[0].dmabuf;
+		devc->cnvbuf = ps2sd_units[0].cnvbuf;
+		devc->intbuf = ps2sd_units[0].intbuf;
+		goto allocated;
+	}
+
+	if ((res = alloc_buffer(devc)) < 0)
+		goto unlock_and_return;
+
+	/*
+	 * clear IOP buffer
+	 */
+	memset(devc->dmabuf, 0, ps2sd_max_iopbufsize);
+	dmacmd.data = (u_int)devc->dmabuf;
+	dmacmd.addr = (u_int)devc->iopbuf;
+	dmacmd.size = ps2sd_max_iopbufsize;
+	dmacmd.mode = 0;
+
+	DPRINT(DBG_INFO, "clear IOP buffer\n");
+	DPRINT(DBG_INFO, "sd_iopdma(%x->%x  %d bytes)\n", 
+	       dmacmd.data, dmacmd.addr, dmacmd.size);
+	ps2sif_writebackdcache(devc->dmabuf, dmacmd.size);
+	ps2sd_iopdma(&dmacmd, 1);
+	DPRINTK(DBG_INFO, "done\n");
+
+	/*
+	 * clear ZERO buffer
+	 */
+	dmacmd.data = (u_int)devc->dmabuf;
+	dmacmd.addr = (u_int)ps2sd_mc.iopzero;
+	dmacmd.size = PS2SD_SPU2PCMBUFSIZE;
+	dmacmd.mode = 0;
+
+	DPRINT(DBG_INFO, "clear IOP ZERO buffer\n");
+	DPRINT(DBG_INFO, "sd_iopdma(%x->%x  %d bytes)\n", 
+	       dmacmd.data, dmacmd.addr, dmacmd.size);
+	ps2sif_writebackdcache(devc->dmabuf, dmacmd.size);
+	ps2sd_iopdma(&dmacmd, 1);
+	DPRINTK(DBG_INFO, "done\n");
+
+	while(1) {
+	  volatile int i;
+	  res = ps2sdcall_trans_stat(devc->core, 0, &resiop);
+	  if (res < 0) {
+	    DPRINT(DBG_INFO, "core%d: ps2sdcall_trans_stat res=%d\n",
+		   devc->core, res);
+	    break;
+	  }
+	  if (resiop == 0 ) break;
+	  for (i = 0; i < 0x200000; i++) {
+	    /* XXX, busy wait */
+	  }
+	}
+
+ allocated:
+	/*
+	 * clear PCM buffer
+	 */
+	res = ps2sdcall_trans(devc->core,
+			      SD_TRANS_MODE_WRITE|
+			      SD_BLOCK_MEM_DRY|
+			      SD_BLOCK_ONESHOT,
+			      ps2sd_units[0].iopbuf,
+			      MIN(ps2sd_max_iopbufsize, 4096), 0, &resiop);
+	DPRINT(DBG_DIAG,
+	       "core%d: clear PCM buffer %lx %dbytes res=%d resiop=%d\n", 
+	       devc->core, ps2sd_units[0].iopbuf,
+	       MIN(ps2sd_max_iopbufsize, 4096), res, resiop);
+	if (res < 0)
+		goto unlock_and_return;
+
+	/*
+	 * install DMA callback routine
+	 */
+	res = ps2sdcall_trans_callback(dmach, ps2sd_intr, NULL,
+				       NULL, NULL, &resiop);
+	DPRINT(DBG_INFO, "core%d: ps2sdcall_trans_callback res=%d resiop=%x\n",
+	       core, res, resiop);
+	if (res < 0) {
+		printk(KERN_CRIT "ps2sd: SetTransCallback failed\n");
+		goto unlock_and_return;
+	}
+	devc->init |= PS2SD_INIT_DMACALLBACK;
+
+	/*
+	 * register device
+	 */
+	devc->dsp = register_sound_dsp(&ps2sd_dsp_fops, -1);
+	if (devc->dsp < 0) {
+		printk(KERN_ERR "ps2sd: Can't install sound device\n");
+	}
+	DPRINT(DBG_INFO, "core%d: register_sound_dsp() = %d\n",
+	       core, devc->dsp);
+	devc->init |= PS2SD_INIT_REGDEV;
+	
+	/*
+	 * initialize mixer stuff
+	 */
+	ps2sd_mute(devc);
+	devc->mixer_main.scale = 0x3fff;
+	devc->mixer_main.volr = 0;
+	devc->mixer_main.voll = 0;
+	devc->mixer_main.regr = SB_SOUND_REG_MVOLR(core);
+	devc->mixer_main.regl = SB_SOUND_REG_MVOLL(core);
+	devc->mixer_main.mixer = mixer;
+
+	devc->mixer_pcm.scale = 0x7fff;
+	devc->mixer_pcm.volr = 0;
+	devc->mixer_pcm.voll = 0;
+	devc->mixer_pcm.regr = SB_SOUND_REG_BVOLR(core);
+	devc->mixer_pcm.regl = SB_SOUND_REG_BVOLL(core);
+	devc->mixer_pcm.mixer = mixer;
+
+	devc->mixer_extrn.scale = 0x7fff;
+	devc->mixer_extrn.volr = 0;
+	devc->mixer_extrn.voll = 0;
+	devc->mixer_extrn.regr = SB_SOUND_REG_AVOLR(core);
+	devc->mixer_extrn.regl = SB_SOUND_REG_AVOLL(core);
+	devc->mixer_extrn.mixer = mixer;
+
+	res = 0;
+
+ unlock_and_return:
+	ps2sif_unlock(ps2sd_mc.lock);
+
+	return res;
+}
+
+static void
+ps2sd_detach_unit(struct ps2sd_unit_context *devc)
+{
+	int res, resiop;
+
+	/*
+	 * unregister device entry
+	 */
+	if (devc->init & PS2SD_INIT_REGDEV)
+		unregister_sound_dsp(devc->dsp);
+	devc->init &= ~PS2SD_INIT_REGDEV;
+
+	/*
+	 * delete timer
+	 */
+	if (devc->init & PS2SD_INIT_TIMER)
+		del_timer(&devc->timer);
+	devc->init &= ~PS2SD_INIT_TIMER;
+
+	/*
+	 * uninstall DMA callback routine
+	 */
+	if (devc->init & PS2SD_INIT_DMACALLBACK) {
+		/* never fail to get the lock */
+		ps2sif_lock(ps2sd_mc.lock, "detach unit");
+		res = ps2sdcall_trans_callback(devc->dmach, NULL, NULL,
+					       NULL, NULL, &resiop);
+		ps2sif_unlock(ps2sd_mc.lock);
+		if (res < 0)
+			printk(KERN_CRIT "ps2sd: SetTransCallback failed\n");
+	}
+	devc->init &= ~PS2SD_INIT_DMACALLBACK;
+
+	/*
+	 * free buffers
+	 */
+	free_buffer(devc);
+
+	devc->init = 0;
+}
+
+/*
+ * adjust buffer size
+ */
+static int
+adjust_bufsize(int size)
+{
+	if (size < PS2SD_MINIMUM_BUFSIZE)
+		return PS2SD_MINIMUM_BUFSIZE;
+	return ALIGN(size, BUFUNIT);
+}
+
+static int
+alloc_buffer(struct ps2sd_unit_context *devc)
+{
+	int res;
+
+	if ((res = free_buffer(devc)) < 0) return res;
+
+	devc->init |= PS2SD_INIT_BUFFERALLOC;
+	res = ps2sif_lock_interruptible(ps2sd_mc.lock, "alloc buffer");
+	if (res < 0)
+		return res;
+
+	/*
+	 * allocate buffer on IOP
+	 */
+	devc->iopbuf = (long)ps2sif_allociopheap(ps2sd_max_iopbufsize);
+	if(devc->iopbuf == 0) {
+		printk(KERN_ERR "ps2sd: can't alloc iop heap\n");
+		return -EIO;
+	}
+	DPRINT(DBG_INFO, "core%d: allocate %d bytes on IOP 0x%lx\n",
+	       devc->core, ps2sd_max_iopbufsize, devc->iopbuf);
+
+	ps2sif_unlock(ps2sd_mc.lock);
+
+	/*
+	 * allocate buffer on main memory
+	 */
+	devc->dmabuf = kmalloc(ps2sd_max_dmabufsize, GFP_KERNEL);
+	if (devc->dmabuf == NULL) {
+		printk(KERN_ERR "ps2sd: can't alloc DMA buffer\n");
+		return -ENOMEM;
+	}
+	DPRINT(DBG_INFO, "core%d: allocate %d bytes, 0x%p for DMA\n",
+	       devc->core, ps2sd_max_dmabufsize, devc->dmabuf);
+
+	devc->cnvbuf = kmalloc(CNVBUFSIZE, GFP_KERNEL);
+	if (devc->cnvbuf == NULL) {
+		printk(KERN_ERR "ps2sd: can't alloc converting buffer\n");
+		return -ENOMEM;
+	}
+	DPRINT(DBG_INFO, "core%d: allocate %d bytes, 0x%p for conversion\n",
+	       devc->core,  CNVBUFSIZE, devc->cnvbuf);
+
+	devc->intbuf = kmalloc(INTBUFSIZE, GFP_KERNEL);
+	if (devc->intbuf == NULL) {
+		printk(KERN_ERR "ps2sd: can't alloc converting buffer\n");
+		return -ENOMEM;
+	}
+	DPRINT(DBG_INFO, "core%d: allocate %d bytes, 0x%p for conversion\n",
+	       devc->core,  INTBUFSIZE, devc->intbuf);
+
+	return reset_buffer(devc);
+}
+
+static void fetch_s8(struct ps2sd_sample *s, unsigned char *addr)
+{
+	char *p = (char *)addr;
+	s->r = (int)*p++ * 256;
+	s->l = (int)*p++ * 256;
+}
+
+static void fetch_s8_m(struct ps2sd_sample *s, unsigned char *addr)
+{
+	char *p = (char *)addr;
+	s->r = (int)*p * 256;
+	s->l = (int)*p * 256;
+}
+
+static void fetch_u8(struct ps2sd_sample *s, unsigned char *addr)
+{
+	char *p = (u_char *)addr;
+	s->r = ((u_int)*p++ * 256) - 0x8000;
+	s->l = ((u_int)*p++ * 256) - 0x8000;
+}
+
+static void fetch_u8_m(struct ps2sd_sample *s, unsigned char *addr)
+{
+	char *p = (u_char *)addr;
+	s->r = ((u_int)*p * 256) - 0x8000;
+	s->l = ((u_int)*p * 256) - 0x8000;
+}
+
+static void fetch_s16le(struct ps2sd_sample *s, unsigned char *addr)
+{
+	*s = *(struct ps2sd_sample *)addr;
+}
+
+static void fetch_s16le_m(struct ps2sd_sample *s, unsigned char *addr)
+{
+	short *p = (short*)addr;
+	s->r = s->l = *p;
+}
+
+static void fetch_s16be(struct ps2sd_sample *s, unsigned char *addr)
+{
+	struct ps2sd_sample *p = (struct ps2sd_sample *)addr;
+	s->r = __swab16p(&p->r);
+	s->l = __swab16p(&p->l);
+}
+
+static void fetch_s16be_m(struct ps2sd_sample *s, unsigned char *addr)
+{
+	short *p = (short*)addr;
+	s->r = s->l = __swab16p(p);
+}
+
+static void fetch_u16le(struct ps2sd_sample *s, unsigned char *addr)
+{
+	struct ps2sd_sample *p = (struct ps2sd_sample *)addr;
+	s->r = p->r - 0x8000;
+	s->l = p->l - 0x8000;
+}
+
+static void fetch_u16le_m(struct ps2sd_sample *s, unsigned char *addr)
+{
+	short *p = (short*)addr;
+	s->r = s->l = *p - 0x8000;
+}
+
+static void fetch_u16be(struct ps2sd_sample *s, unsigned char *addr)
+{
+	struct ps2sd_sample *p = (struct ps2sd_sample *)addr;
+	s->r = __swab16p(&p->r) - 0x8000;
+	s->l = __swab16p(&p->l) - 0x8000;
+}
+
+static void fetch_u16be_m(struct ps2sd_sample *s, unsigned char *addr)
+{
+	short *p = (short*)addr;
+	s->r = s->l = __swab16p(p) - 0x8000;
+}
+
+static void fetch_mulaw(struct ps2sd_sample *s, unsigned char *addr)
+{
+	extern short ps2sd_mulaw2liner16[];
+	unsigned char *p = (unsigned char *)addr;
+	s->r = ps2sd_mulaw2liner16[(int)*p++];
+	s->l = ps2sd_mulaw2liner16[(int)*p++ * 256];
+}
+
+static void fetch_mulaw_m(struct ps2sd_sample *s, unsigned char *addr)
+{
+	extern short ps2sd_mulaw2liner16[];
+	unsigned char *p = (unsigned char *)addr;
+	s->r = ps2sd_mulaw2liner16[(int)*p];
+	s->l = ps2sd_mulaw2liner16[(int)*p];
+}
+
+static int
+set_format(struct ps2sd_unit_context *devc, int format, int speed, int stereo, int force)
+{
+	int res;
+	char *formatname = "???";
+
+	/* Adjust speed value */
+	speed = ALIGN(speed, 25);
+	if (speed < 4000) speed = 4000;
+	if (SPU2SPEED < speed) speed = SPU2SPEED;
+
+	/* Just return, if specified value are the same as current settings. */
+	if (!force &&
+	    devc->format == format &&
+	    devc->speed == speed &&
+	    devc->stereo == stereo)
+		return 0;
+
+	/* Ensure to stop any DMA operation and clear the buffer. */
+	if (devc->dmastat != DMASTAT_STOP)
+		if ((res = stop(devc)) < 0)
+			return res;
+	reset_error(devc);
+	reset_buffer(devc);
+
+	devc->format = format;
+	devc->speed = speed;
+	devc->stereo = stereo;
+
+	/*
+	 * translation paramaters
+	 */
+	if (format == SPU2FMT && speed == SPU2SPEED && stereo) {
+		devc->samplesize = 4;
+		devc->noconversion = 1;
+		formatname = "SPU2 native";
+	} else {
+		devc->noconversion = 0;
+		devc->cnvsrcrate = speed/25 * 2;
+		devc->cnvdstrate = SPU2SPEED/25 * 2;
+		devc->cnvd = devc->cnvdstrate / 2;
+
+		switch (format) {
+		case AFMT_S8:
+			devc->samplesize = stereo ? 2 : 1;
+			devc->fetch = stereo ? fetch_s8 : fetch_s8_m;
+			formatname = "8bit signed";
+			break;
+		case AFMT_U8:
+			devc->samplesize = stereo ? 2 : 1;
+			devc->fetch = stereo ? fetch_u8 : fetch_u8_m;
+			formatname = "8bit unsigned";
+			break;
+		case AFMT_S16_LE:
+			devc->samplesize = stereo ? 4 : 2;
+			devc->fetch = stereo ? fetch_s16le : fetch_s16le_m;
+			formatname = "16bit signed little endian";
+			break;
+		case AFMT_S16_BE:
+			devc->samplesize = stereo ? 4 : 2;
+			devc->fetch = stereo ? fetch_s16be : fetch_s16be_m;
+			formatname = "16bit signed big endian";
+			break;
+		case AFMT_U16_LE:
+			devc->samplesize = stereo ? 4 : 2;
+			devc->fetch = stereo ? fetch_u16le : fetch_u16le_m;
+			formatname = "16bit unsigned little endian";
+			break;
+		case AFMT_U16_BE:
+			devc->samplesize = stereo ? 4 : 2;
+			devc->fetch = stereo ? fetch_u16be : fetch_u16be_m;
+			formatname = "16bit unsigned big endian";
+			break;
+		case AFMT_MU_LAW:
+			devc->samplesize = stereo ? 2 : 1;
+			devc->fetch = stereo ? fetch_mulaw : fetch_mulaw_m;
+			formatname = "logarithmic mu-Law";
+			break;
+		case AFMT_A_LAW:
+		case AFMT_IMA_ADPCM:
+		case AFMT_MPEG:
+			devc->samplesize = 1; /* XXX */
+			return -EINVAL;
+		}
+	}
+
+	/*
+	 * buffer size
+	 */
+	if (devc->requested_fragsize == 0) {
+		devc->dmabufsize = ps2sd_dmabufsize;
+		devc->iopbufsize = ps2sd_iopbufsize;
+	} else {
+		int fragsize, maxfrags;
+		unsigned long flags;
+
+		fragsize = src_to_dest_bytes(devc, devc->requested_fragsize);
+		fragsize = ALIGN(fragsize, BUFUNIT);
+		if (fragsize < BUFUNIT)
+			fragsize = BUFUNIT;
+		if (ps2sd_max_iopbufsize/2 < fragsize)
+			fragsize = ps2sd_max_iopbufsize/2;
+		maxfrags = devc->requested_maxfrags;
+		if (maxfrags < 2)
+			maxfrags = 2;
+		if (ps2sd_max_dmabufsize/fragsize < maxfrags)
+			maxfrags = ps2sd_max_dmabufsize/fragsize;
+		DPRINT(DBG_INFO, "fragment  req=%dx%d  set=%dx%d\n",
+		       devc->requested_fragsize, devc->requested_maxfrags,
+		       dest_to_src_bytes(devc, fragsize), maxfrags);
+		spin_lock_irqsave(&devc->spinlock, flags);
+		devc->iopbufsize = fragsize * 2;
+		devc->dmabufsize = fragsize * maxfrags;
+		reset_buffer(devc);
+		spin_unlock_irqrestore(&devc->spinlock, flags);
+	}
+
+	DPRINT(DBG_INFO,
+	       "set format=%s speed=%d %s samplesize=%d bufsize=%d(%d)\n",
+	       formatname, devc->speed, devc->stereo ? "stereo" : "monaural",
+	       devc->samplesize, devc->iopbufsize, devc->dmabufsize);
+
+	return 0;
+}
+
+static int
+reset_buffer(struct ps2sd_unit_context *devc)
+{
+	int i;
+
+	/*
+	 * initialize IOP buffer context
+	 */
+	for (i = 0; i < 2; i++) {
+		devc->iopbufs[i].size = devc->iopbufsize/2;
+		devc->iopbufs[i].iopaddr =
+			devc->iopbuf + devc->iopbufs[i].size * i;
+		devc->iopbufs[i].dmaid = 0;
+	}
+	devc->fg = &devc->iopbufs[0];
+	devc->bg = &devc->iopbufs[1];
+
+	/*
+	 * initialize buffer context
+	 */
+	devc->dmabufcount = 0;
+	devc->dmabufhead = 0;
+	devc->dmabuftail = 0;
+	devc->dmabufunderflow = 0;
+	devc->cnvbufcount = 0;
+	devc->cnvbufhead = 0;
+	devc->cnvbuftail = 0;
+	devc->intbufcount = 0;
+
+	return 0;
+}
+
+static int
+free_buffer(struct ps2sd_unit_context *devc)
+{
+
+	if (!(devc->init & PS2SD_INIT_BUFFERALLOC))
+		return (0);
+
+	/* never fail to get the lock */
+	ps2sif_lock(ps2sd_mc.lock, "free buffer");
+
+	if (devc->iopbuf != 0) {
+		ps2sif_freeiopheap(devc->iopbuf);
+		DPRINT(DBG_INFO, "core%d: free %d bytes on IOP 0x%lx\n",
+		       devc->core,  devc->iopbufsize, devc->iopbuf);
+		devc->iopbuf = -1;
+	}
+	ps2sif_unlock(ps2sd_mc.lock);
+	if (devc->dmabuf != NULL) {
+		kfree(devc->dmabuf);
+		DPRINT(DBG_INFO, "core%d: free %d bytes, 0x%p for DMA\n",
+		       devc->core,  devc->dmabufsize, devc->dmabuf);
+		devc->dmabuf = NULL;
+		devc->dmabufcount = 0;
+	}
+	if (devc->cnvbuf != NULL) {
+		kfree(devc->cnvbuf);
+		DPRINT(DBG_INFO, "core%d: free %d bytes, 0x%p for conversion\n",
+		       devc->core,  CNVBUFSIZE, devc->cnvbuf);
+		devc->cnvbuf = NULL;
+	}
+	if (devc->intbuf != NULL) {
+		kfree(devc->intbuf);
+		DPRINT(DBG_INFO, "core%d: free %d bytes, 0x%p for conversion\n",
+		       devc->core,  INTBUFSIZE, devc->intbuf);
+		devc->intbuf = NULL;
+	}
+	devc->init &= ~PS2SD_INIT_BUFFERALLOC;
+
+	return (0);
+}
+
+static void
+ps2sd_setup(void)
+{
+	DPRINT(DBG_VERBOSE, "initialize\n");
+
+	/* XXX, nothing to do... */
+}
+
+static int
+ps2sd_command_end(struct ps2sd_unit_context *devc)
+{
+	int i, res;
+	ps2sd_command cmd;
+
+	DPRINT(DBG_COMMAND, "ps2sd_command_end: ");
+	if (!(devc->flags & PS2SD_UNIT_COMMANDMODE)) {
+		DPRINTK(DBG_COMMAND, "not in command mode\n");
+		return (-EINVAL);
+	}
+	DPRINTK(DBG_COMMAND, "exit command mode\n");
+	DPRINT(DBG_COMMAND, "call PS2SDCTL_COMMAND_QUIT\n");
+	res = ps2sif_lock_interruptible(ps2sd_mc.lock, "command_end");
+	if (res < 0)
+		return (-EBUSY);
+	cmd.command = PS2SDCTL_COMMAND_QUIT;
+	res = ps2sdcall_remote(&cmd.command, &cmd.result);
+	DPRINT(DBG_COMMAND, "command: %x res=%d, 0x%x\n", cmd.command,
+	       res, cmd.result);
+	cmd.command = PS2SDCTL_COMMAND_QUIT2;
+	res = ps2sdcall_remote(&cmd.command, &cmd.result);
+	DPRINT(DBG_COMMAND, "command: %x res=%d, 0x%x\n", cmd.command,
+	       res, cmd.result);
+	ps2sif_unlock(ps2sd_mc.lock);
+	ps2sd_setup(); /* reset all settings */
+	/* leave command mode */
+	for (i = 0; i < ps2sd_nunits; i++)
+	    ps2sd_units[i].flags &= ~PS2SD_UNIT_COMMANDMODE;
+	return (0);
+}
+
+static void
+ps2sd_mute(struct ps2sd_unit_context *devc)
+{
+	DPRINT(DBG_VERBOSE, "core%d: MMIX output off\n", devc->core);
+	ps2sdcall_set_reg(SB_SOUND_REG_MMIX(devc->core),
+			  ~(SD_MMIX_MINEL | SD_MMIX_MINER |
+			    SD_MMIX_MINL | SD_MMIX_MINR));
+}
+
+static void
+ps2sd_unmute(struct ps2sd_unit_context *devc)
+{
+	DPRINT(DBG_VERBOSE, "core%d: MMIX output on\n", devc->core);
+	ps2sdcall_set_reg(SB_SOUND_REG_MMIX(devc->core),
+			  ~( SD_MMIX_MINEL | SD_MMIX_MINER ));
+}
+
+static int
+start(struct ps2sd_unit_context *devc)
+{
+	int res, resiop, dmamode;
+	unsigned long flags;
+
+	if (devc->dmastat != DMASTAT_STOP /* just avoid verbose messages */
+	    || setdmastate(devc, DMASTAT_STOP, DMASTAT_START, "start") < 0)
+		return (0);
+
+	CHECKPOINT("start getting lock");
+	res = ps2sif_lock_interruptible(ps2sd_mc.lock,
+				devc->dmach?"start dma1" : "start dma0");
+	if (res < 0) {
+		setdmastate(devc, DMASTAT_START, DMASTAT_STOP,
+			    "can't get lock");
+		return (res);
+	}
+
+	if (devc->dmabufcount < devc->iopbufsize/2) {
+		setdmastate(devc, DMASTAT_START, DMASTAT_STOP,
+			    "no enought data");
+		CHECKPOINT("start unlock 1");
+		ps2sif_unlock(ps2sd_mc.lock);
+		return (0);
+	}
+
+	DPRINT(DBG_INFO, "start DMA%d -------------- \n", devc->dmach);
+
+	setdmastate(devc, DMASTAT_START, DMASTAT_RUNNING, "start");
+
+	/*
+	 * transfer first data fragment
+	 */
+	spin_lock_irqsave(&devc->spinlock, flags);
+	CHECKPOINT("start fill IOP");
+#ifdef PS2SD_FADEINOUT
+	{
+	    int i, j;
+	    short *p = (short*)&devc->dmabuf[devc->dmabufhead];
+	    DPRINT(DBG_INFO, "dma%d: fade in\n", devc->dmach);
+	    for (i = 0; i < 2; i++) {
+		for (j = 0; j < INTRSIZE / sizeof(*p); j++) {
+		    int r = 0x10000 * j / (INTRSIZE / sizeof(*p));
+		    *p = (((*p * r) >> 16) & 0xffff);
+		    p++;
+		}
+	    }
+	    ps2sif_writebackdcache(&devc->dmabuf[devc->dmabufhead], BUFUNIT);
+	}
+#endif
+	devc->bg->dmaid = 0;
+	ps2sd_dmaintr(NULL, devc->dmach);
+	devc->bg->dmaid = 0;
+	devc->dmabufhead += devc->bg->size;
+	devc->dmabufhead %= devc->dmabufsize;
+	devc->dmabufcount -= devc->bg->size;
+	ps2sd_dmaintr(NULL, devc->dmach);
+	devc->prevdmaintrvalid = 0;
+	spin_unlock_irqrestore(&devc->spinlock, flags);
+
+	/*
+	 * start auto DMA IOP -> SPU2
+	 */
+	devc->phaseerr = 0;
+	CHECKPOINT("start DMA");
+	dmamode = 0;
+
+	res = ps2sdcall_trans(devc->dmach | dmamode,
+			    SD_TRANS_MODE_WRITE|SD_BLOCK_MEM_DRY|SD_BLOCK_LOOP,
+			    devc->iopbuf, devc->iopbufsize, 0, &resiop);
+	if (res < 0 || resiop < 0) {
+		printk(KERN_ERR "ps2sd: can't start DMA%d res=%d resiop=%x\n",
+		       devc->dmach, res, resiop);
+		DPRINT(DBG_INFO, "ps2sd: can't start DMA%d res=%d resiop=%x\n",
+		       devc->dmach, res, resiop);
+		setdmastate(devc, DMASTAT_RUNNING, DMASTAT_ERROR,
+			    "can't start DMA");
+		CHECKPOINT("start unlock 3");
+		ps2sif_unlock(ps2sd_mc.lock);
+		return -EIO;
+	}
+
+	/* start DMA watch timer */
+	/*
+	 * (devc->iopbufsize/2/4) is samples/sec
+	 * (devc->iopbufsize/2/4) / SPU2SPEED is expected interval in second
+	 */
+	CHECKPOINT("start start timer");
+	del_timer(&devc->timer); /* there might be previous timer, delete it */
+	devc->timeout = (devc->iopbufsize/2/4) * HZ / SPU2SPEED;
+	devc->timeout *= 5; /* 400% margin */
+	if (devc->timeout < HZ/20)
+		devc->timeout = HZ/20;
+	devc->timer.expires = jiffies + devc->timeout;
+	add_timer(&devc->timer);
+
+	/*
+	 * be sure to set this register after starting auto DMA, 
+	 * otherwise you will hear some noise.
+	 */
+	/* un-mute */
+	CHECKPOINT("start set_reg");
+	ps2sd_unmute(devc);
+
+	CHECKPOINT("start unlock 4");
+	ps2sif_unlock(ps2sd_mc.lock);
+	CHECKPOINT("start end");
+
+	return (0);
+}
+
+static int
+stop(struct ps2sd_unit_context *devc)
+{
+	setdmastate(devc, DMASTAT_RUNNING, DMASTAT_STOPREQ, "stop request");
+
+	return wait_dma_stop(devc);
+}
+
+static int
+wait_dma_stop(struct ps2sd_unit_context *devc)
+{
+	int res, rest;
+	unsigned long flags;
+	DECLARE_WAITQUEUE(wait, current);
+
+	spin_lock_irqsave(&devc->spinlock, flags);
+	add_wait_queue(&devc->dmastat_wq, &wait);
+	CHECKPOINT("stop 0");
+	res = 0; /* succeed */
+	while (devc->dmastat != DMASTAT_STOP) {
+		CHECKPOINT("stop sleep");
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		spin_unlock_irq(&devc->spinlock);
+		rest = schedule_timeout(HZ);
+		spin_lock_irq(&devc->spinlock);
+		if (rest == 0) {
+			/*
+			 * timeout, failed to stop DMA.
+			 * DMA might be hunging up...
+			 */
+			printk(KERN_CRIT "ps2sd: stop DMA%d, timeout\n",
+			       devc->dmach);
+			setdmastate(devc, devc->dmastat, DMASTAT_ERROR,
+				    "stop DMA, timeout");
+			CHECKPOINT("stop timeout");
+			res = -EBUSY;
+			break;
+		}
+		if (signal_pending(current)) {
+			CHECKPOINT("stop interrupted");
+			res = -ERESTARTSYS;
+			break;
+		}
+	}
+	remove_wait_queue(&devc->dmastat_wq, &wait);
+	spin_unlock_irqrestore(&devc->spinlock, flags);
+
+#ifdef PS2SD_DEBUG
+	if (ps2sd_debug & DBG_FLUSHONSTOP)
+		debuglog_flush(NULL);
+#endif
+
+	CHECKPOINT("stop end");
+	return res;
+}
+
+
+static int
+stop_sequence0(void* arg)
+{
+	struct ps2sd_unit_context *devc;
+	static struct sbr_common_arg carg;
+	static struct sbr_sound_trans_arg dmaarg;
+	unsigned long flags;
+	int res;
+
+	devc = arg;
+
+	DPRINT(DBG_INFO, "stop DMA%d --------------\n", devc->dmach);
+
+	if (setdmastate(devc, DMASTAT_STOPPING, DMASTAT_CANCEL,
+			"stop sequence 0") < 0) {
+		printk(KERN_CRIT "stop_sequence0: invalid status, %s\n",
+		       dmastatnames[devc->dmastat]);
+		return (0);
+	}
+
+	spin_lock_irqsave(&devc->spinlock, flags);
+	reset_buffer(devc);
+	wake_up(&devc->write_wq);
+	spin_unlock_irqrestore(&devc->spinlock, flags);
+
+	ps2sd_mc.lock_owner = devc;
+
+	dmaarg.channel = devc->dmach;
+	dmaarg.mode = SB_SOUND_TRANS_MODE_STOP;
+	carg.arg = &dmaarg;
+	carg.func = (void(*)(void *, int))stop_sequence;
+	carg.para = devc;
+	res = sbios(SBR_SOUND_TRANS, &carg);
+	if (res < 0) {
+		printk("ps2sd: can't stop DMA%d\n", devc->dmach);
+		ps2sif_lowlevel_unlock(ps2sd_mc.lock, &devc->lockq);
+		setdmastate(devc, DMASTAT_CANCEL, DMASTAT_ERROR,
+			    "stop sequence 0, can't stop DMA");
+	}
+
+	return (0);
+}
+
+static void
+stop_sequence(void* arg)
+{
+	struct ps2sd_unit_context *devc;
+#ifndef SPU2_REG_DIRECT_ACCESS
+	int res;
+#endif
+
+	devc = ps2sd_mc.lock_owner;
+
+	switch (devc->dmastat) {
+	case DMASTAT_CANCEL:
+		if (arg != NULL)
+			DPRINT(DBG_INFO,
+			       "stop DMA resiop = %d\n", *(int*)arg);
+		else
+			DPRINT(DBG_INFO,
+			       "stop DMA timeout\n");
+
+		res = ps2sdcall_set_reg(SB_SOUND_REG_MMIX(devc->core),
+					~(SD_MMIX_MINEL | SD_MMIX_MINER |
+					  SD_MMIX_MINL | SD_MMIX_MINR));
+		setdmastate(devc, DMASTAT_CANCEL, DMASTAT_STOP,
+			    "stop sequence");
+		ps2sif_lowlevel_unlock(ps2sd_mc.lock, &devc->lockq);
+		break;
+	case DMASTAT_CLEAR:
+		if (arg != NULL)
+			DPRINT(DBG_INFO,
+			       "clear RPC resiop = %d\n", *(int*)arg);
+		else
+			DPRINT(DBG_INFO,
+			       "clear RPC timeout\n");
+		setdmastate(devc, DMASTAT_CLEAR, DMASTAT_STOP,
+			    "stop sequence");
+		ps2sif_lowlevel_unlock(ps2sd_mc.lock, &devc->lockq);
+		break;
+	default:
+		setdmastate(devc, DMASTAT_CLEAR, DMASTAT_STOP,
+			    "stop sequence, state error");
+		ps2sif_lowlevel_unlock(ps2sd_mc.lock, &devc->lockq);
+		break;
+	}
+}
+
+static int
+reset_error(struct ps2sd_unit_context *devc)
+{
+	int res;
+
+	/*
+	 * get the lock
+	 */
+	res = ps2sif_lock_interruptible(ps2sd_mc.lock, "reset error");
+	if (res < 0) {
+		DPRINT(DBG_INFO,
+		       "reset_error(): can't get the lock(interrupted)\n");
+		return (res);
+	}
+
+	/*
+	 * Did any error occurr?
+	 */
+	if (devc->dmastat != DMASTAT_ERROR /* just avoid verbose message */
+	    || setdmastate(devc, DMASTAT_ERROR, DMASTAT_RESET,
+			   "reset") < 0) {
+		/* no error */
+		ps2sif_unlock(ps2sd_mc.lock);
+		return (0);
+	}
+
+	/* ok, we got in error recovery sequence */
+
+	/*
+	 * reset all
+	 */
+	/*
+	 * FIX ME!
+	 */
+	DPRINT(DBG_INFO, "CLEAR ERROR(not implemented)\n");
+
+	/*
+	 * unlock and enter normal status
+	 */
+	setdmastate(devc, DMASTAT_RESET, DMASTAT_STOP, "reset");
+	ps2sif_unlock(ps2sd_mc.lock);
+
+	return (0);
+}
+
+#ifdef CONFIG_T10000_DEBUG_HOOK
+static void
+ps2sd_debug_proc(int c)
+{
+	int i;
+
+	switch (c) {
+	case 't':
+		ps2sd_debug |= DBG_TRACE;
+		printk("ps2sd: debug flags=%08lx\n", ps2sd_debug);
+		break;
+	case 'T':
+		ps2sd_debug |= (DBG_TRACE | DBG_VERBOSE);
+		printk("ps2sd: debug flags=%08lx\n", ps2sd_debug);
+		break;
+	case 'A':
+		ps2sd_debug = 0x7fffffff;
+		printk("ps2sd: debug flags=%08lx\n", ps2sd_debug);
+		break;
+	case 'c':
+		ps2sd_debug = ps2sd_normal_debug;
+		printk("ps2sd: debug flags=%08lx\n", ps2sd_debug);
+		break;
+	case 'C':
+		ps2sd_debug = 0;
+		printk("ps2sd: debug flags=%08lx\n", ps2sd_debug);
+		break;
+	case 'd':
+		printk("ps2sd: lock=%d %s\n", (int)ps2sd_mc.lock->owner,
+		       ps2sd_mc.lock->ownername?ps2sd_mc.lock->ownername:"");
+		for (i = 0; i < 2; i++) {
+		  struct ps2sd_unit_context *devc;
+		  devc = ps2sd_lookup_by_dmach(i);
+		  printk("ps2sd: core%d %s dma=%s underflow=%d total=%8d",
+			 i,
+			 (devc->flags & PS2SD_UNIT_OPENED) ? "open" : "close",
+			 dmastatnames[devc->dmastat],
+			 devc->dmabufunderflow,
+			 devc->total_output_bytes);
+		  printk(" intr=%d count=%d/%d/%d\n",
+			 devc->intr_count,
+			 devc->cnvbufcount,
+			 devc->intbufcount,
+			 devc->dmabufcount);
+		  printk("ps2sd: checkpoint=%s phaseerr=%d\n",
+			 devc->debug_check_point, devc->phaseerr);
+		}
+		break;
+	case 'D':
+#ifdef PS2SD_DEBUG
+		debuglog_flush(NULL);
+#endif
+		break;
+	}
+}
+#endif /* CONFIG_T10000_DEBUG_HOOK */
+
+#ifdef PS2SD_DEBUG
+static void
+ps2sd_print_debug_flags(void)
+{
+	printk(KERN_CRIT "bits for ps2sd_debug:\n");
+	printk(KERN_CRIT "%13s: %08x\n", "verbose",	DBG_VERBOSE);
+	printk(KERN_CRIT "%13s: %08x\n", "information",	DBG_INFO);
+	printk(KERN_CRIT "%13s: %08x\n", "interrupt",	DBG_INTR);
+	printk(KERN_CRIT "%13s: %08x\n", "diagnostic",	DBG_DIAG);
+	printk(KERN_CRIT "%13s: %08x\n", "write",	DBG_WRITE);
+	printk(KERN_CRIT "%13s: %08x\n", "mixer",	DBG_MIXER);
+	printk(KERN_CRIT "%13s: %08x\n", "ioctl",	DBG_IOCTL);
+	printk(KERN_CRIT "%13s: %08x\n", "dma stat",	DBG_DMASTAT);
+	printk(KERN_CRIT "%13s: %08x\n", "trace",	DBG_TRACE);
+	printk(KERN_CRIT "%13s: %08x\n", "RPC",		DBG_RPC);
+	printk(KERN_CRIT "%13s: %08x\n", "RPC server",	DBG_RPCSVC);
+	printk(KERN_CRIT "%13s: %08x\n", "command mode",DBG_COMMAND);
+	printk(KERN_CRIT "%13s: %08x\n", "flush on stop",DBG_FLUSHONSTOP);
+	printk(KERN_CRIT "%13s: %08x\n", "through",	DBG_THROUGH);
+}
+#endif
+
+static int __init
+ps2sd_init(void)
+{
+	int i, res, resiop;
+
+	printk("PlayStation 2 Sound driver");
+	printk("\n");
+
+	ps2sd_mc.init = 0;
+	ps2sd_mc.iopzero = 0;
+	ps2sd_normal_debug = ps2sd_debug;
+	spin_lock_init(&ps2sd_mc.spinlock);
+
+#ifdef PS2SD_DEBUG
+	if (ps2sd_debug == -1) {
+		ps2sd_print_debug_flags();
+		goto error_out;
+	}
+#endif
+
+	if ((ps2sd_mc.lock = ps2sif_getlock(PS2LOCK_SOUND)) == NULL) {
+		printk(KERN_ERR "ps2sd: Can't get lock\n");
+		goto error_out;
+	}
+
+	/* allocate zero buffer on IOP */
+	ps2sd_mc.iopzero = ps2sif_allociopheap(PS2SD_SPU2PCMBUFSIZE);
+	if(ps2sd_mc.iopzero == 0) {
+		printk(KERN_ERR "ps2sd: can't alloc iop heap\n");
+		goto error_out;
+	}
+	DPRINT(DBG_INFO, "allocate %d bytes on IOP 0x%p\n",
+	       PS2SD_SPU2PCMBUFSIZE, ps2sd_mc.iopzero);
+
+	/* adjust buffer size */
+	ps2sd_max_iopbufsize *= 1024;
+	ps2sd_max_dmabufsize *= 1024;
+	ps2sd_iopbufsize *= 1024;
+	ps2sd_dmabufsize *= 1024;
+	ps2sd_max_iopbufsize = adjust_bufsize(ps2sd_max_iopbufsize);
+	ps2sd_max_dmabufsize = ALIGN(ps2sd_max_dmabufsize,
+				     ps2sd_max_iopbufsize);
+	ps2sd_iopbufsize = adjust_bufsize(ps2sd_iopbufsize);
+	if (ps2sd_max_iopbufsize < ps2sd_iopbufsize)
+		ps2sd_iopbufsize = ps2sd_max_iopbufsize;
+	ps2sd_dmabufsize = ALIGN(ps2sd_dmabufsize, ps2sd_iopbufsize);
+
+	DPRINT(DBG_INFO, "iopbufsize %3dKB (max %3dKB)\n",
+	       ps2sd_iopbufsize / 1024, ps2sd_max_iopbufsize / 1024);
+	DPRINT(DBG_INFO, "dmabufsize %3dKB (max %3dKB)\n",
+	       ps2sd_dmabufsize / 1024, ps2sd_max_dmabufsize / 1024);
+
+	/* get lock */
+	res = ps2sif_lock_interruptible(ps2sd_mc.lock, "sd init");
+	if (res < 0)
+		goto error_out;
+
+	/* XXX, suppress output before init */
+	ps2sdcall_set_reg(SB_SOUND_REG_MVOLR(1), 0);
+	ps2sdcall_set_reg(SB_SOUND_REG_MVOLL(1), 0);
+
+	if (ps2sdcall_init(SB_SOUND_INIT_COLD, &resiop) < 0 || resiop < 0) {
+		ps2sif_unlock(ps2sd_mc.lock);
+		goto error_out;
+	}
+	ps2sd_mc.init |= PS2SD_INIT_IOP;
+
+	/* setup SPU2 registers */
+	ps2sd_setup();
+
+	/* setup SPDIF */
+	if (ps2_bootinfo->sysconf.spdif == 0) {
+		DPRINT(DBG_INFO, "SPDIF output on\n");
+		ps2sdcall_set_coreattr(SB_SOUND_CA_SPDIF_MODE,
+				       SD_SPDIF_OUT_PCM |
+				       SD_SPDIF_COPY_PROHIBIT |
+				       SD_SPDIF_MEDIA_CD);
+	} else {
+		DPRINT(DBG_INFO, "SPDIF output off\n");
+		ps2sdcall_set_coreattr(SB_SOUND_CA_SPDIF_MODE,
+				       SD_SPDIF_OUT_OFF);
+	}
+
+	/* release lock */
+	ps2sif_unlock(ps2sd_mc.lock);
+
+	ps2sd_mc.init |= PS2SD_INIT_UNIT;
+#ifdef PS2SD_USE_THREAD
+	/* Initialize mutex, if interrupts happens before starting thread. */
+	init_MUTEX_LOCKED(&ps2sd_mc.intr_sem);
+#endif
+	if (ps2sd_attach_unit(&ps2sd_units[0], 0, 0, &ps2sd_mixers[0],
+			      UNIT0_FLAGS) < 0)
+		goto error_out;
+
+	if (ps2sd_attach_unit(&ps2sd_units[1], 1, 1, &ps2sd_mixers[0],
+			      UNIT1_FLAGS) < 0)
+		goto error_out;
+
+	if (ps2sd_attach_unit(&ps2sd_units[2], 1, 1, &ps2sd_mixers[0],
+			      UNIT2_FLAGS) < 0)
+		goto error_out;
+	ps2sd_units[2].iopmemlist = &ps2sd_unit2_iopmemlist;
+
+#ifdef PS2SD_USE_THREAD
+	/*
+	 * start interrupt service thread
+	 */
+	init_completion(&ps2sd_mc.ack_comp);
+	ps2sd_mc.thread_id = kernel_thread(ps2sd_thread, NULL, CLONE_VM);
+	if (ps2sd_mc.thread_id < 0) {
+		printk(KERN_ERR "ps2sd: can't start thread\n");
+		goto error_out;
+	}
+	/* wait for the thread to start */
+	wait_for_completion(&ps2sd_mc.ack_comp);
+	ps2sd_mc.init |= PS2SD_INIT_THREAD;
+#endif 
+
+	/* initialize mixer device */
+	mixer_dummy_channel.regr = -1;
+	mixer_dummy_channel.regl = -1;
+	mixer_dummy_channel.name = "dummy";
+
+	ps2sd_mixers[0].channels[SOUND_MIXER_VOLUME] = 
+		&ps2sd_units[1].mixer_main;
+	ps2sd_mixers[0].channels[SOUND_MIXER_PCM] =
+		&ps2sd_units[0].mixer_pcm;
+	ps2sd_mixers[0].channels[SOUND_MIXER_ALTPCM] =
+		&ps2sd_units[1].mixer_pcm;
+
+	ps2sd_mixers[0].channels[SOUND_MIXER_BASS] = &mixer_dummy_channel;
+	ps2sd_mixers[0].channels[SOUND_MIXER_TREBLE] = &mixer_dummy_channel;
+	ps2sd_mixers[0].channels[SOUND_MIXER_SYNTH] = &mixer_dummy_channel;
+
+	ps2sd_mixers[0].devmask = 0;
+	for (i = 0; i < SOUND_MIXER_NRDEVICES; i++)
+		if (ps2sd_mixers[0].channels[i] != NULL)
+			ps2sd_mixers[0].devmask |= 1 << i;
+
+	ps2sd_units[0].mixer_main.name = "core0 volume";
+	ps2sd_units[0].mixer_pcm.name = "pcm";
+	ps2sd_units[1].mixer_main.name = "master volume";
+	ps2sd_units[1].mixer_pcm.name = "alternate pcm";
+	ps2sd_units[1].mixer_extrn.name = "core0->core1";
+
+	ps2sdmixer_setvol(&mixer_dummy_channel, 50, 50);
+	ps2sdmixer_setvol(&ps2sd_units[0].mixer_main, 100, 100);
+	ps2sdmixer_setvol(&ps2sd_units[0].mixer_pcm, 50, 50);
+	/* external input volume is disable in CORE0 
+	   ps2sdmixer_setvol(&ps2sd_units[0].mixer_extrn, 100, 100);
+	*/
+	ps2sdmixer_setvol(&ps2sd_units[1].mixer_main, 50, 50);
+	ps2sdmixer_setvol(&ps2sd_units[1].mixer_pcm, 50, 50);
+	ps2sdmixer_setvol(&ps2sd_units[1].mixer_extrn, 100, 100);
+
+	/* register mixer device */
+	ps2sd_mixers[0].mixer = register_sound_mixer(&ps2sd_mixer_fops, -1);
+	if (ps2sd_mixers[0].mixer < 0) {
+		printk(KERN_ERR "ps2sd: Can't install mixer device\n");
+	}
+	DPRINT(DBG_INFO, "register_sound_mixer() = %d\n",
+	       ps2sd_mixers[0].mixer);
+	ps2sd_mc.init |= PS2SD_INIT_REGMIXERDEV;
+
+#ifdef CONFIG_T10000_DEBUG_HOOK
+	if (ps2sd_debug_hook) {
+		extern void (*ps2_debug_hook[0x80])(int c);
+		char *p = "tTAcCdD";
+		DPRINT(DBG_INFO, "install debug hook '%s'\n", p);
+		while (*p)
+			ps2_debug_hook[(int)*p++] = ps2sd_debug_proc;
+	}
+#endif
+
+	return 0;
+
+ error_out:
+	printk("ps2sd: init failed\n");
+	ps2sd_cleanup();
+
+	return -1;
+}
+
+void
+ps2sd_cleanup(void)
+{
+	int i, resiop;
+
+	if (ps2sd_mc.lock)
+		ps2sif_lock(ps2sd_mc.lock, "cleanup");
+
+	if (ps2sd_mc.iopzero != 0) {
+		ps2sif_freeiopheap(ps2sd_mc.iopzero);
+		DPRINT(DBG_INFO, "free %d bytes on IOP 0x%p\n",
+		       PS2SD_SPU2PCMBUFSIZE, ps2sd_mc.iopzero);
+		ps2sd_mc.iopzero = 0;
+	}
+
+#ifdef PS2SD_USE_THREAD
+	/*
+	 * stop thread
+	 */
+	if (ps2sd_mc.init & PS2SD_INIT_THREAD) {
+		DPRINT(DBG_VERBOSE, "stop thread %d\n", ps2sd_mc.thread_id);
+		kill_pid(find_get_pid(ps2sd_mc.thread_id), SIGKILL, 1);
+		/* wait for the thread to exit */
+		wait_for_completion(&ps2sd_mc.ack_comp);
+	}
+	ps2sd_mc.init &= ~PS2SD_INIT_THREAD;
+#endif
+
+	if (ps2sd_mc.init & PS2SD_INIT_UNIT)
+		for (i = 0; i < ps2sd_nunits; i++)
+		       	ps2sd_detach_unit(&ps2sd_units[i]);
+	ps2sd_mc.init &= ~PS2SD_INIT_UNIT;
+
+	if (ps2sd_mc.init & PS2SD_INIT_REGMIXERDEV)
+		unregister_sound_mixer(ps2sd_mixers[0].mixer);
+	ps2sd_mc.init &= ~PS2SD_INIT_REGMIXERDEV;
+
+	if (ps2sd_mc.init & PS2SD_INIT_IOP)
+		ps2sdcall_end(&resiop);
+	ps2sd_mc.init &= ~PS2SD_INIT_IOP;
+
+	ps2sd_mc.init = 0;
+
+#ifdef CONFIG_T10000_DEBUG_HOOK
+	if (ps2sd_debug_hook) {
+		extern void (*ps2_debug_hook[0x80])(int c);
+		char *p = "tTAcCdD";
+		DPRINT(DBG_INFO, "clear debug hook '%s'\n", p);
+		while (*p)
+			ps2_debug_hook[(int)*p++] = NULL;
+	}
+#endif
+
+	if (ps2sd_mc.lock)
+		ps2sif_unlock(ps2sd_mc.lock);
+}
+
+module_init(ps2sd_init);
+module_exit(ps2sd_cleanup);
+
+MODULE_AUTHOR("Sony Computer Entertainment Inc.");
+MODULE_DESCRIPTION("PlayStation 2 sound driver");
+MODULE_LICENSE("GPL");
diff -purN linux-2.6.35.4-orig/drivers/ps2/sdcall.h linux-2.6.35.4/drivers/ps2/sdcall.h
--- linux-2.6.35.4-orig/drivers/ps2/sdcall.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/sdcall.h	2014-07-18 22:29:43.562367724 +0200
@@ -0,0 +1,145 @@
+/*
+ *  PlayStation 2 Sound driver
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <asm/mach-ps2/sbios.h>
+#include <asm/mach-ps2/sifdefs.h>
+
+static __inline__ int ps2sdcall_init(int flag, int *resiop)
+{
+	struct sbr_sound_init_arg arg;
+
+	arg.flag = flag;
+	do {
+		if (sbios_rpc(SBR_SOUND_INIT, &arg, resiop) < 0)
+			return (-1);
+	} while (*resiop == -1);
+
+	return (0);
+}
+
+static __inline__ int ps2sdcall_end(int *resiop)
+{
+	return sbios_rpc(SBR_SOUND_END, NULL, resiop);
+}
+
+static __inline__ int ps2sdcall_get_reg(int reg, u_int *data)
+{
+	struct sb_sound_reg_arg arg;
+	int res;
+
+	arg.idx = reg;
+
+	res = sbios(SB_SOUND_GREG, &arg);
+	*data = arg.data;
+
+	return (res);
+}
+
+static __inline__ int ps2sdcall_set_reg(int reg, u_int data)
+{
+	struct sb_sound_reg_arg arg;
+
+	arg.idx = reg;
+	arg.data = data;
+
+	return sbios(SB_SOUND_SREG, &arg);
+}
+
+static __inline__ int ps2sdcall_get_coreattr(int idx, u_int *data)
+{
+	int res, resiop;
+	struct sbr_sound_coreattr_arg arg;
+
+	arg.idx = idx;
+	res = sbios_rpc(SBR_SOUND_GCOREATTR, &arg, &resiop);
+	*data = arg.data;
+
+	return (res);
+}
+
+static __inline__ int ps2sdcall_set_coreattr(int idx, u_int data)
+{
+	int res, resiop;
+	struct sbr_sound_coreattr_arg arg;
+
+	arg.idx = idx;
+	arg.data = data;
+	res = sbios_rpc(SBR_SOUND_SCOREATTR, &arg, &resiop);
+
+	return (res);
+}
+
+static __inline__ int ps2sdcall_trans(int channel, u_int mode, u_int addr,
+				    u_int size, u_int start_addr, int *resiop)
+{
+	struct sbr_sound_trans_arg arg;
+
+	arg.channel = channel;
+	arg.mode = mode;
+	arg.addr = addr;
+	arg.size = size;
+	arg.start_addr= start_addr;
+
+	return sbios_rpc(SBR_SOUND_TRANS, &arg, resiop);
+}
+
+static __inline__ int ps2sdcall_trans_stat(int channel, int flag, int *resiop)
+{
+	struct sbr_sound_trans_stat_arg arg;
+
+	arg.channel = channel;
+	arg.flag = flag;
+
+	return sbios_rpc(SBR_SOUND_TRANSSTAT, &arg, resiop);
+}
+
+static __inline__ int 
+ps2sdcall_trans_callback(int channel, 
+			 int (*func)(void*, int), void *data,
+			 int (**oldfunc)(void*, int), void **olddata,
+			 int *resiop)
+{
+	struct sbr_sound_trans_callback_arg arg;
+	int res;
+
+	arg.channel = channel;
+	arg.func = func;
+	arg.data = data;
+
+	res = sbios_rpc(SBR_SOUND_TRANSCALLBACK, &arg, resiop);
+
+	if (oldfunc)
+		*oldfunc = arg.oldfunc;
+	if (olddata)
+		*olddata = arg.olddata;
+
+	return (res);
+}
+
+static __inline__ int ps2sdcall_remote(int *command, int *resiop)
+{
+	/*
+	 * XXX, 
+	 * struct sbr_sound_remote_arg in asm/mips/ps2/sbcall.h and
+	 * struct ps2sd_command must have common members and alignments.
+	 * double check if you change this structure.
+	 */
+	return sbios_rpc(SBR_SOUND_REMOTE, command, resiop);
+}
diff -purN linux-2.6.35.4-orig/drivers/ps2/sdcnv.c linux-2.6.35.4/drivers/ps2/sdcnv.c
--- linux-2.6.35.4-orig/drivers/ps2/sdcnv.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/sdcnv.c	2014-07-18 22:29:43.562367724 +0200
@@ -0,0 +1,54 @@
+/*
+ *  PlayStation 2 Sound driver
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+short ps2sd_mulaw2liner16[] = {
+-32124,-31100,-30076,-29052,-28028,-27004,-25980,-24956,
+-23932,-22908,-21884,-20860,-19836,-18812,-17788,-16764,
+-15996,-15484,-14972,-14460,-13948,-13436,-12924,-12412,
+-11900,-11388,-10876,-10364, -9852, -9340, -8828, -8316,
+ -7932, -7676, -7420, -7164, -6908, -6652, -6396, -6140,
+ -5884, -5628, -5372, -5116, -4860, -4604, -4348, -4092,
+ -3900, -3772, -3644, -3516, -3388, -3260, -3132, -3004,
+ -2876, -2748, -2620, -2492, -2364, -2236, -2108, -1980,
+ -1884, -1820, -1756, -1692, -1628, -1564, -1500, -1436,
+ -1372, -1308, -1244, -1180, -1116, -1052,  -988,  -924,
+  -876,  -844,  -812,  -780,  -748,  -716,  -684,  -652,
+  -620,  -588,  -556,  -524,  -492,  -460,  -428,  -396,
+  -372,  -356,  -340,  -324,  -308,  -292,  -276,  -260,
+  -244,  -228,  -212,  -196,  -180,  -164,  -148,  -132,
+  -120,  -112,  -104,   -96,   -88,   -80,   -72,   -64,
+   -56,   -48,   -40,   -32,   -24,   -16,    -8,     0,
+ 32124, 31100, 30076, 29052, 28028, 27004, 25980, 24956,
+ 23932, 22908, 21884, 20860, 19836, 18812, 17788, 16764,
+ 15996, 15484, 14972, 14460, 13948, 13436, 12924, 12412,
+ 11900, 11388, 10876, 10364,  9852,  9340,  8828,  8316,
+  7932,  7676,  7420,  7164,  6908,  6652,  6396,  6140,
+  5884,  5628,  5372,  5116,  4860,  4604,  4348,  4092,
+  3900,  3772,  3644,  3516,  3388,  3260,  3132,  3004,
+  2876,  2748,  2620,  2492,  2364,  2236,  2108,  1980,
+  1884,  1820,  1756,  1692,  1628,  1564,  1500,  1436,
+  1372,  1308,  1244,  1180,  1116,  1052,   988,   924,
+   876,   844,   812,   780,   748,   716,   684,   652,
+   620,   588,   556,   524,   492,   460,   428,   396,
+   372,   356,   340,   324,   308,   292,   276,   260,
+   244,   228,   212,   196,   180,   164,   148,   132,
+   120,   112,   104,    96,    88,    80,    72,    64,
+    56,    48,    40,    32,    24,    16,     8,     0,
+};
diff -purN linux-2.6.35.4-orig/drivers/ps2/sd.h linux-2.6.35.4/drivers/ps2/sd.h
--- linux-2.6.35.4-orig/drivers/ps2/sd.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/sd.h	2014-07-18 22:29:43.562367724 +0200
@@ -0,0 +1,228 @@
+/*
+ *  PlayStation 2 Sound driver
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef PS2SD_H
+#define PS2SD_H
+
+/*
+ * macro defines
+ */
+//#define PS2SD_DEBUG
+#ifdef PS2SD_DEBUG
+
+#include <asm/mach-ps2/debuglog.h>
+
+#define DBG_VERBOSE	(1<< 0)
+#define DBG_INFO	(1<< 1)
+#define DBG_INTR	(1<< 2)
+#define DBG_DIAG	(1<< 3)
+#define DBG_WRITE	(1<< 4)
+#define DBG_MIXER	(1<< 5)
+#define DBG_IOCTL	(1<< 6)
+#define DBG_DMASTAT	(1<< 7)
+#define DBG_TRACE	(1<< 8)
+#define DBG_RPC		(1<< 9)
+#define DBG_RPCSVC	(1<<10)
+#define DBG_COMMAND	(1<<11)
+
+#define DBG_FLUSHONSTOP	(1<<30)
+#define DBG_THROUGH	(1<<31)
+
+#define DBG_LOG_LEVEL	KERN_CRIT
+
+#define DEBUGLOG(fmt, args...)		debuglog(NULL, fmt, ## args)
+
+#define DPRINT(mask, fmt, args...) \
+	do { \
+		if ((ps2sd_debug & (mask)) == (mask)) { \
+			if (ps2sd_debug & DBG_THROUGH) \
+				printk(DBG_LOG_LEVEL "ps2sd: " fmt, ## args); \
+			else \
+				DEBUGLOG(fmt, ## args); \
+		} \
+	} while (0)
+#define DPRINTK(mask, fmt, args...) \
+	do { \
+		if ((ps2sd_debug & (mask)) == (mask)) { \
+			if (ps2sd_debug & DBG_THROUGH) \
+				printk(fmt, ## args); \
+			else \
+				DEBUGLOG(fmt, ## args); \
+		} \
+	} while (0)
+#else
+#define DPRINT(mask, fmt, args...) do {} while (0)
+#define DPRINTK(mask, fmt, args...) do {} while (0)
+#endif
+
+#define TRACE(fmt, args...) DPRINT(DBG_TRACE, fmt, ## args)
+#define TRACE2(fmt, args...) DPRINT(DBG_TRACE|DBG_VERBOSE, fmt, ## args)
+
+#define ARRAYSIZEOF(a)	(sizeof(a)/sizeof(*(a)))
+
+#define PS2SD_DEVC(filp)	((struct ps2sd_unit_context *)(filp)->private_data)
+
+/*
+ * types
+ */
+struct ps2sd_module_context {
+	unsigned int init;
+	ps2sif_lock_t *lock;	/* the lock which is need to RPC and
+				   transfer DMA status */
+	struct ps2sd_unit_context *lock_owner;
+	dma_addr_t iopzero;
+	spinlock_t spinlock;
+
+#ifdef PS2SD_USE_THREAD
+	pid_t thread_id;
+	volatile int intr_status;
+	struct semaphore intr_sem;
+	struct completion ack_comp;
+#endif
+};
+
+struct ps2sd_mixer_context;
+struct ps2sd_mixer_channel {
+	int vol, volr, voll;
+#ifdef SPU2_REG_DIRECT_ACCESS
+	volatile short *regr, *regl;
+#else
+	int regr, regl;
+#endif
+	long scale;
+	char *name;
+	struct ps2sd_mixer_context *mixer;
+};
+
+#ifdef SOUND_MIXER_NRDEVICES
+struct ps2sd_mixer_context {
+	/* Mixer stuff */
+	int mixer;
+	int modified;
+	long devmask;
+	struct ps2sd_mixer_channel *channels[SOUND_MIXER_NRDEVICES];
+	spinlock_t spinlock;
+};
+#endif
+
+struct ps2sd_iopbuf {
+	int size;
+	long iopaddr;
+	unsigned int dmaid;
+};
+
+struct ps2sd_sample {
+	short l, r;
+};
+
+struct ps2iopmem_list;
+
+struct ps2sd_unit_context {
+	unsigned int init;
+	int dsp;
+	int flags;
+	int init_flags;
+#define PS2SD_UNIT_OPENED	(1<<0)
+#define PS2SD_UNIT_INT512	(1<<1)
+#define PS2SD_UNIT_EXCLUSIVE	(1<<2)
+#define PS2SD_UNIT_COMMANDMODE	(1<<3)
+#define PS2SD_UNIT_NOPCM	(1<<5)
+
+	int core;
+	int dmach;
+	wait_queue_head_t write_wq;
+	wait_queue_head_t dmastat_wq;
+	spinlock_t spinlock;
+	volatile int dmastat;
+	int total_output_bytes;
+	ps2sif_lock_queue_t lockq;
+        struct timer_list timer;
+	int intr_count;
+	int timeout;
+	char *debug_check_point;
+
+	/* Mixer stuff */
+	struct ps2sd_mixer_channel mixer_main;
+	struct ps2sd_mixer_channel mixer_pcm;
+	struct ps2sd_mixer_channel mixer_extrn;
+
+	/* IOP->SPU DMA stuff */
+	int iopbufsize;
+	dma_addr_t iopbuf;
+	struct ps2sd_iopbuf iopbufs[2];
+	struct ps2sd_iopbuf *fg, *bg;
+
+	/* main memory->IOP DMA stuff */
+	int dmabufsize;
+	volatile int dmabufcount;
+	volatile int dmabufhead;
+	volatile int dmabuftail;
+	int dmabufunderflow;
+	unsigned char *dmabuf;
+	int phaseerr;
+	int prevdmaintr; 
+	int prevdmaintrvalid; 
+
+	/* format */
+	int format;
+	int speed;
+	int stereo;
+	int requested_fragsize;
+	int requested_maxfrags;
+
+	/* format conversion stuff */
+	int samplesize;
+	void (*fetch)(struct ps2sd_sample *, unsigned char *);
+	int noconversion;
+
+	int cnvbufcount;
+	int cnvbufhead;
+	int cnvbuftail;
+	unsigned char *cnvbuf;
+	long cnvd;
+	long cnvsrcrate;
+	long cnvdstrate;
+	int intbufcount;
+	unsigned char *intbuf;
+
+	struct ps2iopmem_list *iopmemlist;
+};
+
+/*
+ * function prototypes
+ */
+struct ps2sd_unit_context *ps2sd_lookup_by_dsp(int dsp);
+struct ps2sd_unit_context *ps2sd_lookup_by_dmach(int dmach);
+struct ps2sd_mixer_context *ps2sd_lookup_mixer(int mixer);
+
+int ps2sdmixer_setvol(struct ps2sd_mixer_channel *ch, int volr, int voll);
+int ps2sdmixer_do_ioctl(struct ps2sd_mixer_context *, unsigned int,
+			unsigned long);
+
+/*
+ * variables
+ */
+extern unsigned long ps2sd_debug;
+extern struct ps2sd_module_context ps2sd_mc;
+extern struct ps2sd_unit_context ps2sd_units[];
+extern int ps2sd_nunits;
+extern struct file_operations ps2sd_mixer_fops;
+
+#endif /* PS2SD_H */
diff -purN linux-2.6.35.4-orig/drivers/ps2/sdmacro.h linux-2.6.35.4/drivers/ps2/sdmacro.h
--- linux-2.6.35.4-orig/drivers/ps2/sdmacro.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/sdmacro.h	2014-07-18 22:29:43.562367724 +0200
@@ -0,0 +1,64 @@
+/*
+ *  PlayStation 2 Sound driver
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef PS2SDMACRO_H
+#define PS2SDMACRO_H
+
+/*
+ * MIX
+ */
+#define SD_MMIX_SINER  (1 <<  0)
+#define SD_MMIX_SINEL  (1 <<  1)
+#define SD_MMIX_SINR   (1 <<  2)
+#define SD_MMIX_SINL   (1 <<  3)
+#define SD_MMIX_MINER  (1 <<  4)
+#define SD_MMIX_MINEL  (1 <<  5)
+#define SD_MMIX_MINR   (1 <<  6)
+#define SD_MMIX_MINL   (1 <<  7)
+#define SD_MMIX_MSNDER (1 <<  8)
+#define SD_MMIX_MSNDEL (1 <<  9)
+#define SD_MMIX_MSNDR  (1 << 10)
+#define SD_MMIX_MSNDL  (1 << 11)
+
+/*
+ * transfer
+ */
+#define SD_TRANS_MODE_WRITE 0
+#define SD_TRANS_MODE_READ  1
+#define SD_TRANS_MODE_STOP  2
+#define SD_TRANS_MODE_WRITE_FROM 3
+
+#define SD_TRANS_BY_DMA     (0x0<<3)
+#define SD_TRANS_BY_IO      (0x1<<3)
+
+#define SD_BLOCK_ONESHOT (0<<4) 
+#define SD_BLOCK_LOOP (1<<4) 
+
+#define SD_TRANS_STATUS_WAIT  1
+#define SD_TRANS_STATUS_CHECK 0
+
+/*
+ * 32bit mode: with `channel' argument
+ */
+#define SD_BLOCK_MEMIN0 (1<<2) 
+#define SD_BLOCK_MEMIN1 (1<<3) 
+#define SD_BLOCK_NORMAL (0<<4) 
+
+#endif /* PS2SDMACRO_H */
diff -purN linux-2.6.35.4-orig/drivers/ps2/sdmixer.c linux-2.6.35.4/drivers/ps2/sdmixer.c
--- linux-2.6.35.4-orig/drivers/ps2/sdmixer.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/sdmixer.c	2014-07-18 22:29:43.562367724 +0200
@@ -0,0 +1,250 @@
+/*
+ *  PlayStation 2 Mixer driver
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define __NO_VERSION__
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/soundcard.h>
+
+#include <asm/io.h>
+#include <asm/addrspace.h>
+#include <asm/uaccess.h>
+#include <asm/mach-ps2/sbios.h>
+#include <asm/mach-ps2/sifdefs.h>
+#include <asm/mach-ps2/siflock.h>
+
+#include "../../sound/oss/sound_config.h"
+
+#include "sd.h"
+#include "sdmacro.h"
+#include "sdcall.h"
+
+/*
+ * macro defines
+ */
+
+/*
+ * data types
+ */
+
+/*
+ * function prototypes
+ */
+static loff_t ps2sdmixer_llseek(struct file *, loff_t, int);
+static int ps2sdmixer_open(struct inode *, struct file *);
+static int ps2sdmixer_release(struct inode *, struct file *);
+static int ps2sdmixer_ioctl(struct inode *, struct file *, unsigned int, unsigned long);
+
+/*
+ * variables and data
+ */
+struct file_operations ps2sd_mixer_fops = {
+	owner:		THIS_MODULE,
+	llseek:		ps2sdmixer_llseek,
+	ioctl:		ps2sdmixer_ioctl,
+	open:		ps2sdmixer_open,
+	release:	ps2sdmixer_release,
+};
+
+/*
+ * function bodies
+ */
+static loff_t
+ps2sdmixer_llseek(struct file *filp, loff_t offset, int origin)
+{
+	return -ESPIPE;
+}
+
+int
+ps2sdmixer_do_ioctl(struct ps2sd_mixer_context *mixer,
+		    unsigned int cmd, unsigned long arg)
+{
+	int i, res, val;
+
+	/*
+	 * get device driver info
+	 */
+        if (cmd == SOUND_MIXER_INFO) {
+		mixer_info info;
+		strncpy(info.id, "PS2SPU", sizeof(info.id));
+		strncpy(info.name, "PS2 Sound Processing Unit",
+			sizeof(info.name));
+		info.modify_counter = mixer->modified;
+		if (copy_to_user((void *)arg, &info, sizeof(info)))
+			return -EFAULT;
+		return 0;
+	}
+	if (cmd == SOUND_OLD_MIXER_INFO) {
+		_old_mixer_info info;
+		strncpy(info.id, "PS2SPU", sizeof(info.id));
+		strncpy(info.name, "PS2 Sound Processing Unit",
+			sizeof(info.name));
+		if (copy_to_user((void *)arg, &info, sizeof(info)))
+			return -EFAULT;
+		return 0;
+	}
+	if (cmd == OSS_GETVERSION)
+		return put_user(SOUND_VERSION, (int *)arg);
+
+	if (_IOC_TYPE(cmd) != 'M' || _IOC_SIZE(cmd) != sizeof(int))
+                return -EINVAL;
+
+	/*
+	 * get channel info
+	 */
+        if (_IOC_DIR(cmd) == _IOC_READ) {
+                switch (_IOC_NR(cmd)) {
+                case SOUND_MIXER_RECSRC:
+			/* SPU2 have no recording source */
+			return put_user(0, (int *)arg);
+			
+                case SOUND_MIXER_DEVMASK:
+			/* supported devices */
+			return put_user(mixer->devmask, (int *)arg);
+
+                case SOUND_MIXER_RECMASK:
+			/* SPU2 have no recording input */
+			return put_user(0, (int *)arg);
+			
+                case SOUND_MIXER_STEREODEVS:
+			/* Mixer channels supporting stereo */
+			return put_user(mixer->devmask, (int *)arg);
+			
+                case SOUND_MIXER_CAPS:
+			return put_user(0, (int *)arg);
+
+		default:
+			/* get current volume */
+			i = _IOC_NR(cmd);
+                        if (SOUND_MIXER_NRDEVICES <= i ||
+			    mixer->channels[i] == NULL)
+                                return -EINVAL;
+			return put_user(mixer->channels[i]->vol, (int *)arg);
+		}
+	}
+
+        if (_IOC_DIR(cmd) != (_IOC_READ|_IOC_WRITE)) 
+		return -EINVAL;
+
+	/*
+	 * set channel info
+	 */
+	switch (_IOC_NR(cmd)) {
+	case SOUND_MIXER_RECSRC:
+		/* SPU2 have no recording source */
+		return 0;
+
+	default:
+		i = _IOC_NR(cmd);
+		if (SOUND_MIXER_NRDEVICES <= i || 
+		    mixer->channels[i] == NULL)
+			return -EINVAL;
+		if (get_user(val, (int *)arg))
+			return (-EFAULT);
+
+		res = ps2sdmixer_setvol(mixer->channels[i],
+					(val >> 8) & 0xff, val & 0xff);
+		if (res < 0) return res;
+
+                return put_user(mixer->channels[i]->vol, (int *)arg);
+	}
+}
+
+static int
+ps2sdmixer_open(struct inode *inode, struct file *filp)
+{
+	int minor = MINOR(inode->i_rdev);
+	struct ps2sd_mixer_context *mixer;
+
+	DPRINT(DBG_INFO, "open: inode->i_rdev=0x%04x\n", inode->i_rdev);
+	mixer = ps2sd_lookup_mixer(minor);
+	if (mixer == NULL) return -ENODEV;
+
+	filp->private_data = mixer;
+
+	return 0;
+}
+
+static int
+ps2sdmixer_release(struct inode *inode, struct file *filp)
+{
+
+	return 0;
+}
+
+static int
+ps2sdmixer_ioctl(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	struct ps2sd_mixer_context *mixer;
+
+	mixer = (struct ps2sd_mixer_context *)filp->private_data;
+	return ps2sdmixer_do_ioctl(mixer, cmd, arg);
+}
+
+int
+ps2sdmixer_setvol(struct ps2sd_mixer_channel *ch, int volr, int voll)
+{
+	int res;
+
+	if (volr < 0) volr = 0;
+	if (100 < volr) volr = 100;
+	if (voll < 0) voll = 0;
+	if (100 < voll) voll = 100;
+
+	if (ch->mixer != NULL)
+		ch->mixer->modified++;
+	ch->volr = volr;
+	ch->voll = voll;
+	ch->vol = (volr << 8) | voll;
+
+	volr = volr * ch->scale / 100;
+	voll = voll * ch->scale / 100;
+
+	DPRINT(DBG_MIXER, "%14s R=%04x/L=%04x\n", ch->name, volr, voll);
+
+	res = ps2sif_lock_interruptible(ps2sd_mc.lock, "mixer volume");
+	if (res < 0)
+		return res;
+
+	if (ch->regr != -1) {
+	  res = ps2sdcall_set_reg(ch->regr, volr);
+	  if (res < 0) {
+		DPRINT(DBG_DIAG, "%s R=%04x/L=%04x: failed, res=%d\n",
+		       ch->name, volr, voll, res);
+		goto unlock_and_return;
+	  }
+	}
+	if (ch->regl != -1) {
+	  res = ps2sdcall_set_reg(ch->regl, voll);
+	  if (res < 0) {
+		DPRINT(DBG_DIAG, "%s R=%04x/L=%04x: failed, res=%d\n",
+		       ch->name, volr, voll, res);
+		goto unlock_and_return;
+	  }
+	}
+
+ unlock_and_return:
+	ps2sif_unlock(ps2sd_mc.lock);
+
+	return res;
+}
diff -purN linux-2.6.35.4-orig/drivers/ps2/smap.c linux-2.6.35.4/drivers/ps2/smap.c
--- linux-2.6.35.4-orig/drivers/ps2/smap.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/smap.c	2014-07-18 22:29:43.562367724 +0200
@@ -0,0 +1,3048 @@
+/*
+ *  PlayStation 2 Ethernet device driver
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#if defined(linux)
+
+#include <linux/platform_device.h>
+
+#include "smap.h"
+
+#define INW(x) inw((uint32_t)(x))
+#define OUTW(val, x) outw(val, (uint32_t)(x))
+
+/*--------------------------------------------------------------------------*/
+
+static void smap_skb_queue_init(struct smap_chan *smap, struct sk_buff_head *head);
+static void smap_skb_enqueue(struct sk_buff_head *head, struct sk_buff *newsk);
+static void smap_skb_requeue(struct sk_buff_head *head, struct sk_buff *newsk);
+static struct sk_buff * smap_skb_dequeue(struct sk_buff_head *head);
+static void smap_skb_queue_clear(struct smap_chan *smap, struct sk_buff_head *head);
+static int  smap_start_xmit(struct sk_buff *skb, struct net_device *net_dev);
+static int  smap_start_xmit2(struct smap_chan *smap);
+static void smap_tx_intr(struct net_device *net_dev);
+static void smap_rx_intr(struct net_device *net_dev);
+static void smap_emac3_intr(struct net_device *net_dev);
+static irqreturn_t smap_interrupt(int irq, void *dev_id);
+static u_int8_t smap_bitrev(u_int8_t val);
+static u_int32_t smap_crc32(u_int32_t crcval, u_int8_t cval);
+static u_int32_t smap_calc_crc32(struct smap_chan *smap, u_int8_t *addr);
+static int  smap_store_new_mc_list(struct smap_chan *smap);
+static void smap_multicast_list(struct net_device *net_dev);
+static struct net_device_stats * smap_get_stats(struct net_device *net_dev);
+static int  smap_open(struct net_device *net_dev);
+static int  smap_close(struct net_device *net_dev);
+static int  smap_ioctl(struct net_device *net_dev, struct ifreq *ifr, int cmd);
+#ifdef HAVE_TX_TIMEOUT
+static void smap_tx_timeout(struct net_device *net_dev);
+static int  smap_timeout_thread(void *arg);
+#endif /* HAVE_TX_TIMEOUT */
+static void smap_clear_all_interrupt(struct smap_chan *smap);
+static void smap_interrupt_XXable(struct smap_chan *smap, int enable_flag);
+static void smap_txrx_XXable(struct smap_chan *smap, int enable_flag);
+static void smap_txbd_init(struct smap_chan *smap);
+static void smap_rxbd_init(struct smap_chan *smap);
+static int  smap_read_phy(struct smap_chan *smap, u_int32_t phyadr, u_int32_t regadr);
+static int  smap_write_phy(struct smap_chan *smap, u_int32_t phyadr, u_int32_t regadr, u_int16_t data);
+static int smap_fifo_reset(struct smap_chan *smap);
+static void smap_reg_init(struct smap_chan *smap);
+static int  smap_emac3_soft_reset(struct smap_chan *smap);
+static void smap_emac3_set_defvalue(struct smap_chan *smap);
+static void smap_emac3_init(struct smap_chan *smap, int reset_only);
+static void smap_emac3_re_init(struct smap_chan *smap);
+static int  smap_phy_init(struct smap_chan *smap, int reset_only);
+static int  smap_phy_reset(struct smap_chan *smap);
+static int  smap_auto_negotiation(struct smap_chan *smap, int enable_auto_nego);
+static int  smap_confirm_auto_negotiation(struct smap_chan *smap);
+static void smap_force_spd_100M(struct smap_chan *smap);
+static void smap_force_spd_10M(struct smap_chan *smap);
+static void smap_confirm_force_spd(unsigned long arg);
+static void smap_phy_set_dsp(struct smap_chan *smap);
+static void smap_reset(struct smap_chan *smap, int reset_only);
+static void smap_print_mac_address(struct smap_chan *smap, u_int8_t *addr);
+static int  smap_get_node_addr(struct smap_chan *smap);
+static void smap_base_init(struct smap_chan *smap);
+static void smap_dump_packet(struct smap_chan *smap, u_int8_t *ptr, int length);
+static void smap_dump_txbd(struct smap_chan *smap);
+static void smap_dump_rxbd(struct smap_chan *smap);
+static void smap_dump_reg(struct smap_chan *smap);
+static void smap_dump_emac3_reg(struct smap_chan *smap);
+static void smap_dma_force_break(struct smap_chan *smap);
+static void smap_rpcend_notify(void *arg);
+static void smap_dma_setup(struct smap_chan *smap);
+static void smap_run(struct smap_chan *smap);
+static int  smap_thread(void *arg);
+static void smap_chk_linkvalid(struct smap_chan *smap);
+static int  smap_chk_linkvalid_thread(void *arg);
+static int  smap_init_thread(void *arg);
+static inline void eth_copy_and_sum (struct sk_buff *dest, unsigned char *src, int len, int base)
+{
+	memcpy (dest->data, src, len);
+}
+
+/*--------------------------------------------------------------------------*/
+
+static void
+smap_skb_queue_init(struct smap_chan *smap, struct sk_buff_head *head)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&smap->spinlock, flags);
+	(void)skb_queue_head_init(head);
+	spin_unlock_irqrestore(&smap->spinlock, flags);
+
+	return;
+}
+
+static void
+smap_skb_enqueue(struct sk_buff_head *head, struct sk_buff *newsk)
+{
+	(void)skb_queue_tail(head, newsk);
+	return;
+}
+
+static void
+smap_skb_requeue(struct sk_buff_head *head, struct sk_buff *newsk)
+{
+	(void)skb_queue_head(head, newsk);
+	return;
+}
+
+static struct sk_buff *
+smap_skb_dequeue(struct sk_buff_head *head)
+{
+	struct sk_buff *skb;
+
+	skb = skb_dequeue(head);
+	return(skb);
+}
+
+static void
+smap_skb_queue_clear(struct smap_chan *smap, struct sk_buff_head *head)
+{
+	struct sk_buff *skb;
+	unsigned long flags;
+
+	spin_lock_irqsave(&smap->spinlock, flags);
+	while (head->qlen) {
+		skb = smap_skb_dequeue(head);
+		if (skb)
+			dev_kfree_skb(skb);
+	}
+	spin_unlock_irqrestore(&smap->spinlock, flags);
+
+	return;
+}
+
+/*--------------------------------------------------------------------------*/
+
+/* return value: 0 if success, !0 if error */
+static int
+smap_start_xmit(struct sk_buff *skb, struct net_device *net_dev)
+{
+	struct smap_chan *smap = netdev_priv(net_dev);
+	int qmax;
+	unsigned long flags;
+
+	spin_lock_irqsave(&smap->spinlock, flags);
+
+	if ((smap->flags & SMAP_F_LINKVALID) == 0) {
+		printk("%s: xmit: link not valid\n", net_dev->name);
+		spin_unlock_irqrestore(&smap->spinlock, flags);
+		return(-ENETDOWN);
+	}
+
+	qmax = (smap->flags & SMAP_F_DMA_TX_ENABLE) ? SMAP_BD_MAX_ENTRY/2 : 0;
+	if (smap->txqueue.qlen > qmax) {
+		netif_stop_queue(net_dev);
+		spin_unlock_irqrestore(&smap->spinlock, flags);
+		return(-EAGAIN);
+	}
+
+	(void)smap_skb_enqueue(&smap->txqueue, skb);
+	wake_up_interruptible(&smap->wait_smaprun);
+	spin_unlock_irqrestore(&smap->spinlock, flags);
+	return(0);
+}
+
+static int
+smap_start_xmit2(struct smap_chan *smap)
+{
+	struct net_device *net_dev = smap->net_dev;
+	struct sk_buff *skb = NULL;
+	int retval;
+	int i, txlen;
+	int tx_re_q;	/* re-queue and do again */
+	u_int16_t tmp_txbwp;
+	u_int32_t *datap;
+	volatile struct smapbd *txbd;
+	struct completion compl;
+	unsigned long flags;
+
+	tx_re_q = CLEAR;
+	tmp_txbwp = smap->txbwp;
+	smap->txdma_request.count = smap->txdma_request.size = 0;
+	for (i = 0; i < SMAP_DMA_ENTRIES; i++) {
+		skb = NULL;
+
+		if (((smap->flags & SMAP_F_DMA_TX_ENABLE) == 0) && (i > 0))
+			break;
+		spin_lock_irqsave(&smap->spinlock, flags);
+		skb = smap_skb_dequeue(&smap->txqueue);
+		spin_unlock_irqrestore(&smap->spinlock, flags);
+		if (skb == NULL)
+			break;
+		if (smap->txbdusedcnt + smap->txdma_request.count
+						>= (SMAP_BD_MAX_ENTRY-2)) {
+			printk("%s: xmit: txbd is full\n", net_dev->name);
+			tx_re_q |= (1 << i);
+			break;
+		}
+
+		/* check datalen and free buffer space */
+		/* txlen is multiple of 4 */
+		txlen = (skb->len + 3) & ~3;
+
+		if (smap->txdma_request.size + txlen > smap->txfreebufsize) {
+			tx_re_q |= (1 << i);
+			break;
+		}
+
+		if (smap->flags & SMAP_F_DMA_TX_ENABLE) {
+			memcpy((char *)(smap->txdma_ibuf + smap->txdma_request.size), skb->data, skb->len);
+			smap->txdma_request.sdd[i].i_addr = 
+				(unsigned int)(smap->txdma_ibuf + smap->txdma_request.size);
+		} else {
+			smap->txdma_request.sdd[i].i_addr = 0;
+		}
+		smap->txdma_request.sdd[i].f_addr = (tmp_txbwp & 0x0FFC);
+		smap->txdma_request.sdd[i].size = txlen;
+		smap->txdma_request.sdd[i].sdd_misc = (unsigned int)skb;
+		smap->txdma_request.size += txlen;
+		smap->txdma_request.count++;
+
+		tmp_txbwp = SMAP_TXBUFBASE +
+			((tmp_txbwp + txlen - SMAP_TXBUFBASE)%SMAP_TXBUFSIZE);
+	}
+	if (tx_re_q && skb) {
+		spin_lock_irqsave(&smap->spinlock, flags);
+		(void)smap_skb_requeue(&smap->txqueue, skb);
+		spin_unlock_irqrestore(&smap->spinlock, flags);
+	}
+	if (i == 0)
+		goto end;
+
+	if (smap->flags & SMAP_F_DMA_TX_ENABLE) {
+		init_completion(&compl);
+		ps2sif_writebackdcache((void *)smap->txdma_ibuf,
+						smap->txdma_request.size);
+		smap->txdma_request.command =
+				smap->txdma_request.sdd[0].f_addr;	/*XXX*/
+		smap->txdma_request.devctrl = 0;
+		smap->dma_result = 0;
+
+		if (ps2sif_callrpc(&smap->cd_smap_tx, SIFNUM_SmapDmaWrite,
+				SIF_RPCM_NOWAIT,
+				(void *)&smap->txdma_request,
+				sizeof(int) * 4,
+				&smap->dma_result, sizeof(u_int32_t),
+				(ps2sif_endfunc_t)smap_rpcend_notify,
+				(void *)&compl) != 0) {
+			if (smap->flags & SMAP_F_PRINT_MSG) {
+				printk("%s: xmit: callrpc failed, do pio to send this packet.pkt(%d)\n", net_dev->name,smap->txdma_request.count);
+			}
+			goto smappiosend;
+		}
+		wait_for_completion(&compl);
+		if (smap->dma_result != 0) {
+			printk("%s: xmit: dma break (%d)\n",
+					net_dev->name,smap->dma_result);
+			goto end;
+		}
+
+	} else {
+smappiosend:
+		skb = (struct sk_buff *)smap->txdma_request.sdd[0].sdd_misc;
+		/* clear padding bytes */
+		*(int *)&smap->txbuf[skb->len & ~3] = 0;
+		memcpy(smap->txbuf, skb->data, skb->len);
+
+		spin_lock_irqsave(&smap->spinlock, flags);
+		/* send from memory to FIFO */
+		WRITE_SMAPREG16(smap,SMAP_TXFIFO_WR_PTR,
+				smap->txdma_request.sdd[0].f_addr);
+		datap = (u_int32_t *)smap->txbuf;
+		for (i = 0; i < smap->txdma_request.sdd[0].size; i += 4) {
+							/* memory -> FIFO */
+			WRITE_SMAPREG32(smap, SMAP_TXFIFO_DATA, *datap++);
+		}
+		spin_unlock_irqrestore(&smap->spinlock, flags);
+
+		/* re-queue unsend packets */
+		for (i = smap->txdma_request.count - 1; i > 0; i--) {
+			skb = (struct sk_buff *)smap->txdma_request.sdd[i].sdd_misc;
+			smap->txdma_request.sdd[i].sdd_misc = 0;
+			if (skb) {
+				spin_lock_irqsave(&smap->spinlock, flags);
+				(void)smap_skb_requeue(&smap->txqueue, skb);
+				spin_unlock_irqrestore(&smap->spinlock, flags);
+				tx_re_q |= (1 << i);
+			}
+		}
+		smap->txdma_request.count = 1;
+	}
+
+	if (smap->flags & SMAP_F_PRINT_PKT) {
+		for (i = 0; i < smap->txdma_request.count; i++) {
+			skb = (struct sk_buff *)smap->txdma_request.sdd[i].sdd_misc;
+			printk("%s: xmit: mem->fifo done,len=%d,%d,ptr=0x%04x\n",
+				net_dev->name,skb->len,
+				smap->txdma_request.sdd[i].size,
+				smap->txdma_request.sdd[i].f_addr);
+			smap_dump_packet(smap, skb->data,
+					(skb->len < 60) ? skb->len: 60);
+
+		}
+	}
+
+	spin_lock_irqsave(&smap->spinlock, flags);
+	for (i = 0; i < smap->txdma_request.count; i++) {
+		txbd = &smap->txbd[smap->txbds];
+		skb = (struct sk_buff *)smap->txdma_request.sdd[i].sdd_misc;
+
+		smap->txfreebufsize -= smap->txdma_request.sdd[i].size;
+
+		/* send from FIFO to ethernet */
+		OUTW(skb->len, &txbd->length);
+		OUTW(SMAP_TXBUFBASE + smap->txdma_request.sdd[i].f_addr,
+				&txbd->pointer);
+
+		WRITE_SMAPREG8(smap,SMAP_TXFIFO_FRAME_INC, 1);
+
+		OUTW((SMAP_BD_TX_READY|SMAP_BD_TX_GENFCS|SMAP_BD_TX_GENPAD),
+			&txbd->ctrl_stat);
+		smap->txbdusedcnt++;
+
+		/* renew buffer descriptor */
+		SMAP_BD_NEXT(smap->txbds);
+	}
+
+	/* MULTI PACKET MODE */
+	EMAC3REG_WRITE(smap, SMAP_EMAC3_TxMODE0, E3_TX_GNP_0);
+						/* FIFO->ethernet */
+	if (smap->flags & SMAP_F_TXDNV_DISABLE) {
+		smap->flags &= ~SMAP_F_TXDNV_DISABLE;
+		WRITE_SMAPREG16(smap, SMAP_INTR_ENABLE, SMAPREG16(smap,
+					SMAP_INTR_ENABLE) | INTR_TXDNV);
+		WRITE_SMAPREG16(smap,SMAP_INTR_CLR, INTR_TXDNV);
+	}
+	spin_unlock_irqrestore(&smap->spinlock, flags);
+
+	/* renew write pointer */
+	if (smap->txdma_request.count > 0) {
+		i = smap->txdma_request.count - 1;
+		smap->txbwp = SMAP_TXBUFBASE +
+			((smap->txdma_request.sdd[i].f_addr + smap->txdma_request.sdd[i].size)%SMAP_TXBUFSIZE);
+	} else {
+		smap->txbwp = SMAP_TXBUFBASE;
+	}
+
+	net_dev->trans_start = jiffies;		/* save the timestamp */
+
+end:
+	for (i = 0; i < smap->txdma_request.count; i++) {
+		skb = (struct sk_buff *)smap->txdma_request.sdd[i].sdd_misc;
+		smap->txdma_request.sdd[i].sdd_misc = 0;
+		if (skb) {
+			dev_kfree_skb(skb);
+		}
+	}
+	spin_lock_irqsave(&smap->spinlock, flags);
+	if (tx_re_q || smap->txqueue.qlen > 0)
+		retval = -EAGAIN;
+	else
+		retval = 0;
+	spin_unlock_irqrestore(&smap->spinlock, flags);
+	return(retval);
+}
+
+/*--------------------------------------------------------------------------*/
+
+static void
+smap_tx_intr(struct net_device *net_dev)
+{
+	struct smap_chan *smap = netdev_priv(net_dev);
+	volatile struct smapbd *txbd;
+	int txlen, error;
+	u_int16_t txstat;
+	unsigned long flags;
+
+	txbd = &smap->txbd[smap->txbdi];
+	txstat = INW(&txbd->ctrl_stat);
+
+	while (((txstat & SMAP_BD_TX_READY) == 0) && (smap->txbdusedcnt > 0)) {
+		if (smap->flags & SMAP_F_PRINT_PKT) {
+			printk("%s: tx intr: process packet,"
+				"[%d]=stat=0x%04x,len=%d,ptr=0x%04x\n",
+					net_dev->name,smap->txbdi,txstat,
+					INW(&txbd->length), INW(&txbd->pointer));
+		}
+		/* txlen is multiple of 4 */
+		txlen = (INW(&txbd->length) + 3) & ~3;
+		smap->txfreebufsize += txlen;
+
+		error = 0;
+		if (txstat & 0x7FFF) {
+			if (txstat & SMAP_BD_TX_BADFCS) {
+				error++;
+				if (smap->flags & SMAP_F_PRINT_MSG) {
+					printk("%s:tx intr: bad FCS\n", net_dev->name);
+				}
+			}
+			if (txstat & SMAP_BD_TX_BADPKT) {
+				error++;
+				if (smap->flags & SMAP_F_PRINT_MSG) {
+					printk("%s:tx intr: bad previous packet\n", net_dev->name);
+				}
+			}
+			if (txstat & SMAP_BD_TX_LOSSCR) {
+				error++;
+				if (smap->flags & SMAP_F_PRINT_MSG) {
+					printk("%s:tx intr: loss of carrier\n", net_dev->name);
+				}
+			}
+			if (txstat & SMAP_BD_TX_EDEFER) {
+				error++;
+				if (smap->flags & SMAP_F_PRINT_MSG) {
+					printk("%s:tx intr: excessive deferral\n", net_dev->name);
+				}
+			}
+			if (txstat & SMAP_BD_TX_ECOLL) {
+				error++;
+				if (smap->flags & SMAP_F_PRINT_MSG) {
+					printk("%s:tx intr: excessive collisions\n", net_dev->name);
+				}
+			}
+			if (txstat & SMAP_BD_TX_LCOLL) {
+				error++;
+				if (smap->flags & SMAP_F_PRINT_MSG) {
+					printk("%s:tx intr: late collision\n", net_dev->name);
+				}
+			}
+			if (txstat & SMAP_BD_TX_MCOLL) {
+				smap->net_stats.collisions++;	/*XXX*/
+			}
+			if (txstat & SMAP_BD_TX_SCOLL) {
+				smap->net_stats.collisions++;
+			}
+			if (txstat & SMAP_BD_TX_UNDERRUN) {
+				error++;
+				if (smap->flags & SMAP_F_PRINT_MSG) {
+					printk("%s:tx intr: underrun\n", net_dev->name);
+				}
+			}
+			if (txstat & SMAP_BD_TX_SQE) {
+				error++;
+				if (smap->flags & SMAP_F_PRINT_MSG) {
+					printk("%s:tx intr: sqe test failed\n", net_dev->name);
+				}
+			}
+			if ((error > 0) && (smap->flags & SMAP_F_PRINT_MSG)) {
+				printk("%s:Tx intr: [%d]=stat(0x%04x, 0x%04x), len(%d, 0x%04x), ptr(0x%04x)\n", net_dev->name, smap->txbdi,txstat,INW(&txbd->ctrl_stat),INW(&txbd->length),INW(&txbd->length),INW(&txbd->pointer));
+			}
+		}
+
+		if (error == 0) {
+			smap->net_stats.tx_packets++;
+			smap->net_stats.tx_bytes += INW(&txbd->length);
+		} else {
+			smap->net_stats.tx_errors++;
+		}
+
+		smap->txbdusedcnt--;
+
+#if 0
+		spin_lock_irqsave(&smap->spinlock, flags);
+		/* renew txbd */
+		OUTW(0, &txbd->length);
+		OUTW(0, &txbd->pointer);
+		OUTW(0, &txbd->ctrl_stat);
+		spin_unlock_irqrestore(&smap->spinlock, flags);
+#endif
+
+		/* renew buffer descriptor */
+		SMAP_BD_NEXT(smap->txbdi);
+		txbd = &smap->txbd[smap->txbdi];
+		txstat = INW(&txbd->ctrl_stat);
+	}
+
+	if (smap->flags & SMAP_F_OPENED) {
+		netif_wake_queue(net_dev);
+	}
+
+	spin_lock_irqsave(&smap->spinlock, flags);
+	smap->txicnt--;
+	spin_unlock_irqrestore(&smap->spinlock, flags);
+	return;
+}
+
+static void
+smap_rx_intr(struct net_device *net_dev)
+{
+	struct smap_chan *smap = netdev_priv(net_dev);
+	volatile struct smapbd *rxbd;
+	u_int16_t rxstat;
+	int pkt_err, pioflag;
+	int pkt_len;
+	int i, rxlen;
+	u_int32_t *datap;
+	struct sk_buff *skb;
+	u_int8_t *rxbp;
+	int l_rxbdi;
+	int validrcvpkt, rcvpkt;
+	struct completion compl;
+	unsigned long flags;
+
+	pkt_err = pioflag = CLEAR;
+	validrcvpkt = rcvpkt = 0;
+	smap->rxdma_request.size = 0;
+
+	l_rxbdi = smap->rxbdi;
+
+	for (i = 0; i < SMAP_DMA_ENTRIES; i++) {
+		rxbd = &smap->rxbd[l_rxbdi];
+		rxstat = INW(&rxbd->ctrl_stat);
+
+		if (rxstat & SMAP_BD_RX_EMPTY)
+			break;
+
+		if (((smap->flags & SMAP_F_DMA_RX_ENABLE) == 0) && (i > 0))
+			break;
+
+		if (rxstat & 0x7FFF) {
+			if (rxstat & SMAP_BD_RX_OVERRUN) {
+				if (smap->flags & SMAP_F_PRINT_MSG) {
+					printk("%s:rx intr(%d): overrun\n", net_dev->name, i);
+				}
+			}
+			if (rxstat & SMAP_BD_RX_PFRM) {
+				if (smap->flags & SMAP_F_PRINT_MSG) {
+					printk("%s:rx intr(%d): pause frame\n", net_dev->name, i);
+				}
+			}
+			if (rxstat & SMAP_BD_RX_BADFRM) {
+				if (smap->flags & SMAP_F_PRINT_MSG) {
+					printk("%s:rx intr(%d): bad frame\n", net_dev->name, i);
+				}
+			}
+			if (rxstat & SMAP_BD_RX_RUNTFRM) {
+				if (smap->flags & SMAP_F_PRINT_MSG) {
+					printk("%s:rx intr(%d): runt frame\n", net_dev->name, i);
+				}
+			}
+			if (rxstat & SMAP_BD_RX_SHORTEVNT) {
+				if (smap->flags & SMAP_F_PRINT_MSG) {
+					printk("%s:rx intr(%d): short event\n", net_dev->name, i);
+				}
+			}
+			if (rxstat & SMAP_BD_RX_ALIGNERR) {
+				if (smap->flags & SMAP_F_PRINT_MSG) {
+					printk("%s:rx intr(%d): align error\n", net_dev->name, i);
+				}
+			}
+			if (rxstat & SMAP_BD_RX_BADFCS) {
+				if (smap->flags & SMAP_F_PRINT_MSG) {
+					printk("%s:rx intr(%d): bad FCS\n", net_dev->name, i);
+				}
+			}
+			if (rxstat & SMAP_BD_RX_FRMTOOLONG) {
+				if (smap->flags & SMAP_F_PRINT_MSG) {
+					printk("%s:rx intr(%d): frame too long\n", net_dev->name, i);
+				}
+			}
+			if (rxstat & SMAP_BD_RX_OUTRANGE) {
+				if (smap->flags & SMAP_F_PRINT_MSG) {
+					printk("%s:rx intr(%d): out range error\n", net_dev->name, i);
+				}
+			}
+			if (rxstat & SMAP_BD_RX_INRANGE) {
+				if (smap->flags & SMAP_F_PRINT_MSG) {
+					printk("%s:rx intr(%d): in range error\n", net_dev->name, i);
+				}
+			}
+			if (smap->flags & SMAP_F_PRINT_MSG) {
+				printk("%s:Rx intr(%d): [%d]=stat(0x%04x, 0x%04x), len(%d, 0x%04x), ptr(0x%04x)\n", net_dev->name, i, l_rxbdi, rxstat,INW(&rxbd->ctrl_stat),INW(&rxbd->length),INW(&rxbd->length),INW(&rxbd->pointer));
+			} 
+			pkt_err |= (1 << i);
+			break;
+		}
+
+		pkt_len = INW(&rxbd->length);
+
+		if ((pkt_len < SMAP_RXMINSIZE) || (pkt_len > SMAP_RXMAXSIZE)) {
+			if (smap->flags & SMAP_F_PRINT_MSG) {
+				printk("%s:rx intr(%d): packet length error (%d)\n", net_dev->name, i, pkt_len);
+			}
+			pkt_err |= (1 << i);
+			break;
+		}
+
+		/* rxlen is multiple of 4 */
+		rxlen = (pkt_len + 3) & ~3;
+
+		if (smap->flags & SMAP_F_DMA_RX_ENABLE) {
+			smap->rxdma_request.sdd[i].i_addr =
+			  (unsigned int)(smap->rxdma_ibuf+smap->rxdma_request.size);
+		} else {
+			smap->rxdma_request.sdd[i].i_addr = 0;
+		}
+		smap->rxdma_request.sdd[i].f_addr =
+					(unsigned int)(INW(&rxbd->pointer)&0x3FFC);
+		smap->rxdma_request.sdd[i].size = rxlen;
+		smap->rxdma_request.sdd[i].sdd_misc = pkt_len;
+		smap->rxdma_request.size += rxlen;
+
+		SMAP_BD_NEXT(l_rxbdi);
+	}
+	validrcvpkt = rcvpkt = i;
+	if (pkt_err)
+		rcvpkt++;
+
+	if (validrcvpkt == 0)
+		goto end;
+
+	if (smap->flags & SMAP_F_DMA_RX_ENABLE) {
+		init_completion(&compl);
+		ps2sif_writebackdcache((void *)smap->rxdma_ibuf,
+						smap->rxdma_request.size);
+		smap->rxdma_request.command =
+				smap->rxdma_request.sdd[0].f_addr;	/*XXX*/
+		smap->rxdma_request.devctrl = 0;
+		smap->rxdma_request.count = validrcvpkt;
+		smap->dma_result = 0;
+
+		if (ps2sif_callrpc(&smap->cd_smap_rx,SIFNUM_SmapDmaRead,
+				SIF_RPCM_NOWAIT,
+				(void *)&smap->rxdma_request,
+				sizeof(int) * 4,
+				&smap->dma_result, sizeof(u_int32_t),
+				(ps2sif_endfunc_t)smap_rpcend_notify,
+				(void *)&compl) != 0) {
+			if (smap->flags & SMAP_F_PRINT_MSG) {
+				printk("%s:rx intr: callrpc failed, do pio to receive this packet.\n", net_dev->name);
+			}
+			goto smappiorecv;
+		}
+		wait_for_completion(&compl);
+		if (smap->dma_result != 0) {
+			printk("%s: recv: dma break (%d)\n",
+					net_dev->name,smap->dma_result);
+			goto end;
+		}
+
+	} else {
+smappiorecv:
+		spin_lock_irqsave(&smap->spinlock, flags);
+		/* recv from FIFO to memory */
+		WRITE_SMAPREG16(smap,SMAP_RXFIFO_RD_PTR,
+			(u_int16_t)smap->rxdma_request.sdd[0].f_addr);
+		datap = (u_int32_t *)smap->rxbuf;
+		rxlen = smap->rxdma_request.sdd[0].size;
+		for (i = 0; i < rxlen; i += 4) {	/* FIFO -> memory */
+			*datap++ = SMAPREG32(smap,SMAP_RXFIFO_DATA);
+		}
+		spin_unlock_irqrestore(&smap->spinlock, flags);
+		pkt_err = CLEAR;
+		pioflag = SET;
+		validrcvpkt = rcvpkt = 1;
+	}
+	if (smap->flags & SMAP_F_PRINT_PKT) {
+		l_rxbdi = smap->rxbdi;
+		for (i = 0; i < validrcvpkt; i++) {
+			rxbd = &smap->rxbd[l_rxbdi];
+			printk("%s: rx: fifo->mem done,"
+				"[%d]=stat=0x%04x,len=%d,ptr=0x%04x\n",
+				net_dev->name,l_rxbdi,INW(&rxbd->ctrl_stat),
+				INW(&rxbd->length),INW(&rxbd->pointer));
+			if (pioflag) {
+				rxbp = smap->rxbuf;
+			} else {
+				rxbp = (u_int8_t *)(smap->rxdma_request.sdd[i].i_addr);
+			}
+			smap_dump_packet(smap, rxbp, (INW(&rxbd->length) < 60) ? INW(&rxbd->length) : 60);
+			SMAP_BD_NEXT(l_rxbdi);
+		}
+	}
+#if 1	/*XXX*//* it may be able to delete this clause if 2.4 */
+	{
+	/*
+	 * eth_copy_and_sum() expects that ETH_P_IP packet has
+	 * 34 or more bytes in "length" argument unconditionally.
+	 */
+		for (i = 0; i < rcvpkt; i++) {
+			struct ethhdr *eth;
+			if (pkt_err & (1 << i))
+				continue;
+			if (pioflag) {
+				rxbp = smap->rxbuf;
+			} else {
+				rxbp = (u_int8_t *)(smap->rxdma_request.sdd[i].i_addr);
+			}
+			eth = (struct ethhdr *)rxbp;
+			pkt_len = smap->rxdma_request.sdd[i].sdd_misc;
+			if ( (eth->h_proto == htons(ETH_P_IP)) &&
+						(pkt_len < 14 + 20) ) {
+				if (smap->flags & SMAP_F_PRINT_MSG) {
+					printk("%s:rx intr(%d): IP packet len(%d) error\n",
+						net_dev->name, i, pkt_len);
+				}
+				pkt_err |= (1 << i);
+			}
+		}
+	}
+#endif
+	for (i = 0; i < rcvpkt; i++) {
+		if (pkt_err & (1 << i))
+			continue;
+		if (pioflag) {
+			rxbp = smap->rxbuf;
+		} else {
+			rxbp = (u_int8_t *)(smap->rxdma_request.sdd[i].i_addr);
+		}
+		pkt_len = smap->rxdma_request.sdd[i].sdd_misc;
+
+		skb = dev_alloc_skb(pkt_len + 2);
+		if (skb == NULL) {
+			printk("%s:rx intr(%d): skb alloc error\n",
+						net_dev->name, i);
+			break;
+		}
+		skb_reserve(skb, 2);	/* 16 byte align the data fields */
+#if 1
+		eth_copy_and_sum(skb, rxbp, pkt_len, 0);
+		skb_put(skb, pkt_len);
+#else
+		memcpy(skb_put(skb, pkt_len), rxbp, pkt_len);
+#endif
+		skb->dev = net_dev;
+		skb->protocol = eth_type_trans(skb, net_dev);
+		net_dev->last_rx = jiffies;
+		netif_rx(skb);
+	}
+
+end:
+	spin_lock_irqsave(&smap->spinlock, flags);
+	rxbd = &smap->rxbd[smap->rxbdi];
+	for (i = 0; i < rcvpkt; i++) {
+		WRITE_SMAPREG8(smap,SMAP_RXFIFO_FRAME_DEC, 1);
+
+		if (pkt_err & (1 << i)) {
+			smap->net_stats.rx_errors++;
+		} else {
+			smap->net_stats.rx_packets++;
+			smap->net_stats.rx_bytes += smap->rxdma_request.sdd[i].sdd_misc;
+		}
+
+		/* renew rxbd */
+#if 0
+		OUTW(0, &rxbd->length);
+		OUTW(0, &rxbd->pointer);
+#endif
+		OUTW(SMAP_BD_RX_EMPTY, &rxbd->ctrl_stat);
+
+		/* renew buffer descriptor */
+		SMAP_BD_NEXT(smap->rxbdi);
+		rxbd = &smap->rxbd[smap->rxbdi];
+	}
+
+	if ((smap->flags & SMAP_F_RXDNV_DISABLE) && (rcvpkt > 0)) {
+		smap->flags &= ~SMAP_F_RXDNV_DISABLE;
+		WRITE_SMAPREG16(smap, SMAP_INTR_ENABLE,
+				SMAPREG16(smap,SMAP_INTR_ENABLE) | INTR_RXDNV);
+		WRITE_SMAPREG16(smap, SMAP_INTR_CLR, INTR_RXDNV);
+	}
+
+	smap->rxicnt--;
+	spin_unlock_irqrestore(&smap->spinlock, flags);
+
+	return;
+}
+
+static void
+smap_emac3_intr(struct net_device *net_dev)
+{
+	struct smap_chan *smap = netdev_priv(net_dev);
+	u_int32_t stat, ena;
+
+	stat = EMAC3REG_READ(smap, SMAP_EMAC3_INTR_STAT);
+	ena = EMAC3REG_READ(smap, SMAP_EMAC3_INTR_ENABLE);
+
+	/* clear emac3 interrupt */
+	EMAC3REG_WRITE(smap, SMAP_EMAC3_INTR_STAT, stat);
+
+	stat &= (ena|E3_DEAD_ALL);
+	if (stat & E3_INTR_OVERRUN) {		/* this bit does NOT WORKED */
+		if (smap->flags & SMAP_F_PRINT_MSG) {
+			printk("%s:emac3 intr: rx overrun\n", net_dev->name);
+		}
+	}
+	if (stat & E3_INTR_PF) {
+		if (smap->flags & SMAP_F_PRINT_MSG) {
+			printk("%s:emac3 intr: rx pause frame\n",net_dev->name);
+		}
+	}
+	if (stat & E3_INTR_BAD_FRAME) {
+		if (smap->flags & SMAP_F_PRINT_MSG) {
+			printk("%s:emac3 intr: rx bad frame\n", net_dev->name);
+		}
+	}
+	if (stat & E3_INTR_RUNT_FRAME) {
+		if (smap->flags & SMAP_F_PRINT_MSG) {
+			printk("%s:emac3 intr: rx runt frame\n", net_dev->name);
+		}
+	}
+	if (stat & E3_INTR_SHORT_EVENT) {
+		if (smap->flags & SMAP_F_PRINT_MSG) {
+			printk("%s:emac3 intr: rx short event\n",net_dev->name);
+		}
+	}
+	if (stat & E3_INTR_ALIGN_ERR) {
+		if (smap->flags & SMAP_F_PRINT_MSG) {
+			printk("%s:emac3 intr: rx alignment error\n", net_dev->name);
+		}
+	}
+	if (stat & E3_INTR_BAD_FCS) {
+		if (smap->flags & SMAP_F_PRINT_MSG) {
+			printk("%s:emac3 intr: rx bad FCS\n", net_dev->name);
+		}
+	}
+	if (stat & E3_INTR_TOO_LONG) {
+		if (smap->flags & SMAP_F_PRINT_MSG) {
+			printk("%s:emac3 intr: rx frame too long\n", net_dev->name);
+		}
+	}
+	if (stat & E3_INTR_OUT_RANGE_ERR) {
+		if (smap->flags & SMAP_F_PRINT_MSG) {
+			printk("%s:emac3 intr: rx out range error\n", net_dev->name);
+		}
+	}
+	if (stat & E3_INTR_IN_RANGE_ERR) {
+		if (smap->flags & SMAP_F_PRINT_MSG) {
+			printk("%s:emac3 intr: rx in range error\n", net_dev->name);
+		}
+	}
+
+	if (stat & E3_INTR_DEAD_DEPEND) {
+		if (smap->flags & SMAP_F_PRINT_MSG) {
+			printk("%s:emac3 intr: tx dead in dependent mode\n", net_dev->name);
+		}
+	}
+	if (stat & E3_INTR_DEAD_0) {
+		if (smap->flags & SMAP_F_PRINT_MSG) {
+			printk("%s:emac3 intr: tx dead in channel 0\n", net_dev->name);
+		}
+	}
+	if (stat & E3_INTR_SQE_ERR_0) {
+		if (smap->flags & SMAP_F_PRINT_MSG) {
+			printk("%s:emac3 intr: tx sqe test error in channel 0\n", net_dev->name);
+		}
+	}
+	if (stat & E3_INTR_TX_ERR_0) {
+		if (smap->flags & SMAP_F_PRINT_MSG) {
+			printk("%s:emac3 intr: tx transmit error in channel 0\n", net_dev->name);
+		}
+	}
+	if (stat & E3_INTR_DEAD_1) {
+		if (smap->flags & SMAP_F_PRINT_MSG) {
+			printk("%s:emac3 intr: tx dead in channel 1\n", net_dev->name);
+		}
+	}
+	if (stat & E3_INTR_SQE_ERR_1) {
+		if (smap->flags & SMAP_F_PRINT_MSG) {
+			printk("%s:emac3 intr: tx sqe test error in channel 1\n", net_dev->name);
+		}
+	}
+	if (stat & E3_INTR_TX_ERR_1) {
+		if (smap->flags & SMAP_F_PRINT_MSG) {
+			printk("%s:emac3 intr: tx transmit error in channel 1\n", net_dev->name);
+		}
+	}
+	if (stat & E3_INTR_MMAOP_FAIL) {
+		if (smap->flags & SMAP_F_PRINT_MSG) {
+			printk("%s:emac3 intr: phy operation failed\n", net_dev->name);
+		}
+	}
+
+	return;
+}
+
+static irqreturn_t smap_interrupt(int irq, void *dev_id)
+{
+	struct net_device *net_dev = (struct net_device *)dev_id;
+	struct smap_chan *smap = netdev_priv(net_dev);
+	unsigned long flags;
+	u_int16_t stat, ena;
+
+	spin_lock_irqsave(&smap->spinlock, flags);
+
+	stat = SMAPREG16(smap,SMAP_INTR_STAT) & INTR_BITMSK;
+	ena =  SMAPREG16(smap,SMAP_INTR_ENABLE) & INTR_BITMSK;
+	stat &= ena;
+	if (stat == 0)
+		goto end;
+
+	if (stat & INTR_TXDNV) {
+		/* disable TXDNV interrupt */
+		WRITE_SMAPREG16(smap, SMAP_INTR_ENABLE,
+			SMAPREG16(smap, SMAP_INTR_ENABLE) & ~INTR_TXDNV);
+		smap->flags |= SMAP_F_TXDNV_DISABLE;
+		/* clear interrupt */
+		WRITE_SMAPREG16(smap, SMAP_INTR_CLR, INTR_TXDNV);
+
+		smap->txicnt++;
+		wake_up_interruptible(&smap->wait_smaprun);
+		EMAC3REG_WRITE(smap, SMAP_EMAC3_INTR_STAT, E3_DEAD_ALL);
+	}
+	if (stat & INTR_RXDNV) {
+		/* disable RXDNV interrupt */
+		WRITE_SMAPREG16(smap,SMAP_INTR_ENABLE,
+			SMAPREG16(smap, SMAP_INTR_ENABLE) & ~INTR_RXDNV);
+		smap->flags |= SMAP_F_RXDNV_DISABLE;
+		/* clear interrupt */
+		WRITE_SMAPREG16(smap, SMAP_INTR_CLR, INTR_RXDNV);
+
+		if (smap->flags & SMAP_F_PRINT_MSG) {
+			printk("%s: intr: RX desc not valid\n",net_dev->name);
+		}
+		smap->rxicnt++;
+		wake_up_interruptible(&smap->wait_smaprun);
+	}
+	if (stat & INTR_TXEND) {
+		WRITE_SMAPREG16(smap, SMAP_INTR_CLR, INTR_TXEND);
+		/* workaround for race condition of TxEND/RxEND */
+		if (SMAPREG8(smap,SMAP_RXFIFO_FRAME_CNT) > 0) {
+			smap->rxicnt++;
+		}
+		smap->txicnt++;
+		wake_up_interruptible(&smap->wait_smaprun);
+	}
+	if (stat & INTR_RXEND) {
+		WRITE_SMAPREG16(smap, SMAP_INTR_CLR, INTR_RXEND);
+		/* workaround for race condition of TxEND/RxEND */
+		if ((smap->txbdusedcnt > 0) &&
+		    (smap->txbdusedcnt > SMAPREG8(smap,SMAP_TXFIFO_FRAME_CNT))
+		   ) {
+			smap->txicnt++;
+		}
+		smap->rxicnt++;
+		wake_up_interruptible(&smap->wait_smaprun);
+	}
+	if (stat & INTR_EMAC3) {
+		(void)smap_emac3_intr(net_dev);
+	}
+end:
+	spin_unlock_irqrestore(&smap->spinlock, flags);
+	return IRQ_HANDLED;
+}
+
+/*--------------------------------------------------------------------------*/
+
+#define	POLY32	0x04C11DB7
+
+static u_int8_t
+smap_bitrev(u_int8_t val)
+{
+	int i;
+	u_int8_t ret = 0;
+
+	for (i = 0; i < 8; i++) {
+		ret <<= 1;
+		ret |= (val & 0x01) ? 1 : 0;
+		val >>= 1;
+	}
+	return(ret);
+}
+
+static u_int32_t
+smap_crc32(u_int32_t crcval, u_int8_t cval)
+{
+	int i;
+
+	crcval ^= cval << 24;
+	for (i = 0; i < 8; i++) {
+		crcval = crcval & 0x80000000 ? (crcval << 1) ^ POLY32 : crcval << 1;
+	}
+
+	return(crcval);
+}
+
+static u_int32_t
+smap_calc_crc32(struct smap_chan *smap, u_int8_t *addr)
+{
+	int i;
+	u_int32_t crc;
+
+	crc = 0xFFFFFFFF;
+	for (i = 0; i < ETH_ALEN; i++)
+		crc = smap_crc32(crc, smap_bitrev(*addr++));
+
+	return(crc ^ 0xFFFFFFFF);
+}
+
+static int
+smap_store_new_mc_list(struct smap_chan *smap)
+{
+	struct net_device *net_dev = smap->net_dev;
+	struct netdev_hw_addr *ha;
+	int idx, reg, bit, sethtbl = 0;
+	u_int32_t val[4];
+
+	/* clear HW gourp list */
+	EMAC3REG_WRITE(smap, SMAP_EMAC3_GROUP_HASH1, 0x0);
+	EMAC3REG_WRITE(smap, SMAP_EMAC3_GROUP_HASH2, 0x0);
+	EMAC3REG_WRITE(smap, SMAP_EMAC3_GROUP_HASH3, 0x0);
+	EMAC3REG_WRITE(smap, SMAP_EMAC3_GROUP_HASH4, 0x0);
+	val[0] = val[1] = val[2] = val[3] = 0;
+
+	netdev_for_each_mc_addr(ha, net_dev) {
+		/* set new HW group list */
+
+		if ((ha->addr[0]&0x1) == 0)
+			continue;
+#if 0 // TBD: Check what is needed here.
+		if (ha->type != NETDEV_HW_ADDR_T_MULTICAST)
+			continue;
+#endif
+		idx = smap_calc_crc32(smap, ha->addr);
+		idx = (idx >> 26) & 0x3f;
+		reg = idx/16;
+		bit = 15 - (idx%16);
+		val[reg] |= (1 << bit);
+		sethtbl = 1;
+	}
+	if (sethtbl) {
+		/* set HW group list */
+		EMAC3REG_WRITE(smap, SMAP_EMAC3_GROUP_HASH1, val[0]);
+		EMAC3REG_WRITE(smap, SMAP_EMAC3_GROUP_HASH2, val[1]);
+		EMAC3REG_WRITE(smap, SMAP_EMAC3_GROUP_HASH3, val[2]);
+		EMAC3REG_WRITE(smap, SMAP_EMAC3_GROUP_HASH4, val[3]);
+	}
+	return(sethtbl);
+}
+
+static void
+smap_multicast_list(struct net_device *net_dev)
+{
+	struct smap_chan *smap = netdev_priv(net_dev);
+	u_int32_t e3v;
+
+	/* stop tx/rx */
+	(void)smap_txrx_XXable(smap, DISABLE);
+
+	/* disable promisc, all multi, indvi hash and group hash mode */
+	e3v = EMAC3REG_READ(smap, SMAP_EMAC3_RxMODE);
+	e3v &= ~(E3_RX_PROMISC|E3_RX_PROMISC_MCAST|E3_RX_INDIVID_HASH|E3_RX_MCAST);
+	EMAC3REG_WRITE(smap, SMAP_EMAC3_RxMODE, e3v);
+
+	if (net_dev->flags & IFF_PROMISC) {
+		e3v |= E3_RX_PROMISC;
+	} else if (net_dev->flags & IFF_ALLMULTI) {
+		e3v |= E3_RX_PROMISC_MCAST;
+	} else if (netdev_mc_count(net_dev) == 0) {
+	    /* Nothing to do, because INDIVID_ADDR & BCAST are already set */
+	} else {
+		if (smap_store_new_mc_list(smap))
+			e3v |= E3_RX_MCAST;
+	}
+
+	/* set RxMODE register */
+	EMAC3REG_WRITE(smap, SMAP_EMAC3_RxMODE, e3v);
+
+	/* start tx/rx */
+	(void)smap_txrx_XXable(smap, ENABLE);
+
+	return;
+}
+
+/*--------------------------------------------------------------------------*/
+
+static struct net_device_stats *
+smap_get_stats(struct net_device *net_dev)
+{
+	struct smap_chan *smap = netdev_priv(net_dev);
+
+	return(&smap->net_stats);
+}
+
+static int
+smap_open(struct net_device *net_dev)
+{
+	struct smap_chan *smap = netdev_priv(net_dev);
+	int r;
+
+	if (smap->flags & SMAP_F_PRINT_MSG) {
+		printk("%s: PlayStation 2 SMAP open\n", net_dev->name);
+	}
+
+	for (r = 22 * 5; r; r--) {
+		if ( (smap->flags & SMAP_F_LINKVALID) &&
+		     (smap->flags & SMAP_F_INITDONE) )
+			break;
+		interruptible_sleep_on_timeout(&smap->wait_linkvalid, HZ/5);
+	}
+	if (!((smap->flags & SMAP_F_LINKVALID) &&
+				(smap->flags & SMAP_F_INITDONE))) {
+		printk("%s: link not valid\n", net_dev->name);
+		return(-EPERM);
+	}
+	if (smap->flags & SMAP_F_OPENED) {
+		printk("%s: already opend\n", net_dev->name);
+		return(-EBUSY);
+	}
+	(void)smap_fifo_reset(smap);
+	(void)smap_emac3_re_init(smap);
+	(void)smap_txbd_init(smap);
+	(void)smap_rxbd_init(smap);
+
+	if (smap->irq == 0) {
+		printk("%s: invalid irq\n", net_dev->name);
+		return(-ENODEV);
+	}
+	r = request_irq(smap->irq, smap_interrupt, IRQF_SHARED,
+					"PlayStation 2 Ethernet", net_dev);
+	if (r) {
+		printk("%s: re-try request_irq(now error=%d)\n",
+							net_dev->name,r);
+		r = request_irq(smap->irq, smap_interrupt, IRQF_SHARED,
+					"PlayStation 2 Ethernet", net_dev);
+		if (r) {
+			printk("%s: request_irq error(%d)\n", net_dev->name,r);
+			return(-ENODEV);
+		}
+	}
+
+	(void)smap_skb_queue_init(smap, &smap->txqueue);
+	smap->txicnt = smap->rxicnt = 0;
+
+	(void)smap_clear_all_interrupt(smap);
+	(void)smap_interrupt_XXable(smap, ENABLE);
+
+	(void)smap_txrx_XXable(smap, ENABLE);
+
+	netif_start_queue(net_dev);
+
+	smap->flags |= SMAP_F_OPENED;
+
+	return(0);	/* success */
+}
+
+static int
+smap_close(struct net_device *net_dev)
+{
+	struct smap_chan *smap = netdev_priv(net_dev);
+	unsigned long flags;
+	struct completion compl;
+
+	if (smap->flags & SMAP_F_PRINT_MSG) {
+		printk("%s: PlayStation 2 SMAP close\n", net_dev->name);
+	}
+
+	if ((smap->flags & SMAP_F_OPENED) == 0) {
+		printk("PlayStation 2 SMAP: not opened\n");
+		return(-EINVAL);
+	}
+
+	spin_lock_irqsave(&smap->spinlock, flags);
+	smap->flags &= ~SMAP_F_OPENED;
+
+	if (smap->txqueue.qlen > 0) {
+		init_completion(&compl);
+		smap->tx_qpkt_compl = &compl;
+		wake_up_interruptible(&smap->wait_smaprun);
+		spin_unlock_irqrestore(&smap->spinlock, flags);
+
+		/* wait packet sending done */
+		wait_for_completion(&compl);
+		smap->tx_qpkt_compl = NULL;
+	} else {
+		spin_unlock_irqrestore(&smap->spinlock, flags);
+	}
+
+	netif_stop_queue(net_dev);
+
+	/* stop DMA */
+	(void)smap_dma_force_break(smap);
+
+	(void)smap_skb_queue_clear(smap, &smap->txqueue);
+
+	(void)smap_txrx_XXable(smap, DISABLE);
+
+	(void)smap_interrupt_XXable(smap, DISABLE);
+	(void)smap_clear_all_interrupt(smap);
+	smap->txicnt = smap->rxicnt = 0;
+
+	(void)free_irq(smap->irq, net_dev);
+
+	return(0);	/* success */
+}
+
+/*--------------------------------------------------------------------------*/
+static inline int *if_prntmode(struct ifreq *rq)
+{
+	return (int *) &rq->ifr_ifru;
+}
+
+static int
+smap_ioctl(struct net_device *net_dev, struct ifreq *ifr, int cmd)
+{
+	struct smap_chan *smap = netdev_priv(net_dev);
+	struct mii_ioctl_data *miidata =(struct mii_ioctl_data *)&ifr->ifr_data;
+	int retval = 0;
+
+	switch (cmd) {
+	case SIOCGMIIPHY:
+		miidata = if_mii(ifr);
+		if (!miidata)
+			return -EINVAL;
+
+		miidata->phy_id = DsPHYTER_ADDRESS;
+		break;
+
+	case SIOCGMIIREG:
+		miidata->val_out = (u_short)smap_read_phy(smap,
+						miidata->phy_id & 0x1f,
+						miidata->reg_num & 0x1f);
+		break;
+
+#if 0
+	case SIOCSMIIREG:
+		if (!capable(CAP_NET_ADMIN)) {
+			printk("%s: SIOCSMIIREG: not available.\n", net_dev->name);
+			retval = -EPERM;
+			break;
+		}
+		(void)smap_write_phy(smap, miidata->phy_id & 0x1f,
+				miidata->reg_num & 0x1f, miidata->val_in);
+		break;
+#endif
+
+	case SMAP_IOC_PRTMODE:
+	{
+		u_int16_t phyval = 0;
+
+		if (ifr == NULL) {
+			printk("%s: ifr is NULL\n", net_dev->name);
+			retval = -EINVAL;
+			break;
+		}
+
+		phyval = (u_int16_t)smap_read_phy(smap,
+					DsPHYTER_ADDRESS, DsPHYTER_BMSR);
+		if (phyval == (u_int16_t)-1) {
+			printk("%s: read phy error\n", net_dev->name);
+			retval = -EBUSY;
+			break;
+		}
+		if (!(phyval & PHY_BMSR_LINK)) {
+			printk("%s: link not valid(0x%04x)\n",
+							net_dev->name, phyval);
+		} else {
+			u_int16_t anar = 0;
+			u_int16_t anlpar = 0;
+
+			anar = (u_int16_t)smap_read_phy(smap,
+					DsPHYTER_ADDRESS, DsPHYTER_ANAR);
+			anlpar = (u_int16_t)smap_read_phy(smap,
+					DsPHYTER_ADDRESS, DsPHYTER_ANLPAR);
+
+			smap->flags &= ~(SMAP_F_SPD_100M|SMAP_F_DUP_FULL);
+			if (anar & anlpar & (PHY_ANAR_100FD|PHY_ANAR_100HD))
+				smap->flags |= SMAP_F_SPD_100M;
+			if (anar & anlpar & (PHY_ANAR_100FD|PHY_ANAR_10FD))
+				smap->flags |= SMAP_F_DUP_FULL;
+
+			printk("%s: %s: speed=%s, dupmode=%s.\n",
+				net_dev->name,
+				(phyval & PHY_BMSR_ANCP) ?
+					"Auto-Negotiation" : "force mode",
+				(smap->flags & SMAP_F_SPD_100M) ? "100Mbps" : "10Mbps",
+				(smap->flags & SMAP_F_DUP_FULL) ? "FDX" : "HDX");
+		}
+		*(if_prntmode(ifr)) = (int)phyval;
+	}
+		break;
+
+	case SMAP_IOC_DUMPREG:
+		(void)smap_dump_reg(smap);
+		(void)smap_dump_emac3_reg(smap);
+		break;
+
+	case SMAP_IOC_DUMPBD:
+		(void)smap_dump_txbd(smap);
+		(void)smap_dump_rxbd(smap);
+		break;
+
+	case SMAP_IOC_DUMPFLAG:
+		printk("%s: flags = 0x%08x, txmode_val = 0x%08x\n",
+				net_dev->name, smap->flags, smap->txmode_val);
+		break;
+
+	case SMAP_IOC_DUMPPHYSTAT:
+		printk("%s: PHY ID1 = 0x%04x(0x%04x), ID2 = 0x%04x(0x%04x),"
+			" BMSR = 0x%04x\n",
+			net_dev->name,
+			smap_read_phy(smap, DsPHYTER_ADDRESS,DsPHYTER_PHYIDR1),
+			PHY_IDR1_VAL,
+			smap_read_phy(smap, DsPHYTER_ADDRESS,DsPHYTER_PHYIDR2),
+			PHY_IDR2_VAL,
+			smap_read_phy(smap, DsPHYTER_ADDRESS,DsPHYTER_BMSR));
+		break;
+
+	case SMAP_IOC_PRINT_MSG:
+		if (ifr == NULL) {
+			printk("%s: ifr is NULL\n", net_dev->name);
+			retval = -EINVAL;
+			break;
+		}
+		if (*(if_prntmode(ifr)) != 0)
+			smap->flags |= SMAP_F_PRINT_MSG;
+		else
+			smap->flags &= ~SMAP_F_PRINT_MSG;
+		break;
+
+	case SMAP_IOC_DUMP_PKT:
+		if (ifr == NULL) {
+			printk("%s: ifr is NULL\n", net_dev->name);
+			retval = -EINVAL;
+			break;
+		}
+		if (*(if_prntmode(ifr)) != 0)
+			smap->flags |= SMAP_F_PRINT_PKT;
+		else
+			smap->flags &= ~SMAP_F_PRINT_PKT;
+		break;
+
+	default:
+		retval = -EOPNOTSUPP;
+		break;
+	}
+
+	return(retval);
+}
+
+#ifdef HAVE_TX_TIMEOUT
+static void
+smap_tx_timeout(struct net_device *net_dev)
+{
+	struct smap_chan *smap = netdev_priv(net_dev);
+
+#if 0
+	/* this entry point function is called when queue is stopped. */
+	netif_stop_queue(net_dev);
+#endif
+	wake_up_interruptible(&smap->wait_timeout);
+
+	return;
+}
+
+static int
+smap_timeout_thread(void *arg)
+{
+	struct smap_chan *smap = (struct smap_chan *)arg;
+	struct net_device *net_dev = (struct net_device *)smap->net_dev;
+	unsigned long flags;
+	sigset_t blocked, oldset;
+
+	siginitsetinv(&blocked, sigmask(SIGKILL)|sigmask(SIGINT)|sigmask(SIGTERM));
+	sigprocmask(SIG_SETMASK, &blocked, &oldset);
+
+	daemonize("smap timeout");
+
+	smap->timeout_task = current;
+
+	while(1) {
+		interruptible_sleep_on(&smap->wait_timeout);
+		if (signal_pending(current))
+			break;
+
+		printk("%s: tx timeout ticks = %ld\n",
+		       net_dev->name, jiffies - net_dev->trans_start);
+
+#if 1
+		/* for confirmation */
+		netif_stop_queue(net_dev);
+#endif
+		smap->flags &= ~(SMAP_F_LINKESTABLISH|SMAP_F_LINKVALID);
+		netif_carrier_off(net_dev);
+		(void)smap_dma_force_break(smap);
+		(void)smap_reset(smap, RESET_INIT);
+		(void)smap_txrx_XXable(smap, DISABLE);
+		netif_carrier_on(net_dev);
+		(void)smap_txbd_init(smap);
+		(void)smap_rxbd_init(smap);
+		(void)smap_clear_all_interrupt(smap);
+		(void)smap_interrupt_XXable(smap, ENABLE);
+		(void)smap_txrx_XXable(smap, ENABLE);
+		(void)smap_multicast_list(smap->net_dev);
+
+		net_dev->trans_start = jiffies;		/* save new timestamp */
+		smap->net_stats.tx_errors++;
+		netif_wake_queue(net_dev);
+	}
+
+	smap->timeout_task = NULL;
+	if (smap->timeout_compl != NULL)
+		complete(smap->timeout_compl);/* notify that we've exited */
+
+	sigprocmask(SIG_SETMASK, &oldset, NULL);
+
+	return(0);
+}
+#endif /* HAVE_TX_TIMEOUT */
+
+/*--------------------------------------------------------------------------*/
+
+static void
+smap_clear_all_interrupt(struct smap_chan *smap)
+{
+	WRITE_SMAPREG16(smap, SMAP_INTR_CLR, INTR_CLR_ALL);
+
+	EMAC3REG_WRITE(smap, SMAP_EMAC3_INTR_STAT, E3_INTR_ALL);
+
+	return;
+}
+
+static void
+smap_interrupt_XXable(struct smap_chan *smap, int enable_flag)
+{
+	if (enable_flag) {
+		/* enable interrupt */
+		WRITE_SMAPREG16(smap, SMAP_INTR_ENABLE,
+			SMAPREG16(smap, SMAP_INTR_ENABLE) | INTR_ENA_ALL);
+		EMAC3REG_WRITE(smap, SMAP_EMAC3_INTR_ENABLE, E3_INTR_ALL);
+	} else {
+		/* disable interrupt */
+		WRITE_SMAPREG16(smap,SMAP_INTR_ENABLE,
+			SMAPREG16(smap,SMAP_INTR_ENABLE) & ~INTR_ENA_ALL);
+		EMAC3REG_WRITE(smap, SMAP_EMAC3_INTR_ENABLE, 0);
+	}
+	return;
+}
+
+static void
+smap_txrx_XXable(struct smap_chan *smap, int enable_flag)
+{
+	int i;
+	u_int32_t e3v;
+
+	if (enable_flag) {
+		/* enable tx/rx */
+		EMAC3REG_WRITE(smap, SMAP_EMAC3_MODE0,
+					E3_TXMAC_ENABLE|E3_RXMAC_ENABLE);
+	} else {
+		/* disable tx/rx */
+		e3v = EMAC3REG_READ(smap, SMAP_EMAC3_MODE0);
+		e3v &= ~(E3_TXMAC_ENABLE|E3_RXMAC_ENABLE);
+		EMAC3REG_WRITE(smap, SMAP_EMAC3_MODE0, e3v);
+
+		/* check EMAC3 idle status */
+		for (i = SMAP_LOOP_COUNT; i; i--) {
+			e3v = EMAC3REG_READ(smap, SMAP_EMAC3_MODE0);
+			if ( (e3v & E3_RXMAC_IDLE) && (e3v & E3_TXMAC_IDLE) )
+				break;
+		}
+		if (i == 0) {
+			printk("%s: emac3 is still running(%x).\n",
+					smap->net_dev->name, e3v);
+		}
+	}
+	return;
+}
+
+static void
+smap_txbd_init(struct smap_chan *smap)
+{
+	int i;
+	unsigned long flags;
+	volatile struct smapbd *bd = smap->txbd;
+
+	spin_lock_irqsave(&smap->spinlock, flags);
+	smap->txfreebufsize = SMAP_TXBUFSIZE;
+	smap->txbwp = SMAP_TXBUFBASE;
+	smap->txbds = smap->txbdi = smap->txbdusedcnt = 0;
+	for (i = 0; i < SMAP_BD_MAX_ENTRY; i++, bd++) {
+		OUTW(0, &bd->ctrl_stat);		/* clear ready bit */
+		OUTW(0, &bd->reserved);		/* must be zero */
+		OUTW(0, &bd->length);
+		OUTW(0, &bd->pointer);
+	}
+	spin_unlock_irqrestore(&smap->spinlock, flags);
+	return;
+}
+
+static void
+smap_rxbd_init(struct smap_chan *smap)
+{
+	int i;
+	unsigned long flags;
+	volatile struct smapbd *bd = smap->rxbd;
+
+	spin_lock_irqsave(&smap->spinlock, flags);
+	smap->rxbrp = SMAP_RXBUFBASE;
+	smap->rxbdi = 0;
+	for (i = 0; i < SMAP_BD_MAX_ENTRY; i++, bd++) {
+		OUTW(SMAP_BD_RX_EMPTY, &bd->ctrl_stat);	/* set empty bit */
+		OUTW(0, &bd->reserved);			/* must be zero */
+		OUTW(0, &bd->length);
+		OUTW(0, &bd->pointer);
+	}
+	spin_unlock_irqrestore(&smap->spinlock, flags);
+	return;
+}
+
+static int
+smap_read_phy(struct smap_chan *smap, u_int32_t phyadr, u_int32_t regadr)
+{
+	int i;
+	u_int32_t e3v;
+
+	/* check complete bit */
+	for (i = SMAP_LOOP_COUNT; i; i--) {
+		e3v = EMAC3REG_READ(smap, SMAP_EMAC3_STA_CTRL);
+		if (e3v & E3_PHY_OP_COMP)
+			break;
+	}
+	if (i == 0) {
+		printk("%s: read phy: busy\n", smap->net_dev->name);
+		return(-1);
+	}
+
+	/* write phy address and register address */
+	EMAC3REG_WRITE(smap, SMAP_EMAC3_STA_CTRL,
+			E3_PHY_READ |
+			((phyadr&E3_PHY_ADDR_MSK)<<E3_PHY_ADDR_BITSFT) |
+			(regadr&E3_PHY_REG_ADDR_MSK) );
+
+	/* check complete bit */
+	for (i = SMAP_LOOP_COUNT; i; i--) {
+		e3v = EMAC3REG_READ(smap, SMAP_EMAC3_STA_CTRL);
+		if (e3v & E3_PHY_OP_COMP)
+			break;
+	}
+	if (i == 0) {
+		printk("%s: read phy: write address busy, val = %x\n",
+						smap->net_dev->name, e3v);
+		return(-1);
+	}
+
+	/* workarrund: it may be needed to re-read to get correct phy data */
+	e3v = EMAC3REG_READ(smap, SMAP_EMAC3_STA_CTRL);
+	return(e3v >> E3_PHY_DATA_BITSFT);
+}
+
+static int
+smap_write_phy(struct smap_chan *smap,
+		u_int32_t phyadr, u_int32_t regadr, u_int16_t data)
+{
+	int i;
+	u_int32_t e3v;
+
+	/* check complete bit */
+	for (i = SMAP_LOOP_COUNT; i; i--) {
+		e3v = EMAC3REG_READ(smap, SMAP_EMAC3_STA_CTRL);
+		if (e3v & E3_PHY_OP_COMP)
+			break;
+	}
+	if (i == 0) {
+		printk("%s: write phy: busy\n", smap->net_dev->name);
+		return(-1);
+	}
+
+	/* write data, phy address and register address */
+	e3v = ( ((data&E3_PHY_DATA_MSK)<<E3_PHY_DATA_BITSFT) |
+			E3_PHY_WRITE |
+			((phyadr&E3_PHY_ADDR_MSK)<<E3_PHY_ADDR_BITSFT) |
+			(regadr&E3_PHY_REG_ADDR_MSK) );
+	EMAC3REG_WRITE(smap, SMAP_EMAC3_STA_CTRL, e3v);
+
+	/* check complete bit */
+	for (i = SMAP_LOOP_COUNT; i; i--) {
+		e3v = EMAC3REG_READ(smap, SMAP_EMAC3_STA_CTRL);
+		if (e3v & E3_PHY_OP_COMP)
+			break;
+	}
+	if (i == 0) {
+		printk("%s: write phy: write data busy, val = %x\n",
+						smap->net_dev->name, e3v);
+		return(-1);
+	}
+
+	return(0);
+}
+
+static int
+smap_fifo_reset(struct smap_chan *smap)
+{
+	int i, retval = 0;
+	struct net_device *net_dev = smap->net_dev;
+
+	/* reset TX FIFO */
+	WRITE_SMAPREG8(smap, SMAP_TXFIFO_CTRL, TXFIFO_RESET);
+	/* reset RX FIFO */
+	WRITE_SMAPREG8(smap, SMAP_RXFIFO_CTRL, RXFIFO_RESET);
+
+	/* confirm reset done */
+	for (i = SMAP_LOOP_COUNT; i; i--) {
+		if (!(SMAPREG8(smap,SMAP_TXFIFO_CTRL) & TXFIFO_RESET))
+			break;
+	}
+	if (i == 0) {
+		printk("%s: Txfifo reset is in progress\n", net_dev->name);
+		retval |= 1;
+	}
+
+	for (i = SMAP_LOOP_COUNT; i; i--) {
+		if (!(SMAPREG8(smap,SMAP_RXFIFO_CTRL) & RXFIFO_RESET))
+			break;
+	}
+	if (i == 0) {
+		printk("%s: Rxfifo reset is in progress\n", net_dev->name);
+		retval |= 2;
+	}
+
+	return(retval);
+}
+
+static void
+smap_reg_init(struct smap_chan *smap)
+{
+
+	(void)smap_interrupt_XXable(smap, DISABLE);
+	(void)smap_clear_all_interrupt(smap);
+
+	/* BD mode */
+	WRITE_SMAPREG8(smap, SMAP_BD_MODE, 0);	/* swap */
+
+	/* reset TX/RX FIFO */
+	(void)smap_fifo_reset(smap);
+
+	return;
+}
+
+static int
+smap_emac3_soft_reset(struct smap_chan *smap)
+{
+	int i;
+	u_int32_t e3v;
+
+	EMAC3REG_WRITE(smap, SMAP_EMAC3_MODE0, E3_SOFT_RESET);
+	for (i = SMAP_LOOP_COUNT; i; i--) {
+		e3v = EMAC3REG_READ(smap, SMAP_EMAC3_MODE0);
+		if (!(e3v & E3_SOFT_RESET))
+			break;
+	}
+	if (i == 0) {
+		printk("%s: emac3 reset is in progress\n", smap->net_dev->name);
+		return(-1);
+	}
+	return(0);
+}
+
+static void
+smap_emac3_set_defvalue(struct smap_chan *smap)
+{
+	u_int32_t e3v;
+
+	/* set HW address */
+	e3v = ( (smap->hwaddr[0] << 8) | smap->hwaddr[1] );
+	EMAC3REG_WRITE(smap, SMAP_EMAC3_ADDR_HI, e3v);
+	e3v = ( (smap->hwaddr[2] << 24) | (smap->hwaddr[3] << 16) |
+			(smap->hwaddr[4] << 8) | smap->hwaddr[5] );
+	EMAC3REG_WRITE(smap, SMAP_EMAC3_ADDR_LO, e3v);
+
+	/* Inter-frame GAP */
+	EMAC3REG_WRITE(smap, SMAP_EMAC3_INTER_FRAME_GAP, 4);
+
+	/* Rx mode */
+	e3v = (E3_RX_STRIP_PAD|E3_RX_STRIP_FCS|
+				E3_RX_INDIVID_ADDR|E3_RX_BCAST);
+	EMAC3REG_WRITE(smap, SMAP_EMAC3_RxMODE, e3v);
+
+	/* Tx fifo value for request priority */
+	/* low = 7*8=56, urgent = 15*8=120 */
+	e3v = ( (7<<E3_TX_LOW_REQ_BITSFT) | (15<<E3_TX_URG_REQ_BITSFT) );
+	EMAC3REG_WRITE(smap, SMAP_EMAC3_TxMODE1, e3v);
+
+	/* TX threshold, (12+1)*64=832 */
+	e3v = ((12&E3_TX_THRESHLD_MSK)<<E3_TX_THRESHLD_BITSFT);
+	EMAC3REG_WRITE(smap, SMAP_EMAC3_TX_THRESHOLD, e3v);
+
+	/* Rx watermark, low = 16*8=128, hi = 128*8=1024 */
+	e3v = ( ((16&E3_RX_LO_WATER_MSK)<<E3_RX_LO_WATER_BITSFT) |
+			((128&E3_RX_HI_WATER_MSK)<<E3_RX_HI_WATER_BITSFT) );
+	EMAC3REG_WRITE(smap, SMAP_EMAC3_RX_WATERMARK, e3v);
+
+	return;
+}
+
+static void
+smap_emac3_init(struct smap_chan *smap, int reset_only)
+{
+	/* reset emac3 */
+	(void)smap_emac3_soft_reset(smap);
+
+	/* EMAC3 operating MODE */
+	EMAC3REG_WRITE(smap, SMAP_EMAC3_MODE1, SMAP_EMAC3_MODE1_DEF);
+
+	/* phy init */
+	if (smap_phy_init(smap, reset_only) < 0) {
+		printk("%s: phy init error\n", smap->net_dev->name);
+		return;
+	}
+	if (reset_only)		/* this flag may be set when unloading */
+		return;
+
+	/* clear interrupt */
+	(void)smap_clear_all_interrupt(smap);
+	/* disable interrupt */
+	(void)smap_interrupt_XXable(smap, DISABLE);
+
+	/* permanently set to default value */
+	(void)smap_emac3_set_defvalue(smap);
+
+	return;
+}
+
+static void
+smap_emac3_re_init(struct smap_chan *smap)
+{
+	(void)smap_emac3_soft_reset(smap);
+	EMAC3REG_WRITE(smap, SMAP_EMAC3_MODE1, smap->txmode_val);
+	(void)smap_emac3_set_defvalue(smap);
+	return;
+}
+
+/* return value 0: success, <0: error */
+static int
+smap_phy_init(struct smap_chan *smap, int reset_only)
+{
+	int val;
+
+	val = smap_phy_reset(smap);
+	if (val < 0)
+		return val;
+
+	if (reset_only)		/* this flag may be set when unloading */
+		return 0;
+
+	/* auto-negotiation */
+	val = smap_auto_negotiation(smap, ENABLE);
+	if (val == 0) {
+		smap->flags |= SMAP_F_LINKESTABLISH;
+		(void)smap_phy_set_dsp(smap);
+		return(0);	/* auto-negotiation is succeeded */
+	}
+
+	/* force 100Mbps(HDX) or 10Mbps(HDX) */
+	(void)smap_force_spd_100M(smap);
+
+	return(0);
+}
+
+static int
+smap_phy_reset(struct smap_chan *smap)
+{
+	int i;
+	u_int16_t phyval = 0;
+
+	/* set reset bit */
+	smap_write_phy(smap, DsPHYTER_ADDRESS, DsPHYTER_BMCR, PHY_BMCR_RST);
+
+	udelay(300);				/* wait 300us */
+
+	/* confirm reset done */
+	for (i = SMAP_LOOP_COUNT; i; i--) {
+		phyval = (u_int16_t)smap_read_phy(smap,
+					DsPHYTER_ADDRESS, DsPHYTER_BMCR);
+		if (!(phyval & PHY_BMCR_RST))
+			break;
+		udelay(300);
+	}
+	if (i == 0) {
+		printk("%s: PHY reset not complete(BMCR=0x%x)\n",
+					smap->net_dev->name, phyval);
+		return(-1);
+	}
+	return(0);
+}
+
+static int
+smap_auto_negotiation(struct smap_chan *smap, int enable_auto_nego)
+{
+	int i, val;
+
+	if (enable_auto_nego) {
+		/* set auto-negotiation */
+		smap_write_phy(smap, DsPHYTER_ADDRESS, DsPHYTER_BMCR,
+				PHY_BMCR_100M|PHY_BMCR_ANEN|PHY_BMCR_DUPM);
+	}
+
+	val = smap_confirm_auto_negotiation(smap);
+	for (i = SMAP_AUTONEGO_RETRY; i; i--) {
+		if (val < 0) {	/* timeout, error */
+			/* restart auto-negotiation */
+			smap_write_phy(smap, DsPHYTER_ADDRESS, DsPHYTER_BMCR,
+					PHY_BMCR_100M|PHY_BMCR_ANEN|PHY_BMCR_DUPM|PHY_BMCR_RSAN);
+			val = smap_confirm_auto_negotiation(smap);
+		} else
+			break;
+	}
+	if (val == 0)
+		return(0);
+	else
+		return(-1);	/* error */
+}
+
+static int
+smap_confirm_auto_negotiation(struct smap_chan *smap)
+{
+	int i;
+	u_int16_t phyval = 0;
+	u_int16_t anar = 0, anlpar = 0;
+	u_int32_t e3v;
+
+	for (i = SMAP_AUTONEGO_TIMEOUT; i; i--) {
+						/* auto nego timeout is 3s */
+		phyval = (u_int16_t)smap_read_phy(smap,
+					DsPHYTER_ADDRESS, DsPHYTER_BMSR);
+		if (phyval & PHY_BMSR_ANCP)
+			break;
+		interruptible_sleep_on_timeout(&smap->wait_linknego, HZ/100);	/* wait 10ms */
+	}
+	if (i == 0) {
+		printk("%s: Auto-negotiation timeout, not complete(BMSR=%x)\n",
+					smap->net_dev->name, phyval);
+		return(-1);
+	}
+
+	/* auto negotiation completed. */
+	for (i = 3; i; i--) {
+		/* it needs to wait 3 seconds. */
+		interruptible_sleep_on_timeout(&smap->wait_linknego, HZ);
+	}
+
+	/* confirm speed & duplex mode */
+	for (i = SMAP_LOOP_COUNT; i; i--) {
+		phyval = (u_int16_t)smap_read_phy(smap,
+					DsPHYTER_ADDRESS, DsPHYTER_BMSR);
+		if ((phyval & PHY_BMSR_ANCP) && (phyval & PHY_BMSR_LINK))
+			break;
+		udelay(1000);
+	}
+	if (i == 0) {	/* error */
+		printk("%s: Auto-negotiation error?? (BMSR=%x)\n",
+					smap->net_dev->name, phyval);
+		return(-2);
+	}
+
+	anar = (u_int16_t)smap_read_phy(smap,
+			DsPHYTER_ADDRESS, DsPHYTER_ANAR);
+	anlpar = (u_int16_t)smap_read_phy(smap,
+			DsPHYTER_ADDRESS, DsPHYTER_ANLPAR);
+	smap->flags &= ~(SMAP_F_SPD_100M|SMAP_F_DUP_FULL);
+	if (anar & anlpar & (PHY_ANAR_100FD|PHY_ANAR_100HD))
+		smap->flags |= SMAP_F_SPD_100M;
+	if (anar & anlpar & (PHY_ANAR_100FD|PHY_ANAR_10FD))
+		smap->flags |= SMAP_F_DUP_FULL;
+
+	printk("%s: Auto-negotiation complete. %s %s duplex mode.\n",
+			smap->net_dev->name,
+			(smap->flags & SMAP_F_SPD_100M) ? "100Mbps" : "10Mbps",
+			(smap->flags & SMAP_F_DUP_FULL) ? "Full" : "Half");
+	e3v = EMAC3REG_READ(smap, SMAP_EMAC3_MODE1);
+	if (smap->flags & SMAP_F_DUP_FULL) {
+		/* Full duplex mode */
+		e3v |= (E3_FDX_ENABLE|E3_FLOWCTRL_ENABLE|E3_ALLOW_PF);
+	} else {
+		/* Half duplex mode */
+		e3v &= ~(E3_FDX_ENABLE|E3_FLOWCTRL_ENABLE|E3_ALLOW_PF);
+	}
+	e3v &= ~E3_MEDIA_MSK;
+	if (smap->flags & SMAP_F_SPD_100M)
+		e3v |= E3_MEDIA_100M;
+	else
+		e3v |= E3_MEDIA_10M;
+	EMAC3REG_WRITE(smap, SMAP_EMAC3_MODE1, e3v);
+
+	return(0);
+}
+
+static void
+smap_force_spd_100M(struct smap_chan *smap)
+{
+	printk("%s: try 100Mbps Half duplex mode...\n", smap->net_dev->name);
+
+	/* set 100Mbps, half duplex */
+	smap_write_phy(smap, DsPHYTER_ADDRESS, DsPHYTER_BMCR, PHY_BMCR_100M);
+
+	/* delay 2s */
+	smap->flags |= SMAP_F_CHECK_FORCE100M;
+	interruptible_sleep_on_timeout(&smap->wait_linknego, 2*HZ);
+
+	smap_confirm_force_spd((unsigned long)smap);
+
+	return;
+}
+
+static void
+smap_force_spd_10M(struct smap_chan *smap)
+{
+	printk("%s: try 10Mbps Half duplex mode...\n", smap->net_dev->name);
+
+	/* set 10Mbps, half duplex */
+	smap_write_phy(smap, DsPHYTER_ADDRESS, DsPHYTER_BMCR, PHY_BMCR_10M);
+
+	/* delay 2s */
+	smap->flags |= SMAP_F_CHECK_FORCE10M;
+	interruptible_sleep_on_timeout(&smap->wait_linknego, 2*HZ);
+
+	smap_confirm_force_spd((unsigned long)smap);
+
+	return;
+}
+
+static void
+smap_confirm_force_spd(unsigned long arg)
+{
+	struct smap_chan *smap = (struct smap_chan *)arg;
+	int i;
+	u_int16_t phyval = 0;
+	u_int32_t e3v;
+
+	/* confirm link status, wait 1s is needed */
+	for (i = SMAP_FORCEMODE_TIMEOUT; i; i--) {
+		phyval = (u_int16_t)smap_read_phy(smap,
+					DsPHYTER_ADDRESS, DsPHYTER_BMSR);
+		if (phyval & PHY_BMSR_LINK)
+			break;
+		interruptible_sleep_on_timeout(&smap->wait_linknego, HZ/100);	/* wait 10ms */
+	}
+	if (i) {
+validlink:
+		e3v = EMAC3REG_READ(smap, SMAP_EMAC3_MODE1);
+		e3v &= ~(E3_FDX_ENABLE|E3_FLOWCTRL_ENABLE|E3_ALLOW_PF|E3_MEDIA_MSK);
+		if (smap->flags & SMAP_F_CHECK_FORCE100M) {
+			printk("%s: 100Mbps Half duplex mode\n", smap->net_dev->name);
+			e3v |= E3_MEDIA_100M;
+		} else if (smap->flags & SMAP_F_CHECK_FORCE10M) {
+			printk("%s: 10Mbps Half duplex mode\n", smap->net_dev->name);
+			e3v |= E3_MEDIA_10M;
+		}
+		EMAC3REG_WRITE(smap, SMAP_EMAC3_MODE1, e3v);
+		smap->flags &= ~(SMAP_F_CHECK_FORCE100M|SMAP_F_CHECK_FORCE10M);
+		smap->flags |= SMAP_F_LINKESTABLISH;
+		(void)smap_phy_set_dsp(smap);
+		return;			/* success */
+	}
+
+	if (smap->flags & SMAP_F_CHECK_FORCE100M) {
+		smap->flags &= ~SMAP_F_CHECK_FORCE100M;
+		(void)smap_force_spd_10M(smap);
+	} else if (smap->flags & SMAP_F_CHECK_FORCE10M) {
+		smap->flags &= ~SMAP_F_CHECK_FORCE10M;
+		phyval = (u_int16_t)smap_read_phy(smap,
+				DsPHYTER_ADDRESS, DsPHYTER_BMSR);
+		if (phyval & PHY_BMSR_LINK) {
+			/* valid link */
+			smap->flags |= SMAP_F_CHECK_FORCE10M;
+			goto validlink;
+		} else {
+			printk("%s: fail force speed mode."
+				" link not valid.  phystat=0x%04x\n",
+						smap->net_dev->name, phyval);
+		}
+	}
+	return;
+}
+
+static int smap_phy_fcscr_threshold = PHY_FCSCR_THRESHOLD;
+module_param(smap_phy_fcscr_threshold, int, 0);
+MODULE_PARM_DESC(smap_phy_fcscr_threshold,
+		"TBD: Some threshold for detecting 10Mbs or 100Mbs.");
+
+static void
+smap_phy_set_dsp(struct smap_chan *smap)
+{
+	u_int16_t id1, id2, phyval, recr, fcscr;
+
+	if (!(smap->flags & SMAP_F_LINKESTABLISH))  /* link not established */
+		return;
+
+	/* this value is used in emac3 re-init without phy init */
+	smap->txmode_val = EMAC3REG_READ(smap, SMAP_EMAC3_MODE1);
+
+	id1 = (u_int16_t)smap_read_phy(smap, DsPHYTER_ADDRESS,DsPHYTER_PHYIDR1);
+	id2 = (u_int16_t)smap_read_phy(smap, DsPHYTER_ADDRESS,DsPHYTER_PHYIDR2);
+
+	if (!((id1 == PHY_IDR1_VAL) && ((id2&PHY_IDR2_MSK) == PHY_IDR2_VAL))) {
+		smap->flags |= SMAP_F_LINKVALID;
+		return;
+	}
+
+	if (smap->flags & SMAP_F_LINKVALID)
+		return;
+
+{
+	recr = (u_int16_t)smap_read_phy(smap, DsPHYTER_ADDRESS,
+							DsPHYTER_RECR);
+	fcscr = (u_int16_t)smap_read_phy(smap, DsPHYTER_ADDRESS,
+							DsPHYTER_FCSCR);
+	interruptible_sleep_on_timeout(&smap->wait_linknego, HZ/2);
+	recr = (u_int16_t)smap_read_phy(smap, DsPHYTER_ADDRESS,
+							DsPHYTER_RECR);
+	fcscr = (u_int16_t)smap_read_phy(smap, DsPHYTER_ADDRESS,
+							DsPHYTER_FCSCR);
+	if ((recr > 0) || (fcscr > smap_phy_fcscr_threshold)) {
+		printk("%s: detect REL(%d) or FCSL(%d). force 10M HDX mode.\n",
+			smap->net_dev->name, recr, fcscr);
+		/* EMAC3 default operating MODE */
+		EMAC3REG_WRITE(smap, SMAP_EMAC3_MODE1, SMAP_EMAC3_MODE1_DEF);
+		smap->flags &= ~(SMAP_F_LINKESTABLISH|SMAP_F_LINKVALID);
+		(void)smap_force_spd_10M(smap);
+		return;
+	}
+}
+
+	if ((id2&PHY_IDR2_REV_MSK) == 0x0) {
+		smap_write_phy(smap, DsPHYTER_ADDRESS, 0x13, 0x0001);
+		smap_write_phy(smap, DsPHYTER_ADDRESS, 0x19, 0x1898);
+		smap_write_phy(smap, DsPHYTER_ADDRESS, 0x1f, 0x0000);
+		smap_write_phy(smap, DsPHYTER_ADDRESS, 0x1d, 0x5040);
+		smap_write_phy(smap, DsPHYTER_ADDRESS, 0x1e, 0x008c);
+		smap_write_phy(smap, DsPHYTER_ADDRESS, 0x13, 0x0000);
+	}
+	phyval = (u_int16_t)smap_read_phy(smap, DsPHYTER_ADDRESS,
+							DsPHYTER_PHYSTS);
+	if ( (phyval & (PHY_STS_DUPS|PHY_STS_SPDS|PHY_STS_LINK)) ==
+				(PHY_STS_HDX|PHY_STS_10M|PHY_STS_LINK) ) {
+		smap_write_phy(smap, DsPHYTER_ADDRESS, 0x1a, 0x0104);
+	}
+
+	smap->flags |= SMAP_F_LINKVALID;
+	return;
+}
+
+static void
+smap_reset(struct smap_chan *smap, int reset_only)
+{
+	smap_reg_init(smap);
+	smap_emac3_init(smap, reset_only);
+
+	return;
+}
+
+/*--------------------------------------------------------------------------*/
+
+/* 1 clock with putting data */
+static inline void
+smap_eeprom_clock_dataout(struct smap_chan *smap, int val)
+{
+	SMAP_PP_SET_D(smap, val);
+
+	SMAP_PP_CLK_OUT(smap, 0);
+	udelay(1);	/* tDIS */
+
+	SMAP_PP_CLK_OUT(smap, 1);
+	udelay(1);	/* tSKH, tDIH */
+
+	SMAP_PP_CLK_OUT(smap, 0);
+	udelay(1);	/* tSKL */
+}
+
+/* 1 clock with getting data */
+static inline int
+smap_eeprom_clock_datain(struct smap_chan *smap)
+{
+	int r;
+
+	SMAP_PP_SET_D(smap, 0);
+	SMAP_PP_CLK_OUT(smap, 0);
+	udelay(1);	/* tSKL */
+
+	SMAP_PP_CLK_OUT(smap, 1);
+	udelay(1);	/* tSKH, tPD0,1 */
+	r = SMAP_PP_GET_Q(smap);
+
+	SMAP_PP_CLK_OUT(smap, 0);
+	udelay(1);	/* tSKL */
+
+	return(r);
+}
+
+/* put address(6bit) */
+static void
+smap_eeprom_put_addr(struct smap_chan *smap, u_int8_t addr)
+{
+	int i;
+
+	addr &= 0x3f;
+	for (i = 0; i < 6; i++) {
+		smap_eeprom_clock_dataout(smap, (addr & 0x20)?1:0);
+		addr <<= 1;
+	}
+}
+
+/* get data(16bit) */
+static u_int16_t
+smap_eeprom_get_data(struct smap_chan *smap)
+{
+	int i;
+	u_int16_t data = 0;
+
+	for (i = 0; i < 16; i++) {
+		data <<= 1;
+		data |= smap_eeprom_clock_datain(smap);
+	}
+
+	return(data);
+}
+
+/* instruction start(rise S, put start bit, op code) */
+static void
+smap_eeprom_start_op(struct smap_chan *smap, int op)
+{
+	/* set port direction */    
+	WRITE_SMAPREG8(smap, SMAP_PIOPORT_DIR, (PP_SCLK | PP_CSEL | PP_DIN));
+
+	/* rise chip select */
+	SMAP_PP_SET_S(smap, 0);
+	SMAP_PP_SET_D(smap, 0);
+	SMAP_PP_CLK_OUT(smap, 0);
+	udelay(1);	/* tSKS */
+
+	SMAP_PP_SET_S(smap, 1);
+	SMAP_PP_SET_D(smap, 0);
+	SMAP_PP_CLK_OUT(smap, 0);
+	udelay(1);	/* tCSS */
+
+	/* put start bit */
+	smap_eeprom_clock_dataout(smap, 1);
+
+	/* put op code */
+	smap_eeprom_clock_dataout(smap, (op >> 1) & 1);
+	smap_eeprom_clock_dataout(smap, op & 1);
+}
+
+/* chip select low */
+static void
+smap_eeprom_cs_low(struct smap_chan *smap)
+{
+	SMAP_PP_SET_S(smap, 0);
+	SMAP_PP_SET_D(smap, 0);
+	SMAP_PP_CLK_OUT(smap, 0);
+	udelay(2);	/* tSLSH */
+}
+
+/*
+ *   EEPROM instruction
+ */
+/* read instruction */
+static void
+smap_eeprom_exec_read(struct smap_chan *smap,
+					u_int8_t addr, u_int16_t *datap, int n)
+{
+	int i;
+
+	smap_eeprom_start_op(smap, PP_OP_READ);
+	smap_eeprom_put_addr(smap, addr);
+	for (i = 0; i < n; i++) {
+		*datap++ = smap_eeprom_get_data(smap);
+	}
+	smap_eeprom_cs_low(smap);
+}
+
+/*
+ *   read EEPROM
+ */
+static void
+smap_eeprom_read(struct smap_chan *smap, u_int8_t addr, u_int16_t *datap, int n)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&smap->spinlock, flags);
+	smap_eeprom_exec_read(smap, addr, datap, n);
+	spin_unlock_irqrestore(&smap->spinlock, flags);
+}
+
+/*--------------------------------------------------------------------------*/
+
+static void
+smap_print_mac_address(struct smap_chan *smap, u_int8_t *addr)
+{
+	int i;
+
+	printk("%s: MAC address ", smap->net_dev->name);
+	for (i = 0; i < 6; i++) {
+		printk("%02x", addr[i]);
+		if (i != 5)
+			printk(":");
+	}
+	printk("\n");
+	return;
+}
+
+static int
+smap_get_node_addr(struct smap_chan *smap)
+{
+	int i;
+	u_int16_t *macp, cksum, sum = 0;
+
+	macp = (u_int16_t *)smap->hwaddr;
+	smap_eeprom_read(smap, 0x0, macp, 3);
+	smap_eeprom_read(smap, 0x3, &cksum, 1);
+
+	for (i = 0; i < 3; i++) {
+		sum += *macp++;
+	}
+	if (sum != cksum) {
+		printk("%s: MAC address read error\n", smap->net_dev->name);
+		printk("checksum %04x is read from EEPROM, "
+			"and %04x is calculated by mac address read now.\n",
+							cksum, sum);
+		smap_print_mac_address(smap, smap->hwaddr);
+		memset(smap->hwaddr, 0, 6);
+		return(-1);
+	}
+	smap_print_mac_address(smap, smap->hwaddr);
+	if (!smap->net_dev) {
+		printk("%s: net_dev is error(null).\n", smap->net_dev->name);
+		memset(smap->hwaddr, 0, 6);
+		return(-1);
+	}
+	memcpy(smap->net_dev->dev_addr, smap->hwaddr, 6);
+	return(0);
+}
+
+static void
+smap_base_init(struct smap_chan *smap)
+{
+	/* we can access register&BD after this routine returned. */
+
+	smap->base = (volatile u_int8_t *)SMAP_BASE;
+	smap->txbd = (volatile struct smapbd *)(smap->base + SMAP_BD_BASE_TX);
+	smap->rxbd = (volatile struct smapbd *)(smap->base + SMAP_BD_BASE_RX);
+
+	smap->txfreebufsize = SMAP_TXBUFSIZE;
+	smap->txbwp = SMAP_TXBUFBASE;
+	smap->txbds = smap->txbdi = smap->txbdusedcnt = 0;
+
+	smap->rxbrp = SMAP_RXBUFBASE;
+	smap->rxbdi = 0;
+
+	smap->txicnt = smap->rxicnt = 0;
+
+	return;
+}
+
+/*--------------------------------------------------------------------------*/
+
+static void
+smap_dump_packet(struct smap_chan *smap, u_int8_t *ptr, int length)
+{
+	int i;
+
+	printk("%s: dump packet(dump len = %d):\n", smap->net_dev->name, length);
+	for (i = 0; i < length; i++) {
+		printk("%02x", *(ptr + i));
+		if ((i%20)==19)
+			printk("\n");
+		else if ((i%4)==3)
+			printk(" ");
+	}
+	printk("\n");
+	return;
+}
+
+static void
+smap_dump_txbd(struct smap_chan *smap)
+{
+	int i;
+	volatile struct smapbd *bd = smap->txbd;
+
+	printk("Tx Buffer Descriptor\n");
+	for (i = 0; i < SMAP_BD_MAX_ENTRY; i++, bd++) {
+		printk("%02d: stat(0x%04x),rsv(0x%04x),len(%d,0x%04x),ptr(0x%04x), ",
+					i, INW(&bd->ctrl_stat), INW(&bd->reserved),
+					INW(&bd->length), INW(&bd->length), INW(&bd->pointer));
+		if ((i%2)==1)
+			printk("\n");
+	}
+	printk("tx buf w_ptr(0x%04x), free buf size(%d), bd used cnt(%d)\n",
+		smap->txbwp, smap->txfreebufsize, smap->txbdusedcnt);
+	printk("txbds(%d), txbdi(%d)\n", smap->txbds, smap->txbdi);
+}
+
+static void
+smap_dump_rxbd(struct smap_chan *smap)
+{
+	int i;
+	volatile struct smapbd *bd = smap->rxbd;
+
+	printk("Rx Buffer Descriptor\n");
+	for (i = 0; i < SMAP_BD_MAX_ENTRY; i++, bd++) {
+		printk("%02d: stat(0x%04x),rsv(0x%04x),len(%d,0x%04x),ptr(0x%04x), ",
+					i, INW(&bd->ctrl_stat), INW(&bd->reserved),
+					INW(&bd->length), INW(&bd->length), INW(&bd->pointer));
+		if ((i%2)==1)
+			printk("\n");
+	}
+	printk("rx buf r_ptr(0x%04x), rxbdi(%d)\n", smap->rxbrp, smap->rxbdi);
+}
+
+static void
+smap_dump_reg(struct smap_chan *smap)
+{
+	printk("PlayStation 2 SMAP register\n");
+	printk("DMA MODE(0x%02x), BD MODE(0x%02x)\n",
+		SMAPREG8(smap,SMAP_DMA_MODE),SMAPREG8(smap,SMAP_BD_MODE));
+	printk("INTR STAT(0x%04x), ENA(0x%04x)\n",
+		SMAPREG16(smap,SMAP_INTR_STAT),
+		SMAPREG16(smap,SMAP_INTR_ENABLE));
+	printk("TX:CTRL(0x%02x), PTR(0x%04x), SLICE(0x%04x), FRM CNT(0x%02x)\n",
+		SMAPREG8(smap,SMAP_TXFIFO_CTRL),
+		SMAPREG16(smap,SMAP_TXFIFO_WR_PTR),
+		SMAPREG16(smap,SMAP_TXFIFO_DMA_SLICE_CNT),
+		SMAPREG8(smap,SMAP_TXFIFO_FRAME_CNT));
+	printk("RX:CTRL(0x%02x), PTR(0x%04x), SLICE(0x%04x), FRM CNT(0x%02x)\n",
+		SMAPREG8(smap,SMAP_RXFIFO_CTRL),
+		SMAPREG16(smap,SMAP_RXFIFO_RD_PTR),
+		SMAPREG16(smap,SMAP_RXFIFO_DMA_SLICE_CNT),
+		SMAPREG8(smap,SMAP_RXFIFO_FRAME_CNT));
+}
+
+static void
+smap_dump_emac3_reg(struct smap_chan *smap)
+{
+	u_int32_t e3v;
+
+	printk("EMAC3 register\n");
+	e3v = EMAC3REG_READ(smap, SMAP_EMAC3_MODE0);
+	printk("mode0(0x%08x), ", e3v);
+	e3v = EMAC3REG_READ(smap, SMAP_EMAC3_MODE1);
+	printk("mode1(0x%08x)\n", e3v);
+	e3v = EMAC3REG_READ(smap, SMAP_EMAC3_TxMODE0);
+	printk("TXmode0(0x%08x), ", e3v);
+	e3v = EMAC3REG_READ(smap, SMAP_EMAC3_TxMODE1);
+	printk("TXmode1(0x%08x), ", e3v);
+	e3v = EMAC3REG_READ(smap, SMAP_EMAC3_RxMODE);
+	printk("RXmode(0x%08x)\n", e3v);
+	e3v = EMAC3REG_READ(smap, SMAP_EMAC3_INTR_STAT);
+	printk("INTR stat(0x%08x), ", e3v);
+	e3v = EMAC3REG_READ(smap, SMAP_EMAC3_INTR_ENABLE);
+	printk("INTR enable(0x%08x), ", e3v);
+	e3v = EMAC3REG_READ(smap, SMAP_EMAC3_ADDR_HI);
+	printk("addr HI(0x%08x), ", e3v);
+	e3v = EMAC3REG_READ(smap, SMAP_EMAC3_ADDR_LO);
+	printk("LO(0x%08x)\n", e3v);
+	e3v = EMAC3REG_READ(smap, SMAP_EMAC3_VLAN_TPID);
+	printk("vlan TPID(0x%08x), ", e3v);
+	e3v = EMAC3REG_READ(smap, SMAP_EMAC3_VLAN_TCI);
+	printk("vlan TCI(0x%08x), ", e3v);
+	e3v = EMAC3REG_READ(smap, SMAP_EMAC3_PAUSE_TIMER);
+	printk("pause(0x%08x)\n", e3v);
+	e3v = EMAC3REG_READ(smap, SMAP_EMAC3_INDIVID_HASH1);
+	printk("Indivi 1(0x%08x), ", e3v);
+	e3v = EMAC3REG_READ(smap, SMAP_EMAC3_INDIVID_HASH2);
+	printk("2(0x%08x), ", e3v);
+	e3v = EMAC3REG_READ(smap, SMAP_EMAC3_INDIVID_HASH3);
+	printk("3(0x%08x), ", e3v);
+	e3v = EMAC3REG_READ(smap, SMAP_EMAC3_INDIVID_HASH4);
+	printk("4(0x%08x)\n", e3v);
+	e3v = EMAC3REG_READ(smap, SMAP_EMAC3_GROUP_HASH1);
+	printk("Group 1(0x%08x), ", e3v);
+	e3v = EMAC3REG_READ(smap, SMAP_EMAC3_GROUP_HASH2);
+	printk("2(0x%08x), ", e3v);
+	e3v = EMAC3REG_READ(smap, SMAP_EMAC3_GROUP_HASH3);
+	printk("3(0x%08x), ", e3v);
+	e3v = EMAC3REG_READ(smap, SMAP_EMAC3_GROUP_HASH4);
+	printk("4(0x%08x)\n", e3v);
+	e3v = EMAC3REG_READ(smap, SMAP_EMAC3_LAST_SA_HI);
+	printk("LAST SA HI(0x%08x), ", e3v);
+	e3v = EMAC3REG_READ(smap, SMAP_EMAC3_LAST_SA_LO);
+	printk("LO(0x%08x), ", e3v);
+	e3v = EMAC3REG_READ(smap, SMAP_EMAC3_INTER_FRAME_GAP);
+	printk("IFG(0x%08x), ", e3v);
+	e3v = EMAC3REG_READ(smap, SMAP_EMAC3_STA_CTRL);
+	printk("STA ctrl(0x%08x)\n", e3v);
+	e3v = EMAC3REG_READ(smap, SMAP_EMAC3_TX_THRESHOLD);
+	printk("TX threshold(0x%08x), ", e3v);
+	e3v = EMAC3REG_READ(smap, SMAP_EMAC3_RX_WATERMARK);
+	printk("RX watermark(0x%08x)\n", e3v);
+	e3v = EMAC3REG_READ(smap, SMAP_EMAC3_TX_OCTETS);
+	printk("TX octets(0x%08x), ", e3v);
+	e3v = EMAC3REG_READ(smap, SMAP_EMAC3_RX_OCTETS);
+	printk("RX octets(0x%08x)\n", e3v);
+}
+
+/*--------------------------------------------------------------------------*/
+
+static void
+smap_dma_force_break(struct smap_chan *smap)
+{
+	int i, ret;
+	struct net_device *net_dev = smap->net_dev;
+	struct completion compl;
+
+	if ((smap->flags & SMAP_F_DMA_ENABLE) == 0)
+		return;
+
+	init_completion(&compl);
+	if (smap->flags & SMAP_F_DMA_TX_ENABLE) {
+		i = 100;
+		do {
+			if (--i == 0)
+				break;
+			ret = ps2sif_callrpc(&smap->cd_smap_tx_end, 0,
+				SIF_RPCM_NOWAIT, NULL, 0, NULL, 0,
+				(ps2sif_endfunc_t)smap_rpcend_notify,
+				(void *)&compl);
+			switch (ret) {
+			case 0:
+				break;
+			case -SIF_RPCE_SENDP:
+				break;
+			default:
+				printk("%s: TX DMA stop callrpc failed(%d)\n",
+							net_dev->name, ret);
+				break;
+			}
+		} while (ret == -SIF_RPCE_SENDP);
+		if (i == 0) {
+			printk("%s: TX DMA stop callrpc failed2\n",
+								net_dev->name);
+		} else {
+			if (ret == 0) {
+				wait_for_completion(&compl);
+			}
+		}
+	}
+	if (smap->flags & SMAP_F_DMA_RX_ENABLE) {
+		i = 100;
+		do {
+			if (--i == 0)
+				break;
+			ret = ps2sif_callrpc(&smap->cd_smap_rx_end, 0,
+				SIF_RPCM_NOWAIT, NULL, 0, NULL, 0,
+				(ps2sif_endfunc_t)smap_rpcend_notify,
+				(void *)&compl);
+			switch (ret) {
+			case 0:
+				break;
+			case -SIF_RPCE_SENDP:
+				break;
+			default:
+				printk("%s: RX DMA stop callrpc failed(%d)\n",
+							net_dev->name, ret);
+				break;
+			}
+		} while (ret == -SIF_RPCE_SENDP);
+		if (i == 0) {
+			printk("%s: RX DMA stop callrpc failed2\n",
+								net_dev->name);
+		} else {
+			if (ret == 0) {
+				wait_for_completion(&compl);
+			}
+		}
+	}
+	return;
+}
+
+static void
+smap_rpcend_notify(void *arg)
+{
+	complete((struct completion *)arg);
+	return;
+}
+
+static void
+smap_dma_setup(struct smap_chan *smap)
+{
+	int loop;
+	volatile int j;
+	struct completion compl;
+
+	init_completion(&compl);
+	smap->flags &= ~(SMAP_F_DMA_ENABLE|SMAP_F_DMA_TX_ENABLE|SMAP_F_DMA_RX_ENABLE);
+
+	/* bind DMA relay module */
+	for (loop = 100; loop; loop--) {
+		ps2sif_bindrpc(&smap->cd_smap_tx, SIFNUM_SMAP_TX_DMA_BEGIN,
+			SIF_RPCM_NOWAIT, smap_rpcend_notify, (void *)&compl);
+		wait_for_completion(&compl);
+		if (smap->cd_smap_tx.serve != 0)
+			break;
+		j = 0x010000;
+		while (j--) ;
+	}
+	if (smap->cd_smap_tx.serve == 0) {
+		printk("%s: dma setup: bind error 1, use PIO\n", smap->net_dev->name);
+		return;
+	}
+
+	for (loop = 100; loop; loop--) {
+		ps2sif_bindrpc(&smap->cd_smap_tx_end, SIFNUM_SMAP_TX_DMA_END,
+			SIF_RPCM_NOWAIT, smap_rpcend_notify, (void *)&compl);
+		wait_for_completion(&compl);
+		if (smap->cd_smap_tx_end.serve != 0)
+			break;
+		j = 0x010000;
+		while (j--) ;
+	}
+	if (smap->cd_smap_tx_end.serve == 0) {
+		printk("%s: dma setup: bind error 2, use PIO\n", smap->net_dev->name);
+		return;
+	}
+
+	for (loop = 100; loop; loop--) {
+		ps2sif_bindrpc(&smap->cd_smap_rx, SIFNUM_SMAP_RX_DMA_BEGIN,
+			SIF_RPCM_NOWAIT, smap_rpcend_notify, (void *)&compl);
+		wait_for_completion(&compl);
+		if (smap->cd_smap_rx.serve != 0)
+			break;
+		j = 0x010000;
+		while (j--) ;
+	}
+	if (smap->cd_smap_rx.serve == 0) {
+		printk("%s: dma setup: bind error 3, use PIO\n", smap->net_dev->name);
+		return;
+	}
+
+	for (loop = 100; loop; loop--) {
+		ps2sif_bindrpc(&smap->cd_smap_rx_end, SIFNUM_SMAP_RX_DMA_END,
+			SIF_RPCM_NOWAIT, smap_rpcend_notify, (void *)&compl);
+		wait_for_completion(&compl);
+		if (smap->cd_smap_rx_end.serve != 0)
+			break;
+		j = 0x010000;
+		while (j--) ;
+	}
+	if (smap->cd_smap_rx_end.serve == 0) {
+		printk("%s: dma setup: bind error 4, use PIO\n", smap->net_dev->name);
+		return;
+	}
+
+	/* get buffer address for TX DMA */
+	if (ps2sif_callrpc(&smap->cd_smap_tx, SIFNUM_SmapGetTxBufAddr,
+			SIF_RPCM_NOWAIT,
+			NULL, 0, &smap->txdma_ibuf, sizeof(u_int32_t),
+			smap_rpcend_notify, (void *)&compl) != 0) {
+		printk("%s: dma setup: get dma Txbuf address error, use PIO\n",
+							smap->net_dev->name);
+		return;
+	}
+	wait_for_completion(&compl);
+	/* Access IOP memory cached. */
+	smap->txdma_ibuf = phys_to_virt(ps2sif_bustophys(smap->txdma_ibuf));
+	smap->flags |= (SMAP_F_DMA_TX_ENABLE|SMAP_F_DMA_ENABLE);
+
+	if (smap->flags & SMAP_F_PRINT_MSG) {
+		printk("%s: dma setup: txdma_ibuf = %p\n",
+				smap->net_dev->name, smap->txdma_ibuf);
+	}
+
+	/* get buffer address for RX DMA */
+	if (ps2sif_callrpc(&smap->cd_smap_rx, SIFNUM_SmapGetRxBufAddr,
+			SIF_RPCM_NOWAIT,
+			NULL, 0, &smap->rxdma_ibuf, sizeof(u_int32_t),
+			smap_rpcend_notify, (void *)&compl) != 0) {
+		printk("%s: dma setup: get dma Rxbuf address error, use PIO\n",
+							smap->net_dev->name);
+		return;
+	}
+	wait_for_completion(&compl);
+	/* Access IOP memory cached. */
+	smap->rxdma_ibuf = phys_to_virt(ps2sif_bustophys(smap->rxdma_ibuf));
+	smap->flags |= (SMAP_F_DMA_RX_ENABLE|SMAP_F_DMA_ENABLE);
+
+	if (smap->flags & SMAP_F_PRINT_MSG) {
+		printk("%s: dma setup: rxdma_ibuf = %p\n",
+				smap->net_dev->name, smap->rxdma_ibuf);
+	}
+
+	return;
+}
+
+/*--------------------------------------------------------------------------*/
+
+static void
+smap_run(struct smap_chan *smap)
+{
+	unsigned long flags;
+
+	if ((smap->flags & SMAP_F_LINKVALID) == 0)
+		return;
+	if ((smap->flags & SMAP_F_INITDONE) == 0)
+		return;
+	if ((smap->flags & SMAP_F_OPENED) == 0) {
+		spin_lock_irqsave(&smap->spinlock, flags);
+		while (smap->txqueue.qlen > 0) {
+			spin_unlock_irqrestore(&smap->spinlock, flags);
+			(void)smap_start_xmit2(smap);
+			(void)smap_tx_intr(smap->net_dev);
+			spin_lock_irqsave(&smap->spinlock, flags);
+		}
+		spin_unlock_irqrestore(&smap->spinlock, flags);
+		if (smap->tx_qpkt_compl != NULL)
+			complete(smap->tx_qpkt_compl); /*notify all pkts sent*/
+		netif_stop_queue(smap->net_dev);
+		return;
+	}
+
+	for (;;) {
+		if ((smap->flags & SMAP_F_OPENED) == 0) {
+			spin_lock_irqsave(&smap->spinlock, flags);
+			while (smap->txqueue.qlen > 0) {
+				spin_unlock_irqrestore(&smap->spinlock, flags);
+				(void)smap_start_xmit2(smap);
+				(void)smap_tx_intr(smap->net_dev);
+				spin_lock_irqsave(&smap->spinlock, flags);
+			}
+			spin_unlock_irqrestore(&smap->spinlock, flags);
+			if (smap->tx_qpkt_compl != NULL)
+				complete(smap->tx_qpkt_compl); /*notify all pkts sent*/
+			netif_stop_queue(smap->net_dev);
+			break;
+		}
+
+		spin_lock_irqsave(&smap->spinlock, flags);
+		if ((smap->txqueue.qlen > 0) && (smap->flags & SMAP_F_OPENED)) {
+			spin_unlock_irqrestore(&smap->spinlock, flags);
+			(void)smap_start_xmit2(smap);
+		} else
+			spin_unlock_irqrestore(&smap->spinlock, flags);
+
+		spin_lock_irqsave(&smap->spinlock, flags);
+		if ((smap->txicnt > 0) && (smap->flags & SMAP_F_OPENED)) {
+			spin_unlock_irqrestore(&smap->spinlock, flags);
+			(void)smap_tx_intr(smap->net_dev);
+		} else
+			spin_unlock_irqrestore(&smap->spinlock, flags);
+
+		spin_lock_irqsave(&smap->spinlock, flags);
+		if ((smap->rxicnt > 0) && (smap->flags & SMAP_F_OPENED)) {
+			spin_unlock_irqrestore(&smap->spinlock, flags);
+			(void)smap_rx_intr(smap->net_dev);
+		} else
+			spin_unlock_irqrestore(&smap->spinlock, flags);
+
+		spin_lock_irqsave(&smap->spinlock, flags);
+		if ( (smap->txqueue.qlen == 0) && (smap->txicnt == 0) &&
+		     (smap->rxicnt == 0) ) {
+			spin_unlock_irqrestore(&smap->spinlock, flags);
+			break;
+		} else
+			spin_unlock_irqrestore(&smap->spinlock, flags);
+	}
+
+	return;
+}
+
+static int
+smap_thread(void *arg)
+{
+	struct smap_chan *smap = (struct smap_chan *)arg;
+	sigset_t blocked, oldset;
+
+	siginitsetinv(&blocked, sigmask(SIGKILL)|sigmask(SIGINT)|sigmask(SIGTERM));
+	sigprocmask(SIG_SETMASK, &blocked, &oldset);
+
+	/* get rid of all our resources related to user space */
+	daemonize("smap");
+
+	smap->smaprun_task = current;
+
+	while (1) {
+		wait_queue_t wait;
+		init_waitqueue_entry(&wait, current);
+		add_wait_queue(&smap->wait_smaprun, &wait);
+		set_current_state(TASK_INTERRUPTIBLE);
+
+		(void)smap_run(smap);
+
+		schedule();
+		remove_wait_queue(&smap->wait_smaprun, &wait);
+		if (signal_pending(current))
+			break;
+	}
+
+	smap->smaprun_task = NULL;
+	if (smap->smaprun_compl != NULL)
+		complete(smap->smaprun_compl);	/* notify that we've exited */
+	sigprocmask(SIG_SETMASK, &oldset, NULL);
+
+	return(0);
+}
+
+/*--------------------------------------------------------------------------*/
+
+static void
+smap_chk_linkvalid(struct smap_chan *smap)
+{
+	u_int16_t phyval = 0;
+	struct net_device *net_dev = smap->net_dev;
+
+	if ((smap->flags & SMAP_F_INITDONE) == 0)
+		return;
+
+	phyval = (u_int16_t)smap_read_phy(smap, DsPHYTER_ADDRESS,DsPHYTER_BMSR);
+	if ((phyval & PHY_BMSR_LINK) == 0) {
+		if (smap->flags & SMAP_F_LINKVALID) {
+			smap->flags &= ~(SMAP_F_LINKESTABLISH|SMAP_F_LINKVALID);
+			printk("%s: link down\n", smap->net_dev->name);
+			netif_carrier_off(net_dev);
+			netif_stop_queue(net_dev);
+			(void)smap_dma_force_break(smap);
+			(void)smap_reset(smap, RESET_ONLY);
+			(void)smap_skb_queue_clear(smap, &smap->txqueue);
+		}
+	}
+	if (phyval & PHY_BMSR_LINK) {
+		if ((smap->flags & SMAP_F_LINKVALID) == 0) {
+			(void)smap_reset(smap, RESET_INIT);
+			(void)smap_txrx_XXable(smap, DISABLE);
+			netif_carrier_on(net_dev);
+			if (smap->flags & SMAP_F_OPENED) {
+				(void)smap_txbd_init(smap);
+				(void)smap_rxbd_init(smap);
+				(void)smap_skb_queue_init(smap, &smap->txqueue);
+				(void)smap_clear_all_interrupt(smap);
+				(void)smap_interrupt_XXable(smap, ENABLE);
+				(void)smap_txrx_XXable(smap, ENABLE);
+				(void)smap_multicast_list(smap->net_dev);
+				netif_wake_queue(net_dev);
+			} else {
+				printk("%s: you need \"ifup ethX\"\n",
+							smap->net_dev->name);
+			}
+		}
+	}
+
+	return;
+}
+
+static int smap_chklv_ival = 1;
+module_param(smap_chklv_ival, int, 0);
+MODULE_PARM_DESC(smap_chklv_ival,
+		"Interval for link detection.");
+
+static int
+smap_chk_linkvalid_thread(void *arg)
+{
+	struct smap_chan *smap = (struct smap_chan *)arg;
+	sigset_t blocked, oldset;
+
+	siginitsetinv(&blocked, sigmask(SIGKILL)|sigmask(SIGINT)|sigmask(SIGTERM));
+	sigprocmask(SIG_SETMASK, &blocked, &oldset);
+
+	/* get rid of all our resources related to user space */
+	daemonize("smap chk lv %d", smap_chklv_ival); /* up to 16B */
+
+	smap->chk_linkvalid_task = current;
+
+	while (1) {
+		(void)smap_chk_linkvalid(smap);
+
+		interruptible_sleep_on_timeout(&smap->wait_chk_linkvalid,
+						HZ * smap_chklv_ival);
+		if (signal_pending(current))
+			break;
+	}
+
+	smap->chk_linkvalid_task = NULL;
+	if (smap->chk_linkvalid_compl != NULL)
+		complete(smap->chk_linkvalid_compl);/* notify that we've exited */
+
+	sigprocmask(SIG_SETMASK, &oldset, NULL);
+
+	return(0);
+}
+
+/*--------------------------------------------------------------------------*/
+
+static int smap_dma_enable = 1;
+module_param(smap_dma_enable, int, 0);
+MODULE_PARM_DESC(smap_dma_enable,
+		"Enable DMA.");
+
+static int
+smap_init_thread(void *arg)
+{
+	struct smap_chan *smap = (struct smap_chan *)arg;
+	sigset_t blocked, oldset;
+
+	siginitsetinv(&blocked, sigmask(SIGKILL)|sigmask(SIGINT)|sigmask(SIGTERM));
+	sigprocmask(SIG_SETMASK, &blocked, &oldset);
+
+	/* get rid of all our resources related to user space */
+	daemonize("smap init");
+
+	smap_reset(smap, RESET_INIT);
+	smap_txrx_XXable(smap, DISABLE);
+	smap_txbd_init(smap);
+	smap_rxbd_init(smap);
+
+	if (smap_dma_enable) {
+		smap_dma_setup(smap);
+	} else {
+		printk("PlayStation 2 SMAP: PIO mode.\n");
+		smap->flags &= ~(SMAP_F_DMA_ENABLE|SMAP_F_DMA_TX_ENABLE|SMAP_F_DMA_RX_ENABLE);
+	}
+
+	if (smap->flags & SMAP_F_LINKVALID)
+		netif_carrier_on(smap->net_dev);
+	else
+		netif_carrier_off(smap->net_dev);
+
+	smap->irq = IRQ_SBUS_PCIC;
+
+	smap->flags |= SMAP_F_INITDONE;
+
+	sigprocmask(SIG_SETMASK, &oldset, NULL);
+
+	return(0);
+}
+
+extern int ps2_pccard_present;
+
+static const struct net_device_ops smap_netdev_ops = {
+	.ndo_open		= smap_open,
+	.ndo_stop		= smap_close,
+	.ndo_do_ioctl		= smap_ioctl,
+	.ndo_start_xmit		= smap_start_xmit,
+	.ndo_get_stats		= smap_get_stats,
+	.ndo_set_multicast_list = smap_multicast_list,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_set_mac_address 	= NULL,
+	.ndo_change_mtu		= eth_change_mtu,
+#ifdef HAVE_TX_TIMEOUT
+	.ndo_tx_timeout		= smap_tx_timeout,
+#endif
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	.ndo_poll_controller = NULL,
+#endif
+};
+
+static int __devinit smap_probe(struct platform_device *dev)
+{
+	struct net_device *net_dev = NULL;
+	struct smap_chan *smap = NULL;
+	int r;
+
+	if (ps2_pccard_present != 0x0100) {
+		printk("PlayStation 2 HDD/Ethernet device NOT present.\n");
+		return(-ENODEV);
+	}
+
+	net_dev = alloc_etherdev(sizeof(struct smap_chan));
+	if (!net_dev) {
+		return -ENOMEM;
+	}
+
+	SET_NETDEV_DEV(net_dev, &dev->dev);
+	platform_set_drvdata(dev, net_dev);
+
+	smap = netdev_priv(net_dev);
+
+	/* clear control structure */
+	memset(smap, 0, sizeof(struct smap_chan));
+	smap->net_dev = net_dev;
+
+	net_dev->netdev_ops = &smap_netdev_ops;
+#ifdef HAVE_TX_TIMEOUT
+	net_dev->watchdog_timeo = 5 * HZ;
+#endif /* HAVE_TX_TIMEOUT */
+
+	/* alloc tx/rx buffer(16B align) */
+	smap->dtxbuf = kmalloc(SMAP_BUFSIZE+SMAP_ALIGN+SMAP_TXMAXTAILPAD,
+								GFP_KERNEL);
+	smap->drxbuf = kmalloc(SMAP_BUFSIZE+SMAP_ALIGN+SMAP_RXMAXTAILPAD,
+								GFP_KERNEL);
+	if ((smap->dtxbuf == NULL) || (smap->drxbuf == NULL)){
+		printk("PlayStation 2 SMAP: tx(%p)/rx(%p) buffer alloc error\n",
+				smap->dtxbuf, smap->drxbuf);
+		goto error;
+	}
+	if (((int)smap->dtxbuf & (SMAP_ALIGN-1)) == 0)
+		smap->txbuf = smap->dtxbuf;
+	else
+		smap->txbuf = (u_int8_t *)((int)smap->dtxbuf & ~(SMAP_ALIGN-1))
+						+ SMAP_ALIGN;
+
+	if (((int)smap->drxbuf & (SMAP_ALIGN-1)) == 0)
+		smap->rxbuf = smap->drxbuf;
+	else
+		smap->rxbuf = (u_int8_t *)((int)smap->drxbuf & ~(SMAP_ALIGN-1))
+						+ SMAP_ALIGN;
+
+	if ( ((int)smap->txbuf & (SMAP_ALIGN-1)) ||
+				((int)smap->rxbuf & (SMAP_ALIGN-1)) ) {
+		printk("PlayStation 2 SMAP: buffer alignment error, "
+			"tx buf=0x%p, rx buf=0x%p\n", smap->txbuf, smap->rxbuf);
+	}
+
+	smap_base_init(smap);
+	spin_lock_init(&smap->spinlock);
+	init_waitqueue_head(&smap->wait_linknego);
+	init_waitqueue_head(&smap->wait_linkvalid);
+	init_waitqueue_head(&smap->wait_chk_linkvalid);
+	init_waitqueue_head(&smap->wait_smaprun);
+#ifdef HAVE_TX_TIMEOUT
+	init_waitqueue_head(&smap->wait_timeout);
+#endif /* HAVE_TX_TIMEOUT */
+	r = smap_get_node_addr(smap);
+	if (r < 0)
+		goto error;
+
+	if (register_netdev(net_dev)) {
+		goto error;
+	}
+
+	/* create and start thread */
+	kernel_thread(smap_init_thread, (void *)smap, 0);
+	if (smap_chklv_ival > 0) {
+		if (smap_chklv_ival > 999)
+			smap_chklv_ival = 999;	/* MAX: a three-digit number */
+		kernel_thread(smap_chk_linkvalid_thread, (void *)smap, 0);
+	}
+#ifdef HAVE_TX_TIMEOUT
+	kernel_thread(smap_timeout_thread, (void *)smap, 0);
+#endif /* HAVE_TX_TIMEOUT */
+	kernel_thread(smap_thread, (void *)smap, 0);
+
+	printk("Fat PlayStation 2 SMAP(Ethernet) device driver.\n");
+
+	return(0);	/* success */
+
+error:
+	if (smap) {
+		if (smap->dtxbuf) {
+			kfree(smap->dtxbuf);
+		}
+		if (smap->drxbuf) {
+			kfree(smap->drxbuf);
+		}
+	}
+	free_netdev(net_dev);
+	return(-ENODEV);
+}
+
+static int __devexit smap_driver_remove(struct platform_device *pdev)
+{
+	struct net_device *net_dev = platform_get_drvdata(pdev);
+	struct smap_chan *smap = netdev_priv(net_dev);
+
+	if (smap->chk_linkvalid_task != NULL) {
+		struct completion compl;
+
+		init_completion(&compl);
+		smap->chk_linkvalid_compl = &compl;
+		send_sig(SIGKILL, smap->chk_linkvalid_task, 1);
+
+		/* wait the thread exit */
+		wait_for_completion(&compl);
+		smap->chk_linkvalid_compl = NULL;
+	}
+#ifdef HAVE_TX_TIMEOUT
+	if (smap->timeout_task != NULL) {
+		struct completion compl;
+
+		init_completion(&compl);
+		smap->timeout_compl = &compl;
+		send_sig(SIGKILL, smap->timeout_task, 1);
+
+		/* wait the thread exit */
+		wait_for_completion(&compl);
+		smap->timeout_compl = NULL;
+	}
+#endif /* HAVE_TX_TIMEOUT */
+	if (smap->smaprun_task != NULL) {
+		struct completion compl;
+
+		init_completion(&compl);
+		smap->smaprun_compl = &compl;
+		send_sig(SIGKILL, smap->smaprun_task, 1);
+
+		/* wait the thread exit */
+		wait_for_completion(&compl);
+		smap->smaprun_compl = NULL;
+	}
+
+	printk("%s: unloading...", net_dev->name);
+
+	if (net_dev->flags & IFF_UP)
+		dev_close(net_dev);
+
+	unregister_netdev(net_dev);
+
+	(void)smap_reset(smap, RESET_ONLY);
+
+	if (smap->dtxbuf) {
+		kfree(smap->dtxbuf);
+	}
+	if (smap->drxbuf) {
+		kfree(smap->drxbuf);
+	}
+	printk(" done\n");
+
+	free_netdev(net_dev);
+	return 0;
+}
+
+static struct platform_driver smap_driver = {
+	.probe	= smap_probe,
+	.remove	= __devexit_p(smap_driver_remove),
+	.driver	= {
+		.name	= "ps2smap",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init smap_init(void)
+{
+	return platform_driver_register(&smap_driver);
+}
+
+static void __exit smap_exit(void)
+{
+	platform_driver_unregister(&smap_driver);
+	return;
+}
+
+
+module_init(smap_init);
+module_exit(smap_exit);
+
+MODULE_AUTHOR("Juergen Urban");
+MODULE_DESCRIPTION("PlayStation 2 ethernet device driver for fat PS2.");
+MODULE_LICENSE("GPL");
+
+/*--------------------------------------------------------------------------*/
+
+#endif /* linux */
diff -purN linux-2.6.35.4-orig/drivers/ps2/smap.h linux-2.6.35.4/drivers/ps2/smap.h
--- linux-2.6.35.4-orig/drivers/ps2/smap.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/smap.h	2014-07-18 22:29:43.562367724 +0200
@@ -0,0 +1,559 @@
+/*
+ *  PlayStation 2 Ethernet device driver header file
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef	__SMAP_H__
+#define	__SMAP_H__
+
+#include <linux/version.h>
+
+#include <linux/module.h>
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+
+#include <asm/io.h>
+#include <asm/pgtable.h>
+
+#include <asm/mach-ps2/sifdefs.h>
+#include <asm/mach-ps2/dmarelay.h>
+
+#define	SET		1
+#define	CLEAR		0
+#define	TRUE		1
+#define	FALSE		0
+#define	ENABLE		1
+#define	DISABLE		0
+#define	START		1
+#define	STOP		0
+#define	RESET_ONLY	1
+#define	RESET_INIT	0
+
+/*
+ * SMAP control structure(smap channel)
+ */
+struct smap_chan {
+	struct net_device *net_dev;
+	u_int32_t flags;
+	u_int32_t irq;
+	volatile u_int8_t *base;
+	volatile struct smapbd *txbd;
+	volatile struct smapbd *rxbd;
+	u_int8_t hwaddr[6];
+	u_int8_t ppwc;
+	u_int32_t txmode_val;
+	struct net_device_stats net_stats;
+	wait_queue_head_t wait_linknego;
+	wait_queue_head_t wait_linkvalid;
+	wait_queue_head_t wait_chk_linkvalid;
+	struct task_struct *chk_linkvalid_task;
+	struct completion *chk_linkvalid_compl;
+	wait_queue_head_t wait_smaprun;
+	struct task_struct *smaprun_task;
+	struct completion *smaprun_compl;
+	struct completion *tx_qpkt_compl;
+#ifdef HAVE_TX_TIMEOUT
+	wait_queue_head_t wait_timeout;
+	struct task_struct *timeout_task;
+	struct completion *timeout_compl;
+#endif /* HAVE_TX_TIMEOUT */
+	spinlock_t spinlock;
+	int txicnt, rxicnt;
+
+	int txfreebufsize;
+	u_int8_t *dtxbuf, *txbuf;
+	u_int16_t txbwp;
+	int txbds, txbdi;
+	int txbdusedcnt;
+	struct sk_buff_head txqueue;
+
+	u_int8_t *drxbuf, *rxbuf;
+	u_int16_t rxbrp;
+	int rxbdi;
+
+	ps2sif_clientdata_t cd_smap_tx, cd_smap_tx_end;
+	ps2sif_clientdata_t cd_smap_rx, cd_smap_rx_end;
+	u_int32_t dma_result			__attribute__((aligned(16)));
+	void *txdma_ibuf;
+	void *rxdma_ibuf;
+	struct smap_dma_request txdma_request;
+	struct smap_dma_request rxdma_request;
+};
+/* flags */
+#define	SMAP_F_OPENED		(1<<0)
+#define	SMAP_F_LINKESTABLISH	(1<<1)
+#define	SMAP_F_LINKVALID	(1<<2)
+#define	SMAP_F_CHECK_FORCE100M	(1<<3)
+#define	SMAP_F_CHECK_FORCE10M	(1<<4)
+#define	SMAP_F_INITDONE		(1<<5)
+#define	SMAP_F_SPD_100M		(1<<8)
+#define	SMAP_F_DUP_FULL		(1<<9)
+#define	SMAP_F_TXDNV_DISABLE	(1<<16)
+#define	SMAP_F_RXDNV_DISABLE	(1<<17)
+#define	SMAP_F_DMA_ENABLE	(1<<24)
+#define	SMAP_F_DMA_TX_ENABLE	(1<<25)
+#define	SMAP_F_DMA_RX_ENABLE	(1<<26)
+#define	SMAP_F_PRINT_PKT	(1<<30)
+#define	SMAP_F_PRINT_MSG	(1<<31)
+
+/* ioctl */
+/*
+ * 16 ioctls(from SIOCDEVPRIVATE to SIOCDEVPRIVATE+15) are deprecated
+ * and will DISAPPEAR in kernel 2.5.  Refer to include/linux/sockios.h.
+ */
+/* for local use - compatible with kernel 2.2 */
+#define	SMAP_IOC_PRTMODE	(SIOCDEVPRIVATE)
+#define	SMAP_IOC_DUMPREG	(SIOCDEVPRIVATE+1)
+#define	SMAP_IOC_DUMPBD		(SIOCDEVPRIVATE+2)
+#define	SMAP_IOC_DUMPFLAG	(SIOCDEVPRIVATE+3)
+#define	SMAP_IOC_DUMPPHYSTAT	(SIOCDEVPRIVATE+4)
+#define	SMAP_IOC_PRINT_MSG	(SIOCDEVPRIVATE+5)
+#define	SMAP_IOC_DUMP_PKT	(SIOCDEVPRIVATE+6)
+#ifndef	SIOCGMIIPHY
+/* for MII ioctl */
+#define	SIOCGMIIPHY		(SIOCDEVPRIVATE+13) /* Read from current PHY */
+#define	SIOCGMIIREG		(SIOCDEVPRIVATE+14) /* Read any PHY register */
+#define	SIOCSMIIREG		(SIOCDEVPRIVATE+15) /* Write any PHY register */
+
+struct mii_ioctl_data {
+	u16		phy_id;
+	u16		reg_num;
+	u16		val_in;
+	u16		val_out;
+};
+#else
+#include <linux/mii.h>
+#endif
+
+/*
+ * SMAP
+ */
+#define	SMAP_BASE		0x14000000
+#define	SMAP_TXBUFBASE		0x1000
+#define	SMAP_TXBUFSIZE		(4*1024)
+#define	SMAP_RXBUFBASE		0x4000
+#define	SMAP_RXBUFSIZE		(16*1024)
+
+#define	SMAP_ALIGN		64
+#define	SMAP_BUFSIZE		1536			/* 64*24 == 128*12 */
+#define	SMAP_TXMAXSIZE		(6+6+2+1500)
+#define	SMAP_TXMAXTAILPAD	4
+#define	SMAP_TXMAXPKTSZ_INFIFO	(SMAP_TXMAXSIZE+2)	/* multiple of 4 */
+#define	SMAP_RXMAXSIZE		(6+6+2+1500+4)
+#define	SMAP_RXMINSIZE		14		/* ethernet header size */
+#define	SMAP_RXMAXTAILPAD	4
+
+#define	SMAP_LOOP_COUNT		10000
+#define	SMAP_AUTONEGO_TIMEOUT	300
+#define	SMAP_AUTONEGO_RETRY	3
+#define	SMAP_FORCEMODE_WAIT	200
+#define	SMAP_FORCEMODE_TIMEOUT	100
+
+/*
+ * Buffer Descriptor(BD) Offset and Definitions
+ */
+#define	SMAP_BD_BASE			0x3000
+#define	SMAP_BD_BASE_TX			(SMAP_BD_BASE + 0x0000)
+#define	SMAP_BD_BASE_RX			(SMAP_BD_BASE + 0x0200)
+#define	  SMAP_BD_SIZE			512
+#define	  SMAP_BD_MAX_ENTRY		64
+
+#define	SMAP_BD_NEXT(x)	{				\
+	if ((x) == (SMAP_BD_MAX_ENTRY-1)) (x) = 0;	\
+	else (x)++;					\
+}
+
+/* TX Control */
+#define	SMAP_BD_TX_READY	(1<<15)	/* set:driver, clear:HW */
+#define	SMAP_BD_TX_GENFCS	(1<<9)	/* generate FCS */
+#define	SMAP_BD_TX_GENPAD	(1<<8)	/* generate padding */
+#define	SMAP_BD_TX_INSSA	(1<<7)	/* insert source address */
+#define	SMAP_BD_TX_RPLSA	(1<<6)	/* replace source address */
+#define	SMAP_BD_TX_INSVLAN	(1<<5)	/* insert VLAN Tag */
+#define	SMAP_BD_TX_RPLVLAN	(1<<4)	/* replace VLAN Tag */
+
+/* TX Status */
+#define	SMAP_BD_TX_READY	(1<<15) /* set:driver, clear:HW */
+#define	SMAP_BD_TX_BADFCS	(1<<9)	/* bad FCS */
+#define	SMAP_BD_TX_BADPKT	(1<<8)	/* bad previous pkt in dependent mode */
+#define	SMAP_BD_TX_LOSSCR	(1<<7)	/* loss of carrior sense */
+#define	SMAP_BD_TX_EDEFER	(1<<6)	/* excessive deferal */
+#define	SMAP_BD_TX_ECOLL	(1<<5)	/* excessive collision */
+#define	SMAP_BD_TX_LCOLL	(1<<4)	/* late collision */
+#define	SMAP_BD_TX_MCOLL	(1<<3)	/* multiple collision */
+#define	SMAP_BD_TX_SCOLL	(1<<2)	/* single collision */
+#define	SMAP_BD_TX_UNDERRUN	(1<<1)	/* underrun */
+#define	SMAP_BD_TX_SQE		(1<<0)	/* SQE */
+
+/* RX Control */
+#define	SMAP_BD_RX_EMPTY	(1<<15)	/* set:driver, clear:HW */
+
+/* RX Status */
+#define	SMAP_BD_RX_EMPTY	(1<<15)	/* set:driver, clear:HW */
+#define	SMAP_BD_RX_OVERRUN	(1<<9)	/* overrun */
+#define	SMAP_BD_RX_PFRM		(1<<8)	/* pause frame */
+#define	SMAP_BD_RX_BADFRM	(1<<7)	/* bad frame */
+#define	SMAP_BD_RX_RUNTFRM	(1<<6)	/* runt frame */
+#define	SMAP_BD_RX_SHORTEVNT	(1<<5)	/* short event */
+#define	SMAP_BD_RX_ALIGNERR	(1<<4)	/* alignment error */
+#define	SMAP_BD_RX_BADFCS	(1<<3)	/* bad FCS */
+#define	SMAP_BD_RX_FRMTOOLONG	(1<<2)	/* frame too long */
+#define	SMAP_BD_RX_OUTRANGE	(1<<1)	/* out of range error */
+#define	SMAP_BD_RX_INRANGE	(1<<0)	/* in range error */
+
+struct smapbd {
+	u_int16_t ctrl_stat;
+	u_int16_t reserved;		/* must be zero */
+	u_int16_t length;		/* number of bytes in pkt */
+	u_int16_t pointer;
+};
+
+
+/*
+ * Register Offset and Definitions
+ */
+#define	SMAP_PIOPORT_DIR		0x2C
+#define	SMAP_PIOPORT_IN			0x2E
+#define	SMAP_PIOPORT_OUT		0x2E
+#define	  PP_DOUT		(1<<4)	/* Data output, read port */
+#define	  PP_DIN		(1<<5)	/* Data input,  write port */
+#define	  PP_SCLK		(1<<6)	/* Clock,       write port */
+#define	  PP_CSEL		(1<<7)	/* Chip select, write port */
+/* operation code */
+#define	  PP_OP_READ		2	/* 2b'10 */
+#define	  PP_OP_WRITE		1	/* 2b'01 */
+#define	  PP_OP_EWEN		0	/* 2b'00 */
+#define	  PP_OP_EWDS		0	/* 2b'00 */
+
+#define	SMAP_DMA_MODE			0x24
+#define	SMAP_INTR_STAT			0x28
+#define	SMAP_INTR_CLR			0x128
+#define	SMAP_INTR_ENABLE		0x2A
+#define	  INTR_EMAC3		(1<<6)
+#define	  INTR_RXEND		(1<<5)
+#define	  INTR_TXEND		(1<<4)
+#define	  INTR_RXDNV		(1<<3)		/* descriptor not valid */
+#define	  INTR_TXDNV		(1<<2)		/* descriptor not valid */
+#define	  INTR_CLR_ALL		(INTR_RXEND|INTR_TXEND|INTR_RXDNV)
+#define	  INTR_ENA_ALL		(INTR_EMAC3|INTR_CLR_ALL)
+#define	  INTR_BITMSK		0x7C
+#define	SMAP_BD_MODE			0x102
+#define	  BD_SWAP		(1<<0)
+
+#define	SMAP_TXFIFO_CTRL		0x1000
+#define	  TXFIFO_RESET		(1<<0)
+#define	SMAP_TXFIFO_WR_PTR		0x1004
+#define	SMAP_TXFIFO_DMA_SLICE_CNT	0x1008
+#define	SMAP_TXFIFO_FRAME_CNT		0x100C
+#define	SMAP_TXFIFO_FRAME_INC		0x1010
+#define	SMAP_TXFIFO_DATA		0x1100
+
+#define	SMAP_RXFIFO_CTRL		0x1030
+#define	  RXFIFO_RESET		(1<<0)
+#define	SMAP_RXFIFO_RD_PTR		0x1034
+#define	SMAP_RXFIFO_DMA_SLICE_CNT	0x1038
+#define	SMAP_RXFIFO_FRAME_CNT		0x103C
+#define	SMAP_RXFIFO_FRAME_DEC		0x1040
+#define	SMAP_RXFIFO_DATA		0x1200
+
+#define	SMAP_FIFO_ADDR			0x1300
+#define	  FIFO_CMD_READ		(1<<1)
+#define	  FIFO_DATA_SWAP	(1<<0)
+#define	SMAP_FIFO_DATA			0x1308
+
+#define	SMAPREG8(dev, offset)	\
+	(inb((uint32_t)((dev)->base + (offset))))
+#define	WRITE_SMAPREG8(dev, offset, val)	\
+	(outb(val, (uint32_t)((dev)->base + (offset))))
+#define	SMAPREG16(dev, offset)	\
+	(inw((uint32_t)((dev)->base + (offset))))
+#define	WRITE_SMAPREG16(dev, offset, val)	\
+	(outw(val, (uint32_t)((dev)->base + (offset))))
+#define	SMAPREG32(dev, offset)	\
+	(inl((uint32_t)((dev)->base + (offset))))
+#define	WRITE_SMAPREG32(dev, offset, val)	\
+	(outl(val, (uint32_t)((dev)->base + (offset))))
+
+#define	SMAP_EEPROM_WRITE_WAIT	100000
+#define	SMAP_PP_GET_Q(dev)	((SMAPREG8((dev), SMAP_PIOPORT_IN) >> 4) & 1)
+#define	SMAP_PP_SET_D(dev, d)	((dev)->ppwc = (d)?((dev)->ppwc | PP_DIN):((dev)->ppwc & ~PP_DIN))
+#define	SMAP_PP_SET_S(dev, s)	((dev)->ppwc = (s)?((dev)->ppwc | PP_CSEL):((dev)->ppwc & ~PP_CSEL))
+#define	SMAP_PP_CLK_OUT(dev, c)	{ \
+	(dev)->ppwc = (c)?((dev)->ppwc | PP_SCLK):((dev)->ppwc & ~PP_SCLK); \
+	WRITE_SMAPREG8((dev), SMAP_PIOPORT_OUT, (dev)->ppwc); \
+}
+
+/*
+ * EMAC3 Register Offset and Definitions
+ */
+#define	SMAP_EMAC3_BASE			0x2000
+#define	SMAP_EMAC3_MODE0		(SMAP_EMAC3_BASE + 0x00)
+#define	  E3_RXMAC_IDLE		(1<<31)
+#define	  E3_TXMAC_IDLE		(1<<30)
+#define	  E3_SOFT_RESET		(1<<29)
+#define	  E3_TXMAC_ENABLE	(1<<28)
+#define	  E3_RXMAC_ENABLE	(1<<27)
+#define	  E3_WAKEUP_ENABLE	(1<<26)
+
+#define	SMAP_EMAC3_MODE1		(SMAP_EMAC3_BASE + 0x04)
+#define	  E3_FDX_ENABLE		(1<<31)
+#define	  E3_INLPBK_ENABLE	(1<<30)	/* internal loop back */
+#define	  E3_VLAN_ENABLE	(1<<29)
+#define	  E3_FLOWCTRL_ENABLE	(1<<28)	/* integrated flow ctrl(pause frame) */
+#define	  E3_ALLOW_PF		(1<<27)	/* allow pause frame */
+#define	  E3_ALLOW_EXTMNGIF	(1<<25)	/* allow external management IF */
+#define	  E3_IGNORE_SQE		(1<<24)
+#define	  E3_MEDIA_FREQ_BITSFT	(22)
+#define	    E3_MEDIA_10M	(0<<22)
+#define	    E3_MEDIA_100M	(1<<22)
+#define	    E3_MEDIA_1000M	(2<<22)
+#define	    E3_MEDIA_MSK	(3<<22)
+#define	  E3_RXFIFO_SIZE_BITSFT	(20)
+#define	    E3_RXFIFO_512	(0<<20)
+#define	    E3_RXFIFO_1K	(1<<20)
+#define	    E3_RXFIFO_2K	(2<<20)
+#define	    E3_RXFIFO_4K	(3<<20)
+#define	  E3_TXFIFO_SIZE_BITSFT	(18)
+#define	    E3_TXFIFO_512	(0<<18)
+#define	    E3_TXFIFO_1K	(1<<18)
+#define	    E3_TXFIFO_2K	(2<<18)
+#define	  E3_TXREQ0_BITSFT	(15)
+#define	    E3_TXREQ0_SINGLE	(0<<15)
+#define	    E3_TXREQ0_MULTI	(1<<15)
+#define	    E3_TXREQ0_DEPEND	(2<<15)
+#define	  E3_TXREQ1_BITSFT	(13)
+#define	    E3_TXREQ1_SINGLE	(0<<13)
+#define	    E3_TXREQ1_MULTI	(1<<13)
+#define	    E3_TXREQ1_DEPEND	(2<<13)
+#define	  E3_JUMBO_ENABLE	(1<<12)
+
+#define	 SMAP_EMAC3_MODE1_DEF	(E3_FDX_ENABLE|E3_IGNORE_SQE|E3_MEDIA_100M| \
+				 E3_RXFIFO_2K|E3_TXFIFO_1K| \
+				 E3_TXREQ0_MULTI|E3_TXREQ1_SINGLE)
+
+#define	SMAP_EMAC3_TxMODE0		(SMAP_EMAC3_BASE + 0x08)
+#define	  E3_TX_GNP_0		(1<<31)	/* get new packet */
+#define	  E3_TX_GNP_1		(1<<30)	/* get new packet */
+#define	  E3_TX_GNP_DEPEND	(1<<29)	/* get new packet */
+#define	  E3_TX_FIRST_CHANNEL	(1<<28)
+
+#define	SMAP_EMAC3_TxMODE1		(SMAP_EMAC3_BASE + 0x0C)
+#define	  E3_TX_LOW_REQ_MSK	(0x1F)	/* low priority request */
+#define	  E3_TX_LOW_REQ_BITSFT	(27)	/* low priority request */
+#define	  E3_TX_URG_REQ_MSK	(0xFF)	/* urgent priority request */
+#define	  E3_TX_URG_REQ_BITSFT	(16)	/* urgent priority request */
+
+#define	SMAP_EMAC3_RxMODE		(SMAP_EMAC3_BASE + 0x10)
+#define	  E3_RX_STRIP_PAD	(1<<31)
+#define	  E3_RX_STRIP_FCS	(1<<30)
+#define	  E3_RX_RX_RUNT_FRAME	(1<<29)
+#define	  E3_RX_RX_FCS_ERR	(1<<28)
+#define	  E3_RX_RX_TOO_LONG_ERR	(1<<27)
+#define	  E3_RX_RX_IN_RANGE_ERR	(1<<26)
+#define	  E3_RX_PROP_PF		(1<<25)	/* propagate pause frame */
+#define	  E3_RX_PROMISC		(1<<24)
+#define	  E3_RX_PROMISC_MCAST	(1<<23)
+#define	  E3_RX_INDIVID_ADDR	(1<<22)
+#define	  E3_RX_INDIVID_HASH	(1<<21)
+#define	  E3_RX_BCAST		(1<<20)
+#define	  E3_RX_MCAST		(1<<19)
+
+#define	SMAP_EMAC3_INTR_STAT		(SMAP_EMAC3_BASE + 0x14)
+#define	SMAP_EMAC3_INTR_ENABLE		(SMAP_EMAC3_BASE + 0x18)
+#define	  E3_INTR_OVERRUN	(1<<25)	/* this bit does NOT WORKED */
+#define	  E3_INTR_PF		(1<<24)
+#define	  E3_INTR_BAD_FRAME	(1<<23)
+#define	  E3_INTR_RUNT_FRAME	(1<<22)
+#define	  E3_INTR_SHORT_EVENT	(1<<21)
+#define	  E3_INTR_ALIGN_ERR	(1<<20)
+#define	  E3_INTR_BAD_FCS	(1<<19)
+#define	  E3_INTR_TOO_LONG	(1<<18)
+#define	  E3_INTR_OUT_RANGE_ERR	(1<<17)
+#define	  E3_INTR_IN_RANGE_ERR	(1<<16)
+#define	  E3_INTR_DEAD_DEPEND	(1<<9)
+#define	  E3_INTR_DEAD_0	(1<<8)
+#define	  E3_INTR_SQE_ERR_0	(1<<7)
+#define	  E3_INTR_TX_ERR_0	(1<<6)
+#define	  E3_INTR_DEAD_1	(1<<5)
+#define	  E3_INTR_SQE_ERR_1	(1<<4)
+#define	  E3_INTR_TX_ERR_1	(1<<3)
+#define	  E3_INTR_MMAOP_SUCCESS	(1<<1)
+#define	  E3_INTR_MMAOP_FAIL	(1<<0)
+#define	  E3_INTR_ALL		(E3_INTR_OVERRUN|E3_INTR_PF|E3_INTR_BAD_FRAME| \
+				 E3_INTR_RUNT_FRAME|E3_INTR_SHORT_EVENT| \
+				 E3_INTR_ALIGN_ERR|E3_INTR_BAD_FCS| \
+				 E3_INTR_TOO_LONG|E3_INTR_OUT_RANGE_ERR| \
+				 E3_INTR_IN_RANGE_ERR| \
+				 E3_INTR_DEAD_DEPEND|E3_INTR_DEAD_0| \
+				 E3_INTR_SQE_ERR_0|E3_INTR_TX_ERR_0| \
+				 E3_INTR_DEAD_1|E3_INTR_SQE_ERR_1| \
+				 E3_INTR_TX_ERR_1| \
+				 E3_INTR_MMAOP_SUCCESS|E3_INTR_MMAOP_FAIL)
+#define	  E3_DEAD_ALL		(E3_INTR_DEAD_DEPEND|E3_INTR_DEAD_0| \
+				 E3_INTR_DEAD_1)
+
+#define	SMAP_EMAC3_ADDR_HI		(SMAP_EMAC3_BASE + 0x1C)
+#define	SMAP_EMAC3_ADDR_LO		(SMAP_EMAC3_BASE + 0x20)
+
+#define	SMAP_EMAC3_VLAN_TPID		(SMAP_EMAC3_BASE + 0x24)
+#define	  E3_VLAN_ID_MSK	0xFFFF
+
+#define	SMAP_EMAC3_VLAN_TCI		(SMAP_EMAC3_BASE + 0x28)
+#define	  E3_VLAN_TCITAG_MSK	0xFFFF
+
+#define	SMAP_EMAC3_PAUSE_TIMER		(SMAP_EMAC3_BASE + 0x2C)
+#define	  E3_PTIMER_MSK		0xFFFF
+
+#define	SMAP_EMAC3_INDIVID_HASH1	(SMAP_EMAC3_BASE + 0x30)
+#define	SMAP_EMAC3_INDIVID_HASH2	(SMAP_EMAC3_BASE + 0x34)
+#define	SMAP_EMAC3_INDIVID_HASH3	(SMAP_EMAC3_BASE + 0x38)
+#define	SMAP_EMAC3_INDIVID_HASH4	(SMAP_EMAC3_BASE + 0x3C)
+#define	SMAP_EMAC3_GROUP_HASH1		(SMAP_EMAC3_BASE + 0x40)
+#define	SMAP_EMAC3_GROUP_HASH2		(SMAP_EMAC3_BASE + 0x44)
+#define	SMAP_EMAC3_GROUP_HASH3		(SMAP_EMAC3_BASE + 0x48)
+#define	SMAP_EMAC3_GROUP_HASH4		(SMAP_EMAC3_BASE + 0x4C)
+#define	  E3_HASH_MSK		0xFFFF
+
+#define	SMAP_EMAC3_LAST_SA_HI		(SMAP_EMAC3_BASE + 0x50)
+#define	SMAP_EMAC3_LAST_SA_LO		(SMAP_EMAC3_BASE + 0x54)
+
+#define	SMAP_EMAC3_INTER_FRAME_GAP	(SMAP_EMAC3_BASE + 0x58)
+#define	  E3_IFGAP_MSK		0x3F
+
+#define	SMAP_EMAC3_STA_CTRL		(SMAP_EMAC3_BASE + 0x5C)
+#define	  E3_PHY_DATA_MSK	(0xFFFF)
+#define	  E3_PHY_DATA_BITSFT	(16)
+#define	  E3_PHY_OP_COMP	(1<<15)	/* operation complete */
+#define	  E3_PHY_ERR_READ	(1<<14)
+#define	  E3_PHY_STA_CMD_BITSFT	(12)
+#define	    E3_PHY_READ		(1<<12)
+#define	    E3_PHY_WRITE	(2<<12)
+#define	  E3_PHY_OPBCLCK_BITSFT	(10)
+#define	    E3_PHY_50M		(0<<10)
+#define	    E3_PHY_66M		(1<<10)
+#define	    E3_PHY_83M		(2<<10)
+#define	    E3_PHY_100M		(3<<10)
+#define	  E3_PHY_ADDR_MSK	(0x1F)
+#define	  E3_PHY_ADDR_BITSFT	(5)
+#define	  E3_PHY_REG_ADDR_MSK	(0x1F)
+
+#define	SMAP_EMAC3_TX_THRESHOLD		(SMAP_EMAC3_BASE + 0x60)
+#define	  E3_TX_THRESHLD_MSK	(0x1F)
+#define	  E3_TX_THRESHLD_BITSFT	(27)
+
+#define	SMAP_EMAC3_RX_WATERMARK		(SMAP_EMAC3_BASE + 0x64)
+#define	  E3_RX_LO_WATER_MSK	(0x1FF)
+#define	  E3_RX_LO_WATER_BITSFT	(23)
+#define	  E3_RX_HI_WATER_MSK	(0x1FF)
+#define	  E3_RX_HI_WATER_BITSFT	(7)
+
+#define	SMAP_EMAC3_TX_OCTETS		(SMAP_EMAC3_BASE + 0x68)
+#define	SMAP_EMAC3_RX_OCTETS		(SMAP_EMAC3_BASE + 0x6C)
+
+static inline u_int32_t EMAC3REG_READ(struct smap_chan *dev, u_int32_t offset)
+{
+	u_int16_t __tmphi, __tmplo;
+
+	__tmphi = SMAPREG16(dev, offset);
+	__tmplo = SMAPREG16(dev, offset + 2);
+	return (((u_int32_t)__tmphi << 16) | __tmplo);
+}
+
+static inline void EMAC3REG_WRITE(struct smap_chan *dev, u_int32_t offset, u_int32_t v)
+{
+	WRITE_SMAPREG16(dev, offset, ((v >> 16) & 0xFFFF));
+	WRITE_SMAPREG16(dev, offset + 2, (v & 0xFFFF));
+}
+
+
+/*
+ * PHY Register Offset
+ */
+#define	NS_OUI			0x080017
+#define	DsPHYTER_ADDRESS	0x1
+#define	DsPHYTER_BMCR		0x00
+#define	  PHY_BMCR_RST	(1<<15)		/* ReSeT */
+#define	  PHY_BMCR_LPBK	(1<<14)		/* LooPBacK */
+#define	  PHY_BMCR_100M	(1<<13)		/* speed select, 1:100M, 0:10M */
+#define	  PHY_BMCR_10M	(0<<13)		/* speed select, 1:100M, 0:10M */
+#define	  PHY_BMCR_ANEN	(1<<12)		/* Auto-Negotiation ENable */
+#define	  PHY_BMCR_PWDN	(1<<11)		/* PoWer DowN */
+#define	  PHY_BMCR_ISOL	(1<<10)		/* ISOLate */
+#define	  PHY_BMCR_RSAN	(1<<9)		/* ReStart Auto-Negotiation */
+#define	  PHY_BMCR_DUPM	(1<<8)		/* DUPlex Mode, 1:FDX, 0:HDX */
+#define	  PHY_BMCR_COLT	(1<<7)		/* COLlision Test */
+#define	DsPHYTER_BMSR		0x01
+#define	  PHY_BMSR_ANCP	(1<<5)		/* Auto-Negotiation ComPlete */
+#define	  PHY_BMSR_LINK	(1<<2)		/* LINK status */
+#define	DsPHYTER_PHYIDR1	0x02
+#define	  PHY_IDR1_VAL	(((NS_OUI<<2)>>8)&0xffff)
+#define	DsPHYTER_PHYIDR2	0x03
+#define	  PHY_IDR2_VMDL	0x2		/* Vendor MoDeL number */
+#define	  PHY_IDR2_VAL	\
+		(((NS_OUI<<10)&0xFC00)|((PHY_IDR2_VMDL<<4)&0x3F0))
+#define	  PHY_IDR2_MSK		0xFFF0
+#define	  PHY_IDR2_REV_MSK	0x000F
+
+#define	DsPHYTER_ANAR		0x04
+#define	DsPHYTER_ANLPAR		0x05
+#define	  PHY_ANAR_100FD	(1<<8)
+#define	  PHY_ANAR_100HD	(1<<7)
+#define	  PHY_ANAR_10FD		(1<<6)
+#define	DsPHYTER_ANLPARNP	0x05
+#define	DsPHYTER_ANER		0x06
+#define	DsPHYTER_ANNPTR		0x07
+/* extended registers */
+#define	DsPHYTER_PHYSTS		0x10
+#define	  PHY_STS_REL	(1<<13)		/* Receive Error Latch */
+#define	  PHY_STS_POST	(1<<12)		/* POlarity STatus */
+#define	  PHY_STS_FCSL	(1<<11)		/* False Carrier Sense Latch */
+#define	  PHY_STS_SD	(1<<10)		/* 100BT unconditional Signal Detect */
+#define	  PHY_STS_DSL	(1<<9)		/* 100BT DeScrambler Lock */
+#define	  PHY_STS_PRCV	(1<<8)		/* Page ReCeiVed */
+#define	  PHY_STS_RFLT	(1<<6)		/* Remote FauLT */
+#define	  PHY_STS_JBDT	(1<<5)		/* JaBber DetecT */
+#define	  PHY_STS_ANCP	(1<<4)		/* Auto-Negotiation ComPlete */
+#define	  PHY_STS_LPBK	(1<<3)		/* LooPBacK status */
+#define	  PHY_STS_DUPS	(1<<2)		/* DUPlex Status,1:FDX,0:HDX */
+#define	  PHY_STS_FDX	(1<<2)		/* Full Duplex */
+#define	  PHY_STS_HDX	(0<<2)		/* Half Duplex */
+#define	  PHY_STS_SPDS	(1<<1)		/* SPeeD Status */
+#define	  PHY_STS_10M	(1<<1)		/* 10Mbps */
+#define	  PHY_STS_100M	(0<<1)		/* 100Mbps */
+#define	  PHY_STS_LINK	(1<<0)		/* LINK status */
+#define	DsPHYTER_FCSCR		0x14
+#define	  PHY_FCSCR_THRESHOLD	16
+#define	DsPHYTER_RECR		0x15
+#define	DsPHYTER_PCSR		0x16
+#define	DsPHYTER_PHYCTRL	0x19
+#define	DsPHYTER_10BTSCR	0x1A
+#define	DsPHYTER_CDCTRL		0x1B
+
+#endif	/* __SMAP_H__ */
diff -purN linux-2.6.35.4-orig/drivers/ps2/smaprpc.c linux-2.6.35.4/drivers/ps2/smaprpc.c
--- linux-2.6.35.4-orig/drivers/ps2/smaprpc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/smaprpc.c	2014-07-18 22:29:43.562367724 +0200
@@ -0,0 +1,548 @@
+/*
+ *  PlayStation 2 Ethernet device driver
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#if defined(linux)
+
+#include <linux/platform_device.h>
+
+#include <asm/mach-ps2/sbios.h>
+
+#include "smaprpc.h"
+
+#define SMAP_BIND_RPC_ID 0x0815e000
+
+#define SMAP_CMD_SEND 1
+#define SMAP_CMD_SET_BUFFER 2
+#define SMAP_CMD_GET_MAC_ADDR 3
+
+#define SIF_SMAP_RECEIVE 0x07
+
+typedef struct t_SifCmdHeader {
+	u32 size;
+	void *dest;
+	int cid;
+	u32 unknown;
+} SifCmdHeader_t;
+
+typedef struct {
+	struct t_SifCmdHeader sifcmd;
+	u32 payload;
+	u32 size;
+} iop_sifCmdSmapIrq_t;
+
+static u32 smap_rpc_data[2048] __attribute__ ((aligned(64)));
+
+/*--------------------------------------------------------------------------*/
+
+static int smaprpc_start_xmit(struct sk_buff *skb, struct net_device *net_dev);
+
+static struct net_device_stats *smaprpc_get_stats(struct net_device *net_dev);
+
+static int smaprpc_open(struct net_device *net_dev);
+
+static int smaprpc_close(struct net_device *net_dev);
+
+static int smaprpc_ioctl(struct net_device *net_dev, struct ifreq *ifr,
+	int cmd);
+
+static void smaprpc_rpcend_notify(void *arg);
+
+static void smaprpc_rpc_setup(struct smaprpc_chan *smap);
+
+static int smaprpc_thread(void *arg);
+
+static void smaprpc_run(struct smaprpc_chan *smap);
+
+static void smaprpc_start_xmit2(struct smaprpc_chan *smap);
+
+static void smaprpc_skb_queue_init(struct smaprpc_chan *smap,
+	struct sk_buff_head *head);
+static void smaprpc_skb_enqueue(struct sk_buff_head *head,
+	struct sk_buff *newsk);
+static void smaprpc_skb_enqueue(struct sk_buff_head *head,
+	struct sk_buff *newsk);
+static struct sk_buff *smaprpc_skb_dequeue(struct sk_buff_head *head);
+static inline void eth_copy_and_sum (struct sk_buff *dest, unsigned char *src, int len, int base)
+{
+	memcpy (dest->data, src, len);
+}
+
+/*--------------------------------------------------------------------------*/
+
+static void smaprpc_skb_queue_init(struct smaprpc_chan *smap,
+	struct sk_buff_head *head)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&smap->spinlock, flags);
+	(void) skb_queue_head_init(head);
+	spin_unlock_irqrestore(&smap->spinlock, flags);
+
+	return;
+}
+
+static void smaprpc_skb_enqueue(struct sk_buff_head *head,
+	struct sk_buff *newsk)
+{
+	(void) skb_queue_tail(head, newsk);
+	return;
+}
+
+static void smaprpc_skb_requeue(struct sk_buff_head *head,
+	struct sk_buff *newsk)
+{
+	(void) skb_queue_head(head, newsk);
+	return;
+}
+
+static struct sk_buff *smaprpc_skb_dequeue(struct sk_buff_head *head)
+{
+	struct sk_buff *skb;
+
+	skb = skb_dequeue(head);
+	return (skb);
+}
+
+/*--------------------------------------------------------------------------*/
+
+/* return value: 0 if success, !0 if error */
+static int smaprpc_start_xmit(struct sk_buff *skb, struct net_device *net_dev)
+{
+	struct smaprpc_chan *smap = netdev_priv(net_dev);
+
+	unsigned long flags;
+
+	spin_lock_irqsave(&smap->spinlock, flags);
+
+	smaprpc_skb_enqueue(&smap->txqueue, skb);
+	wake_up(&smap->wait_smaprun);
+	spin_unlock_irqrestore(&smap->spinlock, flags);
+	return (0);
+}
+
+/*--------------------------------------------------------------------------*/
+
+static struct net_device_stats *smaprpc_get_stats(struct net_device *net_dev)
+{
+	struct smaprpc_chan *smap = netdev_priv(net_dev);
+
+	return (&smap->net_stats);
+}
+
+static void smaprpc_run(struct smaprpc_chan *smap)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&smap->spinlock, flags);
+	while (smap->txqueue.qlen > 0) {
+		spin_unlock_irqrestore(&smap->spinlock, flags);
+		smaprpc_start_xmit2(smap);
+		spin_lock_irqsave(&smap->spinlock, flags);
+	}
+	spin_unlock_irqrestore(&smap->spinlock, flags);
+}
+
+
+static void smaprpc_start_xmit2(struct smaprpc_chan *smap)
+{
+	int rv;
+
+	struct completion compl;
+
+	struct sk_buff *skb;
+
+	unsigned long flags;
+
+	spin_lock_irqsave(&smap->spinlock, flags);
+	skb = smaprpc_skb_dequeue(&smap->txqueue);
+	spin_unlock_irqrestore(&smap->spinlock, flags);
+	if (skb == NULL)
+		return;
+
+	init_completion(&compl);
+
+	down(&smap->smap_rpc_sema);
+	memcpy(smap_rpc_data, skb->data, skb->len);
+	do {
+		rv = ps2sif_callrpc(&smap->cd_smap_rpc, SMAP_CMD_SEND,
+			SIF_RPCM_NOWAIT,
+			(void *) smap_rpc_data, skb->len,
+			smap_rpc_data, sizeof(smap_rpc_data),
+			(ps2sif_endfunc_t) smaprpc_rpcend_notify, (void *) &compl);
+	} while (rv == -E_SIF_PKT_ALLOC);
+	if (rv != 0) {
+		printk("%s: smaprpc_start_xmit2: callrpc failed, (%d)\n",
+			smap->net_dev->name, rv);
+
+		spin_lock_irqsave(&smap->spinlock, flags);
+		smaprpc_skb_requeue(&smap->txqueue, skb);
+		spin_unlock_irqrestore(&smap->spinlock, flags);
+	} else {
+		wait_for_completion(&compl);
+
+		dev_kfree_skb(skb);
+	}
+	up(&smap->smap_rpc_sema);
+}
+
+static int smaprpc_open(struct net_device *net_dev)
+{
+	struct smaprpc_chan *smap = netdev_priv(net_dev);
+
+	smap->flags |= SMAPRPC_F_OPENED;
+	smaprpc_skb_queue_init(smap, &smap->txqueue);
+
+	return (0);					/* success */
+}
+
+static int smaprpc_close(struct net_device *net_dev)
+{
+	struct smaprpc_chan *smap = netdev_priv(net_dev);
+
+	unsigned long flags;
+
+	spin_lock_irqsave(&smap->spinlock, flags);
+	smap->flags &= ~SMAPRPC_F_OPENED;
+
+	spin_unlock_irqrestore(&smap->spinlock, flags);
+
+	return (0);					/* success */
+}
+
+/*--------------------------------------------------------------------------*/
+
+static int smaprpc_ioctl(struct net_device *net_dev, struct ifreq *ifr, int cmd)
+{
+	int retval = 0;
+
+	printk("%s: PlayStation 2 SMAP ioctl %d\n", net_dev->name, cmd);
+
+	switch (cmd) {
+	default:
+		retval = -EOPNOTSUPP;
+		break;
+	}
+
+	return (retval);
+}
+
+static void smaprpc_rpc_setup(struct smaprpc_chan *smap)
+{
+	int loop;
+
+	int rv;
+
+	volatile int j;
+
+	struct completion compl;
+
+	if (smap->rpc_initialized) {
+		return;
+	}
+	init_completion(&compl);
+
+	/* bind smaprpc.irx module */
+	for (loop = 100; loop; loop--) {
+		rv = ps2sif_bindrpc(&smap->cd_smap_rpc, SMAP_BIND_RPC_ID,
+			SIF_RPCM_NOWAIT, smaprpc_rpcend_notify, (void *) &compl);
+		if (rv < 0) {
+			printk("%s: smap rpc setup: bind rv = %d.\n", smap->net_dev->name,
+				rv);
+			break;
+		}
+		wait_for_completion(&compl);
+		if (smap->cd_smap_rpc.serve != 0)
+			break;
+		j = 0x010000;
+		while (j--);
+	}
+	if (smap->cd_smap_rpc.serve == 0) {
+		printk("%s: smap rpc setup: bind error 1, network will not work on slim PSTwo\n",
+			smap->net_dev->name);
+		return;
+	}
+
+	memset(smap_rpc_data, 0, 32);
+	do {
+		rv = ps2sif_callrpc(&smap->cd_smap_rpc, SMAP_CMD_GET_MAC_ADDR,
+			SIF_RPCM_NOWAIT,
+			(void *) smap_rpc_data, 32,
+			smap_rpc_data, sizeof(smap_rpc_data),
+			(ps2sif_endfunc_t) smaprpc_rpcend_notify, (void *) &compl);
+	} while (rv == -E_SIF_PKT_ALLOC);
+	if (rv != 0) {
+		printk("%s: SMAP_CMD_GET_MAC_ADDR failed, (%d)\n", smap->net_dev->name,
+			rv);
+	} else {
+		wait_for_completion(&compl);
+		memcpy(smap->net_dev->dev_addr, &smap_rpc_data[1], ETH_ALEN);
+		printk("%s: MAC %02x:%02x:%02x:%02x:%02x:%02x\n", smap->net_dev->name,
+			smap->net_dev->dev_addr[0],
+			smap->net_dev->dev_addr[1],
+			smap->net_dev->dev_addr[2],
+			smap->net_dev->dev_addr[3],
+			smap->net_dev->dev_addr[4], smap->net_dev->dev_addr[5]);
+	}
+
+	smap->shared_size = 32 * 1024;
+	smap->shared_addr = kmalloc(smap->shared_size, GFP_KERNEL);
+	if (smap->shared_addr != NULL) {
+		smap_rpc_data[0] = virt_to_phys(smap->shared_addr);
+		smap_rpc_data[1] = smap->shared_size;
+		do {
+			rv = ps2sif_callrpc(&smap->cd_smap_rpc, SMAP_CMD_SET_BUFFER,
+				SIF_RPCM_NOWAIT,
+				(void *) smap_rpc_data, 32,
+				smap_rpc_data, 4,
+				(ps2sif_endfunc_t) smaprpc_rpcend_notify, (void *) &compl);
+		} while (rv == -E_SIF_PKT_ALLOC);
+		if (rv != 0) {
+			printk("%s: SMAP_CMD_SET_BUFFER failed, (rv = %d). Receive will not work.\n",
+				smap->net_dev->name, rv);
+		} else {
+			wait_for_completion(&compl);
+			if (smap_rpc_data[0] != 0) {
+				printk("%s: SMAP_CMD_SET_BUFFER failed, (0x%08x). Receive will not work.\n",
+					smap->net_dev->name, smap_rpc_data[0]);
+			}
+		}
+	} else {
+		printk("%s: Failed to allocate receive buffer. Receive will not work.\n",
+			smap->net_dev->name);
+	}
+	smap->rpc_initialized = -1;
+}
+
+static int smaprpc_thread(void *arg)
+{
+	struct smaprpc_chan *smap = (struct smaprpc_chan *) arg;
+	sigset_t blocked, oldset;
+
+	siginitsetinv(&blocked, sigmask(SIGKILL)|sigmask(SIGINT)|sigmask(SIGTERM));
+	sigprocmask(SIG_SETMASK, &blocked, &oldset);
+
+	/* get rid of all our resources related to user space */
+	daemonize("smaprpc");
+
+	smap->smaprun_task = current;
+
+	while (1) {
+		DECLARE_WAITQUEUE(wait, current);
+
+		add_wait_queue(&smap->wait_smaprun, &wait);
+		set_current_state(TASK_INTERRUPTIBLE);
+
+		smaprpc_run(smap);
+
+		schedule();
+		remove_wait_queue(&smap->wait_smaprun, &wait);
+		if (signal_pending(current))
+			break;
+	}
+
+	smap->smaprun_task = NULL;
+	if (smap->smaprun_compl != NULL)
+		complete(smap->smaprun_compl);	/* notify that we've exited */
+
+	sigprocmask(SIG_SETMASK, &oldset, NULL);
+
+	return (0);
+}
+
+static void smaprpc_rpcend_notify(void *arg)
+{
+	complete((struct completion *) arg);
+	return;
+}
+
+static void handleSmapIRQ(iop_sifCmdSmapIrq_t * pkt, void *arg)
+{
+	struct smaprpc_chan *smap = (struct smaprpc_chan *) arg;
+
+	struct sk_buff *skb;
+
+	u8 *data;
+
+	dma_cache_inv((unsigned long) pkt, sizeof(*pkt));
+	data = phys_to_virt(pkt->payload);
+	dma_cache_inv((unsigned long) data, pkt->size);
+
+	skb = dev_alloc_skb(pkt->size + 2);
+	if (skb == NULL) {
+		printk("%s:handleSmapIRQ, skb alloc error\n", smap->net_dev->name);
+		return;
+	}
+	skb_reserve(skb, 2);		/* 16 byte align the data fields */
+	eth_copy_and_sum(skb, data, pkt->size, 0);
+	skb_put(skb, pkt->size);
+	skb->dev = smap->net_dev;
+	skb->protocol = eth_type_trans(skb, smap->net_dev);
+	smap->net_dev->last_rx = jiffies;
+	netif_rx(skb);
+}
+
+extern int ps2_pccard_present;
+
+static const struct net_device_ops smaprpc_netdev_ops = {
+	.ndo_open		= smaprpc_open,
+	.ndo_stop		= smaprpc_close,
+	.ndo_do_ioctl		= smaprpc_ioctl,
+	.ndo_start_xmit		= smaprpc_start_xmit,
+	.ndo_get_stats		= smaprpc_get_stats,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_set_mac_address 	= NULL,
+	.ndo_change_mtu		= eth_change_mtu,
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	.ndo_poll_controller = NULL,
+#endif
+};
+
+static int __devinit smaprpc_probe(struct platform_device *dev)
+{
+	struct net_device *net_dev = NULL;
+	struct smaprpc_chan *smap = NULL;
+	struct sb_sifaddcmdhandler_arg addcmdhandlerparam;
+
+	if (ps2_pccard_present != 0x0200) {
+		printk("PlayStation 2 HDD/Ethernet device NOT present (slim PSTwo).\n");
+		return (-ENODEV);
+	}
+
+	net_dev = alloc_etherdev(sizeof(struct smaprpc_chan));
+	if (!net_dev) {
+		return -ENOMEM;
+	}
+
+	SET_NETDEV_DEV(net_dev, &dev->dev);
+	platform_set_drvdata(dev, net_dev);
+
+	smap = netdev_priv(net_dev);
+
+	/* clear control structure */
+	memset(smap, 0, sizeof(struct smaprpc_chan));
+
+	/* init network device structure */
+	ether_setup(net_dev);
+	smap->net_dev = net_dev;
+
+	net_dev->netdev_ops = &smaprpc_netdev_ops;
+
+	spin_lock_init(&smap->spinlock);
+	init_MUTEX(&smap->smap_rpc_sema);
+	init_waitqueue_head(&smap->wait_smaprun);
+
+	addcmdhandlerparam.fid = SIF_SMAP_RECEIVE;
+	addcmdhandlerparam.func = handleSmapIRQ;
+	addcmdhandlerparam.data = (void *) smap;
+	if (sbios(SB_SIFADDCMDHANDLER, &addcmdhandlerparam) < 0) {
+		printk("Failed to initialize smap IRQ handler. Receive will not work.\n");
+	}
+
+	if (register_netdev(net_dev)) {
+		goto error;
+	}
+	smaprpc_rpc_setup(smap);
+
+	if (smap->rpc_initialized) {
+		kernel_thread(smaprpc_thread, (void *) smap, 0);
+
+		printk("Slim PlayStation 2 SMAP(Ethernet) device driver.\n");
+
+		return (0);				/* success */
+	}
+	unregister_netdev(net_dev);
+error:
+	printk("Slim PlayStation 2 SMAP(Ethernet) device not found.\n");
+	free_netdev(net_dev);
+	return (-ENODEV);
+}
+
+static int __devexit smaprpc_driver_remove(struct platform_device *pdev)
+{
+	struct net_device *net_dev = platform_get_drvdata(pdev);
+	struct smaprpc_chan *smap = netdev_priv(net_dev);
+
+	if (smap->rpc_initialized) {
+		/* Remove interrupt handler. */
+		struct sb_sifremovecmdhandler_arg param;
+
+		param.fid = SIF_SMAP_RECEIVE;
+		if (sbios(SB_SIFREMOVECMDHANDLER, &param) < 0) {
+			printk("Failed to remove smap IRQ handler.\n");
+		}
+	}
+
+	if (smap->smaprun_task != NULL) {
+		struct completion compl;
+
+		init_completion(&compl);
+		smap->smaprun_compl = &compl;
+		send_sig(SIGKILL, smap->smaprun_task, 1);
+
+		/* wait the thread exit */
+		wait_for_completion(&compl);
+		smap->smaprun_compl = NULL;
+	}
+	if (smap->shared_addr != NULL) {
+		kfree(smap->shared_addr);
+	}
+
+	if (net_dev->flags & IFF_UP)
+		dev_close(net_dev);
+
+	unregister_netdev(net_dev);
+
+	/* XXX: Disable device. */
+
+	free_netdev(net_dev);
+	return 0;
+}
+
+static struct platform_driver smap_driver = {
+	.probe	= smaprpc_probe,
+	.remove	= __devexit_p(smaprpc_driver_remove),
+	.driver	= {
+		.name	= "ps2smaprpc",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init smaprpc_init(void)
+{
+	return platform_driver_register(&smap_driver);
+}
+
+static void __exit smaprpc_exit(void)
+{
+	platform_driver_unregister(&smap_driver);
+	return;
+}
+
+
+module_init(smaprpc_init);
+module_exit(smaprpc_exit);
+
+MODULE_AUTHOR("Juergen Urban");
+MODULE_DESCRIPTION("PlayStation 2 ethernet device driver for slim PSTwo");
+MODULE_LICENSE("GPL");
+
+/*--------------------------------------------------------------------------*/
+
+#endif /* linux */
diff -purN linux-2.6.35.4-orig/drivers/ps2/smaprpc.h linux-2.6.35.4/drivers/ps2/smaprpc.h
--- linux-2.6.35.4-orig/drivers/ps2/smaprpc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/smaprpc.h	2014-07-18 22:29:43.562367724 +0200
@@ -0,0 +1,75 @@
+/*
+ *  PlayStation 2 Ethernet device driver header file
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef	__SMAP_H__
+#define	__SMAP_H__
+
+#include <linux/version.h>
+
+#include <linux/module.h>
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/semaphore.h>
+
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/mach-ps2/sifdefs.h>
+#include <asm/mach-ps2/dmarelay.h>
+
+/*
+ * SMAP control structure(smap channel)
+ */
+struct smaprpc_chan {
+	spinlock_t spinlock;
+	struct net_device *net_dev;
+	u_int32_t flags;
+	u_int32_t irq;
+	struct net_device_stats net_stats;
+
+	ps2sif_clientdata_t cd_smap_rpc;
+	int rpc_initialized;
+	struct semaphore smap_rpc_sema;
+
+	struct task_struct *smaprun_task;
+	struct completion *smaprun_compl;
+	wait_queue_head_t wait_smaprun;
+
+	struct sk_buff_head txqueue;
+
+	void *shared_addr;
+	unsigned int shared_size;
+};
+
+/* flags */
+#define	SMAPRPC_F_OPENED		(1<<0)
+
+#endif /* __SMAP_H__ */
diff -purN linux-2.6.35.4-orig/drivers/ps2/sysproc.c linux-2.6.35.4/drivers/ps2/sysproc.c
--- linux-2.6.35.4-orig/drivers/ps2/sysproc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/ps2/sysproc.c	2014-07-18 22:29:43.562367724 +0200
@@ -0,0 +1,139 @@
+/*
+ *  PlayStation 2 ps2sysproc
+ *
+ *  Copyright (C) 2000-2002 Sony Computer Entertainment Inc.
+ *  Copyright (C) 2010-2013 Juergen Urban
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+/* sysvers */
+#include <asm/mach-ps2/bootinfo.h>
+
+/* sysconf */
+#include <asm/mach-ps2/sysconf.h>
+#include <asm/mach-ps2/ps2.h>
+
+#define INIT_PROC	(1<< 3)
+static int init_flags;
+
+static int proc_calc_metrics(char *page, char **start, off_t off,
+				 int count, int *eof, int len)
+{
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+	return len;
+}
+
+
+int get_ps2sysvers(char *page, char **start, off_t off,
+				 int count, int *eof, void *data)
+{
+        int len;
+
+	sprintf(page,
+		"MODELNAME=\"%s\"\n"
+		"PS1DRVROMVERSION=\"%s\"\n"
+		"PS1DRVHDDVERSION=\"%s\"\n"
+		"PS1DRVPATH=\"%s\"\n"
+		"VM=\"%s\"\n"
+		"RB=\"%s\"\n"
+		"DVDIDCHAR=\"%s\"\n"
+		"DVDROMVERSION=\"%s\"\n"
+		"DVDHDDVERSION=\"%s\"\n"
+		"DVDPATH=\"%s\"\n",
+		ps2_bootinfo->ver_model,
+		ps2_bootinfo->ver_ps1drv_rom,
+		ps2_bootinfo->ver_ps1drv_hdd,
+		ps2_bootinfo->ver_ps1drv_path,
+		ps2_bootinfo->ver_vm,
+		ps2_bootinfo->ver_rb,
+		ps2_bootinfo->ver_dvd_id,
+		ps2_bootinfo->ver_dvd_rom,
+		ps2_bootinfo->ver_dvd_hdd,
+		ps2_bootinfo->ver_dvd_path);
+	
+	len = strlen(page);
+	return proc_calc_metrics(page, start, off, count, eof, len);
+}
+
+
+int get_ps2sysconf(char *page, char **start, off_t off,
+				 int count, int *eof, void *data)
+{
+        int len;
+
+	sprintf(page,
+		"EXDEVICE=0x%04x\n"
+		"RGBYC=%d\n"
+		"SPDIF=%d\n"
+		"ASPECT=%d\n"
+		"LANGUAGE=%d\n"
+		"TIMEZONE=%d\n"
+		"SUMMERTIME=%d\n"
+		"DATENOTATION=%d\n"
+		"TIMENOTATION=%d\n",
+		ps2_pccard_present,
+		ps2_sysconf->video,
+		ps2_sysconf->spdif,
+		ps2_sysconf->aspect,
+		ps2_sysconf->language,
+		ps2_sysconf->timezone,
+		ps2_sysconf->summertime,
+		ps2_sysconf->datenotation,
+		ps2_sysconf->timenotation);
+
+	len = strlen(page);
+	return proc_calc_metrics(page, start, off, count, eof, len);
+}
+
+
+int __init ps2sysproc_init(void)
+{
+
+#ifdef CONFIG_PROC_FS
+	create_proc_read_entry("ps2sysvers", 0, 0, get_ps2sysvers, NULL);
+	create_proc_read_entry("ps2sysconf", 0, 0, get_ps2sysconf, NULL);
+	init_flags |= INIT_PROC;
+#endif
+	return 0;
+}
+
+void
+ps2sysproc_cleanup(void)
+{
+#ifdef CONFIG_PROC_FS
+	if (init_flags & INIT_PROC)
+		remove_proc_entry("ps2sysvers", NULL);
+		remove_proc_entry("ps2sysconf", NULL);
+	init_flags &= ~INIT_PROC;
+#endif
+}
+
+module_init(ps2sysproc_init);
+module_exit(ps2sysproc_cleanup);
+
+MODULE_AUTHOR("Sony Computer Entertainment Inc.");
+MODULE_DESCRIPTION("PlayStation 2 System proc");
+MODULE_LICENSE("GPL");
+
diff -purN linux-2.6.35.4-orig/drivers/rtc/Kconfig linux-2.6.35.4/drivers/rtc/Kconfig
--- linux-2.6.35.4-orig/drivers/rtc/Kconfig	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/drivers/rtc/Kconfig	2014-07-18 22:29:43.566367724 +0200
@@ -905,4 +905,14 @@ config RTC_DRV_MPC5121
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-mpc5121.
 
+config RTC_DRV_PS2
+	tristate "PS2 RTC"
+	depends on SONY_PS2
+	default y
+	help
+	  If you say yes here you will get support for the RTC on PS2.
+
+	  This driver can also be built as a module. If so, the module
+	  will be called rtc-ps2.
+
 endif # RTC_CLASS
diff -purN linux-2.6.35.4-orig/drivers/rtc/Makefile linux-2.6.35.4/drivers/rtc/Makefile
--- linux-2.6.35.4-orig/drivers/rtc/Makefile	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/drivers/rtc/Makefile	2014-07-18 22:29:43.566367724 +0200
@@ -94,3 +94,4 @@ obj-$(CONFIG_RTC_DRV_VR41XX)	+= rtc-vr41
 obj-$(CONFIG_RTC_DRV_WM831X)	+= rtc-wm831x.o
 obj-$(CONFIG_RTC_DRV_WM8350)	+= rtc-wm8350.o
 obj-$(CONFIG_RTC_DRV_X1205)	+= rtc-x1205.o
+obj-$(CONFIG_RTC_DRV_PS2)	+= rtc-ps2.o
diff -purN linux-2.6.35.4-orig/drivers/rtc/rtc-ps2.c linux-2.6.35.4/drivers/rtc/rtc-ps2.c
--- linux-2.6.35.4-orig/drivers/rtc/rtc-ps2.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/rtc/rtc-ps2.c	2014-07-18 22:29:43.566367724 +0200
@@ -0,0 +1,196 @@
+/*
+ * PS2 RTC Driver
+ *
+ * Copyright 2011 Mega Man
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.
+ * If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/rtc.h>
+
+#include "asm/mach-ps2/siflock.h"
+#include "asm/mach-ps2/sbios.h"
+#include "asm/mach-ps2/bootinfo.h"
+#include "asm/mach-ps2/cdvdcall.h"
+
+static ps2sif_lock_t *ps2rtc_lock;
+
+#define PS2_RTC_TZONE	(9 * 60 * 60)
+
+static inline int bcd_to_bin(int val)
+{
+	return (val & 0x0f) + (val >> 4) * 10;
+}
+
+static inline int bin_to_bcd(int val)
+{
+	return ((val / 10) << 4) + (val % 10);
+}
+
+static unsigned long ps2_rtc_get_time(void)
+{
+	int rv;
+	unsigned long t;
+	struct sbr_cdvd_rtc_arg rtc_arg;
+	struct ps2_rtc rtc;
+
+	ps2sif_lock(ps2rtc_lock, "read rtc");
+	rv = ps2cdvdcall_readrtc(&rtc_arg);
+	ps2sif_unlock(ps2rtc_lock);
+
+	if (rv != 1 || rtc_arg.stat != 0) {
+		/* RTC read error */
+		return 0;
+	}
+
+	rtc.sec = bcd_to_bin(rtc_arg.second);
+	rtc.min = bcd_to_bin(rtc_arg.minute);
+	rtc.hour = bcd_to_bin(rtc_arg.hour);
+	rtc.day = bcd_to_bin(rtc_arg.day);
+	rtc.mon = bcd_to_bin(rtc_arg.month);
+	rtc.year = bcd_to_bin(rtc_arg.year);
+
+	/* Convert PlayStation 2 system time (JST) to UTC */
+	t = mktime(rtc.year + 2000, rtc.mon, rtc.day,
+			rtc.hour, rtc.min, rtc.sec);
+	t -= PS2_RTC_TZONE;
+
+	return (t);
+}
+
+static int ps2_rtc_set_time(unsigned long t)
+{
+	int res;
+	struct sbr_cdvd_rtc_arg rtc_arg;
+	struct rtc_time tm;
+
+	/*
+	 * timer_interrupt in arch/mips/kernel/time.c calls this function
+	 * in interrupt.
+	 */
+	if (in_interrupt()) {
+		/* You can't touch RTC in interrupt */
+		return -EAGAIN;
+	}
+
+	/* convert UTC to PlayStation 2 system time (JST) */
+	t += PS2_RTC_TZONE;
+	rtc_time_to_tm(t, &tm);
+
+	rtc_arg.stat = 0;
+	rtc_arg.second = bin_to_bcd(tm.tm_sec);
+	rtc_arg.minute = bin_to_bcd(tm.tm_min);
+	rtc_arg.hour = bin_to_bcd(tm.tm_hour);
+	rtc_arg.day = bin_to_bcd(tm.tm_mday);
+	rtc_arg.month = bin_to_bcd(tm.tm_mon + 1);
+	rtc_arg.year = bin_to_bcd(tm.tm_year - 100);
+
+	ps2sif_lock(ps2rtc_lock, "write rtc");
+	res = ps2cdvdcall_writertc(&rtc_arg);
+	ps2sif_unlock(ps2rtc_lock);
+	if (res != 1)
+		return -EIO;
+	if (rtc_arg.stat != 0)
+		return -EIO;
+
+	return 0;
+}
+
+static int ps2_get_time(struct device *dev, struct rtc_time *tm)
+{
+	unsigned long t;
+
+	t = ps2_rtc_get_time();
+	if (t == 0) {
+		return -EIO;
+	}
+	rtc_time_to_tm(t, tm);
+	return rtc_valid_tm(tm);
+}
+
+static int ps2_set_time(struct device *dev, struct rtc_time *tm)
+{
+	unsigned long t;
+
+	rtc_tm_to_time(tm, &t);
+	return ps2_rtc_set_time(t);
+}
+
+static const struct rtc_class_ops ps2_rtc_ops = {
+	.read_time = ps2_get_time,
+	.set_time = ps2_set_time,
+};
+
+static int __init ps2_rtc_probe(struct platform_device *dev)
+{
+	struct rtc_device *rtc;
+
+	if ((ps2rtc_lock = ps2sif_getlock(PS2LOCK_RTC)) == NULL) {
+		printk(KERN_ERR "ps2rtc: Can't get lock\n");
+		return -EINVAL;
+	}
+
+	ps2sif_lock(ps2rtc_lock, "rtc init");
+	if (ps2cdvdcall_init()) {
+		ps2sif_unlock(ps2rtc_lock);
+		printk(KERN_ERR "ps2rtc: Can't initialize CD/DVD-ROM subsystem\n");
+		return -ENODEV;
+	}
+
+	printk(KERN_INFO "PlayStation 2 Real Time Clock driver\n");
+	ps2sif_unlock(ps2rtc_lock);
+
+	rtc = rtc_device_register("rtc-ps2", &dev->dev, &ps2_rtc_ops,
+				  THIS_MODULE);
+	if (IS_ERR(rtc))
+		return PTR_ERR(rtc);
+
+	platform_set_drvdata(dev, rtc);
+	return 0;
+}
+
+static int __exit ps2_rtc_remove(struct platform_device *dev)
+{
+	rtc_device_unregister(platform_get_drvdata(dev));
+	return 0;
+}
+
+static struct platform_driver ps2_rtc_driver = {
+	.driver = {
+		.name = "rtc-ps2",
+		.owner = THIS_MODULE,
+	},
+	.remove = __exit_p(ps2_rtc_remove),
+};
+
+static int __init ps2_rtc_init(void)
+{
+	return platform_driver_probe(&ps2_rtc_driver, ps2_rtc_probe);
+}
+
+static void __exit ps2_rtc_fini(void)
+{
+	platform_driver_unregister(&ps2_rtc_driver);
+}
+
+module_init(ps2_rtc_init);
+module_exit(ps2_rtc_fini);
+
+MODULE_AUTHOR("Mega Man");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("ps2 RTC driver");
+MODULE_ALIAS("platform:rtc-ps2");
diff -purN linux-2.6.35.4-orig/drivers/serial/Kconfig linux-2.6.35.4/drivers/serial/Kconfig
--- linux-2.6.35.4-orig/drivers/serial/Kconfig	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/drivers/serial/Kconfig	2014-07-18 22:29:43.566367724 +0200
@@ -1575,4 +1575,29 @@ config SERIAL_ALTERA_UART_CONSOLE
 	help
 	  Enable a Altera UART port to be the system console.
 
+config SERIAL_PS2_SBIOS
+	tristate "PS2 serial port over SBIOS"
+	depends on SONY_PS2
+	select SERIAL_CORE
+	default n
+	help
+	  If you have Sony Playstation 2 the output is handled by
+	  the putc function of the SBIOS.
+	  This means you can see the output in ps2link or with
+	  a serial cable connected to the internal serial pins
+	  of the PS2.
+	  To use this as system console, you need to specify
+	  the kernel parameter:
+	  console=ttyS0
+
+config SERIAL_PS2_SBIOS_DEFAULT
+	bool "Use PS2 serial console as default"
+	depends on SERIAL_PS2_SBIOS=y
+	default n
+	help
+	  Don't use graphical console as default. Use PS2 SBIOS
+	  console as default console. This is only for debugging
+	  You need to have a PS2 serial cable or ps2link enabled
+	  in kernelloader.
+
 endmenu
diff -purN linux-2.6.35.4-orig/drivers/serial/Makefile linux-2.6.35.4/drivers/serial/Makefile
--- linux-2.6.35.4-orig/drivers/serial/Makefile	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/drivers/serial/Makefile	2014-07-18 22:29:43.566367724 +0200
@@ -84,3 +84,4 @@ obj-$(CONFIG_SERIAL_TIMBERDALE)	+= timbu
 obj-$(CONFIG_SERIAL_GRLIB_GAISLER_APBUART) += apbuart.o
 obj-$(CONFIG_SERIAL_ALTERA_JTAGUART) += altera_jtaguart.o
 obj-$(CONFIG_SERIAL_ALTERA_UART) += altera_uart.o
+obj-$(CONFIG_SERIAL_PS2_SBIOS) += ps2sbioscon.o
diff -purN linux-2.6.35.4-orig/drivers/serial/ps2sbioscon.c linux-2.6.35.4/drivers/serial/ps2sbioscon.c
--- linux-2.6.35.4-orig/drivers/serial/ps2sbioscon.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/serial/ps2sbioscon.c	2014-07-18 22:29:43.566367724 +0200
@@ -0,0 +1,330 @@
+/*
+ * PS2 SBIOS serial driver
+ *
+ * Copyright (C) 2010 Mega Man
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; version 2 of the License.
+ */
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <linux/console.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ps2/ps2.h>
+
+/* 20 ms */
+#define DELAY_TIME 2
+
+#define DUMMY ((void *) ps2sbios_dummy)
+
+static struct console ps2sbios_console;
+
+static struct timer_list *timer;
+
+static int ps2sbios_dummy(void)
+{
+	return 0;
+}
+
+static void ps2sbios_con_stop_tx(struct uart_port *port)
+{
+}
+
+static void ps2sbios_con_stop_rx(struct uart_port *port)
+{
+}
+
+static void ps2sbios_con_enable_ms(struct uart_port *port)
+{
+}
+
+static void ps2sbios_con_tx_chars(struct uart_port *port)
+{
+	struct circ_buf *xmit = &port->state->xmit;
+	int count;
+
+	if (port->x_char) {
+		prom_putchar(port->x_char);
+		port->icount.tx++;
+		port->x_char = 0;
+		return;
+	}
+	if (uart_circ_empty(xmit) || uart_tx_stopped(port)) {
+		ps2sbios_con_stop_tx(port);
+		return;
+	}
+
+	count = port->fifosize >> 1;
+	do {
+		prom_putchar(xmit->buf[xmit->tail]);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		port->icount.tx++;
+		if (uart_circ_empty(xmit))
+			break;
+	} while (--count > 0);
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(port);
+
+	if (uart_circ_empty(xmit))
+		ps2sbios_con_stop_tx(port);
+}
+
+static void ps2sbios_con_start_tx(struct uart_port *port)
+{
+}
+
+static void ps2sbios_con_timer (unsigned long data)
+{
+	struct uart_port *port;
+	struct tty_struct *tty;
+
+	port = (struct uart_port *)data;
+	if (!port)
+		return;
+	if (!port->state)
+		return;
+	tty = port->state->port.tty;
+	if (!tty)
+		return;
+
+	/* Restart the timer */
+	timer->expires = jiffies + DELAY_TIME;
+	add_timer (timer);
+
+	/* Transmit data */
+	ps2sbios_con_tx_chars(port);
+}
+
+static unsigned int ps2sbios_con_tx_empty(struct uart_port *port)
+{
+	return 0;
+}
+
+static unsigned int ps2sbios_con_get_mctrl(struct uart_port *port)
+{
+	return 0;
+}
+
+static void ps2sbios_con_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+}
+
+static void ps2sbios_con_break_ctl(struct uart_port *port, int break_state)
+{
+}
+
+static void ps2sbios_con_set_termios(struct uart_port *port, struct ktermios *termios,
+			      struct ktermios *old)
+{
+}
+
+static int ps2sbios_con_startup(struct uart_port *port)
+{
+	/* Create timer for transmit */
+	if (!timer) {
+		timer = kmalloc (sizeof (*timer), GFP_KERNEL);
+		if (!timer)
+			return -ENOMEM;
+	}
+	memset(timer, 0, sizeof(*timer));
+	init_timer(timer);
+	timer->data = (unsigned long )port;
+	timer->expires = jiffies + DELAY_TIME;
+	timer->function = ps2sbios_con_timer;
+	add_timer (timer);
+	return 0;
+}
+
+static void ps2sbios_con_shutdown(struct uart_port *port)
+{
+	/* Stop timer */
+	del_timer (timer);
+}
+
+static const char *ps2sbios_con_type(struct uart_port *port)
+{
+	return PS2_SBIOS_SERIAL_DEVICE_NAME;
+}
+
+static void ps2sbios_con_release_port(struct uart_port *port)
+{
+}
+
+static int ps2sbios_con_request_port(struct uart_port *port)
+{
+	return 0;
+}
+
+static void ps2sbios_con_config_port(struct uart_port *port, int flags)
+{
+}
+
+static int ps2sbios_con_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	return 0;
+}
+
+static struct uart_ops ps2sbios_con_ops = {
+	.tx_empty		= ps2sbios_con_tx_empty,
+	.set_mctrl		= ps2sbios_con_set_mctrl,
+	.get_mctrl		= ps2sbios_con_get_mctrl,
+	.stop_tx		= ps2sbios_con_stop_tx,
+	.start_tx		= ps2sbios_con_start_tx,
+	.stop_rx		= ps2sbios_con_stop_rx,
+	.enable_ms		= ps2sbios_con_enable_ms,
+	.break_ctl		= ps2sbios_con_break_ctl,
+	.startup		= ps2sbios_con_startup,
+	.shutdown		= ps2sbios_con_shutdown,
+	.set_termios	= ps2sbios_con_set_termios,
+	.type			= ps2sbios_con_type,
+	.release_port	= ps2sbios_con_release_port,
+	.request_port	= ps2sbios_con_request_port,
+	.config_port	= ps2sbios_con_config_port,
+	.verify_port	= ps2sbios_con_verify_port,
+};
+
+static struct uart_port ps2sbios_con_port = {
+	.ops		= &ps2sbios_con_ops,
+	.type		= PORT_PS2_SBIOS,
+	.flags		= UPF_BOOT_AUTOCONF,
+};
+
+static struct uart_driver ps2sbios_con_reg = {
+	.owner			= THIS_MODULE,
+	.driver_name	= "ps2sbios-uart",
+	.dev_name		= PS2_SBIOS_SERIAL_DEVICE_NAME,
+	.major			= TTY_MAJOR,
+	.minor			= 64,
+	.nr				= 1,
+	.cons			= &ps2sbios_console,
+};
+
+static int serial_ps2sbios_probe(struct platform_device *dev)
+{
+	return uart_add_one_port(&ps2sbios_con_reg, &ps2sbios_con_port);
+}
+
+static int serial_ps2sbios_remove(struct platform_device *dev)
+{
+	struct uart_port *port = platform_get_drvdata(dev);
+
+	uart_remove_one_port(&ps2sbios_con_reg, port);
+	kfree(port);
+
+	return 0;
+}
+
+static const struct dev_pm_ops serial_ps2sbios_pm_ops = {
+	.suspend	= DUMMY,
+	.resume		= DUMMY,
+};
+
+static struct platform_driver serial_ps2sbios_driver = {
+	.probe          = serial_ps2sbios_probe,
+	.remove         = serial_ps2sbios_remove,
+
+	.driver		= {
+		.name	= "ps2sbios-uart",
+		.owner	= THIS_MODULE,
+		.bus	= &platform_bus_type,
+#ifdef CONFIG_PM
+		.pm	= &serial_ps2sbios_pm_ops,
+#endif
+	},
+};
+
+static int	ps2sbios_console_setup(struct console *con, char *options)
+{
+	printk("SBIOS console registered as port %s%d\n", con->name, con->index);
+	return 0;
+}
+
+static void ps2sbios_console_write(struct console *con, const char *s, unsigned n)
+{
+	while (n-- && *s) {
+		if (*s == '\n')
+			prom_putchar('\r');
+		prom_putchar(*s);
+		s++;
+	}
+}
+
+static struct console ps2sbios_console = {
+	.name		= PS2_SBIOS_SERIAL_DEVICE_NAME,
+	.write		= ps2sbios_console_write,
+	.device		= uart_console_device,
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+	.data		= &ps2sbios_con_reg,
+	.setup		= ps2sbios_console_setup,
+};
+
+static struct platform_device ps2sbios_device = {
+	.name			= "ps2sbios-uart",
+	.id				= 0,
+	.dev			= {
+		.platform_data	= NULL,
+	},
+};
+
+static int __init ps2sbios_console_init(void)
+{
+	register_console(&ps2sbios_console);
+	return 0;
+}
+
+static int __init ps2sbios_con_init(void)
+{
+	int result;
+
+	printk("PS2 SBIOS serial driver");
+
+	result = uart_register_driver(&ps2sbios_con_reg);
+	if (result)
+		return result;
+
+	result = platform_driver_register(&serial_ps2sbios_driver);
+	if (result == 0) {
+		result = platform_device_register(&ps2sbios_device);
+		if (result != 0) {
+			platform_driver_unregister(&serial_ps2sbios_driver);
+			uart_unregister_driver(&ps2sbios_con_reg);
+		}
+	} else {
+		uart_unregister_driver(&ps2sbios_con_reg);
+	}
+
+	return result;
+}
+
+void __exit ps2sbios_con_exit(void)
+{
+	platform_driver_unregister(&serial_ps2sbios_driver);
+	uart_unregister_driver(&ps2sbios_con_reg);
+
+	if (timer) {
+		kfree(timer);
+		timer = NULL;
+	}
+}
+
+console_initcall(ps2sbios_console_init);
+module_init (ps2sbios_con_init);
+module_exit(ps2sbios_con_exit);
+
+/* Module information */
+MODULE_AUTHOR("Mega Man");
+MODULE_DESCRIPTION("PS2 SBIOS serial driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:ps2sbios-uart");
diff -purN linux-2.6.35.4-orig/drivers/usb/core/buffer.c linux-2.6.35.4/drivers/usb/core/buffer.c
--- linux-2.6.35.4-orig/drivers/usb/core/buffer.c	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/drivers/usb/core/buffer.c	2014-07-18 22:29:43.566367724 +0200
@@ -115,9 +115,11 @@ void *hcd_buffer_alloc(
 		return kmalloc(size, mem_flags);
 	}
 
-	for (i = 0; i < HCD_BUFFER_POOLS; i++) {
-		if (size <= pool_max [i])
-			return dma_pool_alloc(hcd->pool [i], mem_flags, dma);
+	if (!(hcd->driver->flags & HCD_LOCAL_DMA)) {
+		for (i = 0; i < HCD_BUFFER_POOLS; i++) {
+			if (size <= pool_max [i])
+				return dma_pool_alloc(hcd->pool [i], mem_flags, dma);
+		}
 	}
 	return dma_alloc_coherent(hcd->self.controller, size, dma, mem_flags);
 }
@@ -141,10 +143,12 @@ void hcd_buffer_free(
 		return;
 	}
 
-	for (i = 0; i < HCD_BUFFER_POOLS; i++) {
-		if (size <= pool_max [i]) {
-			dma_pool_free(hcd->pool [i], addr, dma);
-			return;
+	if (!(hcd->driver->flags & HCD_LOCAL_DMA)) {
+		for (i = 0; i < HCD_BUFFER_POOLS; i++) {
+			if (size <= pool_max [i]) {
+				dma_pool_free(hcd->pool [i], addr, dma);
+				return;
+			}
 		}
 	}
 	dma_free_coherent(hcd->self.controller, size, addr, dma);
diff -purN linux-2.6.35.4-orig/drivers/usb/core/hcd.c linux-2.6.35.4/drivers/usb/core/hcd.c
--- linux-2.6.35.4-orig/drivers/usb/core/hcd.c	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/drivers/usb/core/hcd.c	2014-07-18 22:29:43.566367724 +0200
@@ -2140,7 +2140,7 @@ struct usb_hcd *usb_create_hcd (const st
 	usb_bus_init(&hcd->self);
 	hcd->self.controller = dev;
 	hcd->self.bus_name = bus_name;
-	hcd->self.uses_dma = (dev->dma_mask != NULL);
+	hcd->self.uses_dma = (dev->dma_mask != NULL) && !(driver->flags & HCD_LOCAL_DMA);
 
 	init_timer(&hcd->rh_timer);
 	hcd->rh_timer.function = rh_timer_func;
diff -purN linux-2.6.35.4-orig/drivers/usb/host/ohci-hcd.c linux-2.6.35.4/drivers/usb/host/ohci-hcd.c
--- linux-2.6.35.4-orig/drivers/usb/host/ohci-hcd.c	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/drivers/usb/host/ohci-hcd.c	2014-07-18 22:29:43.570367725 +0200
@@ -641,6 +641,11 @@ retry:
 		}
 		udelay (1);
 	}
+#ifdef CONFIG_SONY_PS2
+	/* Enable USB. Leave PS2DEV enabled. */
+	outl(inl(0x1F801570) | 0x08000080, 0x1F801570);
+	outl(1, 0x1F801680);
+#endif
 
 	/* now we're in the SUSPEND state ... must go OPERATIONAL
 	 * within 2msec else HC enters RESUME
@@ -773,6 +778,10 @@ static irqreturn_t ohci_irq (struct usb_
 	/* We only care about interrupts that are enabled */
 	ints &= ohci_readl(ohci, &regs->intrenable);
 
+#ifdef CONFIG_SONY_PS2
+	ohci_writel(ohci, OHCI_INTR_MIE, &regs->intrdisable);
+#endif
+
 	/* interrupt for some other device? */
 	if (ints == 0)
 		return IRQ_NOTMINE;
@@ -1095,6 +1104,11 @@ MODULE_LICENSE ("GPL");
 #define TMIO_OHCI_DRIVER	ohci_hcd_tmio_driver
 #endif
 
+#if defined(CONFIG_SONY_PS2)
+#include "ohci-ps2.c"
+#define PLATFORM_DRIVER		ohci_hcd_ps2_driver
+#endif
+
 #if	!defined(PCI_DRIVER) &&		\
 	!defined(PLATFORM_DRIVER) &&	\
 	!defined(OMAP1_PLATFORM_DRIVER) &&	\
diff -purN linux-2.6.35.4-orig/drivers/usb/host/ohci-ps2.c linux-2.6.35.4/drivers/usb/host/ohci-ps2.c
--- linux-2.6.35.4-orig/drivers/usb/host/ohci-ps2.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/usb/host/ohci-ps2.c	2014-07-18 22:29:43.570367725 +0200
@@ -0,0 +1,200 @@
+/*
+ * USB OHCI HCD (Host Controller Driver) for Playstation 2.
+ *
+ * Copyright (C) 2010 Mega Man
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#include <linux/platform_device.h>
+
+#include <asm/mach-ps2/sifdefs.h>
+
+/* Size of buffer allocated from IOP heap. */
+#define DMA_BUFFER_SIZE (256 * 1024)
+
+#define ERROR(args...) printk(KERN_ERR "ohci-ps: " args);
+
+/* Copied from drivers/base/dma-coherent.c */
+struct dma_coherent_mem {
+	void		*virt_base;
+	u32		device_base;
+	int		size;
+	int		flags;
+	unsigned long	*bitmap;
+};
+
+
+static int ohci_ps2_start(struct usb_hcd *hcd)
+{
+	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
+
+	ohci_hcd_init(ohci);
+	ohci_init(ohci);
+	ohci_run(ohci);
+	hcd->state = HC_STATE_RUNNING;
+	return 0;
+}
+
+static const struct hc_driver ohci_ps2_hc_driver = {
+	.description =		hcd_name,
+	.product_desc =		"PS2 OHCI",
+	.hcd_priv_size =	sizeof(struct ohci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq =			ohci_irq,
+	.flags =		HCD_USB11 | HCD_MEMORY | HCD_LOCAL_MEM | HCD_LOCAL_DMA,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.start =		ohci_ps2_start,
+	.stop =			ohci_stop,
+	.shutdown =		ohci_shutdown,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue =		ohci_urb_enqueue,
+	.urb_dequeue =		ohci_urb_dequeue,
+	.endpoint_disable =	ohci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number =	ohci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data =	ohci_hub_status_data,
+	.hub_control =		ohci_hub_control,
+#ifdef	CONFIG_PM
+	.bus_suspend =		ohci_bus_suspend,
+	.bus_resume =		ohci_bus_resume,
+#endif
+	.start_port_reset =	ohci_start_port_reset,
+};
+
+/*-------------------------------------------------------------------------*/
+
+static int __devinit
+iopheap_alloc_coherent(struct device *dev, size_t size, int flags)
+{
+	dma_addr_t addr;
+
+	addr = ps2sif_allociopheap(size);
+	if (addr != 0) {
+		if (!dma_declare_coherent_memory(dev, ps2sif_bustophys(addr),
+						 addr,
+						 size,
+						 flags)) {
+			ERROR("cannot declare coherent memory\n");
+			ps2sif_freeiopheap(addr);
+			return -ENXIO;
+		}
+		return 0;
+	} else {
+		ERROR("Out of IOP heap memory.\n");
+		return -ENOMEM;
+	}
+}
+
+static void __devexit
+iopheap_free_coherent(struct device *dev)
+{
+	dma_addr_t addr;
+	struct dma_coherent_mem *mem = dev->dma_mem;
+
+	if (!mem)
+		return;
+
+	addr = ps2sif_bustophys(mem->device_base);
+	dma_release_declared_memory(dev);
+	ps2sif_freeiopheap(addr);
+}
+
+#define resource_len(r) (((r)->end - (r)->start) + 1)
+static int ohci_hcd_ps2_probe(struct platform_device *pdev)
+{
+	struct resource *res = NULL;
+	struct usb_hcd *hcd = NULL;
+	int irq = -1;
+	int ret;
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		ERROR("platform_get_resource error.");
+		return -ENODEV;
+	}
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		ERROR("platform_get_irq error.");
+		return -ENODEV;
+	}
+	ret = iopheap_alloc_coherent(&pdev->dev, DMA_BUFFER_SIZE, DMA_MEMORY_MAP | DMA_MEMORY_EXCLUSIVE);
+	if (ret) {
+		return ret;
+	}
+
+	/* initialize hcd */
+	hcd = usb_create_hcd(&ohci_ps2_hc_driver, &pdev->dev, (char *)hcd_name);
+	if (!hcd) {
+		ERROR("Failed to create hcd");
+		return -ENOMEM;
+	}
+
+	hcd->regs = (void __iomem *)res->start;
+	hcd->rsrc_start = res->start;
+	hcd->rsrc_len = resource_len(res);
+	ret = usb_add_hcd(hcd, irq, IRQF_DISABLED);
+	if (ret != 0) {
+		ERROR("Failed to add hcd");
+		usb_put_hcd(hcd);
+		return ret;
+	}
+
+	return ret;
+}
+
+static int ohci_hcd_ps2_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+	usb_remove_hcd(hcd);
+	usb_put_hcd(hcd);
+
+	iopheap_free_coherent(&pdev->dev);
+
+	return 0;
+}
+
+static struct platform_driver ohci_hcd_ps2_driver = {
+	.probe		= ohci_hcd_ps2_probe,
+	.remove		= ohci_hcd_ps2_remove,
+	.shutdown	= usb_hcd_platform_shutdown,
+	.driver		= {
+		.name	= "ps2_ohci",
+		.owner	= THIS_MODULE,
+	},
+};
+
+MODULE_ALIAS("platform:ps2_ohci");
diff -purN linux-2.6.35.4-orig/drivers/video/console/Kconfig linux-2.6.35.4/drivers/video/console/Kconfig
--- linux-2.6.35.4-orig/drivers/video/console/Kconfig	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/drivers/video/console/Kconfig	2014-07-18 22:29:43.570367725 +0200
@@ -133,7 +133,7 @@ config STI_CONSOLE
 
 config FONTS
 	bool "Select compiled-in fonts"
-	depends on FRAMEBUFFER_CONSOLE || STI_CONSOLE
+	depends on FRAMEBUFFER_CONSOLE || STI_CONSOLE || PS2_CONSOLE
 	help
 	  Say Y here if you would like to use fonts other than the default
 	  your frame buffer console usually use.
@@ -146,7 +146,7 @@ config FONTS
 
 config FONT_8x8
 	bool "VGA 8x8 font" if FONTS
-	depends on FRAMEBUFFER_CONSOLE || STI_CONSOLE
+	depends on FRAMEBUFFER_CONSOLE || STI_CONSOLE || PS2_CONSOLE
 	default y if !SPARC && !FONTS
 	help
 	  This is the "high resolution" font for the VGA frame buffer (the one
@@ -160,7 +160,7 @@ config FONT_8x8
 
 config FONT_8x16
 	bool "VGA 8x16 font" if FONTS
-	depends on FRAMEBUFFER_CONSOLE || SGI_NEWPORT_CONSOLE || STI_CONSOLE || USB_SISUSBVGA_CON
+	depends on FRAMEBUFFER_CONSOLE || SGI_NEWPORT_CONSOLE || STI_CONSOLE || USB_SISUSBVGA_CON || PS2_CONSOLE
 	default y if !SPARC && !FONTS
 	help
 	  This is the "high resolution" font for the VGA frame buffer (the one
@@ -226,5 +226,21 @@ config FONT_10x18
 	  big letters. It fits between the sun 12x22 and the normal 8x16 font.
 	  If other fonts are too big or too small for you, say Y, otherwise say N.
 
-endmenu
+config PS2_CONSOLE
+	tristate "Support for PlayStation 2 console device"
+	depends on SONY_PS2 && !FB_PS2
+	default n
+
+config PS2_CONSOLE_SCROLLBACK
+	bool "Console scrollback support"
+	depends on PS2_CONSOLE
+	default y
+
+config PS2_CONSOLE_LARGEBUF
+	bool "Allocate large DMA buffer for console"
+	depends on PS2_CONSOLE
+	select DUMMY_CONSOLE
+	select FONT_8x8
+	select FONT_8x16
 
+endmenu
diff -purN linux-2.6.35.4-orig/drivers/video/console/Makefile linux-2.6.35.4/drivers/video/console/Makefile
--- linux-2.6.35.4-orig/drivers/video/console/Makefile	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/drivers/video/console/Makefile	2014-07-18 22:29:43.570367725 +0200
@@ -39,3 +39,4 @@ obj-$(CONFIG_FB_STI)              += sti
 ifeq ($(CONFIG_USB_SISUSBVGA_CON),y)
 obj-$(CONFIG_USB_SISUSBVGA)           += font.o
 endif
+obj-$(CONFIG_PS2_CONSOLE)         += ps2con.o font.o
diff -purN linux-2.6.35.4-orig/drivers/video/console/ps2con.c linux-2.6.35.4/drivers/video/console/ps2con.c
--- linux-2.6.35.4-orig/drivers/video/console/ps2con.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/video/console/ps2con.c	2014-07-18 22:29:43.570367725 +0200
@@ -0,0 +1,1767 @@
+/*
+ *  linux/drivers/video/ps2con.c
+ *  PlayStation 2 Graphics Synthesizer console driver
+ *
+ *	Copyright (C) 2000-2002  Sony Computer Entertainment Inc.
+ *	Copyright (C) 2010       Mega Man
+ *
+ * 
+ *  This file is based on the low level frame buffer based console driver
+ *  (fbcon.c):
+ *
+ *	Copyright (C) 1995 Geert Uytterhoeven
+ *
+ *  and on the original Amiga console driver (amicon.c):
+ *
+ *	Copyright (C) 1993 Hamish Macdonald
+ *			   Greg Harp
+ *	Copyright (C) 1994 David Carter [carter@compsci.bristol.ac.uk]
+ *
+ *	      with work by William Rucklidge (wjr@cs.cornell.edu)
+ *			   Geert Uytterhoeven
+ *			   Jes Sorensen (jds@kom.auc.dk)
+ *			   Martin Apel
+ *
+ *  and on the original Atari console driver (atacon.c):
+ *
+ *	Copyright (C) 1993 Bjoern Brauel
+ *			   Roman Hodek
+ *
+ *	      with work by Guenther Kelleter
+ *			   Martin Schaller
+ *			   Andreas Schwab
+ *
+ *  Hardware cursor support added by Emmanuel Marty (core@ggi-project.org)
+ *  Smart redraw scrolling, arbitrary font width support, 512char font support
+ *  added by 
+ *                         Jakub Jelinek (jj@ultra.linux.cz)
+ *
+ *  Random hacking by Martin Mares <mj@ucw.cz>
+ *
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License.  See the file COPYING in the main directory of this archive for
+ *  more details.
+ */
+/* TBD: Unfinished state. Rework code. */
+
+#define PS2CONDEBUG
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/tty.h>
+#include <linux/console.h>
+#include <linux/string.h>
+#include <linux/kd.h>
+#include <linux/slab.h>
+#include <linux/vt_kern.h>
+#include <linux/selection.h>
+#include <linux/smp.h>
+#include <linux/init.h>
+#include <linux/font.h>
+#define INCLUDE_LINUX_LOGO_DATA
+#include <linux/linux_logo.h>
+
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/uaccess.h>
+
+#include <linux/ps2/dev.h>
+#include <linux/ps2/gs.h>
+#include <asm/mach-ps2/ps2.h>
+#include <asm/mach-ps2/gsfunc.h>
+#include <asm/mach-ps2/eedev.h>
+#include <asm/mach-ps2/ps2con.h>
+
+//#define LOGO_SUPPORT /* TBD: Add support for logo. */
+
+#ifdef PS2CONDEBUG
+#  define DPRINTK(fmt, args...) ps2_printf(KERN_DEBUG "%s: " fmt, __FUNCTION__ , ## args)
+#else
+#  define DPRINTK(fmt, args...)
+#endif
+
+#define LOGO_H			80
+#define LOGO_W			80
+#define LOGO_LINE	(LOGO_W/8)
+
+static unsigned int ps2_cmap[] = {
+    0x00000000, 0x80aa0000, 0x8000aa00, 0x80aaaa00,
+    0x800000aa, 0x80aa00aa, 0x800055aa, 0x80aaaaaa,
+    0x80555555, 0x80ff5555, 0x8055ff55, 0x80ffff55,
+    0x805555ff, 0x80ff55ff, 0x8055ffff, 0x80ffffff,
+};
+
+static struct ps2_screeninfo defaultinfo;
+static struct ps2dpy ps2dpy[MAX_NR_CONSOLES];
+static int currcon = 0;
+
+static int logo_lines;
+static int logo_shown = -1;
+/* Software scrollback */
+#ifdef CONFIG_PS2_CONSOLE_SCROLLBACK
+int ps2con_softback_size = 32768;
+static unsigned long softback_buf, softback_curr;
+static unsigned long softback_in;
+static unsigned long softback_top, softback_end;
+static int softback_lines;
+#endif
+
+#define REFCOUNT(fd)	(((int *)(fd))[-1])
+#define FNTSIZE(fd)	(((int *)(fd))[-2])
+#define FNTCHARCNT(fd)	(((int *)(fd))[-3])
+#define FNTSUM(fd)	(((int *)(fd))[-4])
+#define FONT_EXTRA_WORDS 4
+
+#define CM_SOFTBACK	(8)
+
+#define advance_row(p, delta) (unsigned short *)((unsigned long)(p) + (delta) * conp->vc_size_row)
+
+static void ps2con_free_font(struct ps2dpy *);
+static int ps2con_set_origin(struct vc_data *);
+
+#define CURSOR_DRAW_DELAY		1
+#define DEFAULT_CURSOR_BLINK_RATE	20
+
+static int cursor_drawn = 0;
+static int vbl_cursor_cnt = 0;
+static int cursor_on = 0;
+static int cursor_blink_rate = DEFAULT_CURSOR_BLINK_RATE;
+
+static inline void cursor_undrawn(void)
+{
+    vbl_cursor_cnt = 0;
+    cursor_drawn = 0;
+}
+
+
+/*
+ *  Interface used by the world
+ */
+
+static const char *ps2con_startup(void);
+static void ps2con_init(struct vc_data *conp, int init);
+static void ps2con_deinit(struct vc_data *conp);
+static void ps2con_clear(struct vc_data *conp, int sy, int sx, int height,
+			 int width);
+static void ps2con_putc(struct vc_data *conp, int ch, int ypos, int xpos);
+static void ps2con_putcs(struct vc_data *conp, const unsigned short *s, int count,
+			 int ypos, int xpos);
+static void ps2con_cursor(struct vc_data *conp, int mode);
+static int ps2con_scroll(struct vc_data *conp, int t, int b, int dir,
+			 int count);
+static void ps2con_bmove(struct vc_data *conp, int sy, int sx, int dy, int dx,
+			 int height, int width);
+static int ps2con_switch(struct vc_data *conp);
+static int ps2con_blank(struct vc_data *conp, int blank, int mode_switch);
+static int ps2con_set_palette(struct vc_data *conp, unsigned char *table);
+static int ps2con_scrolldelta(struct vc_data *conp, int lines);
+
+
+/*
+ *  Internal routines
+ */
+
+static void ps2con_setup(int con, int init, int logo);
+static void ps2con_vbl_handler(int irq, void *dummy, struct pt_regs *fp);
+static void ps2con_revc(struct vc_data *conp, int sy, int sx,
+			int height, int width);
+static void ps2con_clear_margins(struct vc_data *conp, struct ps2dpy *p);
+#ifdef LOGO_SUPPORT
+static int ps2con_show_logo(void);
+#endif
+
+static void cursor_timer_handler(unsigned long dev_addr);
+
+static struct timer_list cursor_timer = {
+    function: cursor_timer_handler
+};
+
+static void cursor_timer_handler(unsigned long dev_addr)
+{
+      ps2con_vbl_handler(0, NULL, NULL);
+      cursor_timer.expires = jiffies+HZ/50;
+      add_timer(&cursor_timer);
+}
+
+
+/*
+ *  Low Level Operations
+ */
+
+static void ps2con_get_screeninfo(struct ps2_screeninfo *info)
+{
+    int con = fg_console;
+    struct ps2dpy *p = &ps2dpy[con];
+
+    p->info = *info;
+
+    acquire_console_sem();
+    ps2con_setup(con, 0, 0);
+    release_console_sem();
+}
+
+static const char *ps2con_startup(void)
+{
+    const char *display_desc = "PlayStation 2 Graphics Synthesizer";
+    static int done = 0;
+
+    if (done)
+	return display_desc;
+    done = 1;
+
+    ps2con_initinfo(&defaultinfo);
+    ps2gs_screeninfo(&defaultinfo, NULL);
+    ps2con_gsp_init();
+    ps2gs_screeninfo_hook = ps2con_get_screeninfo;
+
+    cursor_blink_rate = DEFAULT_CURSOR_BLINK_RATE;
+    init_timer(&cursor_timer);
+    cursor_timer.expires = jiffies+HZ/50;
+    add_timer(&cursor_timer);
+
+    return display_desc;
+}
+
+
+static void ps2con_init(struct vc_data *conp, int init)
+{
+    int unit = conp->vc_num;
+    struct ps2dpy *p = &ps2dpy[unit];
+
+    p->conp = conp;
+    p->info = defaultinfo;
+
+    ps2con_setup(unit, init, !init);
+}
+
+
+static void ps2con_deinit(struct vc_data *conp)
+{
+    int unit = conp->vc_num;
+    struct ps2dpy *p = &ps2dpy[unit];
+
+    ps2con_free_font(p);
+    p->conp = 0;
+}
+
+
+static void ps2con_setup(int con, int init, int logo)
+{
+    struct ps2dpy *p = &ps2dpy[con];
+    struct vc_data *conp = p->conp;
+    int nr_rows, nr_cols;
+    int old_rows, old_cols;
+    unsigned short *save = NULL, *r, *q;
+    int charcnt = 256;
+    const struct font_desc *font;
+
+#if 0 /* TODO */
+    if (con != fg_console || graphics_boot)
+	logo = 0;
+#else
+    if (con != fg_console)
+	logo = 0;
+#endif
+
+#ifdef CONFIG_PS2_CONSOLE_SCROLLBACK
+    if (con == fg_console) {   
+	if (ps2con_softback_size) {
+	    if (!softback_buf) {
+		softback_buf = (unsigned long)kmalloc(ps2con_softback_size, GFP_KERNEL);
+		if (!softback_buf) {
+    	            ps2con_softback_size = 0;
+    	            softback_top = 0;
+    		}
+    	    }
+	} else {
+	    if (softback_buf) {
+		kfree((void *)softback_buf);
+		softback_buf = 0;
+		softback_top = 0;
+	    }
+	}
+	if (softback_buf)
+	    softback_in = softback_top = softback_curr = softback_buf;
+	softback_lines = 0;
+    }
+#endif
+
+    p->fbw = (p->info.w + 63) / 64;
+    switch (p->info.psm) {
+    case PS2_GS_PSMCT32:
+	p->pixel_size = 4;
+	break;
+    case PS2_GS_PSMCT24:
+	p->pixel_size = 3;
+	break;
+    case PS2_GS_PSMCT16:
+    case PS2_GS_PSMCT16S:
+	p->pixel_size = 2;
+	break;
+    default:
+	p->pixel_size = -1;
+    }	
+    p->can_soft_blank = 1;
+
+    if (!p->fontdata) {
+	font = get_default_font(p->info.w, p->info.h,
+		(1 << (8 - 1)),
+		(1 << (8 - 1)) | (1 << (16 - 1)));
+	if (font->width > 0) { 
+	    p->_fontwidth = font->width;
+	    p->grayfont = 0;
+	} else {
+	    p->_fontwidth = -font->width;
+	    p->grayfont = 1;
+	}
+	p->_fontheight = font->height;
+	p->fontdata = font->data;
+    }
+
+    old_cols = conp->vc_cols;
+    old_rows = conp->vc_rows;
+
+    nr_cols = p->info.w / fontwidth(p);
+    nr_rows = p->info.h / fontheight(p);
+
+    if (logo) {
+    	/* Need to make room for the logo */
+	int cnt;
+	int step;
+
+	if (is_nointer(p))
+	    logo_lines = ((LOGO_H / 2) + fontheight(p) - 1) / fontheight(p);
+	else
+	    logo_lines = (LOGO_H + fontheight(p) - 1) / fontheight(p);
+	q = (unsigned short *)(conp->vc_origin + conp->vc_size_row * old_rows);
+	step = logo_lines * old_cols;
+	for (r = q - logo_lines * old_cols; r < q; r++)
+	    if (scr_readw(r) != conp->vc_video_erase_char)
+    	    	break;
+	if (r != q && nr_rows >= old_rows + logo_lines) {
+	    save = kmalloc(logo_lines * nr_cols * 2, GFP_KERNEL);
+	    if (save) {
+		int i = old_cols < nr_cols ? old_cols : nr_cols;
+		scr_memsetw(save, conp->vc_video_erase_char, logo_lines * nr_cols * 2);
+		r = q - step;
+		for (cnt = 0; cnt < logo_lines; cnt++, r += i)
+		    scr_memcpyw(save + cnt * nr_cols, r, 2 * i);
+		r = q;
+	    }
+	}
+	if (r == q) {
+	    /* We can scroll screen down */
+	    r = q - step - old_cols;
+	    for (cnt = old_rows - logo_lines; cnt > 0; cnt--) {
+		scr_memcpyw(r + step, r, conp->vc_size_row);
+		r -= old_cols;
+	    }
+	    if (!save) {
+		conp->vc_y += logo_lines;
+		conp->vc_pos += logo_lines * conp->vc_size_row;
+	    }
+	}
+	scr_memsetw((unsigned short *)conp->vc_origin,
+		    conp->vc_video_erase_char, 
+		    conp->vc_size_row * logo_lines);
+    }
+
+    if (init) {
+	conp->vc_cols = nr_cols;
+	conp->vc_rows = nr_rows;
+    }
+
+    conp->vc_can_do_color = 1;
+    conp->vc_complement_mask = 0x7700;
+    if (charcnt == 256) {
+	conp->vc_hi_font_mask = 0;
+	p->fgshift = 8;
+	p->bgshift = 12;
+	p->charmask = 0xff;
+    } else {
+	conp->vc_hi_font_mask = 0x100;
+	conp->vc_complement_mask <<= 1;
+	p->fgshift = 9;
+	p->bgshift = 13;
+	p->charmask = 0x1ff;
+    }
+
+    p->fgcol = 7;
+    p->bgcol = 0;
+
+    if (!init) {
+	if (conp->vc_cols != nr_cols || conp->vc_rows != nr_rows)
+	    vc_resize(conp, nr_cols, nr_rows);
+	else if (CON_IS_VISIBLE(conp) &&
+		 conp->vc_mode == KD_TEXT) {
+	    ps2con_clear_margins(conp, p);
+	    update_screen(conp);
+	}
+	if (save) {
+    	    q = (unsigned short *)(conp->vc_origin + conp->vc_size_row * old_rows);
+	    scr_memcpyw(q, save, logo_lines * nr_cols * 2);
+	    conp->vc_y += logo_lines;
+    	    conp->vc_pos += logo_lines * conp->vc_size_row;
+    	    kfree(save);
+	}
+    }
+
+    if (logo) {
+	logo_shown = -2;
+	conp->vc_top = logo_lines;
+    }
+
+#ifdef CONFIG_PS2_CONSOLE_SCROLLBACK
+    if (con == fg_console && softback_buf) {
+    	int l = ps2con_softback_size / conp->vc_size_row;
+    	if (l > 5)
+    	    softback_end = softback_buf + l * conp->vc_size_row;
+    	else {
+    	    /* Smaller scrollback makes no sense, and 0 would screw
+    	       the operation totally */
+    	    softback_top = 0;
+    	}
+    }
+#endif
+}
+
+
+/* ====================================================================== */
+
+/*
+ *  ps2con_XXX routines - interface used by the world
+ */
+
+static void ps2con_clear(struct vc_data *conp, int sy, int sx, int height,
+			 int width)
+{
+    int unit = conp->vc_num;
+    struct ps2dpy *p = &ps2dpy[unit];
+    int redraw_cursor = 0;
+    u64 *gsp;
+    int ctx = 0;
+
+    if (logo_shown == fg_console &&
+	sy == 0 && sx == 0 &&
+	height == conp->vc_rows && width == conp->vc_cols) {
+	ps2con_clear_margins(conp, p);
+	logo_shown = -1;
+    }
+
+    if (!p->can_soft_blank && console_blanked)
+	return;
+
+    if (height == 0 || width == 0)
+	return;
+
+    if ((sy <= p->cursor_y) && (p->cursor_y < sy + height) &&
+	(sx <= p->cursor_x) && (p->cursor_x < sx + width)) {
+	cursor_undrawn();
+	redraw_cursor = 1;
+    }
+
+    if ((gsp = ps2con_gsp_alloc(ALIGN16(6 * 8), NULL)) == NULL)
+	return;
+
+    *gsp++ = PS2_GIFTAG_SET_TOPHALF(1, 1, 0, 0, PS2_GIFTAG_FLG_REGLIST, 4);
+    *gsp++ = 0x5510;
+    *gsp++ = 0x006 + (ctx << 9);				/* PRIM */
+    *gsp++ = ps2_cmap[attr_bgcol_ec(p, conp)];			/* RGBAQ */
+    *gsp++ = PACK32(sx * fontwidth(p) * 16, sy * fontheight(p) * 16);
+								/* XYZ2 */
+    *gsp++ = PACK32((sx + width) * fontwidth(p) * 16,
+		    (sy + height) * fontheight(p) * 16);	/* XYZ2 */
+
+    ps2con_gsp_send(ALIGN16(6 * 8), 0);
+
+    if (redraw_cursor)
+	vbl_cursor_cnt = CURSOR_DRAW_DELAY;
+}
+
+#define GRAYSCALE
+
+static void *ps2con_put_pattern(struct ps2dpy *p, void *ptr, 
+				const unsigned short *s, int count)
+{
+    int i, j;
+    const unsigned char *cp;
+    unsigned char mask = 0, pattern = 0;
+    int fgcol, bgcol;
+    unsigned short ch;
+    int x;
+    u32 *p32, *q32, *b32;
+    u16 *p16, *q16, *b16;
+    u8 *p8, *q8, *b8;
+    int fontsize;
+
+#ifdef GRAYSCALE
+    if (p->grayfont)
+	goto gray;
+#endif
+
+    fontsize = (fontwidth(p) + 7) / 8 * fontheight(p);
+    switch (p->pixel_size) {
+    case 4:		/* RGBA32 */
+	b32 = p32 = (u32 *)ptr;
+	for (x = 0; x < count; x++) {
+	    ch = *s++;
+	    cp = p->fontdata + fontsize * (ch & p->charmask);
+	    fgcol = ps2_cmap[attr_fgcol(p, ch)];
+	    bgcol = ps2_cmap[attr_bgcol(p, ch)];
+
+	    q32 = b32;
+	    for (i = 0; i < fontheight(p); i++) {
+		p32 = q32;
+		for (j = 0; j < fontwidth(p); j++) {
+		    if ((j & 7) == 0) {
+			mask = 0x80;
+			pattern = *cp++;
+		    }
+		    if (mask & pattern)
+			*p32++ = fgcol;
+		    else
+			*p32++ = bgcol;
+		    mask >>= 1;
+		}
+		q32 += fontwidth(p) * count;
+	    }
+	    b32 += fontwidth(p);
+	}
+	return (void *)p32;
+
+    case 2:		/* RGBA16 */
+	b16 = p16 = (u16 *)ptr;
+	for (x = 0; x < count; x++) {
+	    ch = *s++;
+	    cp = p->fontdata + fontsize * (ch & p->charmask);
+	    fgcol = bpp32to16(ps2_cmap[attr_fgcol(p, ch)]);
+	    bgcol = bpp32to16(ps2_cmap[attr_bgcol(p, ch)]);
+
+	    q16 = b16;
+	    for (i = 0; i < fontheight(p); i++) {
+		p16 = q16;
+		for (j = 0; j < fontwidth(p); j++) {
+		    if ((j & 7) == 0) {
+			mask = 0x80;
+			pattern = *cp++;
+		    }
+		    if (mask & pattern)
+			*p16++ = fgcol;
+		    else
+			*p16++ = bgcol;
+		    mask >>= 1;
+		}
+		q16 += fontwidth(p) * count;
+	    }
+	    b16 += fontwidth(p);
+	}
+	return (void *)p16;
+
+    case 3:		/* RGB24 */
+	b8 = p8 = (u8 *)ptr;
+	for (x = 0; x < count; x++) {
+	    ch = *s++;
+	    cp = p->fontdata + fontsize * (ch & p->charmask);
+	    fgcol = ps2_cmap[attr_fgcol(p, ch)];
+	    bgcol = ps2_cmap[attr_bgcol(p, ch)];
+
+	    q8 = b8;
+	    for (i = 0; i < fontheight(p); i++) {
+		p8 = q8;
+		for (j = 0; j < fontwidth(p); j++) {
+		    if ((j & 7) == 0) {
+			mask = 0x80;
+			pattern = *cp++;
+		    }
+		    if (mask & pattern) {
+			*p8++ = ((unsigned char *)&fgcol)[0];
+			*p8++ = ((unsigned char *)&fgcol)[1];
+			*p8++ = ((unsigned char *)&fgcol)[2];
+		    } else {
+			*p8++ = ((unsigned char *)&bgcol)[0];
+			*p8++ = ((unsigned char *)&bgcol)[1];
+			*p8++ = ((unsigned char *)&bgcol)[2];
+		    }
+		    mask >>= 1;
+		}
+		q8 += fontwidth(p) * count * 3;
+	    }
+	    b8 += fontwidth(p) * 3;
+	}
+	return (void *)p8;
+    }
+
+#ifdef GRAYSCALE
+gray:
+    fontsize = (fontwidth(p) + 1) / 2 * fontheight(p);
+    switch (p->pixel_size) {
+    case 4:		/* RGBA32 */
+	b32 = p32 = (u32 *)ptr;
+	for (x = 0; x < count; x++) {
+	    ch = *s++;
+	    cp = p->fontdata + fontsize * (ch & p->charmask);
+	    fgcol = ps2_cmap[attr_fgcol(p, ch)];
+	    bgcol = ps2_cmap[attr_bgcol(p, ch)];
+
+	    q32 = b32;
+	    for (i = 0; i < fontheight(p); i++) {
+		p32 = q32;
+		for (j = 0; j < fontwidth(p); j++) {
+		    if ((j & 1) == 0)
+			pattern = *cp++;
+		    mask = pattern & 0x0f;
+		    pattern >>= 4;
+		    *p32++ = 
+			((fgcol & 0xff) * mask / 15 +
+			 (bgcol & 0xff) * (15 - mask) / 15) |
+			((((fgcol >> 8) & 0xff) * mask / 15 +
+			  ((bgcol >> 8) & 0xff) * (15 - mask) / 15) << 8) |
+			((((fgcol >> 16) & 0xff) * mask / 15 +
+			  ((bgcol >> 16) & 0xff) * (15 - mask) / 15) << 16);
+		}
+		q32 += fontwidth(p) * count;
+	    }
+	    b32 += fontwidth(p);
+	}
+	return (void *)p32;
+
+    case 2:		/* RGBA16 */
+	b16 = p16 = (u16 *)ptr;
+	for (x = 0; x < count; x++) {
+	    ch = *s++;
+	    cp = p->fontdata + fontsize * (ch & p->charmask);
+	    fgcol = bpp32to16(ps2_cmap[attr_fgcol(p, ch)]);
+	    bgcol = bpp32to16(ps2_cmap[attr_bgcol(p, ch)]);
+
+	    q16 = b16;
+	    for (i = 0; i < fontheight(p); i++) {
+		p16 = q16;
+		for (j = 0; j < fontwidth(p); j++) {
+		    if ((j & 1) == 0)
+			pattern = *cp++;
+		    mask = pattern & 0x0f;
+		    pattern >>= 4;
+		    *p16++ = 
+			((fgcol & 0x1f) * mask / 15 +
+			 (bgcol & 0x1f) * (15 - mask) / 15) |
+			((((fgcol >> 5) & 0x1f) * mask / 15 +
+			  ((bgcol >> 5) & 0x1f) * (15 - mask) / 15) << 5) |
+			((((fgcol >> 10) & 0x1f) * mask / 15 +
+			  ((bgcol >> 10) & 0x1f) * (15 - mask) / 15) << 10);
+		}
+		q16 += fontwidth(p) * count;
+	    }
+	    b16 += fontwidth(p);
+	}
+	return (void *)p16;
+
+    case 3:		/* RGB24 */
+	b8 = p8 = (u8 *)ptr;
+	for (x = 0; x < count; x++) {
+	    ch = *s++;
+	    cp = p->fontdata + fontsize * (ch & p->charmask);
+	    fgcol = ps2_cmap[attr_fgcol(p, ch)];
+	    bgcol = ps2_cmap[attr_bgcol(p, ch)];
+
+	    q8 = b8;
+	    for (i = 0; i < fontheight(p); i++) {
+		p8 = q8;
+		for (j = 0; j < fontwidth(p); j++) {
+		    if ((j & 1) == 0)
+			pattern = *cp++;
+		    mask = pattern & 0x0f;
+		    pattern >>= 4;
+		    *p8++ = ((fgcol & 0xff) * mask / 15 +
+			     (bgcol & 0xff) * (15 - mask) / 15);
+		    *p8++ = (((fgcol >> 8) & 0xff) * mask / 15 +
+			     ((bgcol >> 8) & 0xff) * (15 - mask) / 15);
+		    *p8++ = (((fgcol >> 16) & 0xff) * mask / 15 +
+			     ((bgcol >> 16) & 0xff) * (15 - mask) / 15);
+		}
+		q8 += fontwidth(p) * count * 3;
+	    }
+	    b8 += fontwidth(p) * 3;
+	}
+	return (void *)p8;
+    }
+#endif
+
+    return NULL;
+}
+
+
+static void ps2con_putc(struct vc_data *conp, int ch, int ypos, int xpos)
+{
+    int unit = conp->vc_num;
+    struct ps2dpy *p = &ps2dpy[unit];
+    int redraw_cursor = 0;
+    u64 *gsp;
+    void *gsp_h;
+    unsigned short sch = ch;
+
+    if (!p->can_soft_blank && console_blanked)
+	return;
+    if (conp->vc_mode != KD_TEXT)
+	return;
+    if (p->pixel_size <= 0)
+	return;
+
+    if ((p->cursor_x == xpos) && (p->cursor_y == ypos)) {
+	cursor_undrawn();
+	redraw_cursor = 1;
+    }
+
+    if ((gsp = ps2con_gsp_alloc(ALIGN16(12 * 8 + fontwidth(p) * fontheight(p) * p->pixel_size), NULL)) == NULL)
+	return;
+    gsp_h = gsp;
+
+    *gsp++ = PS2_GIFTAG_SET_TOPHALF(4, 0, 0, 0, PS2_GIFTAG_FLG_PACKED, 1);
+    *gsp++ = 0x0e;	/* A+D */
+    *gsp++ = (u64)0 | ((u64)p->info.fbp << 32) |
+	((u64)p->fbw << 48) | ((u64)p->info.psm << 56);
+    *gsp++ = PS2_GS_BITBLTBUF;
+    *gsp++ = PACK64(0, PACK32(xpos * fontwidth(p), ypos * fontheight(p)));
+    *gsp++ = PS2_GS_TRXPOS;
+    *gsp++ = PACK64(fontwidth(p), fontheight(p));
+    *gsp++ = PS2_GS_TRXREG;
+    *gsp++ = 0;		/* host to local */
+    *gsp++ = PS2_GS_TRXDIR;
+
+    *gsp++ = PS2_GIFTAG_SET_TOPHALF(ALIGN16(fontwidth(p) * fontheight(p) * p->pixel_size) / 16, 1, 0, 0, PS2_GIFTAG_FLG_IMAGE, 0);
+    *gsp++ = 0;
+
+    ps2con_gsp_send(ALIGN16(ps2con_put_pattern(p, gsp, &sch, 1) - gsp_h), 0);
+
+    if (redraw_cursor)
+	vbl_cursor_cnt = CURSOR_DRAW_DELAY;
+}
+
+
+static void ps2con_putcs(struct vc_data *conp, const unsigned short *s, int count,
+			 int ypos, int xpos)
+{
+    int unit = conp->vc_num;
+    struct ps2dpy *p = &ps2dpy[unit];
+    int redraw_cursor = 0;
+    int gspsz, maxdc, dc;
+    u64 *gsp;
+    void *gsp_h;
+
+    if (!p->can_soft_blank && console_blanked)
+	return;
+    if (conp->vc_mode != KD_TEXT)
+	return;
+    if (p->pixel_size <= 0)
+	return;
+
+    if ((p->cursor_y == ypos) && (xpos <= p->cursor_x) &&
+	(p->cursor_x < (xpos + count))) {
+	cursor_undrawn();
+	redraw_cursor = 1;
+    }
+
+    while (count > 0) {
+	if ((gsp = ps2con_gsp_alloc(ALIGN16(12 * 8 + fontwidth(p) * fontheight(p) * p->pixel_size), &gspsz)) == NULL)
+	    return;
+	gsp_h = gsp;
+	maxdc = (gspsz - ALIGN16(12 * 8)) / (fontwidth(p) * fontheight(p) * p->pixel_size);
+	dc = count > maxdc ? maxdc : count;
+
+	*gsp++ = PS2_GIFTAG_SET_TOPHALF(4, 0, 0, 0, PS2_GIFTAG_FLG_PACKED, 1);
+	*gsp++ = 0x0e;		/* A+D */
+	*gsp++ = (u64)0 | ((u64)p->info.fbp << 32) |
+	    ((u64)p->fbw << 48) | ((u64)p->info.psm << 56);
+	*gsp++ = PS2_GS_BITBLTBUF;
+	*gsp++ = PACK64(0, PACK32(xpos * fontwidth(p), ypos * fontheight(p)));
+	*gsp++ = PS2_GS_TRXPOS;
+	*gsp++ = PACK64(fontwidth(p) * dc, fontheight(p));
+	*gsp++ = PS2_GS_TRXREG;
+	*gsp++ = 0;		/* host to local */
+	*gsp++ = PS2_GS_TRXDIR;
+
+	*gsp++ = PS2_GIFTAG_SET_TOPHALF(ALIGN16(dc * fontwidth(p) * fontheight(p) * p->pixel_size) / 16, 1, 0, 0, PS2_GIFTAG_FLG_IMAGE, 0);
+	*gsp++ = 0;
+
+	ps2con_gsp_send(ALIGN16(ps2con_put_pattern(p, gsp, s, dc) - gsp_h), 0);
+
+	s += dc;
+	xpos += dc;
+	count -= dc;
+    }
+
+    if (redraw_cursor)
+	vbl_cursor_cnt = CURSOR_DRAW_DELAY;
+}
+
+
+static void ps2con_cursor(struct vc_data *conp, int mode)
+{
+    int unit = conp->vc_num;
+    struct ps2dpy *p = &ps2dpy[unit];
+    int y = conp->vc_y;
+
+#ifdef CONFIG_PS2_CONSOLE_SCROLLBACK
+    if (mode & CM_SOFTBACK) {
+    	mode &= ~CM_SOFTBACK;
+    	if (softback_lines) {
+    	    if (y + softback_lines >= conp->vc_rows)
+    		mode = CM_ERASE;
+    	    else
+    	        y += softback_lines;
+	}
+    } else if (softback_lines)
+	ps2con_set_origin(conp);
+#endif
+
+    /* Avoid flickering if there's no real change. */
+    if (p->cursor_x == conp->vc_x && p->cursor_y == y &&
+	(mode == CM_ERASE) == !cursor_on)
+	return;
+
+    cursor_on = 0;
+    if (cursor_drawn)
+	ps2con_revc(p->conp, p->cursor_y, p->cursor_x, 1, 1);
+
+    p->cursor_x = conp->vc_x;
+    p->cursor_y = y;
+
+    switch (mode) {
+    case CM_ERASE:
+	cursor_drawn = 0;
+	break;
+    case CM_MOVE:
+    case CM_DRAW:
+	if (cursor_drawn)
+	    ps2con_revc(p->conp, p->cursor_y, p->cursor_x, 1, 1);
+	vbl_cursor_cnt = CURSOR_DRAW_DELAY;
+	cursor_on = 1;
+	break;
+    }
+}
+
+
+static void ps2con_vbl_handler(int irq, void *dummy, struct pt_regs *fp)
+{
+    struct ps2dpy *p;
+
+    if (!cursor_on)
+	return;
+
+    if (vbl_cursor_cnt && --vbl_cursor_cnt == 0) {
+	p = &ps2dpy[fg_console];
+	ps2con_revc(p->conp, p->cursor_y, p->cursor_x, 1, 1);
+	cursor_drawn ^= 1;
+	vbl_cursor_cnt = cursor_blink_rate;
+    }
+}
+
+
+#ifdef CONFIG_PS2_CONSOLE_SCROLLBACK
+static void ps2con_redraw_softback(struct vc_data *conp, struct ps2dpy *p, long delta)
+{
+    unsigned short *d, *s;
+    unsigned long n;
+    int line = 0;
+    int count = conp->vc_rows;
+    
+    d = (u16 *)softback_curr;
+    if (d == (u16 *)softback_in)
+	d = (u16 *)conp->vc_origin;
+    n = softback_curr + delta * conp->vc_size_row;
+    softback_lines -= delta;
+    if (delta < 0) {
+        if (softback_curr < softback_top && n < softback_buf) {
+            n += softback_end - softback_buf;
+	    if (n < softback_top) {
+		softback_lines -= (softback_top - n) / conp->vc_size_row;
+		n = softback_top;
+	    }
+        } else if (softback_curr >= softback_top && n < softback_top) {
+	    softback_lines -= (softback_top - n) / conp->vc_size_row;
+	    n = softback_top;
+        }
+    } else {
+    	if (softback_curr > softback_in && n >= softback_end) {
+    	    n += softback_buf - softback_end;
+	    if (n > softback_in) {
+		n = softback_in;
+		softback_lines = 0;
+	    }
+	} else if (softback_curr <= softback_in && n > softback_in) {
+	    n = softback_in;
+	    softback_lines = 0;
+	}
+    }
+    if (n == softback_curr)
+    	return;
+    softback_curr = n;
+    s = (u16 *)softback_curr;
+    if (s == (u16 *)softback_in)
+	s = (u16 *)conp->vc_origin;
+    while (count--) {
+	unsigned short *start;
+	unsigned short *le;
+	unsigned short c;
+	int x = 0;
+	unsigned short attr = 1;
+
+	start = s;
+	le = advance_row(s, 1);
+	do {
+	    c = scr_readw(s);
+	    if (attr != (c & 0xff00)) {
+		attr = c & 0xff00;
+		if (s > start) {
+		    ps2con_putcs(conp, start, s - start, line, x);
+		    x += s - start;
+		    start = s;
+		}
+	    }
+	    if (c == scr_readw(d)) {
+	    	if (s > start) {
+	    	    ps2con_putcs(conp, start, s - start, line, x);
+		    x += s - start + 1;
+		    start = s + 1;
+	    	} else {
+	    	    x++;
+	    	    start++;
+	    	}
+	    }
+	    s++;
+	    d++;
+	} while (s < le);
+	if (s > start)
+	    ps2con_putcs(conp, start, s - start, line, x);
+	line++;
+	if (d == (u16 *)softback_end)
+	    d = (u16 *)softback_buf;
+	if (d == (u16 *)softback_in)
+	    d = (u16 *)conp->vc_origin;
+	if (s == (u16 *)softback_end)
+	    s = (u16 *)softback_buf;
+	if (s == (u16 *)softback_in)
+	    s = (u16 *)conp->vc_origin;
+    }
+}
+
+static inline void ps2con_softback_note(struct vc_data *conp, int t, int count)
+{
+    unsigned short *p;
+
+    if (conp->vc_num != fg_console)
+	return;
+    p = (unsigned short *)(conp->vc_origin + t * conp->vc_size_row);
+
+    while (count) {
+    	scr_memcpyw((u16 *)softback_in, p, conp->vc_size_row);
+    	count--;
+    	p = advance_row(p, 1);
+    	softback_in += conp->vc_size_row;
+    	if (softback_in == softback_end)
+    	    softback_in = softback_buf;
+    	if (softback_in == softback_top) {
+    	    softback_top += conp->vc_size_row;
+    	    if (softback_top == softback_end)
+    	    	softback_top = softback_buf;
+    	}
+    }
+    softback_curr = softback_in;
+}
+#endif
+
+static int ps2con_scroll(struct vc_data *conp, int t, int b, int dir,
+			 int count)
+{
+    int unit = conp->vc_num;
+    struct ps2dpy *p = &ps2dpy[unit];
+
+    if (!p->can_soft_blank && console_blanked)
+	return 0;
+
+    if (!count || conp->vc_mode != KD_TEXT)
+	return 0;
+
+    ps2con_cursor(conp, CM_ERASE);
+
+    switch (dir) {
+    case SM_UP:
+	if (count > conp->vc_rows)
+	    count = conp->vc_rows;
+#ifdef CONFIG_PS2_CONSOLE_SCROLLBACK
+	if (softback_top)
+	    ps2con_softback_note(conp, t, count);
+#endif
+	ps2con_bmove(conp, t + count, 0, t, 0, b - t - count, conp->vc_cols);
+	ps2con_clear(conp, b - count, 0, count, conp->vc_cols);
+	break;
+
+    case SM_DOWN:
+	if (count > conp->vc_rows)	/* Maximum realistic size */
+	    count = conp->vc_rows;
+	ps2con_bmove(conp, t, 0, t + count, 0, b - t - count, conp->vc_cols);
+	ps2con_clear(conp, t, 0, count, conp->vc_cols);
+	break;
+    }
+
+    return 0;
+}
+
+
+static void ps2con_bmove(struct vc_data *conp, int sy, int sx, int dy, int dx,
+			 int height, int width)
+{
+    int unit = conp->vc_num;
+    struct ps2dpy *p = &ps2dpy[unit];
+    u64 *gsp;
+
+    if (!p->can_soft_blank && console_blanked)
+	return;
+
+    if (height == 0 || width == 0)
+	return;
+
+    if (((sy <= p->cursor_y) && (p->cursor_y < sy + height) &&
+	 (sx <= p->cursor_x) && (p->cursor_x < sx + width)) ||
+	((dy <= p->cursor_y) && (p->cursor_y < dy + height) &&
+	 (dx <= p->cursor_x) && (p->cursor_x < dx + width)))
+	ps2con_cursor(conp, CM_ERASE|CM_SOFTBACK);
+
+    if ((gsp = ps2con_gsp_alloc(ALIGN16(10 * 8), NULL)) == NULL)
+	return;
+
+    *gsp++ = PS2_GIFTAG_SET_TOPHALF(4, 1, 0, 0, PS2_GIFTAG_FLG_PACKED, 1);
+    *gsp++ = 0x0e;	/* A+D */
+    *gsp++ = (u64)p->info.fbp |
+	((u64)p->fbw << 16) | ((u64)p->info.psm << 24) |
+	((u64)p->info.fbp << 32) |
+	((u64)p->fbw << 48) | ((u64)p->info.psm << 56);
+    *gsp++ = PS2_GS_BITBLTBUF;
+
+    if (sy > dy || (sy == dy && sx > dx)) {
+	/* copy region LT -> RB */
+	*gsp++ = PACK64(PACK32(sx * fontwidth(p),
+			       sy * fontheight(p)),
+			PACK32(dx * fontwidth(p),
+			       dy * fontheight(p)) + (0 << 27));
+    } else {
+	/* copy region RB -> LT */
+	*gsp++ = PACK64(PACK32(sx * fontwidth(p),
+			       sy * fontheight(p)),
+			PACK32(dx * fontwidth(p),
+			       dy * fontheight(p)) + (3 << 27));
+    }
+
+    *gsp++ = PS2_GS_TRXPOS;
+    *gsp++ = PACK64(width * fontwidth(p), height * fontheight(p));
+    *gsp++ = PS2_GS_TRXREG;
+    *gsp++ = 2;	/* local to local */
+    *gsp++ = PS2_GS_TRXDIR;
+
+    ps2con_gsp_send(ALIGN16(10 * 8), 0);
+}
+
+
+static int ps2con_switch(struct vc_data *conp)
+{
+    int oldcon = currcon;
+    int unit = conp->vc_num;
+    struct ps2dpy *p = &ps2dpy[unit];
+    struct ps2dpy *oldp = &ps2dpy[oldcon];
+
+#ifdef CONFIG_PS2_CONSOLE_SCROLLBACK
+    if (softback_top) {
+    	int l = ps2con_softback_size / conp->vc_size_row;
+	if (softback_lines)
+	    ps2con_set_origin(conp);
+        softback_top = softback_curr = softback_in = softback_buf;
+        softback_lines = 0;
+
+	if (l > 5)
+	    softback_end = softback_buf + l * conp->vc_size_row;
+	else {
+	    /* Smaller scrollback makes no sense, and 0 would screw
+	       the operation totally */
+	    softback_top = 0;
+	}
+    }
+#endif
+    if (logo_shown >= 0) {
+    	struct vc_data *conp2 = vc_cons[logo_shown].d;
+
+    	if (conp2->vc_top == logo_lines && conp2->vc_bottom == conp2->vc_rows)
+	    conp2->vc_top = 0;
+    	logo_shown = -1;
+    }
+
+    currcon = unit;
+
+    if ((unit != oldcon) &&
+	!(conp->vc_mode == KD_TEXT &&
+	  conp->vc_mode == KD_TEXT &&
+	  memcmp(&p->info, &oldp->info, sizeof(struct ps2_screeninfo)) == 0))
+	ps2gs_screeninfo(&p->info, NULL);
+
+    if (conp->vc_mode == KD_TEXT)
+	ps2con_clear_margins(conp, p);
+
+    if (logo_shown == -2) {
+	logo_shown = fg_console;
+#ifdef LOGO_SUPPORT
+	ps2con_show_logo(); /* This is protected above by initmem_freed */
+	update_region(conp,
+		      conp->vc_origin + conp->vc_size_row * conp->vc_top,
+		      conp->vc_size_row * (conp->vc_bottom - conp->vc_top) / 2);
+#endif
+	return 0;
+    }
+    return 1;
+}
+
+
+static int ps2con_blank(struct vc_data *conp, int blank, int mode_switch)
+{
+    int unit = conp->vc_num;
+    struct ps2dpy *p = &ps2dpy[unit];
+
+    /* TBD: Parameter mode_switch was added, check. */
+    if (blank < 0)	/* Entering graphics mode */
+	return 0;
+
+    ps2con_cursor(p->conp, blank ? CM_ERASE : CM_DRAW);
+
+    if (!p->can_soft_blank) {
+	if (blank) {
+	    ps2con_clear(conp, 0, 0, conp->vc_rows, conp->vc_cols);
+	    return 0;
+	} else {
+	    /* Tell console.c that it has to restore the screen itself */
+	    return 1;
+	}
+    }
+
+    if (blank) {
+	ps2gs_blank(1);
+	ps2gs_setdpms(blank - 1);
+    } else {
+	ps2gs_blank(0);
+	ps2gs_setdpms(0);
+    }
+    return 0;
+}
+
+
+static void ps2con_free_font(struct ps2dpy *p)
+{
+    if (p->userfont && p->fontdata &&
+        (--REFCOUNT(p->fontdata) == 0))
+	kfree(p->fontdata - FONT_EXTRA_WORDS*sizeof(int));
+    p->fontdata = NULL;
+    p->userfont = 0;
+}
+
+static int ps2con_get_font(struct vc_data *vc, struct console_font *font)
+{
+    int unit = vc->vc_num;
+    struct ps2dpy *p = &ps2dpy[unit];
+    u8 *data = font->data;
+    const u8 *fontdata = p->fontdata;
+    int i, j;
+
+#ifdef CONFIG_FBCON_FONTWIDTH8_ONLY
+    if (fontwidth(p) != 8) return -EINVAL;
+#endif
+    font->width = fontwidth(p);
+    font->height = fontheight(p);
+    font->charcount = (p->charmask == 0x1ff) ? 512 : 256;
+    if (!font->data) return 0;
+    
+    if (font->width <= 8) {
+	j = fontheight(p);
+    	for (i = 0; i < font->charcount; i++) {
+	    memcpy(data, fontdata, j);
+	    memset(data+j, 0, 32-j);
+	    data += 32;
+	    fontdata += j;
+	}
+    }
+#ifndef CONFIG_FBCON_FONTWIDTH8_ONLY
+    else if (font->width <= 16) {
+	j = fontheight(p) * 2;
+	for (i = 0; i < font->charcount; i++) {
+	    memcpy(data, fontdata, j);
+	    memset(data+j, 0, 64-j);
+	    data += 64;
+	    fontdata += j;
+	}
+    } else if (font->width <= 24) {
+	for (i = 0; i < font->charcount; i++) {
+	    for (j = 0; j < fontheight(p); j++) {
+		*data++ = fontdata[0];
+		*data++ = fontdata[1];
+		*data++ = fontdata[2];
+		fontdata += sizeof(u32);
+	    }
+	    memset(data, 0, 3*(32-j));
+	    data += 3 * (32 - j);
+	}
+    } else {
+	j = fontheight(p) * 4;
+	for (i = 0; i < font->charcount; i++) {
+	    memcpy(data, fontdata, j);
+	    memset(data+j, 0, 128-j);
+	    data += 128;
+	    fontdata += j;
+	}
+    }
+#endif
+    return 0;
+}
+
+static int ps2con_do_set_font(struct vc_data *vc, int unit, struct console_font *font, const u8 *data, int userfont)
+{
+    struct ps2dpy *p = &ps2dpy[unit];
+    int resize;
+    int w = font->width;
+    int h = font->height;
+    int cnt;
+    const char *old_data = NULL;
+
+#ifdef CONFIG_PS2_CONSOLE_SCROLLBACK
+    if (CON_IS_VISIBLE(p->conp) && softback_lines)
+	ps2con_set_origin(p->conp);
+#endif
+	
+    resize = (w != fontwidth(p)) || (h != fontheight(p));
+    if (p->userfont)
+        old_data = p->fontdata;
+    if (userfont)
+        cnt = FNTCHARCNT(data);
+    else
+    	cnt = 256;
+    p->fontdata = data;
+    if ((p->userfont = userfont))
+        REFCOUNT(data)++;
+    p->_fontwidth = w;
+    p->_fontheight = h;
+    p->grayfont = 0;
+    if (p->conp->vc_hi_font_mask && cnt == 256) {
+    	p->conp->vc_hi_font_mask = 0;
+    	if (p->conp->vc_can_do_color)
+	    p->conp->vc_complement_mask >>= 1;
+    	p->fgshift--;
+    	p->bgshift--;
+    	p->charmask = 0xff;
+
+	/* ++Edmund: reorder the attribute bits */
+	if (p->conp->vc_can_do_color) {
+	    struct vc_data *conp = p->conp;
+	    unsigned short *cp = (unsigned short *) conp->vc_origin;
+	    int count = conp->vc_screenbuf_size/2;
+	    unsigned short c;
+	    for (; count > 0; count--, cp++) {
+	        c = scr_readw(cp);
+		scr_writew(((c & 0xfe00) >> 1) | (c & 0xff), cp);
+	    }
+	    c = conp->vc_video_erase_char;
+	    conp->vc_video_erase_char = ((c & 0xfe00) >> 1) | (c & 0xff);
+	    conp->vc_attr >>= 1;
+	}
+
+    } else if (!p->conp->vc_hi_font_mask && cnt == 512) {
+    	p->conp->vc_hi_font_mask = 0x100;
+    	if (p->conp->vc_can_do_color)
+	    p->conp->vc_complement_mask <<= 1;
+    	p->fgshift++;
+    	p->bgshift++;
+    	p->charmask = 0x1ff;
+
+	/* ++Edmund: reorder the attribute bits */
+	{
+	    struct vc_data *conp = p->conp;
+	    unsigned short *cp = (unsigned short *) conp->vc_origin;
+	    int count = conp->vc_screenbuf_size/2;
+	    unsigned short c;
+	    for (; count > 0; count--, cp++) {
+	        unsigned short newc;
+	        c = scr_readw(cp);
+		if (conp->vc_can_do_color)
+		    newc = ((c & 0xff00) << 1) | (c & 0xff);
+		else
+		    newc = c & ~0x100;
+		scr_writew(newc, cp);
+	    }
+	    c = conp->vc_video_erase_char;
+	    if (conp->vc_can_do_color) {
+		conp->vc_video_erase_char = ((c & 0xff00) << 1) | (c & 0xff);
+		conp->vc_attr <<= 1;
+	    } else
+	        conp->vc_video_erase_char = c & ~0x100;
+	}
+
+    }
+    if (resize) {
+    	struct vc_data *conp = p->conp;
+	vc_resize(vc, p->info.w / w, p->info.h / h);
+#ifdef CONFIG_PS2_CONSOLE_SCROLLBACK
+        if (CON_IS_VISIBLE(conp) && softback_buf) {
+	    int l = ps2con_softback_size / conp->vc_size_row;
+	    if (l > 5)
+		softback_end = softback_buf + l * conp->vc_size_row;
+	    else {
+		/* Smaller scrollback makes no sense, and 0 would screw
+		   the operation totally */
+		softback_top = 0;
+    	    }
+    	}
+#endif
+    } else if (CON_IS_VISIBLE(p->conp) && vc->vc_mode == KD_TEXT) {
+	ps2con_clear_margins(p->conp, p);
+	update_screen(p->conp);
+    }
+
+    if (old_data && (--REFCOUNT(old_data) == 0))
+	kfree(old_data - FONT_EXTRA_WORDS*sizeof(int));
+
+    return 0;
+}
+
+static int ps2con_copy_font(struct vc_data *vc, int con)
+{
+    int unit = vc->vc_num;
+    struct ps2dpy *od, *p = &ps2dpy[unit];
+    struct console_font *font = &vc->vc_font;
+    int h = font->height;
+
+    if (h < 0 || !vc_cons_allocated( h ))
+        return -ENOTTY;
+    if (h == unit)
+        return 0; /* nothing to do */
+    od = &ps2dpy[h];
+    if (od->fontdata == p->fontdata)
+        return 0; /* already the same font... */
+    font->width = fontwidth(od);
+    font->height = fontheight(od);
+    return ps2con_do_set_font(vc, unit, font, od->fontdata, od->userfont);
+}
+
+static int ps2con_set_font(struct vc_data *vc, struct console_font *font, unsigned flags)
+{
+    int unit = vc->vc_num;
+    int w = font->width;
+    int h = font->height;
+    int size = h;
+    int i, k;
+    u8 *new_data;
+    u8 *data = font->data;
+	u8 *p;
+
+	data = font->data;
+
+    /* TBD: Check additonal parameter flags. */
+#ifdef CONFIG_FBCON_FONTWIDTH8_ONLY
+    if (w != 8)
+    	return -EINVAL;
+#endif
+    if ((w <= 0) || (w > 32) || (font->charcount != 256 && font->charcount != 512))
+        return -EINVAL;
+
+    if (w > 8) { 
+    	if (w <= 16)
+    		size *= 2;
+    	else
+    		size *= 4;
+    }
+    size *= font->charcount;
+       
+    if (!(new_data = kmalloc(FONT_EXTRA_WORDS*sizeof(int)+size, GFP_USER)))
+        return -ENOMEM;
+    new_data += FONT_EXTRA_WORDS*sizeof(int);
+    FNTSIZE(new_data) = size;
+    FNTCHARCNT(new_data) = font->charcount;
+    REFCOUNT(new_data) = 0; /* usage counter */
+    p = new_data;
+    if (w <= 8) {
+	for (i = 0; i < font->charcount; i++) {
+	    memcpy(p, data, h);
+	    data += 32;
+	    p += h;
+	}
+    }
+#ifndef CONFIG_FBCON_FONTWIDTH8_ONLY
+    else if (w <= 16) {
+	h *= 2;
+	for (i = 0; i < font->charcount; i++) {
+	    memcpy(p, data, h);
+	    data += 64;
+	    p += h;
+	}
+    } else if (w <= 24) {
+	for (i = 0; i < font->charcount; i++) {
+	    int j;
+	    for (j = 0; j < h; j++) {
+	        memcpy(p, data, 3);
+		p[3] = 0;
+		data += 3;
+		p += sizeof(u32);
+	    }
+	    data += 3*(32 - h);
+	}
+    } else {
+	h *= 4;
+	for (i = 0; i < font->charcount; i++) {
+	    memcpy(p, data, h);
+	    data += 128;
+	    p += h;
+	}
+    }
+#endif
+    /* we can do it in u32 chunks because of charcount is 256 or 512, so
+       font length must be multiple of 256, at least. And 256 is multiple
+       of 4 */
+    k = 0;
+    while (p > new_data) {
+	p = (u8 *) ((u32 *)p - 1);
+	k += *(u32 *)p;
+    }
+    FNTSUM(new_data) = k;
+    /* Check if the same font is on some other console already */
+    for (i = 0; i < MAX_NR_CONSOLES; i++) {
+    	if (ps2dpy[i].userfont &&
+    	    ps2dpy[i].fontdata &&
+    	    FNTSUM(ps2dpy[i].fontdata) == k &&
+    	    FNTSIZE(ps2dpy[i].fontdata) == size &&
+	    !memcmp(ps2dpy[i].fontdata, new_data, size)) {
+	    kfree(new_data - FONT_EXTRA_WORDS*sizeof(int));
+    	return ps2con_do_set_font(vc, unit, font, ps2dpy[i].fontdata, 1);
+    	}
+    }
+    return ps2con_do_set_font(vc, unit, font, new_data, 1);
+}
+
+static int ps2con_set_def_font(struct vc_data *vc, struct console_font *font, char *name)
+{
+    int unit = vc->vc_num;
+    const struct font_desc *f;
+    struct ps2dpy *p = &ps2dpy[unit];
+
+    if (!name)
+	f = get_default_font(p->info.w, p->info.h,
+		(1 << (8 - 1)),
+		(1 << (8 - 1)) | (1 << (16 - 1)));
+    else if (!(f = find_font(name)))
+	return -ENOENT;
+
+    font->width = f->width;
+    font->height = f->height;
+    return ps2con_do_set_font(vc, unit, font, f->data, 0);
+}
+
+static int ps2con_set_palette(struct vc_data *conp, unsigned char *table)
+{
+    int unit = conp->vc_num;
+    struct ps2dpy *p = &ps2dpy[unit];
+    int i, j, k;
+    unsigned int palette;
+    
+    if (!conp->vc_can_do_color || (!p->can_soft_blank && console_blanked))
+	return -EINVAL;
+    for (i = j = 0; i < 16; i++) {
+	k = table[i];
+	palette = conp->vc_palette[j++];			/* R */
+	palette = palette | (conp->vc_palette[j++] << 8);	/* G */
+	palette = palette | (conp->vc_palette[j++] << 16);	/* B */
+	ps2_cmap[k] = palette;
+    }
+
+    return 0;
+}
+
+
+/* As we might be inside of softback, we may work with non-contiguous buffer,
+   that's why we have to use a separate routine. */
+static void ps2con_invert_region(struct vc_data *conp, u16 *p, int cnt)
+{
+    while (cnt--) {
+	u16 a = scr_readw(p);
+	if (!conp->vc_can_do_color)
+	    a ^= 0x0800;
+	else if (conp->vc_hi_font_mask == 0x100)
+	    a = ((a) & 0x11ff) | (((a) & 0xe000) >> 4) | (((a) & 0x0e00) << 4);
+	else
+	    a = ((a) & 0x88ff) | (((a) & 0x7000) >> 4) | (((a) & 0x0700) << 4);
+	scr_writew(a, p++);
+#ifdef CONFIG_PS2_CONSOLE_SCROLLBACK
+	if (p == (u16 *)softback_end)
+	    p = (u16 *)softback_buf;
+	if (p == (u16 *)softback_in)
+	    p = (u16 *)conp->vc_origin;
+#endif
+    }
+}
+
+static int ps2con_scrolldelta(struct vc_data *conp, int lines)
+{
+    int unit;
+    struct ps2dpy *p;
+    
+    unit = fg_console;
+    p = &ps2dpy[unit];
+#ifdef CONFIG_PS2_CONSOLE_SCROLLBACK
+    if (softback_top) {
+    	if (conp->vc_num != unit)
+    	    return 0;
+    	if (conp->vc_mode != KD_TEXT || !lines)
+    	    return 0;
+    	if (logo_shown >= 0) {
+		struct vc_data *conp2 = vc_cons[logo_shown].d;
+    	
+		if (conp2->vc_top == logo_lines && conp2->vc_bottom == conp2->vc_rows)
+    		    conp2->vc_top = 0;
+    		if (logo_shown == unit) {
+    		    unsigned long p, q;
+    		    int i;
+    		    
+    		    p = softback_in;
+    		    q = conp->vc_origin + logo_lines * conp->vc_size_row;
+    		    for (i = 0; i < logo_lines; i++) {
+    		    	if (p == softback_top) break;
+    		    	if (p == softback_buf) p = softback_end;
+    		    	p -= conp->vc_size_row;
+    		    	q -= conp->vc_size_row;
+    		    	scr_memcpyw((u16 *)q, (u16 *)p, conp->vc_size_row);
+    		    }
+    		    softback_in = p;
+    		    update_region(conp, conp->vc_origin, logo_lines * conp->vc_cols);
+    		}
+		logo_shown = -1;
+	}
+    	ps2con_cursor(conp, CM_ERASE|CM_SOFTBACK);
+    	ps2con_redraw_softback(conp, p, lines);
+    	ps2con_cursor(conp, CM_DRAW|CM_SOFTBACK);
+    	return 0;
+    }
+#endif
+
+    return -ENOSYS;
+}
+
+static int ps2con_set_origin(struct vc_data *conp)
+{
+#ifdef CONFIG_PS2_CONSOLE_SCROLLBACK
+    if (softback_lines && !console_blanked)
+        ps2con_scrolldelta(conp, softback_lines);
+#endif
+    return 0;
+}
+
+static void ps2con_revc(struct vc_data *conp, int sy, int sx,
+			 int height, int width)
+{
+    int unit = conp->vc_num;
+    struct ps2dpy *p = &ps2dpy[unit];
+    u64 *gsp;
+    int ctx = 0;
+
+    if (height == 0 || width == 0)
+	return;
+
+    if ((gsp = ps2con_gsp_alloc(ALIGN16(9 * 8), NULL)) == NULL)
+	return;
+
+    *gsp++ = PS2_GIFTAG_SET_TOPHALF(1, 0, 1, 0x046 + (ctx << 9), PS2_GIFTAG_FLG_PACKED, 1);
+    *gsp++ = 0x0e;	/* A+D */
+    *gsp++ = (0 << 0) | (1 << 2) | (2 << 4) | (3 << 6) | ((u64)0x80 << 32);
+					    /* (Cs - Cd) * 0x80 + 0 */
+    *gsp++ = PS2_GS_ALPHA_1 + ctx;
+
+    *gsp++ = PS2_GIFTAG_SET_TOPHALF(1, 1, 0, 0, PS2_GIFTAG_FLG_REGLIST, 3);
+    *gsp++ = 0x551;
+    *gsp++ = 0xffffff;						/* RGBAQ */
+    *gsp++ = PACK32(sx * fontwidth(p) * 16, sy * fontheight(p) * 16);
+								/* XYZ2 */
+    *gsp++ = PACK32((sx + width) * fontwidth(p) * 16,
+		    (sy + height) * fontheight(p) * 16);	/* XYZ2 */
+
+    ps2con_gsp_send(ALIGN16(9 * 8), 0);
+}
+
+static void ps2con_clear_margins(struct vc_data *conp, struct ps2dpy *p)
+{
+    unsigned int right_start = conp->vc_cols * fontwidth(p);
+    unsigned int bottom_start = conp->vc_rows * fontheight(p);
+    u64 *gsp;
+    int ctx = 0;
+
+    if ((gsp = ps2con_gsp_alloc(ALIGN16(8 * 8), NULL)) == NULL)
+	return;
+
+    *gsp++ = PS2_GIFTAG_SET_TOPHALF(1, 1, 0, 0, PS2_GIFTAG_FLG_REGLIST, 6);
+    *gsp++ = 0x555510;
+    *gsp++ = 0x006 + (ctx << 9);				/* PRIM */
+    *gsp++ = ps2_cmap[attr_bgcol_ec(p, conp)];			/* RGBAQ */
+    *gsp++ = PACK32(right_start * 16, 0);			/* XYZ2 */
+    *gsp++ = PACK32(p->info.w * 16, p->info.h * 16);		/* XYZ2 */
+    *gsp++ = PACK32(0, bottom_start * 16);			/* XYZ2 */
+    *gsp++ = PACK32(p->info.w * 16, p->info.h * 16);		/* XYZ2 */
+
+    ps2con_gsp_send(ALIGN16(8 * 8), 0);
+}
+
+#ifdef LOGO_SUPPORT
+static int __init ps2con_show_logo( void )
+{
+    struct ps2dpy *p = &ps2dpy[fg_console]; /* draw to vt in foreground */
+    u64 *gsp, *gsp_h;
+    u32 *ptr, val;
+    unsigned char *src;
+    int i, x, y;
+    int lines_left, lines, size;
+    int logo_h = LOGO_H;
+
+    if (is_nointer(p))
+	logo_h /= 2;
+
+    for (x = 0; x < smp_num_cpus * (LOGO_W + 8) &&
+	     x < p->info.w - (LOGO_W + 8); x += (LOGO_W + 8)) {
+
+	lines_left = logo_h;
+	src = linux_logo;
+	y = 0;
+
+	while (lines_left > 0) {
+	    gsp_h = gsp = ps2con_gsp_alloc(ALIGN16(12 * 8 + LOGO_W * p->pixel_size), &size);
+	    if (gsp == NULL)
+		return 0;
+	    lines = (size - ALIGN16(12 * 8)) / (LOGO_W * p->pixel_size);
+	    lines = lines > lines_left ? lines_left : lines;
+
+	    *gsp++ = PS2_GIFTAG_SET_TOPHALF(4, 0, 0, 0, PS2_GIFTAG_FLG_PACKED, 1);
+	    *gsp++ = 0x0e;		/* A+D */
+	    *gsp++ = (u64)0 | ((u64)p->info.fbp << 32) |
+		((u64)p->fbw << 48) | ((u64)p->info.psm << 56);
+	    *gsp++ = PS2_GS_BITBLTBUF;
+	    *gsp++ = PACK64(0, PACK32(x, y));
+	    *gsp++ = PS2_GS_TRXPOS;
+	    *gsp++ = PACK64(LOGO_W, lines);
+	    *gsp++ = PS2_GS_TRXREG;
+	    *gsp++ = 0;			/* host to local */
+	    *gsp++ = PS2_GS_TRXDIR;
+
+	    *gsp++ = PS2_GIFTAG_SET_TOPHALF(ALIGN16(LOGO_W * lines * p->pixel_size) / 16,
+				     1, 0, 0, PS2_GIFTAG_FLG_IMAGE, 0);
+	    *gsp++ = 0;
+	    ptr = (u32 *)gsp;
+
+	    while (lines-- > 0) {
+		lines_left--;
+		y++;
+
+		for(i = 0; i < LOGO_W; i++, src++) {
+		    switch (p->pixel_size) {
+		    case 4:		/* RGBA32 */
+			val = (linux_logo_red[*src - 32] << 0) |
+			    (linux_logo_green[*src - 32] << 8) |
+			    (linux_logo_blue[*src - 32] << 16);
+			*ptr++ = val;
+			break;
+		    case 2:		/* RGBA16 */
+			val = ((linux_logo_red[*src - 32] & 0xf8) >> 3) |
+			    ((linux_logo_green[*src - 32] & 0xf8) << (5 - 3)) |
+			    ((linux_logo_blue[*src - 32] & 0xf8) << (10 - 3));
+			*((u16 *)ptr) = val;
+			ptr = (void *) ((u16 *)ptr) + 1;
+			break;
+		    case 3:		/* RGB24 */
+			val = (linux_logo_red[*src - 32] << 0) |
+			    (linux_logo_green[*src - 32] << 8) |
+			    (linux_logo_blue[*src - 32] << 16);
+			*((u8 *)ptr) = ((unsigned char *)&val)[0];
+			ptr = (void *) ((u8 *)ptr) + 1;
+			*((u8 *)ptr) = ((unsigned char *)&val)[1];
+			ptr = (void *) ((u8 *)ptr) + 1;
+			*((u8 *)ptr) = ((unsigned char *)&val)[2];
+			ptr = (void *) ((u8 *)ptr) + 1;
+			break;
+		    }
+		}
+		if (is_nointer(p))
+		    src += LOGO_W;
+	    }
+
+	    ps2con_gsp_send(ALIGN16((unsigned char *)ptr - (unsigned char *)gsp_h), 0);
+	}
+   }
+    
+    return (logo_h + fontheight(p) - 1) / fontheight(p);
+}
+#endif
+
+/*
+ *  The console `switch' structure for the PS2 Graphics Synthesizer console
+ */
+
+const struct consw ps2_con = {
+    owner:		THIS_MODULE,
+    con_startup:	ps2con_startup,
+    con_init:		ps2con_init,
+    con_deinit:		ps2con_deinit,
+    con_clear:		ps2con_clear,
+    con_putc:		ps2con_putc,
+    con_putcs:		ps2con_putcs,
+    con_cursor:		ps2con_cursor,
+    con_scroll:		ps2con_scroll,
+    con_bmove:		ps2con_bmove,
+    con_switch:		ps2con_switch,
+    con_blank:		ps2con_blank,
+    con_font_set:	ps2con_set_font,
+    con_font_get:	ps2con_get_font,
+    con_font_default:	ps2con_set_def_font,
+    con_font_copy:	ps2con_copy_font,
+    con_set_palette:	ps2con_set_palette,
+    con_scrolldelta:	ps2con_scrolldelta,
+    con_set_origin:	ps2con_set_origin,
+    con_save_screen:	NULL,
+    con_build_attr:	NULL,
+    con_invert_region:	ps2con_invert_region,
+#if 0 /* TBD: Check missing calls. */
+	.con_screen_pos 	= fbcon_screen_pos,
+	.con_getxy 		= fbcon_getxy,
+	.con_resize             = fbcon_resize,
+#endif
+};
+
+static int graphics_boot = 0;
+
+static int graphics_setup(char *options)
+{
+    graphics_boot = 1;
+    return 0;
+}
+
+__setup("graphics", graphics_setup);
+
+int __init ps2_console_init(void)
+{
+    if (!graphics_boot) {
+	take_over_console(&ps2_con, 0, MAX_NR_CONSOLES - 1, 1);
+    } else {
+	/* get current crtmode */
+	struct ps2_crtmode crtmode;
+
+	ps2con_initinfo(&defaultinfo);
+	if (defaultinfo.mode == PS2_GS_NTSC ||
+	    defaultinfo.mode == PS2_GS_PAL) {
+	    crtmode.mode = defaultinfo.mode;
+	    crtmode.res = -1;			/* set current mode */
+	    ps2gs_crtmode(&crtmode, NULL);
+	}
+    }
+
+    return 0;
+}
+
+module_init(ps2_console_init)
diff -purN linux-2.6.35.4-orig/drivers/video/Kconfig linux-2.6.35.4/drivers/video/Kconfig
--- linux-2.6.35.4-orig/drivers/video/Kconfig	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/drivers/video/Kconfig	2014-07-18 22:29:43.570367725 +0200
@@ -2229,6 +2229,14 @@ config FB_BROADSHEET
 	  and could also have been called by other names when coupled with
 	  a bridge adapter.
 
+config FB_PS2
+	tristate "Frame buffer driver for Sony Playstation 2"
+	depends on FB && SONY_PS2
+	default y
+	help
+	  This driver implements support for framebuffer of the Sony
+	  Playstation 2.
+
 source "drivers/video/omap/Kconfig"
 source "drivers/video/omap2/Kconfig"
 
diff -purN linux-2.6.35.4-orig/drivers/video/Makefile linux-2.6.35.4/drivers/video/Makefile
--- linux-2.6.35.4-orig/drivers/video/Makefile	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/drivers/video/Makefile	2014-07-18 22:29:43.570367725 +0200
@@ -149,3 +149,6 @@ obj-$(CONFIG_FB_VIRTUAL)          += vfb
 
 #video output switch sysfs driver
 obj-$(CONFIG_VIDEO_OUTPUT_CONTROL) += output.o
+
+obj-$(CONFIG_SONY_PS2)            += ps2core.o
+obj-$(CONFIG_FB_PS2)              += ps2fb.o
diff -purN linux-2.6.35.4-orig/drivers/video/ps2core.c linux-2.6.35.4/drivers/video/ps2core.c
--- linux-2.6.35.4-orig/drivers/video/ps2core.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/video/ps2core.c	2014-07-18 22:29:43.570367725 +0200
@@ -0,0 +1,359 @@
+
+/* Copyright 2010 Mega Man */
+
+/* TBD: Unfinished state. Rework code. */
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/ps2/gs.h>
+#include <linux/semaphore.h>
+#include <linux/hardirq.h>
+
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/uaccess.h>
+#include <asm/mach-ps2/dma.h>
+#include <asm/mach-ps2/eedev.h>
+#include <asm/mach-ps2/ps2con.h>
+
+#ifdef CONFIG_T10000
+static int defaultmode = PS2_GS_VESA, defaultres = PS2_GS_640x480;
+static int default_w = 640, default_h = 480;
+#else
+static int defaultmode = PS2_GS_NTSC, defaultres = PS2_GS_NOINTERLACE;
+static int default_w = 640, default_h = 448;
+#endif
+
+#ifdef CONFIG_PS2_CONSOLE_LARGEBUF
+#define BUF_SIZE	(4096 * 8)
+#else
+#define BUF_SIZE	1024
+#endif
+static unsigned char buf1[BUF_SIZE] __attribute__ ((aligned(16)));
+
+static unsigned char buf2[BUF_SIZE] __attribute__ ((aligned(16)));
+
+struct kdma_buffer;
+
+struct kdma_request {
+	struct dma_request r;
+	void *next;
+	struct kdma_buffer *kdb;
+	unsigned long qwc;
+} __attribute__ ((aligned(DMA_TRUNIT)));
+
+struct kdma_buffer {
+	struct dma_channel *channel;
+	void *start, *end;
+	void *top, *volatile bottom;
+	int size, allocmax;
+	struct semaphore sem;
+	spinlock_t lock;
+	struct dma_completion c;
+	struct kdma_request *kreq;
+	int error;
+};
+
+static void kdma_send_start(struct dma_request *req, struct dma_channel *ch)
+{
+	struct kdma_request *kreq = (struct kdma_request *) req;
+
+	int count = DMA_POLLING_TIMEOUT;
+
+	/*
+	 * If PATH3 is active and no data exists in GIF FIFO,
+	 * previous GS packet may not be terminated.
+	 */
+	while ((GIFREG(PS2_GIFREG_STAT) & 0x1f000c00) == 0x00000c00) {
+		if (--count <= 0) {
+			SET_GIFREG(PS2_GIFREG_CTRL, 1);	/* reset GIF */
+			ps2_printf("ps2dma: GS packet is not terminated\n");
+			break;
+		}
+	}
+
+	WRITEDMAREG(ch, PS2_Dn_MADR,
+		virt_to_bus((void *) kreq + sizeof(struct kdma_request)));
+	WRITEDMAREG(ch, PS2_Dn_QWC, kreq->qwc);
+	WRITEDMAREG(ch, PS2_Dn_CHCR, CHCR_SENDN);
+}
+
+static void kdma_free(struct dma_request *req, struct dma_channel *ch)
+{
+	struct kdma_request *kreq = (struct kdma_request *) req;
+
+	unsigned long flags;
+
+	spin_lock_irqsave(&kreq->kdb->lock, flags);
+	kreq->kdb->bottom = kreq->next;
+	spin_unlock_irqrestore(&kreq->kdb->lock, flags);
+	ps2dma_complete(&kreq->kdb->c);
+}
+
+static struct dma_ops kdma_send_ops =
+	{ kdma_send_start, NULL, NULL, kdma_free };
+
+static void ps2kdma_init(struct kdma_buffer *kdb, int ch, void *buf, int len)
+{
+	len = kdb->size = len & ~(DMA_TRUNIT - 1);
+	kdb->channel = &ps2dma_channels[ch];
+	kdb->start = buf;
+	kdb->end = buf + len;
+	kdb->top = kdb->bottom = NULL;
+	kdb->allocmax = DMA_ALIGN(len - (len >> 2));
+	init_MUTEX(&kdb->sem);
+	spin_lock_init(&kdb->lock);
+	ps2dma_init_completion(&kdb->c);
+	kdb->error = 0;
+}
+
+static void *ps2kdma_alloc(struct kdma_buffer *kdb, int min, int max, int *size)
+{
+	unsigned long flags;
+
+	int free, amin;
+
+	int poll;
+
+	/* polling wait is used when
+	 *  - called from interrupt handler
+	 *  - interrupt is already disabled (in printk()) 
+	 */
+	poll = in_interrupt() || !irqs_disabled();
+
+	if (down_trylock(&kdb->sem) != 0) {
+		if (poll)
+			return NULL;		/* cannot sleep */
+		else
+			down(&kdb->sem);
+	}
+
+	amin = DMA_ALIGN(min) + sizeof(struct kdma_request);
+	if (amin > kdb->size) {
+		up(&kdb->sem);
+		return NULL;			/* requested size is too large */
+	}
+
+	spin_lock_irqsave(&kdb->lock, flags);
+
+	while (1) {
+		if (kdb->top == kdb->bottom) {	/* whole buffer is free */
+			kdb->top = kdb->bottom = kdb->start;
+			free = kdb->size - DMA_TRUNIT;
+			break;
+		}
+		if (kdb->top > kdb->bottom) {	/* [...#####...] */
+			free = kdb->end - kdb->top;
+			if (amin <= free)
+				break;
+			if (kdb->bottom > kdb->start) {
+				kdb->top = kdb->start;	/* wrap around */
+				continue;
+			}
+		} else if (kdb->top < kdb->bottom) {	/* [###.....###] */
+			free = kdb->bottom - kdb->top - DMA_TRUNIT;
+			if (amin <= free)
+				break;
+		}
+
+		spin_unlock_irqrestore(&kdb->lock, flags);
+		kdb->error |=
+			ps2dma_intr_safe_wait_for_completion(kdb->channel, poll, &kdb->c);
+		spin_lock_irqsave(&kdb->lock, flags);
+	}
+
+	if (amin < kdb->allocmax && free > kdb->allocmax)
+		free = kdb->allocmax;
+	free -= sizeof(struct kdma_request);
+	if (size)
+		*size = free > max ? max : free;
+	kdb->kreq = (struct kdma_request *) kdb->top;
+	spin_unlock_irqrestore(&kdb->lock, flags);
+
+	return (void *) kdb->kreq + sizeof(struct kdma_request);
+}
+
+static void ps2kdma_send(struct kdma_buffer *kdb, int len, int flushall)
+{
+	unsigned long flags;
+
+	int alen;
+
+	struct kdma_request *kreq = kdb->kreq;
+
+	spin_lock_irqsave(&kdb->lock, flags);
+	alen = sizeof(struct kdma_request) + DMA_ALIGN(len);
+	kdb->top = (void *) kreq + alen;
+	spin_unlock_irqrestore(&kdb->lock, flags);
+
+	up(&kdb->sem);
+
+	init_dma_request(&kreq->r, &kdma_send_ops);
+	kreq->next = (void *) kreq + alen;
+	kreq->kdb = kdb;
+	kreq->qwc = len >> 4;
+
+	ps2dma_add_queue((struct dma_request *) kreq, kdb->channel, flushall);
+
+	if (kdb->error) {
+		kdb->error = 0;
+		ps2_printf("ps2dma: %s timeout\n", kdb->channel->device);
+	}
+}
+
+static struct kdma_buffer kdb, kkdb;
+
+void ps2con_gsp_init(void)
+{
+	ps2kdma_init(&kdb, DMA_GIF, buf1, BUF_SIZE);
+	ps2kdma_init(&kkdb, DMA_GIF, buf2, BUF_SIZE);
+}
+
+u64 *ps2con_gsp_alloc(int request, int *avail)
+{
+	return ps2kdma_alloc(in_interrupt()? &kkdb : &kdb, request, BUF_SIZE,
+		avail);
+}
+
+void ps2con_gsp_send(int len, int flushall)
+{
+	struct kdma_buffer *buf;
+
+	buf = in_interrupt()? &kkdb : &kdb;
+	if (!flushall) {
+		dma_cache_wback((unsigned long) buf->kreq + sizeof(struct kdma_request),
+			len);
+	}
+	ps2kdma_send(buf, len, flushall);
+}
+
+void ps2con_initinfo(struct ps2_screeninfo *info)
+{
+	info->fbp = 0;
+	info->psm = PS2_GS_PSMCT32;
+	info->mode = defaultmode;
+	info->res = defaultres;
+	info->w = default_w;
+	info->h = default_h;
+
+	if (info->w * info->h > 1024 * 1024)
+		info->psm = PS2_GS_PSMCT16;
+}
+
+const static struct {
+	int w, h;
+} reslist[4][4] = {
+	{
+		{640, 480},
+		{800, 600},
+		{1024, 768},
+		{1280, 1024},
+	}, {
+		{720, 480},
+		{1920, 1080},
+		{1280, 720},
+		{-1, -1},
+	},
+	{
+		{640, 224},
+		{640, 448},
+		{-1, -1},
+		{-1, -1},
+	},
+	{
+		{640, 240},
+		{640, 480},
+		{-1, -1},
+		{-1, -1},
+	},
+};
+
+static int __init crtmode_setup(char *options)
+{
+	int maxres;
+
+	int rrate, w, h;
+
+	if (!options || !*options)
+		return 0;
+
+	if (strnicmp(options, "vesa", 4) == 0) {
+		options += 4;
+		defaultmode = PS2_GS_VESA;
+		maxres = 4;
+	} else if (strnicmp(options, "dtv", 3) == 0) {
+		options += 3;
+		defaultmode = PS2_GS_DTV;
+		maxres = 3;
+	} else if (strnicmp(options, "ntsc", 4) == 0) {
+		options += 4;
+		defaultmode = PS2_GS_NTSC;
+		maxres = 2;
+	} else if (strnicmp(options, "pal", 3) == 0) {
+		options += 3;
+		defaultmode = PS2_GS_PAL;
+		maxres = 2;
+	} else
+		return 0;
+
+	defaultres = 0;
+	if (*options >= '0' && *options <= '9') {
+		defaultres = *options - '0';
+		options++;
+		if (defaultres >= maxres)
+			defaultres = 0;
+	}
+
+	if (defaultmode == PS2_GS_VESA && *options == ',') {
+		rrate = simple_strtoul(options + 1, &options, 0);
+		if (rrate == 60)
+			defaultres |= PS2_GS_60Hz;
+		else if (rrate == 75)
+			defaultres |= PS2_GS_75Hz;
+	}
+
+	w = default_w = reslist[defaultmode][defaultres & 0xff].w;
+	h = default_h = reslist[defaultmode][defaultres & 0xff].h;
+
+	if (*options == ':') {
+		w = simple_strtoul(options + 1, &options, 0);
+		if (*options == ',' || tolower(*options) == 'x') {
+			h = simple_strtoul(options + 1, &options, 0);
+		}
+		if (w > 0)
+			default_w = w;
+		if (h > 0)
+			default_h = h;
+	}
+
+	return 1;
+}
+
+/* Convert resolution to ps2 mode format. */
+int ps2con_get_resolution(int mode, int w, int h, int rate)
+{
+	int res;
+
+	for (res = 0; res < 4; res++) {
+		if (reslist[mode][res & 0xff].w == w) {
+			if (reslist[mode][res & 0xff].h == h) {
+				if (mode == PS2_GS_VESA) {
+					if (rate >= 75) {
+						res |= PS2_GS_75Hz;
+					} else if (rate >= 60) {
+						res |= PS2_GS_60Hz;
+					}
+				}
+				return res;
+			}
+		}
+	}
+	return -1;
+}
+
+__setup("crtmode=", crtmode_setup);
+
+MODULE_LICENSE("GPL");
diff -purN linux-2.6.35.4-orig/drivers/video/ps2fb.c linux-2.6.35.4/drivers/video/ps2fb.c
--- linux-2.6.35.4-orig/drivers/video/ps2fb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/drivers/video/ps2fb.c	2014-07-18 22:29:43.570367725 +0200
@@ -0,0 +1,1580 @@
+/* Copyright 2011 - 2012 Mega Man */
+/* TBD: Unfinished state. Rework code. */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/vmalloc.h>
+#include <linux/platform_device.h>
+#include <linux/ps2/gs.h>
+
+#include <asm/page.h>
+#include <asm/cacheflush.h>
+
+#include <asm/mach-ps2/ps2.h>
+#include <asm/mach-ps2/gsfunc.h>
+#include <asm/mach-ps2/eedev.h>
+#include <asm/mach-ps2/dma.h>
+#include <asm/mach-ps2/ps2con.h>
+
+/** Bigger 1 bit color images will be devided into smaller images with the following maximum width. */
+#define PATTERN_MAX_X 16
+/** Bigger 1 bit color images will be devided into smaller images with the following maximum height. */
+#define PATTERN_MAX_Y 8
+
+/** Alignment for width in Bytes. */
+#define PS2_FBMEM_ALIGN 8
+
+/** Number of colors in palette. */
+#define PAL_COLORS 256
+
+/** Usable memory in GS. */
+#define MAXVIDEOMEMSIZE (4 * 1024 * 1024)
+
+/* ps2fb module parameters. */
+#define VESA "VESA"
+#define DTV "dtv"
+#define NTSC "NTSC"
+#define PAL "pal"
+#define VIDEOMEMEMORYSIZE "videomemsize="
+#define DEFAULTVIDEOMEMSIZE (2 * 1024 * 1024)
+
+#if 0
+#define DPRINTK(args...) ps2_printf(args)
+#else
+#define DPRINTK(args...)
+#endif
+
+static int ps2fb_init(void);
+static void ps2fb_redraw_timer_handler(unsigned long dev_addr);
+
+struct ps2fb_par
+{
+	u32 pseudo_palette[PAL_COLORS];
+	u32 opencnt;
+	int mapped;
+	struct ps2_screeninfo screeninfo;
+	int redraw_xres;
+	int redraw_yres;
+};
+
+static struct timer_list redraw_timer = {
+    function: ps2fb_redraw_timer_handler
+};
+
+static char *mode_option __devinitdata;
+static int crtmode = -1;
+static int videomemsize = DEFAULTVIDEOMEMSIZE;
+
+#define param_get_crtmode NULL
+static int param_set_crtmode(const char *val, struct kernel_param *kp)
+{
+	if (strnicmp(val, VESA, sizeof(VESA) - 1) == 0) {
+		crtmode = PS2_GS_VESA;
+	} else if (strnicmp(val, DTV, sizeof(DTV) - 1) == 0) {
+		crtmode = PS2_GS_DTV;
+	} else if (strnicmp(val, NTSC, sizeof(NTSC) - 1) == 0) {
+		crtmode = PS2_GS_NTSC;
+	} else if (strnicmp(val, PAL, sizeof(PAL) - 1) == 0) {
+		crtmode = PS2_GS_PAL;
+	}
+
+	/* TBD: Add code to support old parameter style. */
+
+	return 0;
+}
+
+#define param_check_crtmode(name, p) __param_check(name, p, void)
+
+module_param_named(crtmode, crtmode, crtmode, 0);
+MODULE_PARM_DESC(crtmode,
+	"Crtmode mode, set to '" VESA "', '" DTV "', '" NTSC "' or '" PAL "'");
+module_param(mode_option, charp, 0);
+MODULE_PARM_DESC(mode_option,
+	"Specify initial video mode as \"<xres>x<yres>[-<bpp>][@<refresh>]\"");
+module_param(videomemsize, int, 0);
+MODULE_PARM_DESC(videomemsize,
+	"Maximum memory for frame buffer mmap");
+
+/* TBD: Calculate correct timing values. */
+static const struct fb_videomode pal_modes[] = {
+	{
+		/* 640x240 @ 50 Hz, 15.625 kHz hsync (PAL RGB) */
+		NULL, 50, 640, 240, 74074, 64, 16, 39, 5, 64, 5,
+		0, FB_VMODE_NONINTERLACED
+	},
+	{
+		/* 640x480i @ 50 Hz, 15.625 kHz hsync (PAL RGB) */
+		NULL, 50, 640, 480, 74074, 64, 16, 39, 5, 64, 5,
+		0, FB_VMODE_INTERLACED
+	},
+};
+
+/* TBD: Calculate correct timing values. */
+static const struct fb_videomode ntsc_modes[] = {
+	{
+		/* 640x224 @ 60 Hz, 15.625 kHz hsync (NTSC RGB) */
+		NULL, 60, 640, 224, 74074, 64, 16, 39, 5, 64, 5,
+		0, FB_VMODE_NONINTERLACED
+	},
+	{
+		/* 640x448i @ 60 Hz, 15.625 kHz hsync (NTSC RGB) */
+		NULL, 60, 640, 448, 74074, 64, 16, 39, 5, 64, 5,
+		0, FB_VMODE_INTERLACED
+	},
+};
+
+/* TBD: Calculate correct timing values. */
+static const struct fb_videomode dtv_modes[] = {
+	{
+		/* 720x480p @ 60 Hz, 15.625 kHz hsync (DTV RGB) */
+		NULL, 60, 720, 480, 74074, 64, 16, 39, 5, 64, 5,
+		0, FB_VMODE_NONINTERLACED
+	},
+	{
+		/* 1280x720p @ 60 Hz, 15.625 kHz hsync (DTV RGB) */
+		NULL, 60, 1280, 720, 74074, 64, 16, 39, 5, 64, 5,
+		0, FB_VMODE_NONINTERLACED
+	},
+	{
+		/* 1920x1080i @ 30 Hz, 15.625 kHz hsync (DTV RGB) */
+		NULL, 30, 1920, 1080, 74074, 64, 16, 39, 5, 64, 5,
+		0, FB_VMODE_INTERLACED
+	},
+};
+
+static void *rvmalloc(unsigned long size)
+{
+	void *mem;
+	unsigned long adr;
+
+	size = PAGE_ALIGN(size);
+	mem = vmalloc_32(size);
+	if (!mem)
+		return NULL;
+
+	memset(mem, 0, size); /* Clear the ram out, no junk to the user */
+	adr = (unsigned long) mem;
+	while (size > 0) {
+		SetPageReserved(vmalloc_to_page((void *)adr));
+		adr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+
+	return mem;
+}
+
+static void rvfree(void *mem, unsigned long size)
+{
+	unsigned long adr;
+
+	if (!mem)
+		return;
+
+	adr = (unsigned long) mem;
+	while ((long) size > 0) {
+		ClearPageReserved(vmalloc_to_page((void *)adr));
+		adr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+	vfree(mem);
+}
+
+u32 colto32(struct fb_var_screeninfo *var, u32 col)
+{
+	u32 rv;
+	u32 r;
+	u32 g;
+	u32 b;
+	u32 t;
+
+	r = (col >> var->red.offset) & (0xFFFFFFFF >> (32 - var->red.length));
+	r <<= 8 - var->red.length;
+	g = (col >> var->green.offset) & (0xFFFFFFFF >> (32 - var->green.length));
+	g <<= 8 - var->green.length;
+	b = (col >> var->blue.offset) & (0xFFFFFFFF >> (32 - var->blue.length));
+	b <<= 8 - var->blue.length;
+	t = (col >> var->transp.offset) & (0xFFFFFFFF >> (32 - var->transp.length));
+	t <<= 8 - var->transp.length;
+
+	rv = (r << 0) | (g << 8) | (b << 16) | (t << 24);
+
+	return rv;
+}
+
+/**
+ *	ps2fb_open - Optional function. Called when the framebuffer is
+ *		     first accessed.
+ *	@info: frame buffer structure that represents a single frame buffer
+ *	@user: tell us if the userland (value=1) or the console is accessing
+ *	       the framebuffer. 
+ *
+ *	Returns negative errno on error, or zero on success.
+ */
+static int ps2fb_open(struct fb_info *info, int user)
+{
+    struct ps2fb_par *par = info->par;
+
+	DPRINTK("ps2fb_open: user %d\n", user);
+
+	if (user) {
+		par->opencnt++;
+	}
+    return 0;
+}
+
+/**
+ *	ps2fb_release - Optional function. Called when the framebuffer 
+ *			device is closed. 
+ *	@info: frame buffer structure that represents a single frame buffer
+ *	@user: tell us if the userland (value=1) or the console is accessing
+ *	       the framebuffer. 
+ *	
+ *	Returns negative errno on error, or zero on success.
+ */
+static int ps2fb_release(struct fb_info *info, int user)
+{
+    struct ps2fb_par *par = info->par;
+
+	DPRINTK("ps2fb_release: user %d\n", user);
+
+	if (user) {
+		par->opencnt--;
+		if (par->opencnt == 0) {
+			/* Redrawing shouldn't be needed after closing by application. */
+			del_timer(&redraw_timer);
+			par->mapped = 0;
+		}
+	}
+    return 0;
+}
+
+/**
+ * Paints a filled rectangle.
+ *
+ * Coordinate system:
+ * 0-----> x++
+ * |
+ * |
+ * |
+ * \/
+ * y++
+ * @color Color format ABGR
+ *
+ */
+static void ps2_paintrect(int sx, int sy, int width, int height, uint32_t color)
+{
+    u64 *gsp;
+    int ctx = 0;
+
+    if ((gsp = ps2con_gsp_alloc(ALIGN16(6 * 8), NULL)) == NULL) {
+		return;
+	}
+
+    *gsp++ = PS2_GIFTAG_SET_TOPHALF(1, 1, 0, 0, PS2_GIFTAG_FLG_REGLIST, 4);
+    *gsp++ = 0x5510;
+	/* PRIM */
+    *gsp++ = 0x006 + (ctx << 9);
+	/* RGBAQ */
+    *gsp++ = color;
+	/* XYZ2 */
+    *gsp++ = PACK32(sx * 16, sy * 16);
+	/* XYZ2 */
+    *gsp++ = PACK32((sx + width) * 16, (sy + height) * 16);
+
+    ps2con_gsp_send(ALIGN16(6 * 8), 0);
+}
+
+/* Convert 1bpp to 32bpp */
+static void *ps2_addpattern1_32(void *gsp, const unsigned char *data, int width, int height, uint32_t bgcolor, uint32_t fgcolor, int lineoffset)
+{
+	int y;
+	int x;
+	int offset;
+    u32 *p32;
+
+	offset = 0;
+	p32 = (u32 *) gsp;
+	for (y = 0; y < height; y++) {
+		for (x = 0; x < width; x++) {
+			u32 v;
+
+			v = data[(offset + x) / 8];
+			v >>= 7 - ((offset + x) & 7);
+			v &= 1;
+			if (v) {
+				*p32++ = fgcolor;
+			} else {
+				*p32++ = bgcolor;
+			}
+		}
+		offset += lineoffset;
+	}
+	return (void *)p32;
+}
+
+/* Convert 1bpp to 16bpp */
+static void *ps2_addpattern1_16(void *gsp, const unsigned char *data, int width, int height, uint16_t bgcolor, uint16_t fgcolor, int lineoffset)
+{
+	int y;
+	int x;
+	int offset;
+    u16 *p16;
+
+	offset = 0;
+	p16 = (u16 *) gsp;
+	for (y = 0; y < height; y++) {
+		for (x = 0; x < width; x++) {
+			u32 v;
+
+			v = data[(offset + x) / 8];
+			v >>= 7 - ((offset + x) & 7);
+			v &= 1;
+			if (v) {
+				*p16++ = fgcolor;
+			} else {
+				*p16++ = bgcolor;
+			}
+		}
+		offset += lineoffset;
+	}
+	return (void *)p16;
+}
+
+/* Paint image from data with 1 bit per pixel in 32bpp framebuffer. */
+static void ps2_paintsimg1_32(struct ps2_screeninfo *info, int sx, int sy, int width, int height, uint32_t bgcolor, uint32_t fgcolor, const unsigned char *data, int lineoffset)
+{
+    u64 *gsp;
+    void *gsp_h;
+    int gspsz; /* Available DMA packet size. */
+	int fbw = (info->w + 63) / 64;
+	unsigned int packetlen;
+
+	if ((gsp = ps2con_gsp_alloc(ALIGN16(12 * 8 + sizeof(fgcolor) * width * height), &gspsz)) == NULL) {
+		DPRINTK("Failed ps2con_gsp_alloc with w %d h %d size %lu\n", width, height, ALIGN16(12 * 8 + sizeof(fgcolor) * width * height));
+	    return;
+	}
+	gsp_h = gsp;
+
+	*gsp++ = PS2_GIFTAG_SET_TOPHALF(4, 0, 0, 0, PS2_GIFTAG_FLG_PACKED, 1);
+	*gsp++ = 0x0e;		/* A+D */
+	*gsp++ = (u64)0 | ((u64)info->fbp << 32) |
+	    ((u64)fbw << 48) | ((u64)info->psm << 56);
+	*gsp++ = PS2_GS_BITBLTBUF;
+	*gsp++ = PACK64(0, PACK32(sx, sy));
+	*gsp++ = PS2_GS_TRXPOS;
+	*gsp++ = PACK64(width, height);
+	*gsp++ = PS2_GS_TRXREG;
+	*gsp++ = 0;		/* host to local */
+	*gsp++ = PS2_GS_TRXDIR;
+
+	*gsp++ = PS2_GIFTAG_SET_TOPHALF(ALIGN16(sizeof(fgcolor) * width * height) / 16, 1, 0, 0, PS2_GIFTAG_FLG_IMAGE, 0);
+	*gsp++ = 0;
+
+	gsp = ps2_addpattern1_32(gsp, data, width, height, bgcolor, fgcolor, lineoffset);
+	packetlen = ((void *) ALIGN16(gsp)) - gsp_h;
+	ps2con_gsp_send(packetlen, 0);
+}
+
+/* Paint image from data with 1 bit per pixel in 16bpp framebuffer. */
+static void ps2_paintsimg1_16(struct ps2_screeninfo *info, int sx, int sy, int width, int height, uint16_t bgcolor, uint16_t fgcolor, const unsigned char *data, int lineoffset)
+{
+    u64 *gsp;
+    void *gsp_h;
+    int gspsz; /* Available DMA packet size. */
+	int fbw = (info->w + 63) / 64;
+	unsigned int packetlen;
+
+	if ((gsp = ps2con_gsp_alloc(ALIGN16(12 * 8 + sizeof(fgcolor) * width * height), &gspsz)) == NULL) {
+		DPRINTK("Failed ps2con_gsp_alloc with w %d h %d size %lu\n", width, height, ALIGN16(12 * 8 + sizeof(fgcolor) * width * height));
+	    return;
+	}
+	gsp_h = gsp;
+
+	*gsp++ = PS2_GIFTAG_SET_TOPHALF(4, 0, 0, 0, PS2_GIFTAG_FLG_PACKED, 1);
+	*gsp++ = 0x0e;		/* A+D */
+	*gsp++ = ((u64)0) | ((u64)info->fbp << 32) |
+	    ((u64)fbw << 48) | ((u64)info->psm << 56);
+	*gsp++ = PS2_GS_BITBLTBUF;
+	*gsp++ = PACK64(0, PACK32(sx, sy));
+	*gsp++ = PS2_GS_TRXPOS;
+	*gsp++ = PACK64(width, height);
+	*gsp++ = PS2_GS_TRXREG;
+	*gsp++ = 0;		/* host to local */
+	*gsp++ = PS2_GS_TRXDIR;
+
+	*gsp++ = PS2_GIFTAG_SET_TOPHALF(ALIGN16(sizeof(fgcolor) * width * height) / 16, 1, 0, 0, PS2_GIFTAG_FLG_IMAGE, 0);
+	*gsp++ = 0;
+
+	gsp = ps2_addpattern1_16(gsp, data, width, height, bgcolor, fgcolor, lineoffset);
+	packetlen = ((void *) ALIGN16(gsp)) - gsp_h;
+	ps2con_gsp_send(packetlen, 0);
+}
+
+/* Paint image from data with 8 bit per pixel. */
+static void *ps2_addpattern8_32(void *gsp, const unsigned char *data, int width, int height, uint32_t *palette, int lineoffset)
+{
+	int y;
+	int x;
+	int offset;
+    u32 *p32;
+
+	offset = 0;
+	p32 = (u32 *) gsp;
+	for (y = 0; y < height; y++) {
+		for (x = 0; x < width; x++) {
+			u32 v;
+
+			v = data[offset + x];
+			*p32++ = palette[v];
+		}
+		offset += lineoffset;
+	}
+	return (void *)p32;
+}
+
+/* Paint image from data with 8 bit per pixel. */
+static void *ps2_addpattern8_16(void *gsp, const unsigned char *data, int width, int height, uint32_t *palette, int lineoffset)
+{
+	int y;
+	int x;
+	int offset;
+    u16 *p16;
+
+	offset = 0;
+	p16 = (u16 *) gsp;
+	for (y = 0; y < height; y++) {
+		for (x = 0; x < width; x++) {
+			u32 v;
+
+			v = data[offset + x];
+			*p16++ = palette[v];
+		}
+		offset += lineoffset;
+	}
+	return (void *)p16;
+}
+
+/* Paint 8bpp image in 32bpp screen buffer. */
+static void ps2_paintsimg8_32(struct ps2_screeninfo *info, int sx, int sy, int width, int height, uint32_t *palette, const unsigned char *data, int lineoffset)
+{
+    u64 *gsp;
+    void *gsp_h;
+    int gspsz; /* Available size. */
+	int fbw = (info->w + 63) / 64;
+	unsigned int packetlen;
+
+	if ((gsp = ps2con_gsp_alloc(ALIGN16(12 * 8 + sizeof(palette[0]) * width * height), &gspsz)) == NULL) {
+		DPRINTK("Failed ps2con_gsp_alloc with w %d h %d size %lu\n", width, height, ALIGN16(12 * 8 + sizeof(palette[0]) * width * height));
+	    return;
+	}
+	gsp_h = gsp;
+
+	*gsp++ = PS2_GIFTAG_SET_TOPHALF(4, 0, 0, 0, PS2_GIFTAG_FLG_PACKED, 1);
+	/* A+D */
+	*gsp++ = 0x0e;
+	*gsp++ = (u64)0 | ((u64)info->fbp << 32) |
+	    ((u64)fbw << 48) | ((u64)info->psm << 56);
+	*gsp++ = PS2_GS_BITBLTBUF;
+	*gsp++ = PACK64(0, PACK32(sx, sy));
+	*gsp++ = PS2_GS_TRXPOS;
+	*gsp++ = PACK64(width, height);
+	*gsp++ = PS2_GS_TRXREG;
+	/* host to local */
+	*gsp++ = 0;
+	*gsp++ = PS2_GS_TRXDIR;
+
+	*gsp++ = PS2_GIFTAG_SET_TOPHALF(ALIGN16(sizeof(palette[0]) * width * height) / 16, 1, 0, 0, PS2_GIFTAG_FLG_IMAGE, 0);
+	*gsp++ = 0;
+
+	gsp = ps2_addpattern8_32(gsp, data, width, height, palette, lineoffset);
+	packetlen = ((void *) ALIGN16(gsp)) - gsp_h;
+	ps2con_gsp_send(packetlen, 0);
+}
+
+/* Paint 8bpp image in 16bpp screen buffer. */
+static void ps2_paintsimg8_16(struct ps2_screeninfo *info, int sx, int sy, int width, int height, uint32_t *palette, const unsigned char *data, int lineoffset)
+{
+    u64 *gsp;
+    void *gsp_h;
+    int gspsz; /* Available size. */
+	int fbw = (info->w + 63) / 64;
+	unsigned int packetlen;
+
+	if ((gsp = ps2con_gsp_alloc(ALIGN16(12 * 8 + sizeof(palette[0]) * width * height), &gspsz)) == NULL) {
+		DPRINTK("Failed ps2con_gsp_alloc with w %d h %d size %lu\n", width, height, ALIGN16(12 * 8 + sizeof(palette[0]) * width * height));
+	    return;
+	}
+	gsp_h = gsp;
+
+	*gsp++ = PS2_GIFTAG_SET_TOPHALF(4, 0, 0, 0, PS2_GIFTAG_FLG_PACKED, 1);
+	/* A+D */
+	*gsp++ = 0x0e;
+	*gsp++ = (u64)0 | ((u64)info->fbp << 32) |
+	    ((u64)fbw << 48) | ((u64)info->psm << 56);
+	*gsp++ = PS2_GS_BITBLTBUF;
+	*gsp++ = PACK64(0, PACK32(sx, sy));
+	*gsp++ = PS2_GS_TRXPOS;
+	*gsp++ = PACK64(width, height);
+	*gsp++ = PS2_GS_TRXREG;
+	/* host to local */
+	*gsp++ = 0;
+	*gsp++ = PS2_GS_TRXDIR;
+
+	*gsp++ = PS2_GIFTAG_SET_TOPHALF(ALIGN16((sizeof(palette[0]) / 2) * width * height) / 16, 1, 0, 0, PS2_GIFTAG_FLG_IMAGE, 0);
+	*gsp++ = 0;
+
+	gsp = ps2_addpattern8_16(gsp, data, width, height, palette, lineoffset);
+	packetlen = ((void *) ALIGN16(gsp)) - gsp_h;
+	ps2con_gsp_send(packetlen, 0);
+}
+
+void ps2fb_dma_send(const void *data, unsigned long len)
+{
+	unsigned long page;
+	unsigned long start;
+	unsigned long end;
+	unsigned long s;
+	unsigned long offset;
+	void *cur_start;
+	unsigned long cur_size;
+
+	/* TBD: Cache is flushed by ps2con_gsp_send, but this may change. */
+
+	start = (unsigned long) data;
+	cur_start = 0;
+	cur_size = 0;
+
+	s = start & (PAGE_SIZE - 1);
+	s = PAGE_SIZE - s;
+	if (s < PAGE_SIZE) {
+		if (s > len) {
+			s = len;
+		}
+		offset = start & (PAGE_SIZE - 1);
+		/* vmalloc_to_pfn is only working with redraw handler. */
+		cur_start = phys_to_virt(PFN_PHYS(vmalloc_to_pfn((void *) start))) + offset;
+		cur_size = ALIGN16(s);
+		start += s;
+		len -= s;
+	}
+
+	end = ALIGN16(start + len);
+
+	for (page = start; page < end; page += PAGE_SIZE) {
+		void *addr;
+		unsigned long size;
+
+		addr = phys_to_virt(PFN_PHYS(vmalloc_to_pfn((void *) page)));
+		size = end - page;
+		if (size > PAGE_SIZE) {
+			size = PAGE_SIZE;
+		}
+
+		if (cur_size > 0) {
+			if (addr == (cur_start + cur_size)) {
+				/* contigous physical memory. */
+				cur_size += size;
+			} else {
+				/* Start DMA transfer for current data. */
+				ps2sdma_send(DMA_GIF, cur_start, ALIGN16(cur_size), 0);
+
+				cur_size = size;
+				cur_start = addr;
+			}
+		} else {
+			cur_start = addr;
+			cur_size = size;
+		}
+	}
+	if (cur_size > 0) {
+		/* Start DMA transfer for current data. */
+		ps2sdma_send(DMA_GIF, cur_start, ALIGN16(cur_size), 0);
+
+		cur_size = 0;
+		cur_start = 0;
+	}
+}
+
+/**
+ *		Copy data to framebuffer on GS side.
+ *
+ *		@param info PS2 screeninfo (16 bit and 32 bit PSM is supported)
+ *		@param sx Destination X coordinate in framebuffer
+ *		@param sy Destination Y coordinate in framebuffer
+ *		@param width Width of frame
+ *		@param height Height of frame
+ *		@param data Source pointer which was allocated with rvmalloc()
+ */
+static void ps2fb_copyframe(struct ps2_screeninfo *info, int sx, int sy, int width, int height, const uint32_t *data)
+{
+    u64 *gsp;
+    void *gsp_h;
+    int gspsz; /* Available size. */
+	int fbw = (info->w + 63) / 64;
+	int bpp;
+
+	if ((gsp = ps2con_gsp_alloc(ALIGN16(12 * 8), &gspsz)) == NULL) {
+		DPRINTK("Failed ps2con_gsp_alloc\n");
+	    return;
+	}
+	/* Calculate number of bytes per pixel. */
+	switch (info->psm) {
+	case PS2_GS_PSMCT32:
+	case PS2_GS_PSMZ32:
+	case PS2_GS_PSMCT24:
+	case PS2_GS_PSMZ24:
+		bpp = 4;
+		break;
+
+	case PS2_GS_PSMCT16:
+	case PS2_GS_PSMCT16S:
+	case PS2_GS_PSMZ16:
+	case PS2_GS_PSMZ16S:
+		bpp = 2;
+		break;
+
+	case PS2_GS_PSMT8:
+	case PS2_GS_PSMT8H:
+		bpp = 1;
+		break;
+
+	default:
+		bpp = 1;
+		break;
+	}
+	gsp_h = gsp;
+
+	*gsp++ = PS2_GIFTAG_SET_TOPHALF(4, 0, 0, 0, PS2_GIFTAG_FLG_PACKED, 1);
+	/* A+D */
+	*gsp++ = 0x0e;
+	*gsp++ = (u64)0 | ((u64)info->fbp << 32) |
+	    ((u64)fbw << 48) | ((u64)info->psm << 56);
+	*gsp++ = PS2_GS_BITBLTBUF;
+	*gsp++ = PACK64(0, PACK32(sx, sy));
+	*gsp++ = PS2_GS_TRXPOS;
+	*gsp++ = PACK64(width, height);
+	*gsp++ = PS2_GS_TRXREG;
+	/* host to local */
+	*gsp++ = 0;
+	*gsp++ = PS2_GS_TRXDIR;
+
+	*gsp++ = PS2_GIFTAG_SET_TOPHALF(ALIGN16(bpp * width * height) / 16, 1, 0, 0, PS2_GIFTAG_FLG_IMAGE, 0);
+	*gsp++ = 0;
+	ps2con_gsp_send(((unsigned long) gsp) - ((unsigned long) gsp_h), 1);
+
+	ps2fb_dma_send(data, ALIGN16(bpp * width * height));
+}
+
+static void ps2fb_redraw(struct fb_info *info)
+{
+	int offset;
+	int y;
+	int maxheight;
+    struct ps2fb_par *par = info->par;
+
+	switch (par->redraw_xres) {
+		case 640:
+			maxheight = 64;
+			break;
+		case 720:
+			maxheight = 56;
+			break;
+		case 800:
+			maxheight = 50;
+			break;
+		case 1024:
+			maxheight = 40;
+			break;
+		case 1280:
+			maxheight = 32;
+			break;
+		case 1920:
+			maxheight = 20;
+			break;
+		default:
+			maxheight = 20;
+			break;
+	}
+
+	offset = ((info->var.bits_per_pixel/8) * par->redraw_xres + PS2_FBMEM_ALIGN - 1) & ~(PS2_FBMEM_ALIGN - 1);
+	for (y = 0; y < par->redraw_yres; y += maxheight) {
+		int h;
+
+		h = par->redraw_yres - y;
+		if (h > maxheight) {
+			h = maxheight;
+		}
+		ps2fb_copyframe(&par->screeninfo, 0, y, par->screeninfo.w, h, (void *) (info->fix.smem_start + y * offset));
+	}
+}
+
+static void ps2fb_redraw_timer_handler(unsigned long data)
+{
+	ps2fb_redraw((void *) data);
+	/* Redraw every 20 ms. */
+	redraw_timer.expires = jiffies + HZ / 50;
+	add_timer(&redraw_timer);
+}
+
+/**
+ *      ps2fb_check_var - Optional function. Validates a var passed in. 
+ *      @var: frame buffer variable screen structure
+ *      @info: frame buffer structure that represents a single frame buffer 
+ *
+ *	Checks to see if the hardware supports the state requested by
+ *	var passed in. This function does not alter the hardware state!!! 
+ *	This means the data stored in struct fb_info and struct ps2fb_par do 
+ *      not change. This includes the var inside of struct fb_info. 
+ *	Do NOT change these. This function can be called on its own if we
+ *	intent to only test a mode and not actually set it. The stuff in 
+ *	modedb.c is a example of this. If the var passed in is slightly 
+ *	off by what the hardware can support then we alter the var PASSED in
+ *	to what we can do.
+ *
+ *      For values that are off, this function must round them _up_ to the
+ *      next value that is supported by the hardware.  If the value is
+ *      greater than the highest value supported by the hardware, then this
+ *      function must return -EINVAL.
+ *
+ *      Exception to the above rule:  Some drivers have a fixed mode, ie,
+ *      the hardware is already set at boot up, and cannot be changed.  In
+ *      this case, it is more acceptable that this function just return
+ *      a copy of the currently working var (info->var). Better is to not
+ *      implement this function, as the upper layer will do the copying
+ *      of the current var for you.
+ *
+ *      Note:  This is the only function where the contents of var can be
+ *      freely adjusted after the driver has been registered. If you find
+ *      that you have code outside of this function that alters the content
+ *      of var, then you are doing something wrong.  Note also that the
+ *      contents of info->var must be left untouched at all times after
+ *      driver registration.
+ *
+ *	Returns negative errno on error, or zero on success.
+ */
+static int ps2fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	int res;
+
+	if (var->bits_per_pixel <= 16) {
+		var->bits_per_pixel = 16;
+	} else if (var->bits_per_pixel <= 32) {
+		var->bits_per_pixel = 32;
+	} else {
+		printk("ps2fb: %d bits per pixel are not supported.\n", var->bits_per_pixel);
+		return -EINVAL;
+	}
+	if ((var->bits_per_pixel/8 * var->xres * var->yres) > MAXVIDEOMEMSIZE) {
+		if (var->bits_per_pixel > 16) {
+			printk("ps2fb: %d bits per pixel are not supported at %dx%d.\n",
+				var->bits_per_pixel, var->xres, var->yres);
+			var->bits_per_pixel = 16;
+		}
+	}
+	if (var->bits_per_pixel == 32) {
+		var->red.offset = 0;
+		var->red.length = 8;
+		var->green.offset = 8;
+		var->green.length = 8;
+		var->blue.offset = 16;
+		var->blue.length = 8;
+		var->transp.offset = 24; /* TBD: Check, seems to be disabled. Not needed? */
+		var->transp.length = 8;
+	} else if (var->bits_per_pixel == 16) {
+		var->red.offset = 0;
+		var->red.length = 5;
+		var->green.offset = 5;
+		var->green.length = 5;
+		var->blue.offset = 10;
+		var->blue.length = 5;
+		var->transp.offset = 15; /* TBD: Check, seems to be disabled. Not needed? */
+		var->transp.length = 1;
+	} else {
+		/* TBD: Add support for 8bpp, because directfb doesn't support BGR, but 8bpp. */
+		/* TBD: Simulate 8bpp, convert on GS side. */
+		printk("ps2fb: %d bits per pixel are not supported.\n", var->bits_per_pixel);
+		return -EINVAL;
+	}
+
+	var->red.msb_right = 0;
+	var->green.msb_right = 0;
+	var->blue.msb_right = 0;
+	var->transp.msb_right = 0;
+
+	if (var->xres_virtual != var->xres) {
+		/* Resolution is not supported. */
+		printk("ps2fb: xres_virtual %d not support with xres %d\n", var->xres_virtual, var->xres);
+		var->xres_virtual = var->xres;
+	}
+
+	if (var->yres_virtual != var->yres) {
+		/* Support second screen. */
+		printk("ps2fb: yres_virtual %d not support with yres %d\n", var->yres_virtual, var->yres);
+		var->yres_virtual = var->yres;
+	}
+
+	if (var->xoffset != 0) {
+		/* Panning not supported. */
+		printk("ps2fb: xoffset %d is not supported\n", var->xoffset);
+		var->xoffset = 0;
+	}
+
+	if (var->yoffset != 0) {
+		/* TBD: Panning not supported. */
+		printk("ps2fb: yoffset %d is not supported\n", var->yoffset);
+		var->yoffset = 0;
+	}
+
+	if (var->nonstd > 3) {
+		printk("ps2fb: unsupported crtmode %d (nonstd)\n", var->nonstd);
+		return -EINVAL;
+	}
+
+	/* TBD: Should use crtmode set by set crtmode application via /dev/ps2gs */
+	res = ps2con_get_resolution(var->nonstd, var->xres, var->yres, 60 /* TBD: calculate rate. */);
+	if (res < 0) {
+		/* Resolution is not supported in this crtmode. */
+		printk("ps2fb: %dx%d is not supported in crtmode %d\n", var->xres, var->yres, var->nonstd);
+		return -EINVAL;
+	}
+
+	if (var->rotate) {
+		/* No support for rotating. */
+		printk("ps2fb: rotate is not supported.\n");
+		return -EINVAL;
+	}
+
+	/* TBD: check more parameters? */
+
+    return 0;	   	
+}
+
+static void ps2fb_switch_mode(struct fb_info *info)
+{
+    struct ps2fb_par *par = info->par;
+	int maxredrawline;
+
+	DPRINTK("ps2fb: %dx%d\n", info->var.xres, info->var.yres);
+	if (par->mapped != 0) {
+		del_timer(&redraw_timer);
+	}
+
+	/* Activate screen mode. */
+	par->screeninfo.psm = PS2_GS_PSMCT32;
+	par->screeninfo.mode = info->var.nonstd;
+	par->screeninfo.w = info->var.xres;
+	par->redraw_xres = info->var.xres;
+	par->screeninfo.h = info->var.yres;
+	par->redraw_yres = info->var.yres;
+	par->screeninfo.res = ps2con_get_resolution(par->screeninfo.mode,
+		info->var.xres, info->var.yres, 60 /* TBD: calculate rate. */);
+	if (info->var.bits_per_pixel == 16) {
+		par->screeninfo.psm = PS2_GS_PSMCT16;
+	}
+
+	DPRINTK("ps2fb: %d %s() mode %dx%d %dbpp crtmode %d res %d psm %d\n", __LINE__, __FUNCTION__, info->var.xres, info->var.yres, info->var.bits_per_pixel, par->screeninfo.mode, par->screeninfo.res, par->screeninfo.psm);
+    ps2gs_screeninfo(&par->screeninfo, NULL);
+
+	/* Clear screen (black). */
+	ps2_paintrect(0, 0, info->var.xres, info->var.yres, 0x80000000);
+
+	info->fix.line_length = (info->var.bits_per_pixel/8 * info->var.xres + PS2_FBMEM_ALIGN - 1) & ~(PS2_FBMEM_ALIGN - 1);
+	maxredrawline = videomemsize / info->fix.line_length;
+	if (maxredrawline < par->redraw_yres) {
+		/* Reserved framebuffer memory is too small. */
+		par->redraw_yres = maxredrawline;
+	}
+	DPRINTK("ps2fb: smem_start 0x%08lx\n", info->fix.smem_start);
+	DPRINTK("ps2fb: smem_len 0x%08lx\n", info->fix.smem_len);
+	DPRINTK("ps2fb: line_length 0x%08lx\n", info->fix.line_length);
+
+	if (par->mapped != 0) {
+		/* Make screen black when mapped the first time. */
+		memset((void *) info->fix.smem_start, 0, info->fix.smem_len);
+
+		/* TBD: Copy current frame buffer to memory. */
+
+		/* Restart timer for redrawing screen, because application could use mmap. */
+		redraw_timer.data = (unsigned long) info;
+   		redraw_timer.expires = jiffies + HZ / 50;
+		/* TBD: Use vbl interrupt handler instead. */
+   		add_timer(&redraw_timer);
+	}
+}
+
+/**
+ *      ps2fb_set_par - Optional function. Alters the hardware state.
+ *      @info: frame buffer structure that represents a single frame buffer
+ *
+ *	Using the fb_var_screeninfo in fb_info we set the resolution of the
+ *	this particular framebuffer. This function alters the par AND the
+ *	fb_fix_screeninfo stored in fb_info. It doesn't not alter var in 
+ *	fb_info since we are using that data. This means we depend on the
+ *	data in var inside fb_info to be supported by the hardware. 
+ *
+ *      This function is also used to recover/restore the hardware to a
+ *      known working state.
+ *
+ *	ps2fb_check_var is always called before ps2fb_set_par to ensure that
+ *      the contents of var is always valid.
+ *
+ *	Again if you can't change the resolution you don't need this function.
+ *
+ *      However, even if your hardware does not support mode changing,
+ *      a set_par might be needed to at least initialize the hardware to
+ *      a known working state, especially if it came back from another
+ *      process that also modifies the same hardware, such as X.
+ *
+ *      If this is the case, a combination such as the following should work:
+ *
+ *      static int ps2fb_check_var(struct fb_var_screeninfo *var,
+ *                                struct fb_info *info)
+ *      {
+ *              *var = info->var;
+ *              return 0;
+ *      }
+ *
+ *      static int ps2fb_set_par(struct fb_info *info)
+ *      {
+ *              init your hardware here
+ *      }
+ *
+ *	Returns negative errno on error, or zero on success.
+ */
+static int ps2fb_set_par(struct fb_info *info)
+{
+	DPRINTK("ps2fb: %d %s()\n", __LINE__, __FUNCTION__);
+
+	ps2fb_switch_mode(info);
+
+    return 0;	
+}
+
+/**
+ *  	ps2fb_setcolreg - Optional function. Sets a color register.
+ *      @regno: Which register in the CLUT we are programming 
+ *      @red: The red value which can be up to 16 bits wide 
+ *      @green: The green value which can be up to 16 bits wide 
+ *      @blue:  The blue value which can be up to 16 bits wide.
+ *      @transp: If supported, the alpha value which can be up to 16 bits wide.
+ *      @info: frame buffer info structure
+ * 
+ *  	Set a single color register. The values supplied have a 16 bit
+ *  	magnitude which needs to be scaled in this function for the hardware. 
+ *	Things to take into consideration are how many color registers, if
+ *	any, are supported with the current color visual. With truecolor mode
+ *	no color palettes are supported. Here a pseudo palette is created
+ *	which we store the value in pseudo_palette in struct fb_info. For
+ *	pseudocolor mode we have a limited color palette. To deal with this
+ *	we can program what color is displayed for a particular pixel value.
+ *	DirectColor is similar in that we can program each color field. If
+ *	we have a static colormap we don't need to implement this function. 
+ * 
+ *	Returns negative errno on error, or zero on success.
+ */
+static int ps2fb_setcolreg(unsigned regno, unsigned red, unsigned green,
+			   unsigned blue, unsigned transp,
+			   struct fb_info *info)
+{
+	struct fb_var_screeninfo *var;
+	u32 *reg;
+
+    if (regno >= PAL_COLORS)  /* no. of hw registers */
+       return -EINVAL;
+
+	var = &info->var;
+	reg = info->pseudo_palette;
+
+	red >>= 16 - var->red.length;
+	green >>= 16 - var->green.length;
+	blue >>= 16 - var->blue.length;
+	transp >>= 16 - var->transp.length;
+
+	reg[regno] =
+		red << var->red.offset |
+		green << var->green.offset |
+		blue << var->blue.offset |
+		transp << var->transp.offset;
+
+	DPRINTK("ps2fb: %d %s() reg %d = 0x%08x r 0x%02x g 0x%02x b 0x%02x\n", __LINE__, __FUNCTION__, regno, ((u32 *) (info->pseudo_palette))[regno], red, green, blue);
+    return 0;
+}
+
+#if 0 /* TBD: Implement functions. */
+ssize_t ps2fb_read(struct fb_info *info, char __user *buf,
+			   size_t count, loff_t *ppos)
+{
+	DPRINTK("ps2fb: %d %s()\n", __LINE__, __FUNCTION__);
+	/* TBD: implement reading of framebuffer. */
+	return count;
+}
+
+ssize_t ps2fb_write(struct fb_info *info, const char __user *buf,
+			    size_t count, loff_t *ppos)
+{
+	DPRINTK("ps2fb: %d %s()\n", __LINE__, __FUNCTION__);
+	/* TBD: implement writing of framebuffer. */
+	return count;
+}
+
+/**
+ *      ps2fb_blank - NOT a required function. Blanks the display.
+ *      @blank_mode: the blank mode we want. 
+ *      @info: frame buffer structure that represents a single frame buffer
+ *
+ *      Blank the screen if blank_mode != FB_BLANK_UNBLANK, else unblank.
+ *      Return 0 if blanking succeeded, != 0 if un-/blanking failed due to
+ *      e.g. a video mode which doesn't support it.
+ *
+ *      Implements VESA suspend and powerdown modes on hardware that supports
+ *      disabling hsync/vsync:
+ *
+ *      FB_BLANK_NORMAL = display is blanked, syncs are on.
+ *      FB_BLANK_HSYNC_SUSPEND = hsync off
+ *      FB_BLANK_VSYNC_SUSPEND = vsync off
+ *      FB_BLANK_POWERDOWN =  hsync and vsync off
+ *
+ *      If implementing this function, at least support FB_BLANK_UNBLANK.
+ *      Return !0 for any modes that are unimplemented.
+ *
+ */
+static int ps2fb_blank(int blank_mode, struct fb_info *info)
+{
+	DPRINTK("ps2fb: %d %s()\n", __LINE__, __FUNCTION__);
+    /* ... */
+    return 0;
+}
+
+/**
+ *	ps2fb_sync - NOT a required function. Normally the accel engine 
+ *		     for a graphics card take a specific amount of time.
+ *		     Often we have to wait for the accelerator to finish
+ *		     its operation before we can write to the framebuffer
+ *		     so we can have consistent display output. 
+ *
+ *      @info: frame buffer structure that represents a single frame buffer
+ *
+ *      If the driver has implemented its own hardware-based drawing function,
+ *      implementing this function is highly recommended.
+ */
+int ps2fb_sync(struct fb_info *info)
+{
+	DPRINTK("ps2fb: %d %s()\n", __LINE__, __FUNCTION__);
+	return 0;
+}
+#endif
+
+/**
+ *      ps2fb_fillrect - REQUIRED function. Can use generic routines if 
+ *		 	 non acclerated hardware and packed pixel based.
+ *			 Draws a rectangle on the screen.		
+ *
+ *      @info: frame buffer structure that represents a single frame buffer
+ *    @region: The structure representing the rectangular region we 
+ *		 wish to draw to.
+ *
+ *	This drawing operation places/removes a retangle on the screen 
+ *	depending on the rastering operation with the value of color which
+ *	is in the current color depth format.
+ */
+void ps2fb_fillrect(struct fb_info *p, const struct fb_fillrect *region)
+{
+	uint32_t color;
+
+	if (region->rop != ROP_COPY) {
+		printk("ps2fb: %d %s() dx %d dy %d w %d h %d col 0x%08x unsupported rop\n", __LINE__, __FUNCTION__,
+			region->dx,
+			region->dy,
+			region->width,
+			region->height,
+			region->color);
+		/* TBD: handle region->rop ROP_COPY or ROP_XOR */
+		return;
+	}
+
+	if (p->fix.visual == FB_VISUAL_TRUECOLOR ||
+	    p->fix.visual == FB_VISUAL_DIRECTCOLOR ) {
+		color = ((u32*)(p->pseudo_palette))[region->color];
+	} else {
+		color = region->color;
+	}
+	ps2_paintrect(region->dx, region->dy,
+		region->width, region->height, colto32(&p->var, color));
+}
+
+/**
+ *      ps2fb_copyarea - REQUIRED function.
+ *
+ *      @info: frame buffer structure that represents a single frame buffer
+ *      @area: Structure providing the data to copy the framebuffer contents
+ *	       from one region to another.
+ *
+ *      This drawing operation copies a rectangular area from one area of the
+ *		screen to another area.
+ */
+void ps2fb_copyarea(struct fb_info *info, const struct fb_copyarea *area) 
+{
+	struct ps2fb_par *par = info->par;
+	u64 *gsp;
+	int fbw = (par->screeninfo.w + 63) / 64;
+	
+	DPRINTK("ps2fb: %d %s()\n", __LINE__, __FUNCTION__);
+	
+	if ((gsp = ps2con_gsp_alloc(ALIGN16(10 * 8), NULL)) == NULL) {
+		printk("ps2fb: ps2con_gsp_alloc() failed in ps2con_bmove().\n");
+		return;
+	}
+	
+	*gsp++ = PS2_GIFTAG_SET_TOPHALF(4, 1, 0, 0, PS2_GIFTAG_FLG_PACKED, 1);
+	/* A+D */
+	*gsp++ = 0x0e;
+	*gsp++ = (u64)par->screeninfo.fbp |
+	((u64)fbw << 16) | ((u64)par->screeninfo.psm << 24) |
+	((u64)par->screeninfo.fbp << 32) |
+	((u64)fbw << 48) | ((u64)par->screeninfo.psm << 56);
+	*gsp++ = PS2_GS_BITBLTBUF;
+
+	if (area->sy > area->dy || (area->sy == area->dy && area->sx > area->dx)) {
+		/* copy region LT -> RB */
+		*gsp++ = PACK64(PACK32(area->sx, area->sy),
+		PACK32(area->dx, area->dy) + (0 << 27));
+	} else {
+		/* copy region RB -> LT */
+		*gsp++ = PACK64(PACK32(area->sx, area->sy),
+			PACK32(area->dx, area->dy) + (3 << 27));
+	}
+	
+	*gsp++ = PS2_GS_TRXPOS;
+	*gsp++ = PACK64(area->width, area->height);
+	*gsp++ = PS2_GS_TRXREG;
+	/* local to local */
+	*gsp++ = 2;
+	*gsp++ = PS2_GS_TRXDIR;
+	
+	ps2con_gsp_send(ALIGN16(10 * 8), 0);
+}
+
+/**
+ *      ps2fb_imageblit - REQUIRED function.
+ *
+ *		@info: frame buffer structure that represents a single frame buffer
+ *		@image:	structure defining the image.
+ *
+ *      This drawing operation draws a image on the screen. It can be a 
+ *		mono image (needed for font handling) or a color image (needed for
+ *		tux). 
+ */
+void ps2fb_imageblit(struct fb_info *info, const struct fb_image *image) 
+{
+    struct ps2fb_par *par = info->par;
+
+	if (image->depth == 1) {
+		int x;
+		int y;
+		int offset;
+		uint32_t fgcolor;
+		uint32_t bgcolor;
+
+		fgcolor = ((u32*)(info->pseudo_palette))[image->fg_color];
+		bgcolor = ((u32*)(info->pseudo_palette))[image->bg_color];
+		offset = (image->width + 7) & ~7;
+		for (x = 0; x < image->width; x += PATTERN_MAX_X)
+		{
+			int w;
+
+			w = image->width - x;
+			if (w > PATTERN_MAX_X) {
+				w = PATTERN_MAX_X;
+			}
+			for (y = 0; y < image->height; y += PATTERN_MAX_Y)
+			{
+				int h;
+
+				h = image->height - y;
+				if (h > PATTERN_MAX_Y) {
+					h = PATTERN_MAX_Y;
+				}
+				if (par->screeninfo.psm == PS2_GS_PSMCT32) {
+					ps2_paintsimg1_32(&par->screeninfo, image->dx + x, image->dy + y, w, h,
+						bgcolor, fgcolor, image->data + (x + y * offset) / 8,
+						offset);
+				} else if (par->screeninfo.psm == PS2_GS_PSMCT16) {
+					ps2_paintsimg1_16(&par->screeninfo, image->dx + x, image->dy + y, w, h,
+						bgcolor, fgcolor, image->data + (x + y * offset) / 8,
+						offset);
+				} else {
+					printk("ps2fb: PSM %d is not supported.\n", par->screeninfo.psm);
+				}
+			}
+		}
+	} else if (image->depth == 8) {
+		int x;
+		int y;
+		int offset;
+
+		offset = image->width;
+		for (x = 0; x < image->width; x += PATTERN_MAX_X)
+		{
+			int w;
+
+			w = image->width - x;
+			if (w > PATTERN_MAX_X) {
+				w = PATTERN_MAX_X;
+			}
+			for (y = 0; y < image->height; y += PATTERN_MAX_Y)
+			{
+				int h;
+
+				h = image->height - y;
+				if (h > PATTERN_MAX_Y) {
+					h = PATTERN_MAX_Y;
+				}
+				if (par->screeninfo.psm == PS2_GS_PSMCT32) {
+					ps2_paintsimg8_32(&par->screeninfo, image->dx + x, image->dy + y, w, h,
+						info->pseudo_palette, image->data + x + y * offset,
+						offset);
+				} else if (par->screeninfo.psm == PS2_GS_PSMCT16) {
+					ps2_paintsimg8_16(&par->screeninfo, image->dx + x, image->dy + y, w, h,
+						info->pseudo_palette, image->data + x + y * offset,
+						offset);
+				} else {
+					printk("ps2fb: PSM %d is not supported.\n", par->screeninfo.psm);
+				}
+			}
+		}
+	} else {
+		printk("ps2fb: blit depth %d dx %d dy %d w %d h %d 0x%08x\n",
+		image->depth,
+		image->dx,
+		image->dy,
+		image->width,
+		image->height,
+		(unsigned int)image->data);
+		/* TBD: Implement other color depths in ps2fb_imageblit()? */
+	}
+}
+
+static int ps2fb_mmap(struct fb_info *info,
+		    struct vm_area_struct *vma)
+{
+	unsigned long start = vma->vm_start;
+	unsigned long size = vma->vm_end - vma->vm_start;
+	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+	unsigned long page, pos;
+    struct ps2fb_par *par = info->par;
+
+	if (offset + size > info->fix.smem_len) {
+		return -EINVAL;
+	}
+
+	if ((info->fix.smem_start == 0) && (info->fix.smem_len > 0)) {
+		/* Memory is allocated on first call to mmap. */
+		/* This will save memory until framebuffer is used. */
+		info->fix.smem_start = (unsigned long) rvmalloc(info->fix.smem_len);
+	}
+
+	if (info->fix.smem_start == 0) {
+		printk("ps2fb: Failed to allocate frame buffer (%d Bytes).\n", info->fix.smem_len);
+		return -ENOMEM;
+	}
+
+	pos = (unsigned long)info->fix.smem_start + offset;
+	/* Framebuffer can't be mapped. Map normal memory instead
+	 * and copy every 20ms the data from memory to the
+	 * framebuffer. Currently there is no other way beside
+	 * mapping to access the framebuffer from applications
+	 * like xorg.
+	 */
+
+	while (size > 0) {
+		page = vmalloc_to_pfn((void *)pos);
+		if (remap_pfn_range(vma, start, page, PAGE_SIZE, PAGE_SHARED)) {
+			return -EAGAIN;
+		}
+		start += PAGE_SIZE;
+		pos += PAGE_SIZE;
+		if (size > PAGE_SIZE)
+			size -= PAGE_SIZE;
+		else
+			size = 0;
+	}
+
+	vma->vm_flags |= VM_RESERVED;	/* avoid to swap out this VMA */
+
+	if (par->mapped == 0) {
+		par->mapped = 1;
+
+		/* Make screen black when mapped the first time. */
+		memset((void *) info->fix.smem_start, 0, info->fix.smem_len);
+
+		/* TBD: Copy current frame buffer to memory. */
+
+		/* Start timer for redrawing screen, because application could use mmap. */
+		redraw_timer.data = (unsigned long) info;
+   		redraw_timer.expires = jiffies + HZ / 50;
+		/* TBD: Use vbl interrupt handler instead. */
+   		add_timer(&redraw_timer);
+	}
+	return 0;
+}
+
+static struct fb_ops ps2fb_ops = {
+	.owner		= THIS_MODULE,
+	.fb_open = ps2fb_open,
+	.fb_release = ps2fb_release,
+#if 0 /* TBD: Implement functions. */
+	.fb_read = ps2fb_read,
+	.fb_write = ps2fb_write,
+	.fb_blank = ps2fb_blank,
+	.fb_sync = ps2fb_sync,
+	/** TBD: .fb_ioctl = ps2fb_ioctl, */
+#endif
+	.fb_check_var = ps2fb_check_var,
+	.fb_set_par = ps2fb_set_par,
+	.fb_setcolreg = ps2fb_setcolreg,
+	.fb_fillrect = ps2fb_fillrect,
+	.fb_copyarea = ps2fb_copyarea,
+	.fb_imageblit = ps2fb_imageblit,
+	.fb_mmap = ps2fb_mmap,
+};
+
+
+
+static int __devinit ps2fb_probe(struct platform_device *pdev)
+{
+    struct fb_info *info;
+    struct ps2fb_par *par;
+    struct device *device = &pdev->dev; /* or &pdev->dev */
+    int cmap_len, retval;	
+
+	/* TBD: move to other function? */
+	ps2con_gsp_init();
+   
+	DPRINTK("ps2fb: %d %s()\n", __LINE__, __FUNCTION__);
+
+    /*
+     * Dynamically allocate info and par
+     */
+    info = framebuffer_alloc(sizeof(struct ps2fb_par), device);
+
+    if (!info) {
+		return -ENOMEM;
+    }
+
+    /* 
+     * Here we set the screen_base to the virtual memory address
+     * for the framebuffer. Usually we obtain the resource address
+     * from the bus layer and then translate it to virtual memory
+     * space via ioremap. Consult ioport.h. 
+     */
+    info->screen_base = NULL; /* TBD: framebuffer_virtual_memory; */
+    info->fbops = &ps2fb_ops;
+
+	strcpy(info->fix.id, "PS2 GS");
+	info->fix.type = FB_TYPE_PACKED_PIXELS;
+	info->fix.visual = FB_VISUAL_TRUECOLOR; /* TBD: FB_VISUAL_PSEUDOCOLOR, */
+	info->fix.xpanstep = 1;
+	info->fix.ypanstep = 1; // TBD: Add suport for second screen.
+	info->fix.ywrapstep = 1 ;
+	info->fix.accel = FB_ACCEL_NONE; /* TBD: Check if something is possible. */
+
+
+    par = info->par;
+	info->pseudo_palette = par->pseudo_palette;
+	par->opencnt = 0;
+
+    ps2con_initinfo(&par->screeninfo);
+	if ((crtmode < 0) || (crtmode > 3)) {
+		/* Set default to old crtmode parameter. */
+		info->var.nonstd = par->screeninfo.mode;
+	} else {
+	    info->var.nonstd = crtmode;
+	}
+
+
+    /*
+     * Set up flags to indicate what sort of acceleration your
+     * driver can provide (pan/wrap/copyarea/etc.) and whether it
+     * is a module -- see FBINFO_* in include/linux/fb.h
+     *
+     * If your hardware can support any of the hardware accelerated functions
+     * fbcon performance will improve if info->flags is set properly.
+     *
+     * FBINFO_HWACCEL_COPYAREA - hardware moves
+     * FBINFO_HWACCEL_FILLRECT - hardware fills
+     * FBINFO_HWACCEL_IMAGEBLIT - hardware mono->color expansion
+     * FBINFO_HWACCEL_YPAN - hardware can pan display in y-axis
+     * FBINFO_HWACCEL_YWRAP - hardware can wrap display in y-axis
+     * FBINFO_HWACCEL_DISABLED - supports hardware accels, but disabled
+     * FBINFO_READS_FAST - if set, prefer moves over mono->color expansion
+     * FBINFO_MISC_TILEBLITTING - hardware can do tile blits
+     *
+     * NOTE: These are for fbcon use only.
+     */
+    info->flags = FBINFO_DEFAULT
+		| FBINFO_HWACCEL_COPYAREA
+		| FBINFO_HWACCEL_FILLRECT
+		| FBINFO_HWACCEL_IMAGEBLIT;
+	/* TBD: Support FBINFO_HWACCEL_YPAN or FBINFO_HWACCEL_YWRAP some applications need this. */
+
+    /*
+     * This should give a reasonable default video mode. The following is
+     * done when we can set a video mode. 
+     */
+	switch (info->var.nonstd) {
+	case PS2_GS_PAL:
+		retval = fb_find_mode(&info->var, info, mode_option, pal_modes, ARRAY_SIZE(pal_modes), NULL, 32);
+		break;
+	case PS2_GS_NTSC:
+		retval = fb_find_mode(&info->var, info, mode_option, ntsc_modes, ARRAY_SIZE(ntsc_modes), NULL, 32);
+		break;
+	case PS2_GS_DTV:
+		retval = fb_find_mode(&info->var, info, mode_option, dtv_modes, ARRAY_SIZE(dtv_modes), NULL, 32);
+		break;
+	case PS2_GS_VESA:
+		retval = fb_find_mode(&info->var, info, mode_option, NULL, 0, NULL, 32);
+		break;
+	default:
+		printk("ps2fb: unknown crtmode %d\n", info->var.nonstd);
+		retval = fb_find_mode(&info->var, info, mode_option, NULL, 0, NULL, 32);
+		break;
+	}
+	DPRINTK("ps2fb: fb_find_mode retval = %d\n", retval);
+	DPRINTK("ps2fb: mode_option %s %dx%d\n", mode_option, info->var.xres, info->var.yres);
+  
+	if (!retval)
+		return -EINVAL;			
+
+	if (videomemsize > 0) {
+		info->fix.smem_len = videomemsize;
+	} else {
+		info->fix.smem_len = 0;
+	}
+	info->fix.smem_start = 0;
+	ps2fb_switch_mode(info);
+
+    /* This has to be done! */
+	cmap_len = PAL_COLORS;
+    if (fb_alloc_cmap(&info->cmap, cmap_len, 0))
+	return -ENOMEM;
+
+	if (register_framebuffer(info) < 0) {
+		fb_dealloc_cmap(&info->cmap);
+		return -EINVAL;
+	}
+	DPRINTK(KERN_INFO "fb%d: %s frame buffer device\n", info->node,
+		info->fix.id);
+	platform_set_drvdata(pdev, info);
+
+    init_timer(&redraw_timer);
+
+    return 0;
+}
+
+static int __devexit ps2fb_remove(struct platform_device *pdev)
+{
+	struct fb_info *info = platform_get_drvdata(pdev);
+
+	DPRINTK("ps2fb: %d %s()\n", __LINE__, __FUNCTION__);
+	if (info) {
+		if (info->fix.smem_start != 0) {
+			rvfree((void *) info->fix.smem_start, info->fix.smem_len);
+			info->fix.smem_start = 0;
+		}
+		info->fix.smem_len = 0;
+		unregister_framebuffer(info);
+		fb_dealloc_cmap(&info->cmap);
+		framebuffer_release(info);
+	}
+	return 0;
+}
+
+static struct platform_driver ps2fb_driver = {
+	.probe = ps2fb_probe,
+	.remove = __devexit_p(ps2fb_remove),
+	.driver = {
+		.name = "ps2fb",
+	},
+};
+
+#ifndef MODULE
+/*
+ * Only necessary if your driver takes special options,
+ * otherwise we fall back on the generic fb_setup().
+ */
+int __init ps2fb_setup(char *options)
+{
+	char *this_opt;
+
+	DPRINTK("ps2fb: %d %s()\n", __LINE__, __FUNCTION__);
+
+	if (!options || !*options)
+		return 0;
+
+    /* Parse user speficied options (`video=ps2fb:') */
+	while ((this_opt = strsep(&options, ",")) != NULL) {
+		if (!*this_opt) continue;
+
+		if (strnicmp(this_opt, VESA, sizeof(VESA) - 1) == 0) {
+			crtmode = PS2_GS_VESA;
+		} else if (strnicmp(this_opt, DTV, sizeof(DTV) - 1) == 0) {
+			crtmode = PS2_GS_DTV;
+		} else if (strnicmp(this_opt, NTSC, sizeof(NTSC) - 1) == 0) {
+			crtmode = PS2_GS_NTSC;
+		} else if (strnicmp(this_opt, PAL, sizeof(PAL) - 1) == 0) {
+			crtmode = PS2_GS_PAL;
+		} else if (strnicmp(this_opt, VIDEOMEMEMORYSIZE, sizeof(VIDEOMEMEMORYSIZE) - 1) == 0) {
+			videomemsize = simple_strtoul(this_opt + sizeof(VIDEOMEMEMORYSIZE) - 1, NULL, 10);
+		} else if (this_opt[0] >= '0' && this_opt[0] <= '9') {
+			mode_option = this_opt;
+		} else {
+			printk(KERN_WARNING
+				"ps2fb: unrecognized option %s\n", this_opt);
+		}
+	}
+	return 0;
+}
+#endif /* MODULE */
+
+static int __init ps2fb_init(void)
+{
+	int ret;
+	/*
+	 *  For kernel boot options (in 'video=ps2fb:<options>' format)
+	 */
+#ifndef MODULE
+	char *option = NULL;
+
+	DPRINTK("ps2fb: %d %s()\n", __LINE__, __FUNCTION__);
+
+	if (fb_get_options("ps2fb", &option))
+		return -ENODEV;
+	ps2fb_setup(option);
+#else
+	DPRINTK("ps2fb: %d %s()\n", __LINE__, __FUNCTION__);
+#endif
+
+	ret = platform_driver_register(&ps2fb_driver);
+	DPRINTK("ps2fb: %d %s() ret = %d\n", __LINE__, __FUNCTION__, ret);
+
+	return ret;
+}
+
+static void __exit ps2fb_exit(void)
+{
+	DPRINTK("ps2fb: %d %s()\n", __LINE__, __FUNCTION__);
+	platform_driver_unregister(&ps2fb_driver);
+}
+
+/* ------------------------------------------------------------------------- */
+
+module_init(ps2fb_init);
+module_exit(ps2fb_exit);
+
+MODULE_LICENSE("GPL");
diff -purN linux-2.6.35.4-orig/fs/partitions/check.c linux-2.6.35.4/fs/partitions/check.c
--- linux-2.6.35.4-orig/fs/partitions/check.c	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/fs/partitions/check.c	2014-07-18 22:29:43.570367725 +0200
@@ -38,6 +38,7 @@
 #include "efi.h"
 #include "karma.h"
 #include "sysv68.h"
+#include "ps2.h"
 
 #ifdef CONFIG_BLK_DEV_MD
 extern void md_autodetect_dev(dev_t dev);
@@ -112,6 +113,9 @@ static int (*check_part[])(struct parsed
 #ifdef CONFIG_SYSV68_PARTITION
 	sysv68_partition,
 #endif
+#ifdef CONFIG_PS2_PARTITION
+	ps2_partition,
+#endif
 	NULL
 };
  
diff -purN linux-2.6.35.4-orig/fs/partitions/Kconfig linux-2.6.35.4/fs/partitions/Kconfig
--- linux-2.6.35.4-orig/fs/partitions/Kconfig	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/fs/partitions/Kconfig	2014-07-18 22:29:43.570367725 +0200
@@ -249,3 +249,29 @@ config SYSV68_PARTITION
 	  partition table format used by Motorola Delta machines (using
 	  sysv68).
 	  Otherwise, say N.
+
+config PS2_PARTITION
+	bool "PS2 APA partition support" if PARTITION_ADVANCED
+	default y if SONY_PS2
+	help
+	  Support hard disks partitioned on Playstation 2 (APA).
+
+config PS2_PARTITION_SPLIT
+	bool "Show splitted partitions" if PS2_PARTITION
+	default n
+	help
+	  Larger Playstation 2 partitions may be splitted into several parts
+	  over the hard disc. Linux doesn't support merging the splitted parts.
+	  Therefore you will not have a device node for these partitions.
+	  You should use the program apascan to access it.
+	  If you enable this option you will also see the splitted parts.
+	  The splitted parts can be used in conjunction with the device mapper,
+	  but this is incompatible with apascan and the old PS2 Linux.
+
+config PS2_PARTITION_ALL
+	bool "Show all PS2 partitions" if PS2_PARTITION_SPLIT
+	default n
+	help
+	  By default there only partitions accessible which are created with
+	  ps2fdisk. This option will enable other partitions used by games.
+	  This is not recommended.
diff -purN linux-2.6.35.4-orig/fs/partitions/Makefile linux-2.6.35.4/fs/partitions/Makefile
--- linux-2.6.35.4-orig/fs/partitions/Makefile	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/fs/partitions/Makefile	2014-07-18 22:29:43.570367725 +0200
@@ -18,3 +18,4 @@ obj-$(CONFIG_IBM_PARTITION) += ibm.o
 obj-$(CONFIG_EFI_PARTITION) += efi.o
 obj-$(CONFIG_KARMA_PARTITION) += karma.o
 obj-$(CONFIG_SYSV68_PARTITION) += sysv68.o
+obj-$(CONFIG_PS2_PARTITION) += ps2.o
diff -purN linux-2.6.35.4-orig/fs/partitions/ps2.c linux-2.6.35.4/fs/partitions/ps2.c
--- linux-2.6.35.4-orig/fs/partitions/ps2.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/fs/partitions/ps2.c	2014-07-18 22:29:43.570367725 +0200
@@ -0,0 +1,137 @@
+/*
+ *  fs/partitions/ps2.c
+ *  support for PlayStation 2 partition(APA) 
+ *
+ *        Copyright (C) 2002  Sony Computer Entertainment Inc.
+ *        Copyright (C) 2013  Mega Man
+ *
+ *  This file is subject to the terms and conditions of the GNU General
+ *  Public License Version 2. See the file "COPYING" in the main
+ *  directory of this archive for more details.
+ *
+ * $Id: ps2.c,v 1.1 2013/07/01 16:53:17 kloader Exp $
+ */
+
+
+#include "check.h"
+#include "ps2.h"
+
+static int ps2_partition_one(struct parsed_partitions *state,
+			     struct ps2_partition *pp, int resv_m, int resv_s,
+			     int *slot)
+{
+	int i;
+#ifndef CONFIG_PS2_PARTITION_SPLIT
+	int pno;
+	char *p;
+	char *pe;
+#endif
+
+	if (le32_to_cpu(pp->magic) != PS2_PARTITION_MAGIC)
+		return 0;
+
+	if ((le16_to_cpu(pp->flag) & PS2_PART_FLAG_SUB) != 0)
+		return 1;
+
+	if (pp->id[0] == '\0' || pp->id[1] == '\0'
+#ifndef CONFIG_PS2_PARTITION_ALL
+		|| strncmp((char*)(&pp->id), PS2_LINUX_ID, strlen(PS2_LINUX_ID)) != 0
+#endif
+		) {
+#if 0
+		if (strnlen(pp->id, PS2_PART_NID) < PS2_PART_NID) {
+			printk("Ignoring PS2 partition '%s'.\n", pp->id);
+		}
+#endif
+		/* not PS2 Linux partition */
+		return 1;
+	}
+
+#ifndef CONFIG_PS2_PARTITION_SPLIT
+	/* PS2 Linux partition */
+	p = &pp->id[strlen(PS2_LINUX_ID)];
+
+	pe = &pp->id[PS2_PART_NID];
+
+	pno = 0;
+	while (p < pe && *p >= '0' && *p <= '9')
+		pno = pno * 10 + (*p++ - '0');
+	if (pno == 0)
+		pno = 1;
+	if (pno < 1 || pno > state->limit - 1)
+		return 1;
+
+	*slot = pno;
+	/* Add only partitions which are complete. */
+	/* TBD: The other partitions should be merged.  */
+	if (le32_to_cpu(pp->nsub) == 0) {
+		put_partition(state, *slot, le32_to_cpu(pp->start) + resv_m,
+			le32_to_cpu(pp->nsector) - resv_m);
+	}
+#else
+	put_partition(state, *slot, le32_to_cpu(pp->start) + resv_m,
+		le32_to_cpu(pp->nsector) - resv_m);
+	if (le32_to_cpu(pp->nsub) != 0) {
+		/* The device mapper must be used to merge the partitions. */
+		state->parts[*slot].flags = ADDPART_FLAG_RAID;
+		printk(" %s [1 of %d]\n", pp->id, pp->nsub + 1);
+	} else {
+		printk(" %s [complete]\n", pp->id);
+	}
+	(*slot)++;
+	for (i = 0; i < le32_to_cpu(pp->nsub); i++) {
+		put_partition(state, *slot, le32_to_cpu(pp->subs[i].start) + resv_s,
+			le32_to_cpu(pp->subs[i].nsector) - resv_s);
+		printk(" %s [%d of %d]\n", pp->id, i + 2, pp->nsub + 1);
+		state->parts[*slot].flags = ADDPART_FLAG_RAID;
+		(*slot)++;
+	}
+#endif
+
+	return 1;
+}
+
+int ps2_partition(struct parsed_partitions *state)
+{
+	struct block_device *bdev = state->bdev;
+	int resv_m;
+	int resv_s;
+	struct ps2_partition *pp;
+	sector_t sector;
+	unsigned char *data;
+	Sector sect;
+	int slot;
+
+	resv_m = PS2_PART_RESV_MAIN / bdev_logical_block_size(bdev);
+	if (resv_m == 0)
+		resv_m = 1;
+	resv_s = PS2_PART_RESV_SUB / bdev_logical_block_size(bdev);
+	if (resv_s == 0)
+		resv_s = 1;
+
+	sector = 0;
+	slot = 1;
+	do {
+		data = read_part_sector(state, sector, &sect);
+		if (!data) {
+			return -1;
+		}
+
+		pp = (struct ps2_partition *) data;
+		if (sector == 0) {
+			if (memcmp(pp->mbr.magic, PS2_MBR_MAGIC, 32) != 0 ||
+			    le32_to_cpu(pp->mbr.version) > PS2_MBR_VERSION) {
+				put_dev_sector(sect);
+				return 0;
+			}
+		}
+		if (!ps2_partition_one(state, pp, resv_m, resv_s, &slot)) {
+			put_dev_sector(sect);
+			break;
+		}
+		sector = le32_to_cpu(pp->next);
+		put_dev_sector(sect);
+	} while (sector != 0);
+
+	return 1;
+}
diff -purN linux-2.6.35.4-orig/fs/partitions/ps2.h linux-2.6.35.4/fs/partitions/ps2.h
--- linux-2.6.35.4-orig/fs/partitions/ps2.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/fs/partitions/ps2.h	2014-07-18 22:29:43.570367725 +0200
@@ -0,0 +1,68 @@
+/*
+ *  fs/partitions/ps2.h
+ *  support for PlayStation 2 partition(APA) 
+ *
+ *        Copyright (C) 2002  Sony Computer Entertainment Inc.
+ *
+ *  This file is subject to the terms and conditions of the GNU General
+ *  Public License Version 2. See the file "COPYING" in the main
+ *  directory of this archive for more details.
+ *
+ * $Id: ps2.h,v 1.1 2013/07/01 16:53:17 kloader Exp $
+ */
+
+
+#define PS2_SEGMENT_HASH_ENTRIES	16
+
+#define PS2_PARTITION_MAGIC	0x00415041
+#define PS2_MBR_VERSION		0x00000002
+#define PS2_MBR_MAGIC		"Sony Computer Entertainment Inc."
+
+#define PS2_PART_NID		32
+#define PS2_PART_NPASSWD	8
+#define PS2_PART_NNAME		128
+#define PS2_PART_MAXSUB		64
+#define PS2_PART_MAXSUB_SHIFT	6
+
+#define PS2_PART_FLAG_SUB	0x0001
+
+#define PS2_PART_RESV_MAIN	(4 * 1024 * 1024)
+#define PS2_PART_RESV_SUB	(4 * 1024)
+
+struct ps2_partition {
+	__u32	sum;
+	__u32	magic;
+	__u32	next;
+	__u32	prev;
+	char	id[PS2_PART_NID];
+	char	rpwd[PS2_PART_NPASSWD];
+	char	fpwd[PS2_PART_NPASSWD];
+	__u32	start;
+	__u32	nsector;
+	__u16	fstype;
+	__u16	flag;
+	__u32	nsub;
+	char	date[8];
+	__u32	main;
+	__u32	number;
+	__u32	modver;
+	__u32	rsvd[7];
+	char	name[PS2_PART_NNAME];
+	struct ps2_mbr {
+		char	magic[32];
+		__u32	version;
+		__u32	nsector;
+		char	date[8];
+		__u32	osd_start;
+		__u32	osd_count;
+		char	rsvd[200];
+	} mbr;
+	struct ps2_subpart {
+		__u32	start;
+		__u32	nsector;
+	} subs[PS2_PART_MAXSUB];
+};
+
+#define PS2_LINUX_ID		"__linux."
+
+int ps2_partition(struct parsed_partitions *state);
diff -purN linux-2.6.35.4-orig/include/linux/Kbuild linux-2.6.35.4/include/linux/Kbuild
--- linux-2.6.35.4-orig/include/linux/Kbuild	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/include/linux/Kbuild	2014-07-18 22:29:43.574367725 +0200
@@ -390,3 +390,4 @@ unifdef-y += xfrm.h
 objhdr-y += version.h
 header-y += wimax.h
 header-y += wimax/
+header-y += ps2/
diff -purN linux-2.6.35.4-orig/include/linux/major.h linux-2.6.35.4/include/linux/major.h
--- linux-2.6.35.4-orig/include/linux/major.h	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/include/linux/major.h	2014-07-18 22:29:43.574367725 +0200
@@ -171,6 +171,17 @@
 
 #define VIOTAPE_MAJOR		230
 
+/* "PlayStation 2" local devices */
+#define PS2DEV_MAJOR		240	/* PS2 Graphics Synthesizer */
+#define PERFDEV_MAJOR		241	/* EE performance counter device */
+#define TASDEV_MAJOR		242	/* MIPS test and set helper device */
+#define PS2CDVD_MAJOR		243	/* PS2 CD/DVD */
+#define PS2PAD_MAJOR		244	/* PS2 PAD */
+#define PS2MC_MAJOR		245	/* PS2 Memory Card */
+#define PS2RM_MAJOR		247	/* PS2 Remote Controller */
+#define PS2SYSCONF_MAJOR	248	/* PS2 System configration */
+#define AKMEM_MAJOR		249	/* AKMEM */
+
 #define BLOCK_EXT_MAJOR		259
 #define SCSI_OSD_MAJOR		260	/* open-osd's OSD scsi device */
 
diff -purN linux-2.6.35.4-orig/include/linux/ps2/dev.h linux-2.6.35.4/include/linux/ps2/dev.h
--- linux-2.6.35.4-orig/include/linux/ps2/dev.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/include/linux/ps2/dev.h	2014-07-18 22:29:43.574367725 +0200
@@ -0,0 +1,256 @@
+#ifndef __PS2_DEV_H
+#define __PS2_DEV_H
+/* Copyright 2010 Mega Man */
+/* TBD: Unfinished state. Rework code. */
+
+#include <linux/ioctl.h>
+#include <asm/types.h>
+#include <linux/ps2/ee.h>
+#include <linux/ps2/gs.h>
+#include <linux/ps2/pad.h>
+
+#define PS2_DEV_EVENT	"/dev/ps2event"
+#define PS2_DEV_MEM	"/dev/ps2mem"
+#define PS2_DEV_GS	"/dev/ps2gs"
+#define PS2_DEV_VPU0	"/dev/ps2vpu0"
+#define PS2_DEV_VPU1	"/dev/ps2vpu1"
+#define PS2_DEV_IPU	"/dev/ps2ipu"
+#define PS2_DEV_SPR	"/dev/ps2spr"
+#define PS2_DEV_PAD0	"/dev/ps2pad00"
+#define PS2_DEV_PAD1	"/dev/ps2pad10"
+#define PS2_DEV_PADSTAT	"/dev/ps2padstat"
+
+/* event number defines */
+
+#define PS2EV_N_MAX		16
+#define PS2EV_N_VBSTART		0
+#define PS2EV_N_VBEND		1
+#define PS2EV_N_VIF0		2
+#define PS2EV_N_VIF1		3
+#define PS2EV_N_VU0		4
+#define PS2EV_N_VU1		5
+#define PS2EV_N_IPU		6
+#define PS2EV_N_SIGNAL		8
+#define PS2EV_N_FINISH		9
+#define PS2EV_N_HSYNC		10
+#define PS2EV_N_VSYNC		11
+#define PS2EV_N_EDW		12
+#define PS2EV_N_ALL		-1
+
+#define PS2EV_VBSTART		(1 << PS2EV_N_VBSTART)
+#define PS2EV_VBEND		(1 << PS2EV_N_VBEND)
+#define PS2EV_VIF0		(1 << PS2EV_N_VIF0)
+#define PS2EV_VIF1		(1 << PS2EV_N_VIF1)
+#define PS2EV_VU0		(1 << PS2EV_N_VU0)
+#define PS2EV_VU1		(1 << PS2EV_N_VU1)
+#define PS2EV_IPU		(1 << PS2EV_N_IPU)
+#define PS2EV_SIGNAL		(1 << PS2EV_N_SIGNAL)
+#define PS2EV_FINISH		(1 << PS2EV_N_FINISH)
+#define PS2EV_HSYNC		(1 << PS2EV_N_HSYNC)
+#define PS2EV_VSYNC		(1 << PS2EV_N_VSYNC)
+#define PS2EV_EDW		(1 << PS2EV_N_EDW)
+#define PS2EV_GET		-1
+#define PS2EV_ALL		0xffff
+
+#define PS2EV_SENDDONE		(1 << 0)
+#define PS2EV_RECVDONE		(1 << 1)
+
+/* misc. defines */
+
+#define PS2_GSRESET_GIF		0
+#define PS2_GSRESET_GS		1
+#define PS2_GSRESET_FULL	2
+
+/* structures for ioctl argument */
+
+struct ps2_packet {
+    void *ptr;
+    unsigned int len;
+};
+
+struct ps2_packet_spr {
+    void *ptr;
+    unsigned short len;
+    __u16 offset;
+};
+
+struct ps2_plist {
+    int num;
+    struct ps2_packet *packet;
+};
+
+struct ps2_plist_spr {
+    int num;
+    struct ps2_packet_spr *packet;
+};
+
+struct ps2_pchain {
+    void *ptr;
+    int tte;
+};
+
+struct ps2_pstop {
+    void *ptr;
+    int qct;
+};
+
+struct ps2_image {
+    void *ptr;
+    int fbp;
+    int fbw;
+    int psm;
+    int x, y;
+    int w, h;
+};
+
+struct ps2_gssreg {
+    __u64 val;
+    int reg;
+};
+
+struct ps2_gsreg {
+    __u64 val;
+    int reg;
+};
+
+struct ps2_gifreg {
+    __u32 val;
+    int reg;
+};
+
+struct ps2_screeninfo {
+    int mode;
+    int res;
+    int w, h;
+    int fbp;
+    int psm;
+};
+
+struct ps2_crtmode {
+    int mode;
+    int res;
+};
+
+struct ps2_display {
+    int ch;
+    int w, h;
+    int dx, dy;
+};
+
+struct ps2_dispfb {
+    int ch;
+    int fbp;
+    int fbw;
+    int psm;
+    int dbx, dby;
+};
+
+struct ps2_pmode {
+    int sw;
+    int mmod, amod, slbg; /* TBD: Don't use comma, because of unknown order. */
+    int alp;
+};
+
+struct ps2_vifreg {
+    __u32 val;
+    int reg;
+};
+
+struct ps2_fifo {
+    __u8 data[16];
+};
+
+struct ps2_gsinfo {
+    unsigned long size;
+};
+
+struct ps2_vpuinfo {
+    unsigned long umemsize;
+    unsigned long vumemsize;
+};
+
+struct ps2_sprinfo {
+    unsigned long size;
+};
+
+struct ps2_sgssreg_vb {
+    int num;
+    struct ps2_gssreg *gssreg;
+};
+
+/* ioctl function number defines */
+
+#define PS2IOC_MAGIC		0xee
+
+/* ps2event */
+#define PS2IOC_ENABLEEVENT	_IO(PS2IOC_MAGIC, 0)
+#define PS2IOC_GETEVENT		_IO(PS2IOC_MAGIC, 1)
+#define PS2IOC_WAITEVENT	_IO(PS2IOC_MAGIC, 2)
+#define PS2IOC_EVENTCOUNT	_IO(PS2IOC_MAGIC, 3)
+#define PS2IOC_HSYNCACT		_IO(PS2IOC_MAGIC, 4)
+#define PS2IOC_GETHSYNC		_IO(PS2IOC_MAGIC, 5)
+#define PS2IOC_SETSIGNAL	_IO(PS2IOC_MAGIC, 6)
+
+/* common DMA functions */
+#define PS2IOC_SEND		_IOW(PS2IOC_MAGIC, 16, struct ps2_packet)
+#define PS2IOC_SENDA		_IOW(PS2IOC_MAGIC, 17, struct ps2_packet)
+#define PS2IOC_SENDL		_IOW(PS2IOC_MAGIC, 18, struct ps2_plist)
+#define PS2IOC_SENDQCT		_IO(PS2IOC_MAGIC, 19)
+#define PS2IOC_SENDSTOP		_IOW(PS2IOC_MAGIC, 20, struct ps2_pstop)
+#define PS2IOC_SENDLIMIT	_IO(PS2IOC_MAGIC, 21)
+#define PS2IOC_RECV		_IOW(PS2IOC_MAGIC, 24, struct ps2_packet)
+#define PS2IOC_RECVA		_IOW(PS2IOC_MAGIC, 25, struct ps2_packet)
+#define PS2IOC_RECVL		_IOW(PS2IOC_MAGIC, 26, struct ps2_plist)
+#define PS2IOC_RECVQCT		_IO(PS2IOC_MAGIC, 27)
+#define PS2IOC_RECVSTOP		_IOW(PS2IOC_MAGIC, 28, struct ps2_pstop)
+#define PS2IOC_RECVLIMIT	_IO(PS2IOC_MAGIC, 29)
+
+/* ps2gs */
+#define PS2IOC_GSINFO		_IOR(PS2IOC_MAGIC, 32, struct ps2_gsinfo)
+#define PS2IOC_GSRESET		_IO(PS2IOC_MAGIC, 33)
+#define PS2IOC_LOADIMAGE	_IOW(PS2IOC_MAGIC, 34, struct ps2_image)
+#define PS2IOC_STOREIMAGE	_IOW(PS2IOC_MAGIC, 35, struct ps2_image)
+#define PS2IOC_SGSSREG		_IOW(PS2IOC_MAGIC, 36, struct ps2_gssreg)
+#define PS2IOC_GGSSREG		_IOWR(PS2IOC_MAGIC, 37, struct ps2_gssreg)
+#define PS2IOC_SGSREG		_IOW(PS2IOC_MAGIC, 38, struct ps2_gsreg)
+#define PS2IOC_SGIFREG		_IOW(PS2IOC_MAGIC, 39, struct ps2_gifreg)
+#define PS2IOC_GGIFREG		_IOWR(PS2IOC_MAGIC, 40, struct ps2_gifreg)
+#define PS2IOC_SSCREENINFO	_IOW(PS2IOC_MAGIC, 41, struct ps2_screeninfo)
+#define PS2IOC_GSCREENINFO	_IOR(PS2IOC_MAGIC, 42, struct ps2_screeninfo)
+#define PS2IOC_SCRTMODE		_IOW(PS2IOC_MAGIC, 43, struct ps2_crtmode)
+#define PS2IOC_GCRTMODE		_IOR(PS2IOC_MAGIC, 44, struct ps2_crtmode)
+#define PS2IOC_SDISPLAY		_IOW(PS2IOC_MAGIC, 45, struct ps2_display)
+#define PS2IOC_GDISPLAY		_IOWR(PS2IOC_MAGIC, 46, struct ps2_display)
+#define PS2IOC_SDISPFB		_IOW(PS2IOC_MAGIC, 47, struct ps2_dispfb)
+#define PS2IOC_GDISPFB		_IOWR(PS2IOC_MAGIC, 48, struct ps2_dispfb)
+#define PS2IOC_SPMODE		_IOW(PS2IOC_MAGIC, 49, struct ps2_pmode)
+#define PS2IOC_GPMODE		_IOR(PS2IOC_MAGIC, 50, struct ps2_pmode)
+#define PS2IOC_DPMS		_IO(PS2IOC_MAGIC, 51)
+#define PS2IOC_LOADIMAGEA	_IOW(PS2IOC_MAGIC, 52, struct ps2_image)
+#define PS2IOC_SGSSREG_VB	_IOW(PS2IOC_MAGIC, 53, struct ps2_sgssreg_vb)
+
+/* ps2vpu0, ps2vpu1 */
+#define PS2IOC_VPUINFO		_IOR(PS2IOC_MAGIC, 64, struct ps2_vpuinfo)
+#define PS2IOC_SVIFREG		_IOW(PS2IOC_MAGIC, 65, struct ps2_vifreg)
+#define PS2IOC_GVIFREG		_IOWR(PS2IOC_MAGIC, 66, struct ps2_vifreg)
+
+/* ps2ipu */
+#define PS2IOC_SIPUCMD		_IOW(PS2IOC_MAGIC, 81, __u32)
+#define PS2IOC_GIPUCMD		_IOR(PS2IOC_MAGIC, 82, __u32)
+#define PS2IOC_SIPUCTRL		_IOW(PS2IOC_MAGIC, 83, __u32)
+#define PS2IOC_GIPUCTRL		_IOR(PS2IOC_MAGIC, 84, __u32)
+#define PS2IOC_GIPUTOP		_IOR(PS2IOC_MAGIC, 85, __u32)
+#define PS2IOC_GIPUBP		_IOR(PS2IOC_MAGIC, 86, __u32)
+#define PS2IOC_SIPUFIFO		_IOW(PS2IOC_MAGIC, 87, struct ps2_fifo)
+#define PS2IOC_GIPUFIFO		_IOR(PS2IOC_MAGIC, 88, struct ps2_fifo)
+
+/* ps2spr */
+#define PS2IOC_SPRINFO		_IOR(PS2IOC_MAGIC, 96, struct ps2_sprinfo)
+
+/* ps2mem */
+#define PS2IOC_PHYSADDR		_IO(PS2IOC_MAGIC, 128)
+
+/* ps2gs, ps2vpu0, ps2vpu1 */
+#define PS2IOC_SENDC		_IOW(PS2IOC_MAGIC, 129, struct ps2_pchain)
+
+#endif /* __PS2_DEV_H */
diff -purN linux-2.6.35.4-orig/include/linux/ps2/ee.h linux-2.6.35.4/include/linux/ps2/ee.h
--- linux-2.6.35.4-orig/include/linux/ps2/ee.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/include/linux/ps2/ee.h	2014-07-18 22:29:43.574367725 +0200
@@ -0,0 +1,177 @@
+#ifndef __PS2_EE_H
+#define __PS2_EE_H
+/* Copyright 2010 Mega Man */
+/* TBD: Unfinished state. Rework code. */
+
+#include <asm/types.h>
+
+/* GIF */
+/* GIF registers */
+#define PS2_GIFREG_CTRL		0
+#define PS2_GIFREG_MODE		1
+#define PS2_GIFREG_STAT		2
+#define PS2_GIFREG_TAG0		4
+#define PS2_GIFREG_TAG1		5
+#define PS2_GIFREG_TAG2		6
+#define PS2_GIFREG_TAG3		7
+#define PS2_GIFREG_CNT		8
+#define PS2_GIFREG_P3CNT	9
+#define PS2_GIFREG_P3TAG	10
+//
+#ifdef _MIPS_ARCH_R5900
+#define PS2_GIFTAG_CLEAR_TAG(p)	\
+	__asm__ __volatile__ ("sq       $0, (%0)" : : "r"(p))
+#else
+#if (_MIPS_SIM == _ABIO32)
+#define PS2_GIFTAG_CLEAR_TAG(p) \
+	do { \
+		unsigned long *k = p; \
+		\
+		k[0] = 0; \
+		k[1] = 0; \
+		k[2] = 0; \
+		k[3] = 0; \
+	} while(0)
+#else
+#define PS2_GIFTAG_CLEAR_TAG(p)		*(__u128 *)(p) = 0
+#endif
+#endif
+
+#if !(_MIPS_SIM == _ABIO32)
+typedef unsigned int __u128 __attribute__((mode(TI)));
+#endif
+
+
+/* GIF types */
+typedef struct {
+	unsigned NLOOP: 15 __attribute__((packed));
+	unsigned EOP:    1 __attribute__((packed));
+	unsigned pad:   30 __attribute__((packed));
+	unsigned PRE:    1 __attribute__((packed));
+	unsigned PRIM:  11 __attribute__((packed));
+	unsigned FLG:    2 __attribute__((packed));
+	unsigned NREG:   4 __attribute__((packed));
+	unsigned REGS0:  4 __attribute__((packed));
+	unsigned REGS1:  4 __attribute__((packed));
+	unsigned REGS2:  4 __attribute__((packed));
+	unsigned REGS3:  4 __attribute__((packed));
+	unsigned REGS4:  4 __attribute__((packed));
+	unsigned REGS5:  4 __attribute__((packed));
+	unsigned REGS6:  4 __attribute__((packed));
+	unsigned REGS7:  4 __attribute__((packed));
+	unsigned REGS8:  4 __attribute__((packed));
+	unsigned REGS9:  4 __attribute__((packed));
+	unsigned REGS10: 4 __attribute__((packed));
+	unsigned REGS11: 4 __attribute__((packed));
+	unsigned REGS12: 4 __attribute__((packed));
+	unsigned REGS13: 4 __attribute__((packed));
+	unsigned REGS14: 4 __attribute__((packed));
+	unsigned REGS15: 4 __attribute__((packed));
+} ps2_giftag __attribute__((aligned(16))); // 128bit
+// FLG
+#define PS2_GIFTAG_FLG_PACKED	0
+#define PS2_GIFTAG_FLG_REGLIST	1
+#define PS2_GIFTAG_FLG_IMAGE	2
+// REGS
+#define PS2_GIFTAG_REGS_PRIM		0x0
+#define PS2_GIFTAG_REGS_RGBAQ		0x1
+#define PS2_GIFTAG_REGS_ST		0x2
+#define PS2_GIFTAG_REGS_UV		0x3
+#define PS2_GIFTAG_REGS_XYZF2		0x4
+#define PS2_GIFTAG_REGS_XYZ2		0x5
+#define PS2_GIFTAG_REGS_TEX0_1		0x6
+#define PS2_GIFTAG_REGS_TEX0_2		0x7
+#define PS2_GIFTAG_REGS_CLAMP_1		0x8
+#define PS2_GIFTAG_REGS_CLAMP_2		0x9
+#define PS2_GIFTAG_REGS_FOG		0xa
+#define PS2_GIFTAG_REGS_XYZF3		0xc
+#define PS2_GIFTAG_REGS_XYZ3		0xd
+#define PS2_GIFTAG_REGS_AD		0xe
+#define PS2_GIFTAG_REGS_NOP		0xf
+
+/* bit offset for top half of GIFTAG */
+#define PS2_GIFTAG_EOP_THOFFSET		15
+#define PS2_GIFTAG_PRE_THOFFSET		(PS2_GIFTAG_EOP_THOFFSET+1+30)
+#define PS2_GIFTAG_PRIM_THOFFSET	(PS2_GIFTAG_PRE_THOFFSET+1)
+#define PS2_GIFTAG_FLG_THOFFSET		(PS2_GIFTAG_PRIM_THOFFSET+11)
+#define PS2_GIFTAG_NREG_THOFFSET	(PS2_GIFTAG_FLG_THOFFSET+2)
+
+/* make top half of GIFTAG */
+#define PS2_GIFTAG_SET_TOPHALF(nloop, eop, pre, prim, flg, nreg) \
+       ((__u64)(nloop)  \
+        | ((__u64)(eop) << PS2_GIFTAG_EOP_THOFFSET) \
+        | ((__u64)(pre) << PS2_GIFTAG_PRE_THOFFSET) \
+        | ((__u64)(prim) << PS2_GIFTAG_PRIM_THOFFSET) \
+        | ((__u64)(flg) << PS2_GIFTAG_FLG_THOFFSET) \
+        | ((__u64)(nreg) << PS2_GIFTAG_NREG_THOFFSET))
+
+/* VIF */
+/* VIF defines */
+#define PS2_VIF_SET_CODE(immediate, num, cmd, irq) \
+	((immediate) | ((num) << 16) | ((cmd) << 24) | ((irq) << 31))
+#define PS2_VIF_NOP		0x00
+#define PS2_VIF_STCYCL		0x01
+#define PS2_VIF_OFFSET		0x02	/* VIF1 only */
+#define PS2_VIF_BASE		0x03	/* VIF1 only */
+#define PS2_VIF_ITOP		0x04
+#define PS2_VIF_STMOD		0x05
+#define PS2_VIF_MSKPATH3	0x06	/* VIF1 only */
+#define PS2_VIF_MARK		0x07
+#define PS2_VIF_FLUSHE		0x10
+#define PS2_VIF_FLUSH		0x11	/* VIF1 only */
+#define PS2_VIF_FLUSHA		0x13	/* VIF1 only */
+#define PS2_VIF_MSCAL		0x14
+#define PS2_VIF_MSCNT		0x17
+#define PS2_VIF_MSCALF		0x15	/* VIF1 only */
+#define PS2_VIF_STMASK		0x20
+#define PS2_VIF_STROW		0x30
+#define PS2_VIF_STCOL		0x31
+#define PS2_VIF_MPG		0x4a
+#define PS2_VIF_DIRECT		0x50	/* VIF1 only */
+#define PS2_VIF_DIRECTHL	0x51	/* VIF1 only */
+#define PS2_VIF_UNPACK		0x60
+
+#define PS2_VIFREG_STAT		0
+#define PS2_VIFREG_FBRST	1
+#define PS2_VIFREG_ERR		2
+#define PS2_VIFREG_MARK		3
+#define PS2_VIFREG_CYCLE	4
+#define PS2_VIFREG_MODE		5
+#define PS2_VIFREG_NUM		6
+#define PS2_VIFREG_MASK		7
+#define PS2_VIFREG_CODE		8
+#define PS2_VIFREG_ITOPS	9
+#define PS2_VIFREG_BASE		10	/* VIF1 only */
+#define PS2_VIFREG_OFST		11	/* VIF1 only */
+#define PS2_VIFREG_TOPS		12	/* VIF1 only */
+#define PS2_VIFREG_ITOP		13
+#define PS2_VIFREG_TOP		14	/* VIF1 only */
+#define PS2_VIFREG_R0		16
+#define PS2_VIFREG_R1		17
+#define PS2_VIFREG_R2		18
+#define PS2_VIFREG_R3		19
+#define PS2_VIFREG_C0		20
+#define PS2_VIFREG_C1		21
+#define PS2_VIFREG_C2		22
+#define PS2_VIFREG_C3		23
+
+/* DMA */
+typedef struct {
+	__u32 QWC:   16 __attribute__((packed));
+	__u32 pad16: 10 __attribute__((packed));
+	__u32 PCE:    2 __attribute__((packed));
+	__u32 ID:     3 __attribute__((packed));
+	__u32 IRQ:    1 __attribute__((packed));
+	__u32 ADDR:  32 __attribute__((packed));
+	__u64 pad64: 64 __attribute__((packed));
+} ps2_dmatag __attribute__((aligned(16))); // 128bit
+#define PS2_DMATAG_REFE		0
+#define PS2_DMATAG_CNT		1
+#define PS2_DMATAG_NEXT		2
+#define PS2_DMATAG_REF		3
+#define PS2_DMATAG_REFS		4
+#define PS2_DMATAG_CALL		5
+#define PS2_DMATAG_RET		6
+#define PS2_DMATAG_END		7
+
+#endif /* __PS2_EE_H */
diff -purN linux-2.6.35.4-orig/include/linux/ps2/gs.h linux-2.6.35.4/include/linux/ps2/gs.h
--- linux-2.6.35.4-orig/include/linux/ps2/gs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/include/linux/ps2/gs.h	2014-07-18 22:29:43.574367725 +0200
@@ -0,0 +1,970 @@
+#ifndef __PS2_GS_H
+#define __PS2_GS_H
+/* Copyright 2010 Mega Man */
+/* TBD: Unfinished state. Rework code. */
+
+#include <asm/types.h>
+
+/* crtmode : mode */
+#define PS2_GS_VESA	0
+#define PS2_GS_DTV	1
+#define PS2_GS_NTSC	2
+#define PS2_GS_PAL	3
+
+/* crtmode : res (NTSC, PAL) */
+#define PS2_GS_NOINTERLACE	0
+#define PS2_GS_INTERLACE	1
+#define PS2_GS_FIELD		0x00000
+#define PS2_GS_FRAME		0x10000
+
+/* crtmode : res (VESA) */
+#define PS2_GS_640x480		0
+#define PS2_GS_800x600		1
+#define PS2_GS_1024x768		2
+#define PS2_GS_1280x1024	3
+#define PS2_GS_60Hz		0x0100
+#define PS2_GS_75Hz		0x0200
+
+/* crtmode : res (DTV) */
+#define PS2_GS_480P	0
+#define PS2_GS_1080I	1
+#define PS2_GS_720P	2
+
+/* GS pixel format */
+#define PS2_GS_PSMCT32		0
+#define PS2_GS_PSMCT24		1
+#define PS2_GS_PSMCT16		2
+#define PS2_GS_PSMCT16S		10
+#define PS2_GS_PSMT8		19
+#define PS2_GS_PSMT4		20
+#define PS2_GS_PSMT8H		27
+#define PS2_GS_PSMT4HL		36
+#define PS2_GS_PSMT4HH		44
+#define PS2_GS_PSMZ32		48
+#define PS2_GS_PSMZ24		49
+#define PS2_GS_PSMZ16		50
+#define PS2_GS_PSMZ16S		58
+
+/* GS registers */
+#define PS2_GS_PRIM		0x00
+#define PS2_GS_RGBAQ		0x01
+#define PS2_GS_ST		0x02
+#define PS2_GS_UV		0x03
+#define PS2_GS_XYZF2		0x04
+#define PS2_GS_XYZ2		0x05
+#define PS2_GS_TEX0_1		0x06
+#define PS2_GS_TEX0_2		0x07
+#define PS2_GS_CLAMP_1		0x08
+#define PS2_GS_CLAMP_2		0x09
+#define PS2_GS_FOG		0x0a
+#define PS2_GS_XYZF3		0x0c
+#define PS2_GS_XYZ3		0x0d
+#define PS2_GS_TEX1_1		0x14
+#define PS2_GS_TEX1_2		0x15
+#define PS2_GS_TEX2_1		0x16
+#define PS2_GS_TEX2_2		0x17
+#define PS2_GS_XYOFFSET_1	0x18
+#define PS2_GS_XYOFFSET_2	0x19
+#define PS2_GS_PRMODECONT	0x1a
+#define PS2_GS_PRMODE		0x1b
+#define PS2_GS_TEXCLUT		0x1c
+#define PS2_GS_SCANMSK		0x22
+#define PS2_GS_MIPTBP1_1	0x34
+#define PS2_GS_MIPTBP1_2	0x35
+#define PS2_GS_MIPTBP2_1	0x36
+#define PS2_GS_MIPTBP2_2	0x37
+#define PS2_GS_TEXA		0x3b
+#define PS2_GS_FOGCOL		0x3d
+#define PS2_GS_TEXFLUSH		0x3f
+#define PS2_GS_SCISSOR_1	0x40
+#define PS2_GS_SCISSOR_2	0x41
+#define PS2_GS_ALPHA_1		0x42
+#define PS2_GS_ALPHA_2		0x43
+#define PS2_GS_DIMX		0x44
+#define PS2_GS_DTHE		0x45
+#define PS2_GS_COLCLAMP		0x46
+#define PS2_GS_TEST_1		0x47
+#define PS2_GS_TEST_2		0x48
+#define PS2_GS_PABE		0x49
+#define PS2_GS_FBA_1		0x4a
+#define PS2_GS_FBA_2		0x4b
+#define PS2_GS_FRAME_1		0x4c
+#define PS2_GS_FRAME_2		0x4d
+#define PS2_GS_ZBUF_1		0x4e
+#define PS2_GS_ZBUF_2		0x4f
+#define PS2_GS_BITBLTBUF	0x50
+#define PS2_GS_TRXPOS		0x51
+#define PS2_GS_TRXREG		0x52
+#define PS2_GS_TRXDIR		0x53
+#define PS2_GS_HWREG		0x54
+#define PS2_GS_SIGNAL		0x60
+#define PS2_GS_FINISH		0x61
+#define PS2_GS_LABEL		0x62
+#define PS2_GS_NOP		0x7f
+
+/* GS register setting utils */
+#define PS2_GS_SETREG_ALPHA_1	PS2_GS_SET_ALPHA
+#define PS2_GS_SETREG_ALPHA_2	PS2_GS_SET_ALPHA
+#define PS2_GS_SETREG_ALPHA(a, b, c, d, fix) \
+	((__u64)(a)       | ((__u64)(b) << 2)     | ((__u64)(c) << 4) | \
+	((__u64)(d) << 6) | ((__u64)(fix) << 32))
+
+#define PS2_GS_SETREG_BITBLTBUF(sbp, sbw, spsm, dbp, dbw, dpsm) \
+	((__u64)(sbp)         | ((__u64)(sbw) << 16) | \
+	((__u64)(spsm) << 24) | ((__u64)(dbp) << 32) | \
+	((__u64)(dbw) << 48)  | ((__u64)(dpsm) << 56))
+
+#define PS2_GS_SETREG_CLAMP_1	PS2_GS_SET_CLAMP
+#define PS2_GS_SETREG_CLAMP_2	PS2_GS_SET_CLAMP
+#define PS2_GS_SETREG_CLAMP(wms, wmt, minu, maxu, minv, maxv) \
+	((__u64)(wms)         | ((__u64)(wmt) << 2) | \
+	((__u64)(minu) << 4)  | ((__u64)(maxu) << 14) | \
+	((__u64)(minv) << 24) | ((__u64)(maxv) << 34))
+
+#define PS2_GS_SETREG_COLCLAMP(clamp) ((__u64)(clamp))
+
+#define PS2_GS_SETREG_DIMX(dm00, dm01, dm02, dm03, dm10, dm11, dm12, dm13, \
+			dm20, dm21, dm22, dm23, dm30, dm31, dm32, dm33) \
+	((__u64)(dm00)        | ((__u64)(dm01) << 4)  | \
+	((__u64)(dm02) << 8)  | ((__u64)(dm03) << 12) | \
+	((__u64)(dm10) << 16) | ((__u64)(dm11) << 20) | \
+	((__u64)(dm12) << 24) | ((__u64)(dm13) << 28) | \
+	((__u64)(dm20) << 32) | ((__u64)(dm21) << 36) | \
+	((__u64)(dm22) << 40) | ((__u64)(dm23) << 44) | \
+	((__u64)(dm30) << 48) | ((__u64)(dm31) << 52) | \
+	((__u64)(dm32) << 56) | ((__u64)(dm33) << 60))
+
+#define PS2_GS_SETREG_DTHE(dthe) ((__u64)(dthe))
+
+#define PS2_GS_SETREG_FBA_1	PS2_GS_SETREG_FBA
+#define PS2_GS_SETREG_FBA_2	PS2_GS_SETREG_FBA
+#define PS2_GS_SETREG_FBA(fba) ((__u64)(fba))
+
+#define PS2_GS_SETREG_FOG(f) ((__u64)(f) << 56)
+
+#define PS2_GS_SETREG_FOGCOL(fcr, fcg, fcb) \
+	((__u64)(fcr) | ((__u64)(fcg) << 8) | ((__u64)(fcb) << 16))
+
+#define PS2_GS_SETREG_FRAME_1	PS2_GS_SETREG_FRAME
+#define PS2_GS_SETREG_FRAME_2	PS2_GS_SETREG_FRAME
+#define PS2_GS_SETREG_FRAME(fbp, fbw, psm, fbmask) \
+	((__u64)(fbp)        | ((__u64)(fbw) << 16) | \
+	((__u64)(psm) << 24) | ((__u64)(fbmask) << 32))
+
+#define PS2_GS_SETREG_LABEL(id, idmsk) \
+	((__u64)(id) | ((__u64)(idmsk) << 32))
+
+#define PS2_GS_SETREG_MIPTBP1_1	PS2_GS_SETREG_MIPTBP1
+#define PS2_GS_SETREG_MIPTBP1_2	PS2_GS_SETREG_MIPTBP1
+#define PS2_GS_SETREG_MIPTBP1(tbp1, tbw1, tbp2, tbw2, tbp3, tbw3) \
+	((__u64)(tbp1)        | ((__u64)(tbw1) << 14) | \
+	((__u64)(tbp2) << 20) | ((__u64)(tbw2) << 34) | \
+	((__u64)(tbp3) << 40) | ((__u64)(tbw3) << 54))
+
+#define PS2_GS_SETREG_MIPTBP2_1	PS2_GS_SETREG_MIPTBP2
+#define PS2_GS_SETREG_MIPTBP2_2	PS2_GS_SETREG_MIPTBP2
+#define PS2_GS_SETREG_MIPTBP2(tbp4, tbw4, tbp5, tbw5, tbp6, tbw6) \
+	((__u64)(tbp4)        | ((__u64)(tbw4) << 14) | \
+	((__u64)(tbp5) << 20) | ((__u64)(tbw5) << 34) | \
+	((__u64)(tbp6) << 40) | ((__u64)(tbw6) << 54))
+
+#define PS2_GS_SETREG_PABE(pabe) ((__u64)(pabe))
+
+#define PS2_GS_SETREG_PRIM(prim, iip, tme, fge, abe, aa1, fst, ctxt, fix) \
+	((__u64)(prim)      | ((__u64)(iip) << 3)  | ((__u64)(tme) << 4) | \
+	((__u64)(fge) << 5) | ((__u64)(abe) << 6)  | ((__u64)(aa1) << 7) | \
+	((__u64)(fst) << 8) | ((__u64)(ctxt) << 9) | ((__u64)(fix) << 10))
+
+#define PS2_GS_SETREG_PRMODE(iip, tme, fge, abe, aa1, fst, ctxt, fix) \
+	(((__u64)(iip) << 3) | ((__u64)(tme) << 4)  | \
+	 ((__u64)(fge) << 5) | ((__u64)(abe) << 6)  | ((__u64)(aa1) << 7) | \
+	 ((__u64)(fst) << 8) | ((__u64)(ctxt) << 9) | ((__u64)(fix) << 10))
+
+#define PS2_GS_SETREG_PRMODECONT(ac) ((__u64)(ac))
+
+#define PS2_GS_SETREG_RGBAQ(r, g, b, a, q) \
+	((__u64)(r)        | ((__u64)(g) << 8) | ((__u64)(b) << 16) | \
+	((__u64)(a) << 24) | ((__u64)(q) << 32))
+
+#define PS2_GS_SETREG_SCANMSK(msk) ((__u64)(msk))
+
+#define PS2_GS_SETREG_SCISSOR_1	PS2_GS_SETREG_SCISSOR
+#define PS2_GS_SETREG_SCISSOR_2	PS2_GS_SETREG_SCISSOR
+#define PS2_GS_SETREG_SCISSOR(scax0, scax1, scay0, scay1) \
+	((__u64)(scax0)        | ((__u64)(scax1) << 16) | \
+	((__u64)(scay0) << 32) | ((__u64)(scay1) << 48))
+
+#define PS2_GS_SETREG_SIGNAL(id, idmsk) \
+	((__u64)(id) | ((__u64)(idmsk) << 32))
+
+#define PS2_GS_SETREG_ST(s, t) ((__u64)(s) |  ((__u64)(t) << 32))
+
+#define PS2_GS_SETREG_TEST_1 PS2_GS_SETREG_TEST
+#define PS2_GS_SETREG_TEST_2 PS2_GS_SETREG_TEST
+#define PS2_GS_SETREG_TEST(ate, atst, aref, afail, date, datm, zte, ztst) \
+	((__u64)(ate)         | ((__u64)(atst) << 1) | \
+	((__u64)(aref) << 4)  | ((__u64)(afail) << 12) | \
+	((__u64)(date) << 14) | ((__u64)(datm) << 15) | \
+	((__u64)(zte) << 16)  | ((__u64)(ztst) << 17))
+
+#define PS2_GS_SETREG_TEX0_1	PS2_GS_SETREG_TEX0
+#define PS2_GS_SETREG_TEX0_2	PS2_GS_SETREG_TEX0
+#define PS2_GS_SETREG_TEX0(tbp, tbw, psm, tw, th, tcc, tfx, \
+			   cbp, cpsm, csm, csa, cld) \
+	((__u64)(tbp)         | ((__u64)(tbw) << 14) | \
+	((__u64)(psm) << 20)  | ((__u64)(tw) << 26) | \
+	((__u64)(th) << 30)   | ((__u64)(tcc) << 34) | \
+	((__u64)(tfx) << 35)  | ((__u64)(cbp) << 37) | \
+	((__u64)(cpsm) << 51) | ((__u64)(csm) << 55) | \
+	((__u64)(csa) << 56)  | ((__u64)(cld) << 61))
+
+#define PS2_GS_SETREG_TEX1_1	PS2_GS_SETREG_TEX1
+#define PS2_GS_SETREG_TEX1_2	PS2_GS_SETREG_TEX1
+#define PS2_GS_SETREG_TEX1(lcm, mxl, mmag, mmin, mtba, l, k) \
+	((__u64)(lcm)        | ((__u64)(mxl) << 2)  | \
+	((__u64)(mmag) << 5) | ((__u64)(mmin) << 6) | \
+	((__u64)(mtba) << 9) | ((__u64)(l) << 19) | \
+	((__u64)(k) << 32))
+
+#define PS2_GS_SETREG_TEX2_1	PS2_GS_SETREG_TEX2
+#define PS2_GS_SETREG_TEX2_2	PS2_GS_SETREG_TEX2
+#define PS2_GS_SETREG_TEX2(psm, cbp, cpsm, csm, csa, cld) \
+	(((__u64)(psm) << 20) | ((__u64)(cbp) << 37) | \
+	((__u64)(cpsm) << 51) | ((__u64)(csm) << 55) | \
+	((__u64)(csa) << 56)  | ((__u64)(cld) << 61))
+
+#define PS2_GS_SETREG_TEXA(ta0, aem, ta1) \
+	((__u64)(ta0) | ((__u64)(aem) << 15) | ((__u64)(ta1) << 32))
+
+#define PS2_GS_SETREG_TEXCLUT(cbw, cou, cov) \
+	((__u64)(cbw) | ((__u64)(cou) << 6) | ((__u64)(cov) << 12))
+
+#define PS2_GS_SETREG_TRXDIR(xdr) ((__u64)(xdr))
+
+#define PS2_GS_SETREG_TRXPOS(ssax, ssay, dsax, dsay, dir) \
+	((__u64)(ssax)        | ((__u64)(ssay) << 16) | \
+	((__u64)(dsax) << 32) | ((__u64)(dsay) << 48) | \
+	((__u64)(dir) << 59))
+
+#define PS2_GS_SETREG_TRXREG(rrw, rrh) \
+	((__u64)(rrw) | ((__u64)(rrh) << 32))
+
+#define PS2_GS_SETREG_UV(u, v) ((__u64)(u) | ((__u64)(v) << 16))
+
+#define PS2_GS_SETREG_XYOFFSET_1	PS2_GS_SETREG_XYOFFSET
+#define PS2_GS_SETREG_XYOFFSET_2	PS2_GS_SETREG_XYOFFSET
+#define PS2_GS_SETREG_XYOFFSET(ofx, ofy) ((__u64)(ofx) | ((__u64)(ofy) << 32))
+
+#define PS2_GS_SETREG_XYZ3 PS2_GS_SETREG_XYZ
+#define PS2_GS_SETREG_XYZ2 PS2_GS_SETREG_XYZ
+#define PS2_GS_SETREG_XYZ(x, y, z) \
+	((__u64)(x) | ((__u64)(y) << 16) | ((__u64)(z) << 32))
+
+#define PS2_GS_SETREG_XYZF3 PS2_GS_SETREG_XYZF
+#define PS2_GS_SETREG_XYZF2 PS2_GS_SETREG_XYZF
+#define PS2_GS_SETREG_XYZF(x, y, z, f) \
+	((__u64)(x) | ((__u64)(y) << 16) | ((__u64)(z) << 32) | \
+	((__u64)(f) << 56))
+
+#define PS2_GS_SETREG_ZBUF_1	PS2_GS_SETREG_ZBUF
+#define PS2_GS_SETREG_ZBUF_2	PS2_GS_SETREG_ZBUF
+#define PS2_GS_SETREG_ZBUF(zbp, psm, zmsk) \
+	((__u64)(zbp) | ((__u64)(psm) << 24) | \
+	((__u64)(zmsk) << 32))
+
+
+/* GS special registers */
+#define PS2_GSSREG_PMODE	0x00
+#define PS2_GSSREG_SMODE1	0x01
+#define PS2_GSSREG_SMODE2	0x02
+#define PS2_GSSREG_SRFSH	0x03
+#define PS2_GSSREG_SYNCH1	0x04
+#define PS2_GSSREG_SYNCH2	0x05
+#define PS2_GSSREG_SYNCV	0x06
+#define PS2_GSSREG_DISPFB1	0x07
+#define PS2_GSSREG_DISPLAY1	0x08
+#define PS2_GSSREG_DISPFB2	0x09
+#define PS2_GSSREG_DISPLAY2	0x0a
+#define PS2_GSSREG_EXTBUF	0x0b
+#define PS2_GSSREG_EXTDATA	0x0c
+#define PS2_GSSREG_EXTWRITE	0x0d
+#define PS2_GSSREG_BGCOLOR	0x0e
+#define PS2_GSSREG_CSR		0x40
+#define PS2_GSSREG_IMR		0x41
+#define PS2_GSSREG_BUSDIR	0x44
+#define PS2_GSSREG_SIGLBLID	0x48
+#define PS2_GSSREG_SYSCNT	0x4f
+
+/* GS register bit assign/define */
+#define PS2_GS_CLEAR_GSREG(p)	*(__u64 *)(p) = 0
+/* ALPHA */
+typedef struct {
+	__u64 A:      2 __attribute__((packed));
+	__u64 B:      2 __attribute__((packed));
+	__u64 C:      2 __attribute__((packed));
+	__u64 D:      2 __attribute__((packed));
+	__u64 pad8:  24 __attribute__((packed));
+	__u64 FIX:    8 __attribute__((packed));
+	__u64 pad40: 24 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_alpha;
+#define PS2_GS_ALPHA_A_CS	0
+#define PS2_GS_ALPHA_A_CD	1
+#define PS2_GS_ALPHA_A_ZERO	2
+#define PS2_GS_ALPHA_B_CS	0
+#define PS2_GS_ALPHA_B_CD	1
+#define PS2_GS_ALPHA_B_ZERO	2
+#define PS2_GS_ALPHA_C_AS	0
+#define PS2_GS_ALPHA_C_AD	1
+#define PS2_GS_ALPHA_C_FIX	2
+#define PS2_GS_ALPHA_D_CS	0
+#define PS2_GS_ALPHA_D_CD	1
+#define PS2_GS_ALPHA_D_ZERO	2
+
+/* BITBLTBUF */
+/** use ioctl PS2IOC_{LOAD,SAVE}IMAGE for HOST<->LOCAL xfer **/
+typedef struct {
+	__u64 SBP:   14 __attribute__((packed));
+	__u64 pad14:  2 __attribute__((packed));
+	__u64 SBW:    6 __attribute__((packed));
+	__u64 pad22:  2 __attribute__((packed));
+	__u64 SPSM:   6 __attribute__((packed));
+	__u64 pad30:  2 __attribute__((packed));
+	__u64 DBP:   14 __attribute__((packed));
+	__u64 pad46:  2 __attribute__((packed));
+	__u64 DBW:    6 __attribute__((packed));
+	__u64 pad54:  2 __attribute__((packed));
+	__u64 DPSM:   6 __attribute__((packed));
+	__u64 pad62:  2 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_bitbltbuf;
+
+/* CLAMP */
+typedef struct {
+	__u64 WMS:    2 __attribute__((packed));
+	__u64 WMT:    2 __attribute__((packed));
+	__u64 MINU:  10 __attribute__((packed));
+	__u64 MAXU:  10 __attribute__((packed));
+	__u64 MINV:  10 __attribute__((packed));
+	__u64 MAXV:  10 __attribute__((packed));
+	__u64 pad44: 20 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_clamp;
+#define PS2_GS_CLAMP_REPEAT		0
+#define PS2_GS_CLAMP_CLAMP		1
+#define PS2_GS_CLAMP_REGION_CLAMP	2
+#define PS2_GS_CLAMP_REGION_REPEAT	3
+
+/* COLCLAMP */
+typedef struct {
+	__u64 CLAMP:  1 __attribute__((packed));
+	__u64 pad01: 63 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_colclamp;
+#define PS2_GS_COLCLAMP_MASK		0
+#define PS2_GS_COLCLAMP_CLAMP		1
+
+
+/* DIMX */
+typedef struct {
+	__u64 DM00:  3 __attribute__((packed));
+	__u64 pad03: 1 __attribute__((packed));
+	__u64 DM01:  3 __attribute__((packed));
+	__u64 pad07: 1 __attribute__((packed));
+	__u64 DM02:  3 __attribute__((packed));
+	__u64 pad11: 1 __attribute__((packed));
+	__u64 DM03:  3 __attribute__((packed));
+	__u64 pad15: 1 __attribute__((packed));
+	__u64 DM10:  3 __attribute__((packed));
+	__u64 pad19: 1 __attribute__((packed));
+	__u64 DM11:  3 __attribute__((packed));
+	__u64 pad23: 1 __attribute__((packed));
+	__u64 DM12:  3 __attribute__((packed));
+	__u64 pad27: 1 __attribute__((packed));
+	__u64 DM13:  3 __attribute__((packed));
+	__u64 pad31: 1 __attribute__((packed));
+	__u64 DM20:  3 __attribute__((packed));
+	__u64 pad35: 1 __attribute__((packed));
+	__u64 DM21:  3 __attribute__((packed));
+	__u64 pad39: 1 __attribute__((packed));
+	__u64 DM22:  3 __attribute__((packed));
+	__u64 pad43: 1 __attribute__((packed));
+	__u64 DM23:  3 __attribute__((packed));
+	__u64 pad47: 1 __attribute__((packed));
+	__u64 DM30:  3 __attribute__((packed));
+	__u64 pad51: 1 __attribute__((packed));
+	__u64 DM31:  3 __attribute__((packed));
+	__u64 pad55: 1 __attribute__((packed));
+	__u64 DM32:  3 __attribute__((packed));
+	__u64 pad59: 1 __attribute__((packed));
+	__u64 DM33:  3 __attribute__((packed));
+	__u64 pad63: 1 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_dimx;
+
+/* DTHE */
+typedef struct {
+	__u64 DTHE:   1 __attribute__((packed));
+	__u64 pad01: 63 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_dthe;
+#define PS2_GS_DTHE_OFF		0
+#define PS2_GS_DTHE_ON		1
+
+/* FBA */
+typedef struct {
+	__u64 FBA:   1 __attribute__((packed));
+	__u64 pad01: 63 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_fba;
+
+/* FINISH */
+typedef struct {
+	__u64 pad00: 64 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_finish;
+
+/* FOG */
+typedef struct {
+	__u64 pad00: 56 __attribute__((packed));
+	__u64 F:      8 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_fog;
+
+/* FOGCOL */
+typedef struct {
+	__u64 FCR:    8 __attribute__((packed));
+	__u64 FCG:    8 __attribute__((packed));
+	__u64 FCB:    8 __attribute__((packed));
+	__u64 pad24: 40 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_fogcol;
+
+/* FRAME */
+typedef struct {
+	__u64 FBP:    9 __attribute__((packed));
+	__u64 pad09:  7 __attribute__((packed));
+	__u64 FBW:    6 __attribute__((packed));
+	__u64 pad22:  2 __attribute__((packed));
+	__u64 PSM:    6 __attribute__((packed));
+	__u64 pad30:  2 __attribute__((packed));
+	__u64 FBMSK: 32 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_frame;
+
+/* HWREG */
+/** use ioctl PS2IOC_{LOAD,SAVE}IMAGE **/
+typedef struct {
+	__u64 DATA: 64 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_hwreg;
+
+/* LABEL */
+typedef struct {
+	__u64 ID:    32 __attribute__((packed));
+	__u64 IDMSK: 32 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_label;
+
+/* MIPTBP1 */
+typedef struct {
+	__u64 TBP1:  14 __attribute__((packed));
+	__u64 TBW1:   6 __attribute__((packed));
+	__u64 TBP2:  14 __attribute__((packed));
+	__u64 TBW2:   6 __attribute__((packed));
+	__u64 TBP3:  14 __attribute__((packed));
+	__u64 TBW3:   6 __attribute__((packed));
+	__u64 pad60:  4 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_miptbp1;
+
+/* MIPTBP2 */
+typedef struct {
+	__u64 TBP4:  14 __attribute__((packed));
+	__u64 TBW4:   6 __attribute__((packed));
+	__u64 TBP5:  14 __attribute__((packed));
+	__u64 TBW5:   6 __attribute__((packed));
+	__u64 TBP6:  14 __attribute__((packed));
+	__u64 TBW6:   6 __attribute__((packed));
+	__u64 pad60:  4 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_miptbp2;
+
+/* PABE */
+typedef struct {
+	__u64 PABE:   1 __attribute__((packed));
+	__u64 pad01: 63 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_pabe;
+#define PS2_GS_PABE_OFF		0
+#define PS2_GS_PABE_ON		1
+
+/* PRIM */
+typedef struct {
+	__u64 PRIM:   3 __attribute__((packed));
+	__u64 IIP:    1 __attribute__((packed));
+	__u64 TME:    1 __attribute__((packed));
+	__u64 FGE:    1 __attribute__((packed));
+	__u64 ABE:    1 __attribute__((packed));
+	__u64 AA1:    1 __attribute__((packed));
+	__u64 FST:    1 __attribute__((packed));
+	__u64 CTXT:   1 __attribute__((packed));
+	__u64 FIX:    1 __attribute__((packed));
+	__u64 pad11: 53 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_prim;
+#define PS2_GS_PRIM_PRIM_POINT		0
+#define PS2_GS_PRIM_PRIM_LINE		1
+#define PS2_GS_PRIM_PRIM_LINESTRIP	2
+#define PS2_GS_PRIM_PRIM_TRIANGLE	3
+#define PS2_GS_PRIM_PRIM_TRISTRIP	4
+#define PS2_GS_PRIM_PRIM_TRIFAN		5
+#define PS2_GS_PRIM_PRIM_SPRITE		6
+#define PS2_GS_PRIM_IIP_FLAT		0
+#define PS2_GS_PRIM_IIP_GOURAUD		1
+#define PS2_GS_PRIM_TME_OFF		0
+#define PS2_GS_PRIM_TME_ON		1
+#define PS2_GS_PRIM_FGE_OFF		0
+#define PS2_GS_PRIM_FGE_ON		1
+#define PS2_GS_PRIM_ABE_OFF		0
+#define PS2_GS_PRIM_ABE_ON		1
+#define PS2_GS_PRIM_AA1_OFF		0
+#define PS2_GS_PRIM_AA1_ON		1
+#define PS2_GS_PRIM_FST_STQ		0
+#define PS2_GS_PRIM_FST_UV		1
+#define PS2_GS_PRIM_CTXT_CONTEXT1	0
+#define PS2_GS_PRIM_CTXT_CONTEXT2	1
+#define PS2_GS_PRIM_FIX_NOFIXDDA	0
+#define PS2_GS_PRIM_FIX_FIXDDA		1
+
+/* PRMODE */
+typedef struct {
+	__u64 pad00:  3 __attribute__((packed));
+	__u64 IIP:    1 __attribute__((packed));
+	__u64 TME:    1 __attribute__((packed));
+	__u64 FGE:    1 __attribute__((packed));
+	__u64 ABE:    1 __attribute__((packed));
+	__u64 AA1:    1 __attribute__((packed));
+	__u64 FST:    1 __attribute__((packed));
+	__u64 CTXT:   1 __attribute__((packed));
+	__u64 FIX:    1 __attribute__((packed));
+	__u64 pad11: 53 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_prmode;
+/* use PRIM defines */
+
+/* PRMODECONT */
+typedef struct {
+	__u64 AC:     1 __attribute__((packed));
+	__u64 pad01: 63 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_prmodecont;
+#define PS2_GS_PRMODECONT_REFPRMODE	0
+#define PS2_GS_PRMODECONT_REFPRIM	1
+
+/* RGBAQ */
+typedef struct {
+	__u64 R: 8 __attribute__((packed));
+	__u64 G: 8 __attribute__((packed));
+	__u64 B: 8 __attribute__((packed));
+	__u64 A: 8 __attribute__((packed));
+	float Q    __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_rgbaq;
+
+/* SCANMSK */
+typedef struct {
+	__u64 MSK:    2 __attribute__((packed));
+	__u64 pad02: 62 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_scanmsk;
+#define PS2_GS_SCANMSK_NOMASK		0
+#define PS2_GS_SCANMSK_MASKEVEN		2
+#define PS2_GS_SCANMSK_MASKODD		3
+
+/* SCISSOR */
+typedef struct {
+	__u64 SCAX0: 11 __attribute__((packed));
+	__u64 pad11:  5 __attribute__((packed));
+	__u64 SCAX1: 11 __attribute__((packed));
+	__u64 pad27:  5 __attribute__((packed));
+	__u64 SCAY0: 11 __attribute__((packed));
+	__u64 pad43:  5 __attribute__((packed));
+	__u64 SCAY1: 11 __attribute__((packed));
+	__u64 pad59:  5 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_scissor;
+
+/* SIGNAL */
+typedef struct {
+	__u64 ID:    32 __attribute__((packed));
+	__u64 IDMSK: 32 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_signal;
+
+/* ST */
+typedef struct {
+	float S __attribute__((packed));
+	float T __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_st;
+
+/* TEST */
+typedef struct {
+	__u64 ATE:    1 __attribute__((packed));
+	__u64 ATST:   3 __attribute__((packed));
+	__u64 AREF:   8 __attribute__((packed));
+	__u64 AFAIL:  2 __attribute__((packed));
+	__u64 DATE:   1 __attribute__((packed));
+	__u64 DATM:   1 __attribute__((packed));
+	__u64 ZTE:    1 __attribute__((packed));
+	__u64 ZTST:   2 __attribute__((packed));
+	__u64 pad19: 45 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_test;
+#define PS2_GS_TEST_ATE_OFF		0
+#define PS2_GS_TEST_ATE_ON		1
+#define PS2_GS_TEST_ATST_NEVER		0
+#define PS2_GS_TEST_ATST_ALWAYS		1
+#define PS2_GS_TEST_ATST_LESS		2
+#define PS2_GS_TEST_ATST_LEQUAL		3
+#define PS2_GS_TEST_ATST_EQUAL		4
+#define PS2_GS_TEST_ATST_GEQUAL		5
+#define PS2_GS_TEST_ATST_GREATER	6
+#define PS2_GS_TEST_ATST_NOTEQUAL	7
+#define PS2_GS_TEST_AFAIL_KEEP		0
+#define PS2_GS_TEST_AFAIL_FB_ONLY	1
+#define PS2_GS_TEST_AFAIL_ZB_ONLY	2
+#define PS2_GS_TEST_AFAIL_RGB_ONLY	3
+#define PS2_GS_TEST_DATE_OFF		0
+#define PS2_GS_TEST_DATE_ON		1
+#define PS2_GS_TEST_DATM_PASS0		0
+#define PS2_GS_TEST_DATM_PASS1		1
+#define PS2_GS_TEST_ZTE_OFF		0
+#define PS2_GS_TEST_ZTE_ON		1
+#define PS2_GS_TEST_ZTST_NEVER		0
+#define PS2_GS_TEST_ZTST_ALWAYS		1
+#define PS2_GS_TEST_ZTST_GEQUAL		2
+#define PS2_GS_TEST_ZTST_GREATER	3
+#define PS2_GS_ZNEVER		PS2_GS_TEST_ZTST_NEVER
+#define PS2_GS_ZALWAYS		PS2_GS_TEST_ZTST_ALWAYS
+#define PS2_GS_ZGEQUAL		PS2_GS_TEST_ZTST_GEQUAL
+#define PS2_GS_ZGREATER		PS2_GS_TEST_ZTST_GREATER
+
+/* TEX0 */
+typedef struct {
+	__u64 TBP0: 14 __attribute__((packed));
+	__u64 TBW:   6 __attribute__((packed));
+	__u64 PSM:   6 __attribute__((packed));
+	__u64 TW:    4 __attribute__((packed));
+	__u64 TH:    4 __attribute__((packed));
+	__u64 TCC:   1 __attribute__((packed));
+	__u64 TFX:   2 __attribute__((packed));
+	__u64 CBP:  14 __attribute__((packed));
+	__u64 CPSM:  4 __attribute__((packed));
+	__u64 CSM:   1 __attribute__((packed));
+	__u64 CSA:   5 __attribute__((packed));
+	__u64 CLD:   3 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_tex0;
+#define PS2_GS_TEX_TCC_RGB			0
+#define PS2_GS_TEX_TCC_RGBA			1
+#define PS2_GS_TEX_TFX_MODULATE			0
+#define PS2_GS_TEX_TFX_DECAL			1
+#define PS2_GS_TEX_TFX_HIGHLIGHT		2
+#define PS2_GS_TEX_TFX_HIGHLIGHT2		3
+#define PS2_GS_TEX_CSM_CSM1			0
+#define PS2_GS_TEX_CSM_CSM2			1
+#define PS2_GS_TEX_CLD_NOUPDATE			0
+#define PS2_GS_TEX_CLD_LOAD			1
+#define PS2_GS_TEX_CLD_LOAD_COPY0		2
+#define PS2_GS_TEX_CLD_LOAD_COPY1		3
+#define PS2_GS_TEX_CLD_TEST0_LOAD_COPY0		4
+#define PS2_GS_TEX_CLD_TEST1_LOAD_COPY1		5
+
+/* TEX1 */
+typedef struct {
+	__u64 LCM:    1 __attribute__((packed));
+	__u64 pad01:  1 __attribute__((packed));
+	__u64 MXL:    3 __attribute__((packed));
+	__u64 MMAG:   1 __attribute__((packed));
+	__u64 MMIN:   3 __attribute__((packed));
+	__u64 MTBA:   1 __attribute__((packed));
+	__u64 pad10:  9 __attribute__((packed));
+	__u64 L:      2 __attribute__((packed));
+	__u64 pad21: 11 __attribute__((packed));
+	__u64 K:     12 __attribute__((packed));
+	__u64 pad44: 20 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_tex1;
+#define PS2_GS_TEX1_LCM_CALC				0
+#define PS2_GS_TEX1_LCM_K				1
+#define PS2_GS_TEX1_MMAG_NEAREST			0
+#define PS2_GS_TEX1_MMAG_LINEAR				1
+#define PS2_GS_TEX1_MMIN_NEAREST			0
+#define PS2_GS_TEX1_MMIN_LINEAR				1
+#define PS2_GS_TEX1_MMIN_NEAREST_MIPMAP_NEAREST		2
+#define PS2_GS_TEX1_MMIN_NEAREST_MIPMAP_LINEAR		3
+#define PS2_GS_TEX1_MMIN_LINEAR_MIPMAP_NEAREST		4
+#define PS2_GS_TEX1_MMIN_LINEAR_MIPMAP_LINEAR		5
+#define PS2_GS_TEX1_MTBA_NOAUTO				0
+#define PS2_GS_TEX1_MTBA_AUTO				1
+
+/* TEX2 */
+typedef struct {
+	__u64 pad00: 20 __attribute__((packed));
+	__u64 PSM:    6 __attribute__((packed));
+	__u64 pad26: 11 __attribute__((packed));
+	__u64 CBP:   14 __attribute__((packed));
+	__u64 CPSM:   4 __attribute__((packed));
+	__u64 CSM:    1 __attribute__((packed));
+	__u64 CSA:    5 __attribute__((packed));
+	__u64 CLD:    3 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_tex2;
+/* use TEX0 defines */
+
+/* TEXA */
+typedef struct {
+	__u64 TA0:    8 __attribute__((packed));
+	__u64 pad08:  7 __attribute__((packed));
+	__u64 AEM:    1 __attribute__((packed));
+	__u64 pad16: 16 __attribute__((packed));
+	__u64 TA1:    8 __attribute__((packed));
+	__u64 pad40: 24 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_texa;
+#define PS2_GS_TEXA_AEM_NORMAL		0
+#define PS2_GS_TEXA_AEM_BLACKTHRU	1
+
+/* TEXCLUT */
+typedef struct {
+	__u64 CBW:    6 __attribute__((packed));
+	__u64 COU:    6 __attribute__((packed));
+	__u64 COV:   10 __attribute__((packed));
+	__u64 pad22: 42 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_texclut;
+
+/* TEXFLUSH */
+typedef struct {
+	__u64 pad00: 64 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_texflush;
+
+/* TRXDIR */
+typedef struct {
+	__u64 XDR:    2 __attribute__((packed));
+	__u64 pad02: 62 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_trxdir;
+#define PS2_GS_TRXDIR_HOST_TO_LOCAL	0
+#define PS2_GS_TRXDIR_LOCAL_TO_HOST	1
+#define PS2_GS_TRXDIR_LOCAL_TO_LOCAL	2
+
+/* TRXPOS */
+typedef struct {
+	__u64 SSAX:  11 __attribute__((packed));
+	__u64 pad11:  5 __attribute__((packed));
+	__u64 SSAY:  11 __attribute__((packed));
+	__u64 pad27:  5 __attribute__((packed));
+	__u64 DSAX:  11 __attribute__((packed));
+	__u64 pad43:  5 __attribute__((packed));
+	__u64 DSAY:  11 __attribute__((packed));
+	__u64 DIR:    2 __attribute__((packed));
+	__u64 pad61:  3 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_trxpos;
+#define PS2_GS_TRXPOS_DIR_LR_UD		0
+#define PS2_GS_TRXPOS_DIR_LR_DU		1
+#define PS2_GS_TRXPOS_DIR_RL_UD		2
+#define PS2_GS_TRXPOS_DIR_RL_DU		3
+
+/* TRXREG */
+typedef struct {
+	__u64 RRW:   12 __attribute__((packed));
+	__u64 pad12: 20 __attribute__((packed));
+	__u64 RRH:   12 __attribute__((packed));
+	__u64 pad44: 20 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_trxreg;
+
+/* UV */
+typedef struct {
+	__u64 U:     14 __attribute__((packed));
+	__u64 pad14:  2 __attribute__((packed));
+	__u64 V:     14 __attribute__((packed));
+	__u64 pad30: 34 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_uv;
+
+/* XYOFFSET */
+typedef struct {
+	__u64 OFX:   16 __attribute__((packed));
+	__u64 pad16: 16 __attribute__((packed));
+	__u64 OFY:   16 __attribute__((packed));
+	__u64 pad48: 16 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_xyoffset;
+
+/* XYZ2/3 */
+typedef struct {
+	__u64 X: 16 __attribute__((packed));
+	__u64 Y: 16 __attribute__((packed));
+	__u64 Z: 32 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_xyz;
+
+/* XYZF2/3 */
+typedef struct {
+	__u64 X: 16 __attribute__((packed));
+	__u64 Y: 16 __attribute__((packed));
+	__u64 Z: 24 __attribute__((packed));
+	__u64 F:  8 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_xyzf;
+
+/* ZBUF */
+typedef struct {
+	__u64 ZBP:    9 __attribute__((packed));
+	__u64 pad09: 15 __attribute__((packed));
+	__u64 PSM:    4 __attribute__((packed));
+	__u64 pad28:  4 __attribute__((packed));
+	__u64 ZMSK:   1 __attribute__((packed));
+	__u64 pad33: 31 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_zbuf;
+#define PS2_GS_ZBUF_ZMSK_NOMASK	0
+#define PS2_GS_ZBUF_ZMSK_MASK	1
+
+/* GS special registers */
+/* BGCOLOR */
+typedef struct {
+	__u64 R:      8 __attribute__((packed));
+	__u64 G:      8 __attribute__((packed));
+	__u64 B:      8 __attribute__((packed));
+	__u64 pad24: 40 __attribute__((packed));
+} __attribute__((packed)) ps2_gssreg_bgcolor;
+
+/* BUSDIR */
+/** ioctl, PS2IOC_{LOAD,SAVE}IMAGE **/
+/** set always HOST_TO_LOCAL(0) **/
+
+/* CSR */
+/** see ps2gs_{en,jp}.txt **/
+typedef struct {
+	__u64 SIGNAL:      1 __attribute__((packed)); /* ro */
+	__u64 FINISH:      1 __attribute__((packed)); /* ro */
+	__u64 HSINT:       1 __attribute__((packed)); /* ro */
+	__u64 VSINT:       1 __attribute__((packed)); /* ro */
+	__u64 reserved04:  3 __attribute__((packed)); /* ro */
+	__u64 pad07:       1 __attribute__((packed));
+	__u64 FLUSH:       1 __attribute__((packed)); /* rw */
+	__u64 RESET:       1 __attribute__((packed)); /* N/A */
+	__u64 pad10:       2 __attribute__((packed));
+	__u64 NFIELD:      1 __attribute__((packed)); /* ro */
+	__u64 FIELD:       1 __attribute__((packed)); /* ro */
+	__u64 FIFO:        2 __attribute__((packed)); /* ro */
+	__u64 REV:         8 __attribute__((packed)); /* ro */
+	__u64 ID:          8 __attribute__((packed)); /* ro */
+	__u64 pad32:      32 __attribute__((packed));
+} __attribute__((packed)) ps2_gssreg_csr;
+#define PS2_GS_CSR_FLUSH		1
+#define PS2_GS_CSR_FIELD_EVEN		0
+#define PS2_GS_CSR_FIELD_ODD		1
+#define PS2_GS_CSR_FIFO_HALFFULL	0
+#define PS2_GS_CSR_FIFO_EMPTY		1
+#define PS2_GS_CSR_FIFO_ALMOSTFULL	2
+
+/* DISPFB1/2 */
+/** see ps2gs_{en,jp}.txt **/
+typedef struct {
+	__u64 FBP:    9 __attribute__((packed));
+	__u64 FBW:    6 __attribute__((packed));
+	__u64 PSM:    5 __attribute__((packed));
+	__u64 pad20: 12 __attribute__((packed));
+	__u64 DBX:   11 __attribute__((packed));
+	__u64 DBY:   11 __attribute__((packed));
+	__u64 pad54: 10 __attribute__((packed));
+} __attribute__((packed)) ps2_gssreg_dispfb;
+
+/* DISPLAY1/2 */
+/** see ps2gs_{en,jp}.txt **/
+typedef struct {
+	__u64 DX:    12 __attribute__((packed));
+	__u64 DY:    11 __attribute__((packed));
+	__u64 MAGH:   4 __attribute__((packed));
+	__u64 MAGV:   2 __attribute__((packed));
+	__u64 pad29:  3 __attribute__((packed));
+	__u64 DW:    12 __attribute__((packed));
+	__u64 DH:    11 __attribute__((packed));
+	__u64 pad55:  9 __attribute__((packed));
+} __attribute__((packed)) ps2_gssreg_display;
+
+/* EXTBUF */
+typedef struct {
+	__u64 EXBP:  14 __attribute__((packed));
+	__u64 EXBW:   6 __attribute__((packed));
+	__u64 FBIN:   2 __attribute__((packed));
+	__u64 WFFMD:  1 __attribute__((packed));
+	__u64 EMODA:  2 __attribute__((packed));
+	__u64 EMODC:  2 __attribute__((packed));
+	__u64 pad27:  5 __attribute__((packed));
+	__u64 WDX:   11 __attribute__((packed));
+	__u64 WDY:   11 __attribute__((packed));
+	__u64 pad54: 10 __attribute__((packed));
+} __attribute__((packed)) ps2_gssreg_extbuf;
+#define PS2_GS_EXTBUF_FBIN_OUT1		0
+#define PS2_GS_EXTBUF_FBIN_OUT2		1
+#define PS2_GS_EXTBUF_WFFMD_FIELD	0
+#define PS2_GS_EXTBUF_WFFMD_FRAME	1
+#define PS2_GS_EXTBUF_EMODA_THURU	0
+#define PS2_GS_EXTBUF_EMODA_Y		1
+#define PS2_GS_EXTBUF_EMODA_Y2		2
+#define PS2_GS_EXTBUF_EMODA_ZERO	3
+#define PS2_GS_EXTBUF_EMODC_THURU	0
+#define PS2_GS_EXTBUF_EMODC_MONO	1
+#define PS2_GS_EXTBUF_EMODC_YCbCr	2
+#define PS2_GS_EXTBUF_EMODC_ALPHA	3
+
+/* EXTDATA */
+typedef struct {
+	__u64 SX:    12 __attribute__((packed));
+	__u64 SY:    11 __attribute__((packed));
+	__u64 SMPH:   4 __attribute__((packed));
+	__u64 SMPV:   2 __attribute__((packed));
+	__u64 pad29:  3 __attribute__((packed));
+	__u64 WW:    12 __attribute__((packed));
+	__u64 WH:    11 __attribute__((packed));
+	__u64 pad55:  9 __attribute__((packed));
+} __attribute__((packed)) ps2_gssreg_extdata;
+
+/* EXTWRITE */
+typedef struct {
+	__u64 EXTWRITE:  1 __attribute__((packed));
+	__u64 pad01: 63 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_extwrite;
+#define PS2_GS_EXTWRITE_STOP	0
+#define PS2_GS_EXTWRITE_START	1
+
+/* IMR */
+/** see ps2event_{en,jp}.txt **/
+typedef struct {
+	__u64 pad00:      8 __attribute__((packed));
+	__u64 SIGMSK:     1 __attribute__((packed)); /* ro */
+	__u64 FINISHMSK:  1 __attribute__((packed)); /* ro */
+	__u64 HSMSK:      1 __attribute__((packed)); /* ro */
+	__u64 VSMSK:      1 __attribute__((packed)); /* ro */
+	__u64 reserve12:  1 __attribute__((packed)); /* ro */
+	__u64 reserve13:  1 __attribute__((packed)); /* ro */
+	__u64 reserve14:  1 __attribute__((packed)); /* ro */
+	__u64 pad15:     49 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_imr;
+
+/* PMODE */
+/** see ps2gs_{en,jp}.txt **/
+typedef struct {
+	__u64 EN1:        1 __attribute__((packed));
+	__u64 EN2:        1 __attribute__((packed));
+	__u64 CRTMD:      3 __attribute__((packed));
+	__u64 MMOD:       1 __attribute__((packed));
+	__u64 AMOD:       1 __attribute__((packed));
+	__u64 SLBG:       1 __attribute__((packed));
+	__u64 ALP:        8 __attribute__((packed));
+	__u64 reserve16: 17 __attribute__((packed));
+	__u64 pad33:     31 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_pmode;
+#define PS2_GS_PMODE_EN_OFF		0
+#define PS2_GS_PMODE_EN_ON		1
+#define PS2_GS_PMODE_MMOD_PORT1		0
+#define PS2_GS_PMODE_MMOD_ALP		1
+#define PS2_GS_PMODE_AMOD_PORT1		0
+#define PS2_GS_PMODE_AMOD_PORT2		1
+#define PS2_GS_PMODE_SLBG_BLEND2	0
+#define PS2_GS_PMODE_SLBG_BLENDBG	1
+
+/* SIGLBLID */
+typedef struct {
+	__u64 SIGID: 32 __attribute__((packed));
+	__u64 LBLID: 32 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_siglblid;
+
+/* SMODE2 */
+/** see ps2gs_{en,jp}.txt **/
+typedef struct {
+	__u64 INT:    1 __attribute__((packed));
+	__u64 FFMD:   1 __attribute__((packed));
+	__u64 DPMS:   2 __attribute__((packed));
+	__u64 pad04: 60 __attribute__((packed));
+} __attribute__((packed)) ps2_gsreg_smode2;
+#define PS2_GS_SMODE2_INT_NOINTERLACE	0
+#define PS2_GS_SMODE2_INT_INTERLACE	1
+#define PS2_GS_SMODE2_FFMD_FIELD	0
+#define PS2_GS_SMODE2_FFMD_FRAME	1
+#define PS2_GS_SMODE2_DPMS_ON		0
+#define PS2_GS_SMODE2_DPMS_STANDBY	1
+#define PS2_GS_SMODE2_DPMS_SUSPEND	2
+#define PS2_GS_SMODE2_DPMS_OFF		3
+
+#endif /* __PS2_GS_H */
diff -purN linux-2.6.35.4-orig/include/linux/ps2/Kbuild linux-2.6.35.4/include/linux/ps2/Kbuild
--- linux-2.6.35.4-orig/include/linux/ps2/Kbuild	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/include/linux/ps2/Kbuild	2014-07-18 22:29:43.574367725 +0200
@@ -0,0 +1,5 @@
+header-y += dev.h
+header-y += ee.h
+header-y += gs.h
+header-y += mcio.h
+header-y += pad.h
diff -purN linux-2.6.35.4-orig/include/linux/ps2/mcio.h linux-2.6.35.4/include/linux/ps2/mcio.h
--- linux-2.6.35.4-orig/include/linux/ps2/mcio.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/include/linux/ps2/mcio.h	2014-07-18 22:29:43.574367725 +0200
@@ -0,0 +1,104 @@
+/*
+ *  PlayStation 2 Memory Card driver
+ *
+ *        Copyright (C) 2000-2002  Sony Computer Entertainment Inc.
+ *
+ *  This file is subject to the terms and conditions of the GNU General
+ *  Public License Version 2. See the file "COPYING" in the main
+ *  directory of this archive for more details.
+ *
+ * $Id: mcio.h,v 1.1 2012/05/26 17:30:56 kloader Exp $
+ */
+#ifndef _PS2MCIO_H_
+#define _PS2MCIO_H_
+
+#define PS2MC_NAME_MAX	31
+#define PS2MC_PATH_MAX	1023
+#define PS2MC_BASEDIR	""
+
+#define PS2MC_INVALIDPORTSLOT	-1
+#define PS2MC_TYPE_EMPTY	0
+#define PS2MC_TYPE_PS1		1
+#define PS2MC_TYPE_PS2		2
+#define PS2MC_TYPE_POCKETSTATION 3
+
+#define PS2MC_SETDIR_MODE	(1<<0)
+#define PS2MC_SETDIR_MTIME	(1<<1)
+#define PS2MC_SETDIR_CTIME	(1<<2)
+
+#define PS2MC_PORT(ps)	(((ps) >> 4) & 0xf)
+#define PS2MC_SLOT(ps)	(((ps) >> 0) & 0xf)
+#define PS2MC_PORTSLOT(port, slot) ((((port) & 0xf) << 4) | ((slot) & 0xf))
+
+#define PS2MC_INIT_LISTENER(a)	INIT_LIST_HEAD(&(a)->link)
+
+struct ps2mc_cardinfo {
+	int type;
+	int blocksize;
+	unsigned long totalblocks;
+	unsigned long freeblocks;
+	int formatted;
+	int generation;
+	int busy;
+};
+
+struct ps2mc_arg {
+	char *path;
+	int pathlen;
+	int mode;
+	int pos;
+	unsigned char *data;
+	int count;
+	int reserved[8];
+};
+
+struct ps2mc_dirent {
+	char	name[PS2MC_NAME_MAX];
+	u_short	namelen;
+	umode_t	mode;
+	off_t	size;
+	time_t	ctime;
+	time_t	mtime;
+};
+
+#ifdef __KERNEL__
+struct ps2mc_listener {
+	struct list_head link;
+	void *ctx;
+	void (*func)(void *, int, int, int);
+};
+
+void ps2mc_add_listener(struct ps2mc_listener *);
+void ps2mc_del_listener(struct ps2mc_listener *);
+int ps2mc_getinfo(int, struct ps2mc_cardinfo *);
+int ps2mc_readdir(int, const char *, int, struct ps2mc_dirent *, int);
+int ps2mc_getdir(int, const char*, struct ps2mc_dirent *);
+int ps2mc_setdir(int, const char *, int, struct ps2mc_dirent *);
+
+int ps2mc_getdtablesize(void);
+int ps2mc_open(int, const char *, int);
+int ps2mc_close(int);
+off_t ps2mc_lseek(int, off_t, int);
+ssize_t ps2mc_write(int, const void *, size_t);
+ssize_t ps2mc_read(int, const void *, size_t);
+int ps2mc_mkdir(int, const char *);
+int ps2mc_rename(int, const char *, char *);
+int ps2mc_delete(int, const char *);
+int ps2mc_checkdev(dev_t dev);
+char *ps2mc_terminate_name(char[PS2MC_NAME_MAX+1], const char *, int);
+void ps2mc_add_disks(void);
+void ps2mc_del_disks(void);
+
+#endif /* __KERNEL__ */
+
+#define	PS2MC_IOCTL	'm'
+#define	PS2MC_IOCGETINFO		_IOR(PS2MC_IOCTL, 0, struct ps2mc_cardinfo)
+#define	PS2MC_IOCFORMAT			_IO(PS2MC_IOCTL, 1)
+#define	PS2MC_IOCUNFORMAT		_IO(PS2MC_IOCTL, 2)
+#define	PS2MC_IOCSOFTFORMAT		_IO(PS2MC_IOCTL, 3)
+#define	PS2MC_IOCWRITE			_IOWR(PS2MC_IOCTL, 4, struct ps2mc_arg)
+#define	PS2MC_IOCREAD			_IOWR(PS2MC_IOCTL, 5, struct ps2mc_arg)
+#define PS2MC_IOCNOTIFY			_IO(PS2MC_IOCTL, 6)
+#define PS2MC_CALL			_IO(PS2MC_IOCTL, 7)
+
+#endif /* _PS2MCIO_H_ */
diff -purN linux-2.6.35.4-orig/include/linux/ps2/pad.h linux-2.6.35.4/include/linux/ps2/pad.h
--- linux-2.6.35.4-orig/include/linux/ps2/pad.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.35.4/include/linux/ps2/pad.h	2014-07-18 22:29:43.574367725 +0200
@@ -0,0 +1,112 @@
+#ifndef __PS2_PAD_H
+#define __PS2_PAD_H
+/* Copyright 2010 Mega Man */
+/* TBD: Unfinished state. Rework code. */
+
+#include <linux/ioctl.h>
+
+#define	PS2PAD_IOCTL	'p'
+
+#define PS2PAD_TYPE_NEJICON	0x2
+#define PS2PAD_TYPE_DIGITAL	0x4
+#define PS2PAD_TYPE_ANALOG	0x5
+#define PS2PAD_TYPE_DUALSHOCK	0x7
+
+#define PS2PAD_STAT_NOTCON     	0x00
+#define PS2PAD_STAT_READY      	0x01
+#define PS2PAD_STAT_BUSY       	0x02
+#define PS2PAD_STAT_ERROR      	0x03
+
+#define PS2PAD_RSTAT_COMPLETE	0x00
+#define PS2PAD_RSTAT_FAILED	0x01
+#define PS2PAD_RSTAT_BUSY	0x02
+
+#define PS2PAD_BUTTON_LEFT	0x8000
+#define PS2PAD_BUTTON_DOWN	0x4000
+#define PS2PAD_BUTTON_RIGHT	0x2000
+#define PS2PAD_BUTTON_UP	0x1000
+#define PS2PAD_BUTTON_START	0x0800
+#define PS2PAD_BUTTON_R3	0x0400
+#define PS2PAD_BUTTON_L3	0x0200
+#define PS2PAD_BUTTON_SELECT	0x0100
+#define PS2PAD_BUTTON_SQUARE	0x0080
+#define PS2PAD_BUTTON_CROSS	0x0040
+#define PS2PAD_BUTTON_CIRCLE	0x0020
+#define PS2PAD_BUTTON_TRIANGLE	0x0010
+#define PS2PAD_BUTTON_R1	0x0008
+#define PS2PAD_BUTTON_L1	0x0004
+#define PS2PAD_BUTTON_R2	0x0002
+#define PS2PAD_BUTTON_L2	0x0001
+
+#define PS2PAD_BUTTON_A		0x0020
+#define PS2PAD_BUTTON_B		0x0010
+#define PS2PAD_BUTTON_R		0x0008
+
+#define PS2PAD_DATASIZE		32
+
+#define PS2PAD_SUCCEEDED	1
+#define PS2PAD_FAILED		0
+
+#define PS2PAD_PORT(n)		(((n) >> 4) & 0xf)
+#define PS2PAD_SLOT(n)		(((n) >> 0) & 0xf)
+#define PS2PAD_TYPE(n)		(((n) >> 4) & 0xf)
+
+struct ps2pad_stat {
+	unsigned char portslot;	/* (port# << 4) | slot#	*/
+	unsigned char stat;
+	unsigned char rstat;
+	unsigned char type;
+};
+
+struct ps2pad_actinfo {
+	int actno;
+	int term;
+	int result;
+};
+
+struct ps2pad_combinfo {
+	int listno;
+	int offs;
+	int result;
+};
+
+struct ps2pad_modeinfo {
+	int term;
+	int offs;
+	int result;
+};
+#define PS2PAD_MODECURID	1
+#define PS2PAD_MODECUREXID	2
+#define PS2PAD_MODECUROFFS	3
+#define PS2PAD_MODETABLE	4
+
+struct ps2pad_mode {
+	int offs;
+	int lock;
+};
+
+struct ps2pad_act {
+	int len;
+	unsigned char data[32];
+};
+
+#define PS2PAD_ACTFUNC		1
+#define PS2PAD_ACTSUB		2
+#define PS2PAD_ACTSIZE		3
+#define PS2PAD_ACTCURR		4
+
+#define	PS2PAD_IOCPRESSMODEINFO		_IOR(PS2PAD_IOCTL, 0, int)
+#define	PS2PAD_IOCENTERPRESSMODE	_IO(PS2PAD_IOCTL, 1)
+#define	PS2PAD_IOCEXITPRESSMODE		_IO(PS2PAD_IOCTL, 2)
+#define	PS2PAD_IOCGETREQSTAT		_IOR(PS2PAD_IOCTL, 3, int)
+#define	PS2PAD_IOCGETSTAT		_IOR(PS2PAD_IOCTL, 4, int)
+#define	PS2PAD_IOCACTINFO		_IOWR(PS2PAD_IOCTL, 5, struct ps2pad_actinfo)
+#define	PS2PAD_IOCCOMBINFO		_IOWR(PS2PAD_IOCTL, 6, struct ps2pad_combinfo)
+#define	PS2PAD_IOCMODEINFO		_IOWR(PS2PAD_IOCTL, 7, struct ps2pad_modeinfo)
+#define	PS2PAD_IOCSETMODE		_IOW(PS2PAD_IOCTL, 8, struct ps2pad_mode)
+#define	PS2PAD_IOCSETACTALIGN		_IOW(PS2PAD_IOCTL, 9, struct ps2pad_act)
+#define	PS2PAD_IOCSETACT		_IOW(PS2PAD_IOCTL, 10, struct ps2pad_act)
+
+#define	PS2PAD_IOCGETNPADS		_IOR(PS2PAD_IOCTL, 11, int)
+
+#endif /* __PS2_PAD_H */
diff -purN linux-2.6.35.4-orig/include/linux/serial_core.h linux-2.6.35.4/include/linux/serial_core.h
--- linux-2.6.35.4-orig/include/linux/serial_core.h	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/include/linux/serial_core.h	2014-07-18 22:29:43.574367725 +0200
@@ -186,6 +186,9 @@
 #define PORT_ALTERA_JTAGUART	91
 #define PORT_ALTERA_UART	92
 
+/* PS2 SBIOS debug port. */
+#define PORT_PS2_SBIOS	93
+
 #ifdef __KERNEL__
 
 #include <linux/compiler.h>
diff -purN linux-2.6.35.4-orig/include/linux/usb/hcd.h linux-2.6.35.4/include/linux/usb/hcd.h
--- linux-2.6.35.4-orig/include/linux/usb/hcd.h	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/include/linux/usb/hcd.h	2014-07-18 22:29:43.574367725 +0200
@@ -185,6 +185,7 @@ struct hc_driver {
 	int	flags;
 #define	HCD_MEMORY	0x0001		/* HC regs use memory (else I/O) */
 #define	HCD_LOCAL_MEM	0x0002		/* HC needs local memory */
+#define	HCD_LOCAL_DMA	0x0004		/* HC needs local DMA memory */
 #define	HCD_USB11	0x0010		/* USB 1.1 */
 #define	HCD_USB2	0x0020		/* USB 2.0 */
 #define	HCD_USB3	0x0040		/* USB 3.0 */
diff -purN linux-2.6.35.4-orig/init/main.c linux-2.6.35.4/init/main.c
--- linux-2.6.35.4-orig/init/main.c	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/init/main.c	2014-07-18 22:29:43.574367725 +0200
@@ -77,6 +77,9 @@
 #include <asm/setup.h>
 #include <asm/sections.h>
 #include <asm/cacheflush.h>
+#ifdef CONFIG_SONY_PS2
+#include <asm/mach-ps2/ps2.h>
+#endif
 
 #ifdef CONFIG_X86_LOCAL_APIC
 #include <asm/smp.h>
@@ -780,6 +783,12 @@ static void __init do_initcalls(void)
 {
 	initcall_t *fn;
 
+#ifdef CONFIG_SONY_PS2
+	/* PS2 device system must be initialized before each device. */
+	/* TBD: Define bus for this. */
+	ps2_dev_init();
+#endif
+
 	for (fn = __early_initcall_end; fn < __initcall_end; fn++)
 		do_one_initcall(*fn);
 
@@ -912,6 +921,11 @@ static int __init kernel_init(void * unu
 	 * the work
 	 */
 
+#ifdef CONFIG_SONY_PS2
+	/* Disable auto off when pressing the power button, because file system could be damaged. */
+	ps2_powerbutton_enable_auto_shutoff(0);
+#endif
+
 	if (!ramdisk_execute_command)
 		ramdisk_execute_command = "/init";
 
diff -purN linux-2.6.35.4-orig/kernel/sys_ni.c linux-2.6.35.4/kernel/sys_ni.c
--- linux-2.6.35.4-orig/kernel/sys_ni.c	2010-08-27 01:47:12.000000000 +0200
+++ linux-2.6.35.4/kernel/sys_ni.c	2014-07-18 22:29:43.574367725 +0200
@@ -50,6 +50,7 @@ cond_syscall(compat_sys_sendmsg);
 cond_syscall(sys_recvmsg);
 cond_syscall(sys_recvmmsg);
 cond_syscall(compat_sys_recvmsg);
+cond_syscall(compat_sys_recv);
 cond_syscall(compat_sys_recvfrom);
 cond_syscall(compat_sys_recvmmsg);
 cond_syscall(sys_socketcall);
